"CREATE FUNCTION array_contains(p_int_arr integer[], p_value integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  FOR i IN array_lower(p_int_arr, 1)..array_upper(p_int_arr, 1) LOOP
   	-- null array value never matches
      IF p_int_arr[i] Is Null THEN
      	Return false;
      ElsIf p_int_arr[i] = p_value THEN
      	Return true;
      END IF;
	END LOOP;
   -- no match found
   Return false;
END;
$$;",utils.sql
"CREATE FUNCTION array_contains(p_str_arr character varying[], p_value integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
	FOR i IN array_lower(p_str_arr, 1)..array_upper(p_str_arr, 1) LOOP
   	-- handle nulls separately
      IF p_str_arr[i] Is Null THEN
      	IF p_value Is Null THEN
      		Return true;
          Else
         	Return false;
         END IF;
      ElsIf p_int_arr[i] = p_value THEN
      	Return true;
      END IF;
	END LOOP;
   -- no match found
   Return false;
END;
$$;",utils.sql
"CREATE FUNCTION check_hex_range(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_temp text;
    c_r1 integer;
    c_r2 integer;
begin

    c_temp := split_part(i_rule, '-', 1);
    while length(c_temp) < 4 loop
        c_temp := '0' || c_temp;
    end loop;
    c_r1 := cast(cast('x' || cast(c_temp as text) as bit(16)) as integer);
    c_temp := split_part(i_rule, '-', 2);
    while length(c_temp) < 4 loop
        c_temp := '0' || c_temp;
    end loop;
    c_r2 := cast(cast('x' || cast(c_temp as text) as bit(16)) as integer);
    if i_octet between c_r1 and c_r2 then
        return 't';
    end if;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_hex_rule(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_element text;
    c_work  text;
begin
    if i_rule = '*' then   -- * matches anything!
        return 't';
    end if;

    c_work := i_rule;
    while c_work <> '' loop
        -- raise notice 'c_work = %',c_work;
        if c_work ~ ',' then
            c_element := substr(c_work, 0, strpos(c_work, ','));
            c_work := substr(c_work, strpos(c_work, ',')+1);
        else
            c_element := c_work;
            c_work := '';
        end if;

        if c_element ~ '-' then
            if check_hex_range(i_octet, c_element) then
                return 't';
            end if;
        else
            while length(c_element) < 4 loop
                c_element := '0' || c_element;
            end loop;
            if i_octet = cast(cast('x' || cast(c_element as text) as bit(16)) as integer) then
                return 't';
            end if;
        end if;
    end loop;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_rule(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_element text;
    c_work	text;
begin
    if i_rule = '*' then   -- * matches anything!
        return 't';
    end if;

    c_work := i_rule;
    while c_work <> '' loop
        -- raise notice 'c_work = %',c_work;
        if c_work ~ ',' then
            c_element := substr(c_work, 0, strpos(c_work, ','));
            c_work := substr(c_work, strpos(c_work, ',')+1);
        else
            c_element := c_work;
            c_work := '';
        end if;

        if c_element ~ '-' then
            if check_range(i_octet, c_element) then
                return 't';
            end if;
        else
            if i_octet = to_number(c_element, '99999') then
                return 't';
            end if;
        end if;
    end loop;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION clinic.fun_scal_number_ak() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	index_ak int;
	exist int;
BEGIN
	index_ak = 99;
	exist = 1;
	WHILE exist <> 0 LOOP
		index_ak = index_ak +1;
		SELECT count(*) INTO exist FROM patients WHERE nak = index_ak;
	END LOOP;
	RETURN 	index_ak;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v1.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v2.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v3.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v4.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v5.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",hog-database-start.sql
"CREATE FUNCTION consulta_descuento_del_producto(id_producto integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
		DECLARE
		 result_temp record;
		 result record;
		 id_marca_producto integer;
		 id_tipo_producto integer;


		BEGIN 
		-- Esta funcion recibe un ID de un producto y consulta si existe algun descuento que aplique a dicho producto
		-- Dado el caso de que al producto aplique varios descuento se selecciona el descuento de mayor %
	        -- Retorna el % descuento y el ID del descuento
		-- si no encuentra descuentos retorna null, null
		select into result 0 as porcentaje_descuento, 0 as id;		

		--Consulta el descuento mayor que aplica directamente sobre el producto
		result_temp= consulta_descuento(id_producto, 'Productos');

		raise notice 'desc producto: %' , result_temp;

		begin
			if result_temp.porcentaje_descuento>result.porcentaje_descuento then result=result_temp; end if;
		EXCEPTION WHEN OTHERS  then
		end;
			
		--Se consulta el id de la marca del producto
		select into id_marca_producto 
		COALESCE(p.id_marca_producto, 0)
		from producto p 
		where p.id=id_producto;
		
		--Consulta el descuento mayor que aplica sobre marcas de producto (se valida que el producto sea de la marca)
		if id_marca_producto>0 then
			result_temp= consulta_descuento(id_marca_producto, 'Marcas Productos');
			raise notice 'desc marca producto: %' , result_temp;
			begin
				if result_temp.porcentaje_descuento>result.porcentaje_descuento then result=result_temp; end if;
			EXCEPTION WHEN OTHERS  then
			end;
		end if;

		--Se consulta el id del tipo producto
		select into id_tipo_producto 
		COALESCE(p.id_tipo_producto, 0)
		from producto p 
		where p.id=id_producto;

		-- mientras el id_tipo_producto sea >0 se ejecutara el while
		WHILE id_tipo_producto>0 LOOP
			result_temp= consulta_descuento(id_tipo_producto, 'Tipos Productos');
			raise notice 'desc tipo producto: %' , result_temp; 
			
			begin
				if result_temp.porcentaje_descuento>result.porcentaje_descuento then 				
				result=result_temp; end if;
			EXCEPTION WHEN OTHERS  then
			end;

			--se consulta el id_tipo_producto padre y vuele a ejecutar el while
			select into id_tipo_producto 
			COALESCE(tp.id_tipo_producto_padre, 0)
			from tipo_producto tp 
			where tp.id=id_tipo_producto;
		END LOOP;
		      
		 RETURN result;
		END;
		$$;",backup%20invselb%202017-07-28.sql
"CREATE FUNCTION consulta_siguiente_numero_factura_por_resolucion(nombre_resolucion character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
 numero_inicio_r INT;
 numero_fin_r INT;
 numero_siguiente_r bigint;
 i_r INT;
 numero_temp_r INT;
        BEGIN 
        

 --Se consulta el siguiente numero de factura segun el campo numero_ultima_factura
 SELECT INTO numero_siguiente_r rf.numero_ultima_factura 
 FROM resolucion_facturacion rf 
 WHERE rf.nombre= nombre_resolucion
 AND rf.numero_ultima_factura>=rf.numero_inicio 
 AND  rf.numero_ultima_factura< numero_fin 
 and (rf.numero_ultima_factura+1)  not in (
  select fv.numero_factura from factura_venta fv 
  where fv.resolucion_facturacion =rf.nombre  
  and fv.resolucion_facturacion =nombre_resolucion);

 --Si la consulta anterior arroja resultado lo retorna
 IF numero_siguiente_r IS NOT NULL THEN
  RETURN numero_siguiente_r+1;
 END IF;

 -- si la parte anterior no arrojo resultados se consulta el inicio y fin de la resolucion
 -- la idea es recorrer preguntando que no exista el numero en alguna factura antigua
 SELECT
 INTO numero_inicio_r, numero_fin_r numero_inicio,numero_fin 
 FROM resolucion_facturacion WHERE nombre =nombre_resolucion;

 RAISE NOTICE 'numero inicio: %',numero_inicio_r;
 RAISE NOTICE 'numero fin: %',numero_fin_r;

 --Se recorre desde el inicio hasta el fin de la resolucion buscando que numero no se ha hecho factura
 i_r:=numero_inicio_r;
 WHILE(i_r<=numero_fin_r)
 LOOP
  
  SELECT INTO numero_temp_r fv.numero_factura 
  FROM factura_venta fv 
  where fv.resolucion_facturacion = nombre_resolucion
  AND fv.numero_factura=i_r;
 
  IF NOT numero_temp_r IS NULL  THEN
    numero_siguiente_r:=i_r;
  END IF;
  i_r:=i_r+1;
 END LOOP;

 RETURN numero_inicio_r;
END;
$$;",backup%20invselb%202017-07-28.sql
"CREATE FUNCTION convert_quantity(_part_code character varying, _version_num integer, _quantity common.quantity, _uom_code_from character varying, _uom_code_to character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
  __uom_domain_to character varying;
  __uom_domain_from character varying;
  __unit_conversion_factors common.unit_conversion_type[];
  __m common.unit_conversion_type;
  __exponentiation integer DEFAULT 1;

BEGIN

  /*
  case
    when __array @> ARRAY[30] then
      raise notice 'msg %', 0;
    when __array @> ARRAY[20] then
      raise notice 'msg %', 1;
    when __array @> ARRAY[10] then
      raise notice 'msg %', 0;
  end case;

  raise NOTICE 'array dump %', __unit_conversion_factors;
  raise NOTICE 'array unnest %', unnest(array[__unit_conversion_factors[1]]);


  case when __unit_conversion_factors @> ARRAY[(_uom_code_from,_uom_code_to,null)::mdm.unit_conversion_type] THEN
  RAISE NOTICE 'ok %', __unit_conversion_factors;
  else RAISE NOTICE 'not ok %', __unit_conversion_factors;
  end case
  
  */

  -- визначити домен одиниці виміру, до якої приводимо
  __uom_domain_to := uom.get_domain(_uom_code := _uom_code_to);
  -- визначити домен одиниці виміру, з якої приводимо
  __uom_domain_from := uom.get_domain(_uom_code := _uom_code_from);

  --RAISE NOTICE 'conversion from % to %', __uom_domain_to, __uom_domain_from;

  -- якщо той самий домен, то використовуємо коефіцієнт Сі
  IF (__uom_domain_from = __uom_domain_to) THEN
    --RAISE NOTICE 'formula = % * %', _quantity, mdm.get_factor(_uom_code_from, _uom_code_to);
    RETURN _quantity * uom.get_factor(_uom_code_from, _uom_code_to);
  END IF;

    __unit_conversion_factors := inventory.get_uom_conversion_factors(
      _part_code := _part_code,
      _version_num := _version_num,
      _uom_domain_from := __uom_domain_from,
      _uom_domain_to := __uom_domain_to);

    -- логіка перетворення з основного домену в додатковий
    IF (array_ndims(__unit_conversion_factors) >= 1) THEN

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF (__m.uom_code_from = _uom_code_from AND __m.uom_code_to = _uom_code_to) THEN
          RAISE NOTICE 'full forward match % to % = %',_uom_code_from, _uom_code_to, __m.factor;
          RETURN _quantity * (__m.factor ^ __exponentiation);
        END IF;
      END LOOP;

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF ( __m.uom_code_from = _uom_code_from) THEN
          RAISE NOTICE 'partial forward _from_ match % to % = %',_uom_code_from, __m.uom_code_to, __m.factor;
          RETURN _quantity *  
            (__m.factor ^ __exponentiation) *
            uom.get_factor(_uom_code_to, __m.uom_code_to);
        END IF;
      END LOOP;

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF ( __m.uom_code_to = _uom_code_to) THEN
          RAISE NOTICE 'partial forward _to_ match % to % = %',__m.uom_code_from, _uom_code_to, __m.factor;
          RETURN _quantity * 
            (__m.factor ^ __exponentiation) * 
            uom.get_factor(_uom_code_from, __m.uom_code_from);
        END IF;
      END LOOP;

      RAISE NOTICE 'finally forward match % to % = %', 
        __unit_conversion_factors[1].uom_code_from, 
        __unit_conversion_factors[1].uom_code_to, 
        __unit_conversion_factors[1].factor;
      RETURN _quantity * 
        uom.get_factor(_uom_code_from, __unit_conversion_factors[1].uom_code_from) * 
        (__unit_conversion_factors[1].factor ^ __exponentiation) *
        uom.get_factor(__unit_conversion_factors[1].uom_code_to, _uom_code_to);

    -- логіка перетворення з додаткового в основний домен
    ELSE
      __unit_conversion_factors := inventory.get_uom_conversion_factors(
        _part_code := _part_code,
        _version_num := _version_num,
        _uom_domain_from := __uom_domain_to,
        _uom_domain_to := __uom_domain_from);

      IF (array_ndims(__unit_conversion_factors) >= 1) THEN
        __exponentiation := -1;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF (__m.uom_code_from = _uom_code_to AND __m.uom_code_to = _uom_code_from) THEN
            RAISE NOTICE 'full reverse match % to % = %',_uom_code_from, _uom_code_to, __m.factor;
            RETURN _quantity * (__m.factor ^ __exponentiation);
          END IF;
        END LOOP;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF ( __m.uom_code_from = _uom_code_to) THEN
            RAISE NOTICE 'partial reverse _from_ match % to % = %',_uom_code_from, __m.uom_code_to, __m.factor;
            RETURN _quantity *  
              (__m.factor ^ __exponentiation) *
              uom.get_factor(_uom_code_from ,  __m.uom_code_to);
          END IF;
        END LOOP;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF ( __m.uom_code_to = _uom_code_from) THEN
            RAISE NOTICE 'partial reverse _to_ match % to % = %',__m.uom_code_to, _uom_code_from, __m.factor;
            RETURN _quantity * 
              (__m.factor ^ __exponentiation) * 
              uom.get_factor(_uom_code_to, __m.uom_code_from);
          END IF;
        END LOOP;

        RAISE NOTICE 'finally reverse match % to % = %',
          __unit_conversion_factors[1].uom_code_from,
          __unit_conversion_factors[1].uom_code_to,
          __unit_conversion_factors[1].factor;
        RETURN _quantity * 
          uom.get_factor(_uom_code_from ,  __unit_conversion_factors[1].uom_code_to) *
          (__unit_conversion_factors[1].factor ^ __exponentiation) *
          uom.get_factor(__unit_conversion_factors[1].uom_code_from, _uom_code_to);

      ELSE
        --RETURN 987654321;
        RAISE EXCEPTION 'no conversion factor found for measure domains % and % for % version %',
          __uom_domain_from,
          __uom_domain_to, 
          _part_code,
          _version_num;
          
      END IF;

    END IF;

END;

$$;",mdm.sql
"CREATE FUNCTION dba.pxgetean13(tmpcd character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare ProdCD char(13);
  declare CDigit char(1);
  declare i integer;
  declare step1 integer;
  declare step2 integer;
  declare sum integer;
  declare factor_ integer;
  BEGIN
    ProdCD = '';
    if length(tmpCD) <> 12 then
      ProdCD = tmpCD;
    else
      i = 12; --(len(tmpCD)
      sum = 0;
      factor_ = 3;
      while i >= 1 loop
        sum = sum+(cast(SUBSTRING(tmpCD,i,1) as integer)*factor_);
        i = i-1;
        factor_ = 4-factor_;
      end loop;
      --CDigit = remainder((1000-sum),10);
      CDigit = (1000-sum) % 10;
      ProdCD = tmpCD || cast(CDigit as char(1));
    end if;
    --return length(tmpCD);  
    return ProdCD;
  END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION doc_get_id(path text) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
declare
  iParentId bigint;
  iId bigint;
  i integer;
  sPart text;
  arrParts text[];
begin
  iParentId = 0;
  arrParts = regexp_split_to_array($1,
    _get_config_var('doc_path_delimeters'));
  i = array_lower(arrParts, 1);
  while i<=array_upper(arrParts, 1) loop
    sPart = arrParts[i];
    if(sPart <> '') then
      select id from docs where node = sPart and parent_id = iParentId into iId;
      if(iId is null) then
        return null;
      else
        iParentId = iId;
      end if;
    end if;
    i = i+1;
  end loop;
  return iId;
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION dumbloom_contains (  
  b    dumbloom,  
  item text  
) RETURNS boolean AS   
$$  
DECLARE  
  i   integer;  
  idx integer;  
BEGIN  
  IF b IS NULL THEN  
    RETURN FALSE;  
  END IF;  
  
  FOREACH i IN ARRAY dumbloom_fingerprint(b, item) LOOP  -- 计算k个哈希产生的值，判断是否有非1的bit, 有则返回false，如果全部为1则返回true.   
    idx := i / 32 + 1;  
    IF NOT (b.bits[idx] & (1 << (i % 32)))::boolean THEN  
      RETURN FALSE;  
    END IF;  
  END LOOP;  
  
  RETURN TRUE;  
END;  
$$  
LANGUAGE 'plpgsql' IMMUTABLE;",20160523_01.md
"CREATE FUNCTION dumbloom_empty (  
  -- 2% false probability  
  p float8 DEFAULT 0.02,  
  -- 100k expected uniques  
  n integer DEFAULT 100000  
) RETURNS dumbloom AS  
$$  
DECLARE  
  m    integer;  
  k    integer;  
  i    integer;  
  bits integer[];     
BEGIN  
  -- Getting m and k from n and p is some math sorcery  
  -- See: https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions  
  m := abs(ceil(n * ln(p) / (ln(2) ^ 2)))::integer;  
  k := round(ln(2) * m / n)::integer;  
  bits := NULL;  
  
  -- Initialize all bits to 0  
  FOR i in 1 .. ceil(m / 32.0) LOOP  
    bits := array_append(bits, 0);  
  END LOOP;  
  
  RETURN (m, k, bits)::dumbloom;  
END;  
$$  
LANGUAGE 'plpgsql' IMMUTABLE;",20160523_01.md
"CREATE FUNCTION ejemplo(numero integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
cont integer;
BEGIN
cont:=1;
FOR cont IN cont..numero LOOP
	
	raise notice '%',cont;
	
	END LOOP;
	
END;

$$;",competencia_15032014_1.sql
"CREATE FUNCTION extractdomain(url text, domain_level integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
v_domain_full text;
v_domain text;
v_matches text[];
v_level INTEGER := 1;
v_url_levels INTEGER := 0;
rec record;
BEGIN
SELECT regexp_matches(lower(url), E'https?://(www\\.)?([-\\wа-яА-Я0-9.]*\\.[а-яa-z]{2,6})', 'gi') INTO v_matches LIMIT 1;

IF v_matches IS NULL OR v_matches[2] IS NULL THEN
RETURN NULL;
END IF;

v_domain_full := v_matches[2];

v_matches := regexp_split_to_array(v_domain_full, E'\\.'); 
SELECT count(*) INTO v_url_levels FROM regexp_split_to_table(v_domain_full, E'\\.');

IF v_url_levels = domain_level THEN
RETURN v_domain_full;
END IF;

IF v_url_levels < domain_level THEN
RETURN NULL;
END IF;

v_domain := v_matches[v_url_levels];

IF (domain_level > 1) THEN
FOR i IN 1..domain_level-1 LOOP
v_domain := v_matches[v_url_levels - i] || '.' || v_domain;
END LOOP;
END IF;

RETURN v_domain;
END;
$$;",02.sql
"CREATE FUNCTION fn_formatn(n integer, l integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare 
	res varchar(10);
begin
res := N::varchar(10);
while char_length(res) < L loop
  res := '0' || res;
end loop;  
return res;  
end;
$$;",pomanager.sql
"CREATE FUNCTION generate_random_string() RETURNS TEXT AS $$
DECLARE
  items TEXT[] =
    ARRAY[
      'AAAA','BBBB','CCCC','DDDD','EEEE','FFFF','GGGG',
      'HHHH','IIII','JJJJ','KKKK','LLLL','MMMM','NNNN',
      'OOOO','PPPP','QQQQ','RRRR','SSSS','TTTT','UUUU',
      'VVVV','WWWW','XXXX','YYYY','ZZZZ',
      '&amp;', '&#34;', '&#39;', '&#38;','&#60;','&#62;',
      '&#162;','&#163;','&#164;','&#165;','&#166;','&#167;',
      '&#168;','&#169;','&#170;','&#171;','&#172;','&#173;',
      '&#174;','&#175;','&#176;','&#177;','&#178;','&#179;',
      '&#180;','&#181;','&#182;','&#183;','&#184;','&#185;',
      '&#186;','&#187;','&#188;','&#189;','&#190;'
    ];
  length INTEGER := random(500, 1500);
  result TEXT := '';
  items_length INTEGER := array_length(items, 1);
BEGIN
  FOR x IN 1..length LOOP
    result := result || items[ random(1, items_length) ];
  END LOOP;

  RETURN result;
END;
$$ LANGUAGE PLPGSQL;",the-real-cost-of-data-roundtrip.html.md
"CREATE FUNCTION get_control_sum(source integer[], coeff integer[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$declare
   sum integer;
   m integer;
begin
   m := min_int(array_length(source, 1), array_length(coeff, 1));

   sum := 0;
   for i in 1 .. m loop
      sum := sum + source[i] * coeff[i];
   end loop;
	
   return sum;
end;$$;",create.sql
"CREATE FUNCTION get_function_params(p_schema character varying, p_function character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
   rec record;
   r integer;
   v_params_arr varchar[];
   v_types varchar;
   v_types_arr integer[];
   v_type integer;
   v_type_name varchar;
   v_params_out varchar = '';

BEGIN
   SELECT proname, p.proargtypes, p.proargnames
          , p.proargmodes, p.proallargtypes INTO rec
   FROM pg_proc p
   INNER JOIN pg_namespace n ON p.pronamespace = n.oid
   WHERE n.nspname = p_schema
         AND proname = p_function;

   v_params_arr = rec.proargnames;   -- string_to_array(v_param_names, ',');
   v_types = array_to_string(rec.proargtypes, ',');

   If Length(v_types) > 0 Then
      v_types_arr = string_to_array(v_types, ',');

      FOR r IN array_lower(v_types_arr, 1)..array_upper(v_types_arr, 1) LOOP
          -- lookup name type
          v_type = v_types_arr[r];
          SELECT typname INTO v_type_name FROM pg_type
          WHERE oid = v_type;
          -- convert all int types to 'integer'
          If Substr(v_type_name, 1, 3) = 'int' Then
             v_type_name = 'integer';
          End If;
          -- add delimiter
          If Length(v_params_out) > 0 Then
             v_params_out = v_params_out || ', ';
          End If;
          -- add param name only when present
          If array_upper(v_params_arr, 1) > 0 Then
             v_params_out = v_params_out || v_params_arr[r] || ' ' || v_type_name;
           Else
             v_params_out = v_params_out || v_type_name;
          End If;
      END LOOP;
   End If;

   Return v_params_out;
END
$$;",utils.sql
"CREATE FUNCTION get_last_period_start_bil(integer, character varying, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		data DATE;
		datab DATE;
		periodo INTERVAL;
	BEGIN
		SELECT data_partenza INTO data FROM bilancio WHERE userid=$1 AND nome = $2;
		SELECT periodovalidita INTO periodo FROM bilancio WHERE userid=$1 AND nome = $2;
		WHILE (data + periodo <= $3) LOOP
			data=data+periodo;
		END LOOP;

		IF data > $3 THEN
			RETURN $3;
		ELSE 
			RETURN data;
		END IF;
	END;
$_$;",dump.sql
"CREATE FUNCTION get_last_period_start_cred(integer, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		data DATE;
		datab DATE;
		periodo INTERVAL;
	BEGIN
		SELECT data_creazione INTO data FROM conto WHERE numero = $1;
		SELECT scadenza_giorni INTO periodo FROM conto WHERE numero = $1;
		WHILE (data + periodo <= $2) LOOP
			data=data+periodo;
		END LOOP;

		IF data > $2 THEN
			RETURN $2;
		ELSE 
			RETURN data;
		END IF;
	END;
$_$;",dump.sql
"CREATE FUNCTION get_random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, get_random_number(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION iplike(i_ipaddress text, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  declare
    c_i integer;
    c_r text;

    c_addrwork text;
    c_addrtemp text;
    c_rulework text;
    c_ruletemp text;
    c_scopeid text;

    i integer;

  begin
    if i_ipaddress is NULL or i_ipaddress is null then
        return 'f';
    end if;

    if i_rule = '*.*.*.*' or i_rule = '*:*:*:*:*:*:*:*' then
        return 't';
    end if;

    -- First, strip apart the IP address into octets, and
    -- verify that they are legitimate (0-255)
    --
    -- IPv4
    if i_ipaddress ~ E'^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' and i_rule ~ E'^[0-9*,-]+\.[0-9*,-]+\.[0-9*,-]+\.[0-9*,-]+$' then
        c_addrwork := i_ipaddress;
        c_rulework := i_rule;

        i := 0;
        while i < 4 loop
            if (strpos(c_addrwork, '.') > 0) then
                c_i := to_number(substr(c_addrwork, 0, strpos(c_addrwork, '.')), '999');
            else 
                c_i := to_number(c_addrwork, '999');
            end if;

            if c_i > 255 then
                return 'f';
            end if;
            c_addrwork := ltrim(ltrim(c_addrwork, '0123456789'), '.');

            if (strpos(c_rulework, '.') > 0) then
                c_r := substr(c_rulework, 0, strpos(c_rulework, '.'));
            else
                c_r := c_rulework;
            end if;

            if not check_rule(c_i, c_r) then
                return 'f';
            end if;

            c_rulework := ltrim(ltrim(c_rulework, '0123456789,-*'), '.');

            i := i + 1;
        end loop;
    -- IPv6
    elsif i_ipaddress ~ E'^[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+(%[0-9]+)?$' and i_rule ~ E'^[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+(%[0-9*,-]+)?$' then
        c_addrwork := i_ipaddress;
        c_rulework := i_rule;

        -- TODO Add support for scope identifiers

        i := 0;
        while i < 8 loop
            if (strpos(c_addrwork, ':') > 0) then
                c_addrtemp = substr(c_addrwork, 0, strpos(c_addrwork, ':'));
            else 
                c_addrtemp = c_addrwork;
            end if;
            if (strpos(c_addrtemp, '%') > 0) then
                -- Strip off the scope ID for now
                c_scopeid = substr(c_addrtemp, strpos(c_addrtemp, '%') + 1);
                c_addrtemp = substr(c_addrtemp, 0, strpos(c_addrtemp, '%'));
            end if;
            while length(c_addrtemp) < 4 loop
                c_addrtemp := '0' || c_addrtemp;
            end loop;
            c_i := cast(cast('x' || cast(c_addrtemp as text) as bit(16)) as integer);

            -- Max 16-bit integer value
            if c_i > 65535 then
                return 'f';
            end if;
            c_addrwork := ltrim(ltrim(c_addrwork, '0123456789abcdef'), ':');

            if (strpos(c_rulework, ':') > 0) then
                c_r := substr(c_rulework, 0, strpos(c_rulework, ':'));
            else
                c_r := c_rulework;
            end if;

            if not check_hex_rule(c_i, c_r) then
                return 'f';
            end if;

            c_rulework := ltrim(ltrim(c_rulework, '0123456789abcdef,-*'), ':');

            i := i + 1;
        end loop;
    else
        return 'f';
    end if;	

  return 't';
end;
$_$;",init-opennms.sql
"CREATE FUNCTION is_null_or_empty(p_array character varying[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    i integer;
    v_item varchar;
BEGIN
    IF array_lower(p_array, 1) Is Null THEN
       Return true;
    END IF;

    FOR i IN array_lower(p_array, 1)..array_upper(p_array, 1) LOOP
        If p_array[i] is not null Then
           v_item = Trim(p_array[i]);
           If Length(v_item) > 0 Then
              Return false;
           End If;
        End If;
    END LOOP;

    -- by this point, no valid array elements found
    Return true;
END;
$$;",utils.sql
"CREATE FUNCTION is_null_or_empty(p_array numeric[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    i integer;
BEGIN
    IF array_lower(p_array, 1) Is Null THEN
       Return true;
    END IF;

    FOR i IN array_lower(p_array, 1)..array_upper(p_array, 1) LOOP
        If p_array[i] is not null Then
           Return false;
        End If;
    END LOOP;

    -- by this point, no valid array elements found
    Return true;
END;
$$;",utils.sql
"CREATE FUNCTION member_propagate_address(p_from_person_id integer, p_to_person_ids integer[], p_include_residence boolean, p_include_mailing boolean) RETURNS void
    AS $$
DECLARE
    v_from_member RECORD;
    i integer;
BEGIN
    SELECT INTO v_from_member address_id, mailing_address_id
      FROM member 
      WHERE person_id = p_from_person_id;

    i := 1;
    WHILE NOT p_to_person_ids[i] IS NULL LOOP
       IF p_include_residence THEN
           PERFORM member_set_address(false, p_to_person_ids[i],
                   v_from_member.address_id);
       END IF;
       IF p_include_mailing THEN
           PERFORM member_set_address(true, p_to_person_ids[i],
                   v_from_member.mailing_address_id);
       END IF;
       i := i + 1;
    END LOOP;

END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION public.count_node(anyarray, node_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
                DECLARE
                  table_name text;
                  sel_count integer;
                  counter integer;
                BEGIN
                counter := 0;
                FOREACH table_name IN ARRAY $1
                LOOP
                  RAISE NOTICE 'processing table %',table_name;
                  EXECUTE format('
                 SELECT COUNT(*) FROM %I AS x
                    WHERE x.connection_node_start_id = %L
                    OR x.connection_node_end_id = %L'
                      , table_name, $2, $2)
                     INTO sel_count;
                  RAISE NOTICE 'counted % appearences of
                     connection_node_id % ', sel_count, $2;
                  counter := counter + sel_count;
                  IF counter > 1 THEN
                 EXIT;
                  END IF;
                END LOOP;
                RETURN counter;
                END
                $_$;",work_empty_schema_2020-01-15.sql
"CREATE FUNCTION public.f_verificapermissaoselect(p_objeto text, p_autorizado integer, p_autorizante integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
   v_tipoobjeto varchar(60);
   v_permissao  integer default null;
   v_id_validos integer[] ;
   v_retorno boolean default false;
   V_textosaida text;
   v_sql text;
   v_posicao integer default 0;
   v_chaveprimaria text;
   v_colunaidusuario text;
begin
     select obj_visibilidade
         from tb_objeto where Obj_nomeobjetobanco = p_objeto into v_tipoobjeto;
     if v_tipoobjeto = 'IRRESTRITA' then
        return '';    
      else
        select obj_chaveprimaria, obj_colunaidusuario from tb_objeto 
                        where obj_nomeobjetobanco   = p_objeto into v_chaveprimaria, v_colunaidusuario;
        select per_codigo from v_permissaoselect where per_autorizadocodigo  = p_autorizado
                                                 and   per_autorizantecodigo = p_autorizante
                                                 and   obj_nomeobjetobanco   = p_objeto into v_permissao;
        if v_permissao is null then
           v_textosaida:=(' '||v_chaveprimaria||' = -1'); -- não tem permissao
           return v_textosaida;
        else
 --         select Obj_chaveprimaria, Obj_colunaidautorizante from tb_objeto where upper(obj_nomeobjetobanco) = upper(p_objeto) into v_nomecolunaID, V_colunaautorizante; 
          v_sql := 'select array_agg('||v_chaveprimaria||') from '|| p_objeto||'  where '||v_colunaidusuario||' = '||p_autorizante;
          execute v_sql into v_id_validos; 
          if v_id_validos is null then
             v_textosaida :=(' '||v_chaveprimaria||' = 0'); -- tem permissao mas não tem dados
             return v_textosaida;
          else 
             v_textosaida := '(';
           for i in 1..array_upper(v_id_validos, 1) loop
                v_textosaida := v_textosaida||' '||v_id_validos[i]||', '; 
           end loop;
                v_textosaida := v_textosaida||')';
                select replace (v_textosaida, ', )', ')') into v_textosaida;
           end if;
      end if;
     end if;
      return v_textosaida;
end;
$$;",database_agdatabox-api.db
"CREATE FUNCTION public.fn_formatn(n integer, l integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare 
	res varchar(10);
begin
res := N::varchar(10);
while char_length(res) < L loop
  res := '0' || res;
end loop;  
return res;  
end;
$$;",pomanager.sq
"CREATE FUNCTION public.foo() RETURNS void
    LANGUAGE plpgsql
    AS $$
	BEGIN
		FOR i IN 1..10 LOOP
			SELECT * FROM tb_usuario WHERE usu_codigo = i;
		END LOOP;
	END;
$$;",database_agdatabox-api.db
"CREATE FUNCTION public.fun_ordentipo(pnomenclatura character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
 DECLARE
     nome integer [];
     valor integer ;
     resul integer;
 BEGIN
      nome := string_to_array(pnomenclatura,'.');
      valor := 100000000;
      resul :=0;
      FOR i IN 1..(array_length(nome, 1)) LOOP
	resul:= resul + (nome[i]*valor);
        valor:=valor/100;
      END LOOP;
	return resul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_get_datos_documentos(pdatos character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
     vatributos character varying [];
     vdatos character varying [];
     vseparador character varying;
     vnombre_tipo character varying;
     vresul character varying;
 BEGIN
      vatributos := string_to_array(pdatos,'|');
      vseparador='';
      vresul :='';
      FOR i IN 1..(array_length(vatributos, 1)) LOOP
	vdatos= string_to_array(vatributos[i],';');
	select nombre into vnombre_tipo  from gd_atributos_documento where borrado='N'and codigo=vdatos[1];
	IF FOUND THEN
		vresul:= vresul || vseparador || vdatos[2];
		vseparador=';';
	END IF;
      END LOOP;
	return vresul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_get_datos_documentos_campos(pdatos character varying, ptipo_documento character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
     vatributos character varying [];
     vdatos character varying [];
     vseparador character varying;
     vnombre_tipo character varying;
     vresul character varying;
 BEGIN
      vatributos := string_to_array(pdatos,'|');
      vseparador='';
      vresul :='';
      if pdatos<>'' then
	      FOR i IN 1..(array_length(vatributos, 1)) LOOP
		vdatos= string_to_array(vatributos[i],';');
		select nombre into vnombre_tipo  from gd_atributos_documento where borrado='N' and tipo_documento=ptipo_documento and codigo=vdatos[1];
		IF FOUND THEN
			vresul:= vresul || vseparador || vnombre_tipo || ': ' || vdatos[2];
			vseparador='<br>';
		END IF;
	      END LOOP;
	end if;
	return vresul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_valida_datos_doc_tp(pvalor text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      vregistros varchar[];
      vdatos varchar[];
      vcodigo date;
      verror varchar;
 BEGIN
	BEGIN
		verror='';
		vregistros := string_to_array(pvalor,'|');
		FOR i IN 1..(array_length(vregistros, 1)) LOOP
			vdatos := string_to_array(vregistros[i],';');
			--1=codig atributo,2=valor, 3=tipo de dato
			if vdatos[3]='FE' then 
				if es_fecha(vdatos[2])=false then 
					verror=verror || 'Fecha invalida<br>'; 
				else --validar que la fecha no sea superior a la actual
					if cast(vdatos[2] as date) >= CURRENT_TIMESTAMP then
						verror=verror || 'Fecha invalida superior a la fecha actual del sistema<br>'; 
					end if;
				end if; 
			end if;			
			if vdatos[3]='NU' then if es_numero(vdatos[2])=false then verror=verror || 'Nuero incorrecto<br>'; end if; end if;
		        if vdatos[3]='DE' then if es_numero(vdatos[2])=false then verror=verror || 'Nuero incorrecto<br>'; end if; end if;
		        
		END LOOP;
				
	EXCEPTION WHEN OTHERS THEN
		verror=sqlerrm;		
	END;
	return verror;
	--select es_numero('9999999999999999999999');
	--'70;MUÑOS RAMOS MELANIE SOFIA ;TC|69;1312506528;TC|71;14/11/2024;FE|72;INTELECTUAL ;TC|73;87%;TC|74;MUY GRAVE;TC'
	--select case when cast('11/12/2024' as date) >= CURRENT_TIMESTAMP then 'SI' else 'NO' end
	--select gd_valida_datos_doc_tp('70;MUÑOS RAMOS MELANIE SOFIA ;TC|69;1312506528;TC|71;14/11/2024;FE|72;INTELECTUAL ;TC|73;87%;TC|74;MUY GRAVE;TC')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.pxgetean13(tmpcd character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare ProdCD char(13);
  declare CDigit char(1);
  declare i integer;
  declare step1 integer;
  declare step2 integer;
  declare sum integer;
  declare factor_ integer;
  BEGIN
    ProdCD = '';
    if len(tmpCD) <> 12 then
      ProdCD = tmpCD;
    else
      i = 12; --(len(tmpCD)
      sum = 0;
      factor_ = 3;
      while i >= 1 loop
        sum = sum+(cast(SUBSTRING(tmpCD,i,1) as integer)*factor_);
        i = i-1;
        factor_ = 4-factor_;
      end loop;
      CDigit = remainder((1000-sum),10);
      ProdCD = tmpCD+cast(CDigit as char(1));
    end if;
    return ProdCD;
  END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION public.validacion(numerico character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    truerut VARCHAR(9);

    digito INT := 0;

    suma INT := 0;

    digitof INT :=0;

    largo INT;

BEGIN

    largo := LENGTH(NUMERICO);

    IF(largo=8) THEN

        TRUERUT := LPAD(NUMERICO,9,'0'); --agrega ceros al comienzo hasta alcanzar un lenght de 9

    ELSE

        TRUERUT := NUMERICO;

    END IF;

    digito := SUBSTR(TRUERUT,9,1);

    suma := SUBSTR(TRUERUT,1,1) * 3;

    suma := (suma + SUBSTR(TRUERUT,2,1) * 2);

    suma := (suma + SUBSTR(TRUERUT,3,1) * 7);

    suma := (suma + SUBSTR(TRUERUT,4,1) * 6);

    suma := (suma + SUBSTR(TRUERUT,5,1) * 5);

    suma := (suma + SUBSTR(TRUERUT,6,1) * 4);

    suma := (suma + SUBSTR(TRUERUT,7,1) * 3);

    suma := (suma + SUBSTR(TRUERUT,8,1) * 2);

    WHILE (suma > 11) LOOP 

      suma := suma - 11; 

    END LOOP; 

    digitof := (11 - suma);

    IF (digitof=10) THEN

      digitof:= 0;

    END IF;

    IF (digitof=digito) THEN

      RETURN TRUE;

    ELSE

      RETURN FALSE;

    END IF;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.validacion(numerico integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    truerut VARCHAR(9);

    digito INT := 0;

    suma INT := 0;

    digitof INT :=0;

    largo INT;

BEGIN

    largo := LENGTH(CAST(NUMERICO AS VARCHAR));

    IF(largo=8) THEN

        TRUERUT := LPAD(CAST(NUMERICO AS VARCHAR),9,'0'); --agrega ceros al comienzo hasta alcanzar un lenght de 9

    ELSE

        TRUERUT := NUMERICO;

    END IF;

    digito := SUBSTR(TRUERUT,9,1);

    suma := CAST(SUBSTR(TRUERUT,1,1) AS INT) * 3;

    suma := (suma + CAST(SUBSTR(TRUERUT,2,1) AS INT) * 2);

    suma := (suma + CAST(SUBSTR(TRUERUT,3,1) AS INT) * 7);

    suma := (suma + CAST(SUBSTR(TRUERUT,4,1) AS INT) * 6);

    suma := (suma + CAST(SUBSTR(TRUERUT,5,1) AS INT) * 5);

    suma := (suma + CAST(SUBSTR(TRUERUT,6,1) AS INT) * 4);

    suma := (suma + CAST(SUBSTR(TRUERUT,7,1) AS INT) * 3);

    suma := (suma + CAST(SUBSTR(TRUERUT,8,1) AS INT) * 2);

    WHILE (suma > 11) LOOP 

      suma := suma - 11; 

    END LOOP; 

    digitof := (11 - suma);

    IF (digitof=10) THEN

      digitof:= 0;

    END IF;

    IF (digitof=digito) THEN

      RETURN TRUE;

    ELSE

      RETURN FALSE;

    END IF;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION random_string(
  IN string_length INTEGER,
  IN possible_chars TEXT DEFAULT 'abcdefghijklmnopqrstuvwxyz'
)
RETURNS text
LANGUAGE plpgsql
AS $$
  DECLARE
    output TEXT = '';
    i INT4;
    pos INT4;
  BEGIN
    FOR i IN 1..string_length LOOP
      pos := 1 + CAST( random() * ( LENGTH(possible_chars) - 1) AS INT4 );
      output := output || substr(possible_chars, pos, 1);
    END LOOP;
    RETURN output;
  END;
$$;",performance.md
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
BEGIN
  IF length < 0 THEN
    RAISE EXCEPTION 'Given length cannot be less than 0';
  END IF;
  FOR i in 1..length LOOP
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  END LOOP;
  RETURN result;
END;
$$;",graphA.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",chrs_employees_20160812.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",chrs_employees_20160825.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",tblleave_timesheet
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2007-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2008-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2009-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",bubblers_dump.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160222%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160227%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160307%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160308%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160310%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160312%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160315%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160325%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160510%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160513%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160524%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160531%20karental.sql
"CREATE FUNCTION random_text_simple(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, get_random_number(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION random_text_simple_1(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, random_range(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION remove_end_chars(p_text character varying, p_end_chars character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	counter integer;
	v_len integer;
   v_char varchar;
   v_text varchar = p_text;
   v_found boolean = true;
BEGIN
	v_len = Length(p_end_chars);
   WHILE v_found LOOP
   	v_found = false;
     	counter = 1;
   	WHILE counter <= v_len LOOP
   		v_char = Substring(p_end_chars FROM counter for 1);
        	IF Substring(v_text FROM Length(v_text) for 1) = v_char THEN
      		v_text = RTrim(v_text, v_char);
            v_found = true;
         END IF;
         counter = counter + 1;
   	END LOOP;
   END LOOP;
   Return v_text;
END;
$$;",utils.sql
"CREATE FUNCTION replace_html_codes(p_text character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_inputstr varchar = p_text;
   v_chars varchar[][];
   i integer;
BEGIN
	v_chars = array[['&#32;',' '],['&#33;','!'],['&#34;','""""'],['&quot;','""""']]
 				|| array[['&#35;','#'],['&#36;','$'],['&#37;','%'],['&#38;','&']]
				|| array[['&amp;','&'],['&#39;',''''],['&40;','('],['&#41;',')']]
				|| array[['&#42;','*'],['&#43;','+'],['&44;',','],['&#45;','-']]
				|| array[['&#46;','.'],['&#47;','/'],['&58;',':'],['&#59;',';']]
				|| array[['&#60;','<'],['&#61;','='],['&62;','>'],['&#63;','?']]
				|| array[['&#64;','@'],['&#91;','['],['&92;','\\'],['&#93;',']']]
				|| array[['&#94;','^'],['&#95;','_'],['&96;',''''],['&#123;','{']]
				|| array[['&#124;','|'],['&#125;','}'],['&126;','~'],['&lt;','<']]
            || ARRAY[['&gt;','>'],['&amp;','&'],['&quot;','""'],['&apos;','''']];

   FOR i IN array_lower(v_chars, 1)..array_upper(v_chars, 1) LOOP
		v_inputstr = Replace(v_inputstr, v_chars[i][1], v_chars[i][2]);
   END LOOP;

   v_inputstr = regexp_replace(v_inputstr, '&#..;', '');
   v_inputstr = regexp_replace(v_inputstr, '&#...;', '');

   Return v_inputstr;
END;
$_$;",utils.sql
"CREATE FUNCTION secondsworked(timestamp with time zone[]) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
declare
/*	times timestamp with time zone[] := ARRAY[];*/
	times timestamp with time zone[];
	count integer := 1;
	span numeric := 0;
	mag integer := 0;
begin
	times := $1;
	if array_upper(times, 1) % 2 = 1 then
		times := times || 'now'::timestamp with time zone;
	end if;

	mag := array_upper(times,1);

	while count <= mag loop
		span := span + extract(epoch from times[count + 1] - times[count]);
		count := count + 2;
	end loop;
	return span;
end;
$_$;",db.sql
"CREATE FUNCTION secondsworkedcompleted(timestamp with time zone[]) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
/*	times timestamp with time zone[] := ARRAY[];*/
	times timestamp with time zone[];
	count integer := 1;
	span numeric := 0;
	mag integer := 0;
begin
	times := $1;

	mag := array_upper(times,1);

	if mag % 2 = 1 then
           --remove the last time from the calculation -- only show completed ones
	   mag := mag - 1;
	end if;

	while count <= mag loop
		span := span + extract(epoch from times[count + 1] - times[count]);
		count := count + 2;
	end loop;
	return span;
end;
$_$;",db.sql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION str2flt(""in"" text, exponent text) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$declare
------------------------------------------
-- Author: SG Langer, March 2014
-- Purpose: Take any numeric looking string as input
-- 	and isolate the parts left and right of decimal
-- 	and convert to numbers
-- Args: $1 = the numeric string
--	$2 = an exponent if scientific notation (not implemented yet)
-- Caller: numerous
-----------------------------------------
	func text := 'ddw: str2flt';
	leftval text;
	rightval text ;
	sum double precision := 0;
	sign int := 1;
	exp int := 0;
	digit text;
	asc_val int;
begin
	-- check if a decimal,and slice off everything to the right of it
	if (strpos($1, '.') < 1) then
		-- casting does not work. CAST thinks $1 is ''
		--val := cast ($1 as int);
		leftval := $1;
		rightval := '0';
	else
		leftval := substr($1, 0, strpos($1, '.'));
		rightval := substr($1, strpos($1, '.'), char_length($1)); 
	end if;
	
	-- check if it is negative
	if (strpos(leftval, '-') =1) then
		sign := -1;
		leftval := substr(leftval, 2, char_length(leftval));
	end if;

	-- now, build up the Float part of the leftVal
	while char_length(leftval)> 0 loop
		-- need to handle ""invalid input"" when substr hits a ',' or ' '
		digit := substr(leftval, char_length(leftval)) ;
		-- now check that digit is Numeric else ignore
		select into asc_val ascii(digit);
		--perform logger (func, 'leftval digit and asc: ' || digit  || ' ' || asc_val);
		if (asc_val > 47 AND asc_val < 58) then
			sum := sum + 10^exp * cast (digit as int) ;	
			exp := exp + 1 ;
		end if;
		leftval := substr(leftval, 0, char_length(leftval) );
	end loop ;

	-- now, build up the Float part of the rightVal
	exp := -1 * char_length(rightval) + 1 ;
	while char_length(rightval)> 0 loop
		digit := substr(rightval, char_length(rightval));
		-- now check that digit is Numeric else ignore
		select into asc_val ascii(digit);
		if (asc_val > 47 AND asc_val < 58) then
			sum := sum + 10^exp * cast (digit as int) ;	
			exp := exp + 1 ;
		end if;
		rightval := substr(rightval, 0, char_length(rightval) );
		--perform logger (func, 'right val: ' || rightval || ' ' || sum);
	end loop;

	return sign * sum;
end$_$;",purged-ddw.sql
"CREATE FUNCTION str2int(str text, exponent text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
------------------------------------------
-- Author: SG Langer, March 2014
-- Purpose: Take any numeric looking string as input
--	Trim off the float part (if one), then
--	create an int and return. This was necessary 
--	because neither Cast nor to_number() in pgSQL work. 
--	Oh, they work when I called them directly like
--	CAST ('123.45' as int)
-- 	but failed when I did this
--	CAST (table.textField as int)
-- 	I kept getting ""Wrong input syntax for int: '' ""
--	That is to say both CAST and to_number see the textField as NULL
--	As the URL's below show, I was not the first to see this
-- Args: $1 = the numeric string
--	$2 = an exponent if scientific notation (not implemented yet)
-- Caller: numerous
-----------------------------------------
	func text;
	val text;
	sum int;
	exp int;
	digit text;
	sign int;
	asc_val int;
begin
	func :='ddw:str2int';
	exp :=0;
	sum :=0;
	sign := 1;

	-- check if a decimal,and slice off everything to the right of it
	if (strpos($1, '.') < 1) then
		-- casting does not work. CAST thinks $1 is ''
		--val := cast ($1 as int);
		val := $1;
	else
		val := substr($1, 0, strpos($1, '.'));
	end if;
	
	-- check if it is negative
	if (strpos(val, '-') =1) then
		sign := -1;
		val := substr(val, 2, char_length(val));
	end if;

	while char_length(val)> 0 loop
		-- need to handle ""invalid input"" when substr hits a ',' or ' '
		BEGIN
			digit := substr(val, char_length(val));
			-- now check that digit is Numeric else ignore
			select into asc_val ascii(digit);
			if (asc_val > 47 AND asc_val < 58) then
				sum := sum + 10^exp * cast (digit as int) ; 
				exp := exp + 1 ;
				perform logger (func, 'digit and exp ' || digit || ' ' || exp); 
			end if;
		EXCEPTION WHEN others then
			-- do nothing, just log error
			perform logger (func, 'exception =' || others);
		END; 
		--perform logger (func, val || ' ' || sum);
		val := substr(val, 0, char_length(val) );
	end loop ;
	
	-- THESE all have SAME problem, think $1 is NULL
	-- http://forums.codeguru.com/showthread.php?527147-PL-pgsql-Convert-character-varying-to-an-integer
	--select into val to_number(quote_literal($1), quote_literal(99999999));

	--http://grokbase.com/t/postgresql/pgsql-general/01bv71dv92/casting-varchar-to-numeric
	--select into val $1::double precision::numeric ;
	return sign * sum;
end
$_$;",purged-ddw.sql
"CREATE FUNCTION uf_dbadm_dropfunction(prm_schema name, prm_name name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_nargs smallint;
  var_args oidvector;
  var_argmodes char[];
  var_continuar smallint;
  var_sql varchar(1024);
  var_tmparg varchar(100);
begin
  -- Elimina todas las funciones bajo el nombre prm_schema.prm_name

  var_sql := '';
  var_continuar := 1;
  while var_continuar = 1 loop
    var_nargs := null;
    var_args := null;
    -- obtener info de la funcion
    select a.pronargs, a.proargtypes, a.proargmodes
    into var_nargs, var_args, var_argmodes
    from pg_proc a inner join pg_namespace b on a.pronamespace = b.oid
    where a.proname = prm_name and b.nspname = prm_schema
    limit 1;
    if var_args is null then
      var_continuar := 0;
      exit;
    end if;
    -- raise notice 'Cant param %',var_nargs::varchar;
    -- se tiene la cantidad de argmentos y el array de los tipos de datos
    var_sql := 'drop function if exists ' || prm_schema::varchar || '.' || prm_name::varchar || '(';
    -- armar los parametros
    FOR i IN 1..var_nargs LOOP
      select b.nspname::varchar || '.' || a.typname
      into var_tmparg
      from pg_type a inner join pg_namespace b on a.typnamespace = b.oid
      where a.oid = var_args[i - 1];

      if var_argmodes is not null then
        if var_argmodes[i] = 'i' then
          var_tmparg := 'IN ' || var_tmparg;
        elsif var_argmodes[i] = 'o' then
          var_tmparg := 'OUT ' || var_tmparg;
        elsif var_argmodes[i] = 'b' then
          var_tmparg := 'INOUT ' || var_tmparg;
        end if;
      end if;

      var_sql := var_sql || var_tmparg  ;
      if i <> var_nargs then
        var_sql := var_sql || ', '  ;
      end if;
    END LOOP;

    var_sql := var_sql || ');';
    var_nargs := null;
    var_args := null;

    execute var_sql;

  end loop;

  return 1;
end

$$;",db-base-modif.sql
"CREATE FUNCTION xml_forest(p_content_arr character varying[], p_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	i integer;
	v_content varchar = '';
BEGIN
	IF fx.is_null_or_empty(p_content_arr) THEN
   	Return '';
   END IF;
	FOR i IN array_lower(p_content_arr, 1)..array_upper(p_content_arr, 1) LOOP
  		v_content = v_content || Coalesce(p_content_arr[i], '');
	END LOOP;

   Return '<' || p_name || '>' || v_content || '</' || p_name || '>';
END;
$$;",utils.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN
	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",ETL.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN
	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",scripts_dw.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN

	FOR i IN 1 .. 3 LOOP
		SELECT * INTO a FROM (SELECT CargaTEClientes(20,i)) as s;
		SELECT * INTO a FROM (SELECT CargaTEProductos(20,i)) as s;
	END LOOP;

	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",ETL%20(mod).sql
"CREATE OR REPLACE FUNCTION GoogleEncodeSignedInteger(c INT)
RETURNS VARCHAR(255) AS $$
DECLARE
  e VARCHAR(255);
  s BIT(32);
  b BIT(6);
  n INT;
BEGIN
 e = '';
 s = (c::BIT(32))<<1;

 IF s::INT < 0 THEN
   s = ~s;
   END IF;

 WHILE s::INT >= B'100000'::INT LOOP
   b = B'100000' | (('0'||substring(s, 28, 5))::BIT(6));
   n = b::INT + 63;
   e = e || chr(n);
   s = s >> 5;
 END LOOP;
 e = e || chr(s::INT+63);

RETURN e;
End
$$ LANGUAGE plpgsql;",cmdOut.txt
"CREATE OR REPLACE FUNCTION createSeqId(text, text)
RETURNS text AS
$BODY$
DECLARE
t text;
i int;
j int;
n int;
BEGIN
n=nextval($2);
i=32-character_length($1)-character_length(n||'');
j=1;
t='';
for j IN 1..i loop
T = T||'0';
END loop ;
t = $1 || t||n;
RETURN t;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE;",sql.md
"CREATE OR REPLACE FUNCTION event_full_cleanup_p ()
returns void as $$
DECLARE
   event_partition VARCHAR (200);
BEGIN
     TRUNCATE TABLE VPX_EVENT_PARTITION_LOOKUP;
     --Truncate partitions
     FOR part IN 1..92
     LOOP
       event_partition = 'TRUNCATE TABLE VPX_EVENT_' || CAST(part AS TEXT) || ' CASCADE ';
       EXECUTE event_partition;
       event_partition = 'TRUNCATE TABLE VPX_EVENT_ARG_' || CAST(part AS TEXT) || ' CASCADE ';
       EXECUTE event_partition;
       event_partition = 'ANALYZE VPX_EVENT_' || CAST(part AS TEXT);
       EXECUTE event_partition;
       event_partition = 'ANALYZE VPX_EVENT_ARG_' || CAST(part AS TEXT);
       EXECUTE event_partition;
    END LOOP;
    TRUNCATE TABLE VPX_ENTITY_LAST_EVENT;
END
$$language plpgsql;",cleanvcdb.sh
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id	int,
	gradshash 	hstore,
	agenthash 	hstore
) returns FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		IF rakeback_id = tmp_rb_id THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id	int,
	gradshash 	hstore,
	agenthash 	hstore
) returns FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		IF rakeback_id = tmp_rb_id THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	FLOAT;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;

				IF tmp_back_water > 0 THEN
					IF tmp_back_water > max_back_water THEN
						max_back_water = tmp_back_water;
					END IF;
				ELSE
					max_back_water = 0.0;
				END IF;
			END IF;
		END IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",1_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	FLOAT;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;

				IF tmp_back_water > 0 THEN
					IF tmp_back_water > max_back_water THEN
						max_back_water = tmp_back_water;
					END IF;
				ELSE
					max_back_water = 0.0;
				END IF;
			END IF;
		END IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id  THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;
				IF tmp_back_water > max_back_water THEN
					max_back_water = tmp_back_water;
				end IF;
			end IF;
		end IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash hstore,
	agenthash hstore,
	volume 	float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
  	tmp_rb_volume 	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		tmp_rb_volume = hash->'valid_value';
		IF rakeback_id = tmp_rb_id AND volume >= (tmp_rb_volume::float) THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION makeuid
(
  r int
)
RETURNS TEXT AS $$
DECLARE
  buff TEXT;
  rem int;
  div int;
  BEGIN
  buff = '';
  div = r;
  rem = 0;
while div>0 Loop
if div >92 then
	rem = div%93;
	buff = chr(rem+34)||buff;
	div = div / 93;
else 
	buff = chr(div+34)||buff;
	div = 0;
end if;
end loop;  
RETURN buff;
End
$$ LANGUAGE plpgsql;",cmdOut.txt
"CREATE OR REPLACE FUNCTION mid_findInnerPath(nMeshID integer, nFromLink integer, nToLink integer, nTargetCross integer)
	RETURNS varchar[]
	LANGUAGE plpgsql
AS $$ 
DECLARE
	rstPathArray		varchar[];
	rstPathCount		integer;
	rstPath				varchar;
	
	tmpPathArray		varchar[];
	tmpLastNodeArray	bigint[];
	tmpLastLinkArray	bigint[];
	tmpPathCount		integer;
	tmpPathIndex		integer;
	
	nStartNode			integer;
	nEndNode			integer;
	
	nNewFromLink		bigint;
	nNewToLink			bigint;
	
	rec        			record;
BEGIN
	-- init
	execute
	'
	 select (
		 case
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
			)
		 then fnode
		 else tnode
		 end
		)as curnode
	 from org_roadsegment
	 where meshid = '||nMeshID||' and road = ' ||nFromLink|| '
	'
	into nStartNode
	;
	
	execute
	'
	 select (
		 case
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
			)
		 then fnode
		 else tnode
		 end
		)as curnode
	 from org_roadsegment
	 where meshid = '||nMeshID||' and road = ' ||nToLink|| '
	'
	into nEndNode
	;
	
	execute
	'
	 select new_road
	 from temp_link_mapping
	 where meshid = '||nMeshID||' and road = ' ||nFromLink|| '
	'
	into nNewFromLink
	;
	
	execute
	'
	 select new_road
	 from temp_link_mapping
	 where meshid = '||nMeshID||' and road = ' ||nToLink|| '
	'
	into nNewToLink
	;
	
	--rstPathArray
	rstPathCount		:= 0;
	tmpPathArray		:= ARRAY[cast(nNewFromLink as varchar)];
	tmpLastNodeArray	:= ARRAY[nStartNode];
	tmpLastLinkArray	:= ARRAY[nNewFromLink];
	tmpPathCount		:= 1;
	tmpPathIndex		:= 1;

	-- search
	WHILE tmpPathIndex <= tmpPathCount LOOP
		--raise INFO '%', cast(tmpPathArray as varchar);
		if tmpLastNodeArray[tmpPathIndex] = nEndNode then
			rstPathCount		:= rstPathCount + 1;
			rstPath				:= cast(tmpPathArray[tmpPathIndex]||'|'||nNewToLink as varchar);
			rstPath				:= replace(rstPath, '(2)', '');
			rstPath				:= replace(rstPath, '(3)', '');
			if rstPathCount = 1 then
				rstPathArray	:= ARRAY[rstPath];
			else
				rstPathArray	:= array_append(rstPathArray, rstPath);
			end if;
		else
			for rec in execute
				'
				 select b.new_road as nextroad, a.dir, a.nextnode
				 from
				 (
					 select meshid, road as nextroad, ''(2)'' as dir, tnode as nextnode
					 from org_roadsegment
					 where	(meshid = '||nMeshID||') and
					 		(fnode = ' ||tmpLastNodeArray[tmpPathIndex]|| ') and 
							(direction in (1,2)) and
							(
							tnode in
								(
								 select node
								 from org_roadnode
								 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
								)
							)
					 union
					 
					 select meshid, road as nextroad, ''(3)'' as dir, fnode as nextnode
					 from org_roadsegment
					 where	(meshid = '||nMeshID||') and
					 		(tnode = ' ||tmpLastNodeArray[tmpPathIndex]|| ') and
							(direction in (1,3)) and
							(
							fnode in
								(
								 select node
								 from org_roadnode
								 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
								)
							)
				 )as a
				 left join temp_link_mapping as b
				 on a.meshid = b.meshid and a.nextroad = b.road
				'
			loop
				if 		not (rec.nextroad in (nNewFromLink, nNewToLink, tmpLastLinkArray[tmpPathIndex]))
					and	not ((rec.nextroad||rec.dir) = ANY(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+')))
				then
					tmpPathCount		:= tmpPathCount + 1;
					tmpPathArray		:= array_append(tmpPathArray, cast(tmpPathArray[tmpPathIndex]||'|'||rec.nextroad||rec.dir as varchar));
					tmpLastNodeArray	:= array_append(tmpLastNodeArray, cast(rec.nextnode as bigint));
					tmpLastLinkArray	:= array_append(tmpLastLinkArray, cast(rec.nextroad as bigint));
				end if;
			end loop;
		end if;
		tmpPathIndex := tmpPathIndex + 1;
	END LOOP;

	return rstPathArray;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_findTargetNodeIndex(fnode_array bigint[], tnode_array bigint[], nTargetNode bigint)
    RETURNS smallint
    LANGUAGE plpgsql
AS $$
DECLARE
	nCount					integer;
	nIndex					integer;
BEGIN
	nCount	:= array_upper(fnode_array, 1);
	for nIndex in 1..(nCount-1) loop
		if (fnode_array[nIndex] = nTargetNode) or (tnode_array[nIndex] = nTargetNode) then
			return nIndex;
		end if;
	end loop;
	raise INFO 'signpost wrong: target node is not on the path';
	return 0;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_hwy_in_out_type(nNodeID bigint, junction smallint, sapa smallint)
	RETURNS smallint
	LANGUAGE plpgsql volatile
AS $$
DECLARE
	s_node_array         bigint[];
	e_node_array         bigint[];
	one_way_code_array   bigint[];
	road_type_array      bigint[];
	link_type_array      bigint[];
	i                    integer;
	j                    integer;
BEGIN
	 
	SELECT array_agg(s_node), array_agg(e_node), array_agg(one_way_code), 
	       array_agg(road_type), array_agg(link_type)
	  into s_node_array, e_node_array, one_way_code_array, road_type_array, link_type_array
	  FROM (
		SELECT 1 as gid, s_node, e_node, one_way_code, road_type, link_type
		FROM link_tbl
		where s_node = nNodeID or e_node = nNodeID
	  ) AS A
	  group by gid;
	  
	i            := 1;
	--raise info 's_node_array: %', s_node_array;
	while i <= array_upper(s_node_array, 1) loop
		-- JCT
		if junction = 1 and link_type_array[i] in (3) then
			if one_way_code_array[i] in (1, 4) then
				raise info 'sa node_id: %', nNodeID;
				return NULL;
			end if;
			--raise info 'nNodeID: %, s_node: %, e_node: %, one_way_code: %', nNodeID, s_node_array[i], e_node_array[i], one_way_code_array[i];
			-- In
			if (nNodeID = s_node_array[i] and 3 = one_way_code_array[i]) 
			  or (nNodeID = e_node_array[i] and 2 = one_way_code_array[i]) then
				return 0;
			else -- Out
				return 1;
			end if;
		end if;
		
		-- SAPA
		if sapa = 1 and link_type_array[i] in (7, 3) then
			if one_way_code_array[i] in (4) then
				raise info 'sa node_id: %', nNodeID;
				return NULL;
			end if;
			-- In
			if (nNodeID = s_node_array[i] and 3 = one_way_code_array[i]) 
			  or (nNodeID = e_node_array[i] and 2 = one_way_code_array[i]) then
				return 0;
			else -- Out
				return 1;
			end if;
		end if;
		i := i + 1;
	end loop;

	if junction = 1 then
		-- NODE JCT
		--i    := 1;
		--while i <= array_upper(s_node_array, 1) loop
			-- JCT
		--	if link_type_array[i] not in (2) then
		--		raise info 'Do not exist JCT LINK, node_id: %', nNodeID;
		--		return NULL;
		--	end if;
		--	i    := i + 1;
		--end loop;
		-- It is a NODE JCT
		--return 1;
		raise info 'Do not exist JCT LINK, node_id: %', nNodeID;
		return NULL;
	end if;

	if sapa = 1 then
		raise info 'Do not exist SAPA LINK, node_id: %', nNodeID;
	end if;
	
	return NULL;	
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_next_sapa_idx(sapa_array integer[], curr_idx integer)
	RETURNS integer
	LANGUAGE plpgsql volatile
AS $$
DECLARE
	i   integer;
BEGIN
	if curr_idx > 0 then
		i := curr_idx;
	else
		i := 1;
	end if;

	while i <= array_upper(sapa_array, 1) loop
		if sapa_array[i] is not null and sapa_array[i] > 0 then
			return i;
		end if;
		i := i + 1;
	end loop;
	return NUll;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_pass_lid(link_lid character varying, split_char character)
	RETURNS character varying
	LANGUAGE plpgsql
AS $$ 
DECLARE
	first_pos integer;
	last_pos integer;
	i integer;
BEGIN
	first_pos := 0;
	last_pos  := 0;
	IF link_lid IS NULL or split_char is null THEN 
		RETURN NULL;
	END IF;

	first_pos = strpos(link_lid, split_char);
	last_pos  = first_pos;
	i = first_pos + 1;
	while i <= length(link_lid) loop
		if substr(link_lid, i, 1) = split_char then
			last_pos = i;
		end if;
		i := i + 1;
	end loop;

	IF first_pos = last_pos THEN
		RETURN NULL;
	END IF;
	
	return substr(link_lid, first_pos + 1, last_pos - first_pos -1);
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_specific_char_num(org_str varchar, find_char char)
returns int
LANGUAGE plpgsql
AS
$$ 
DECLARE
	rtn_cnt int;
	str_length int;
	ipos int;
BEGIN
	ipos := 1;
	rtn_cnt := 0;
	str_length := char_length(org_str);
	while ipos <= str_length loop
		if substring(org_str,ipos, 1) = find_char then
			rtn_cnt := rtn_cnt + 1;
		end if;
		ipos := ipos +1;
	end loop;
	
	return rtn_cnt;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_toll_type(gate_info character varying)
 RETURNS  smallint[]
    LANGUAGE plpgsql
    AS  
$$ 
DECLARE
	temp         smallint[];
	cnt          integer;
	sp           integer;
	tollgatetype integer;
	mark         integer;            
BEGIN
	mark := 1;
	if gate_info is null then
		temp[1] := 0;
		temp[2] := 0;
		return temp;
	end if;
	tollgatetype := 0;
	sp = 1;
	-- Get the first record        
	--FETCH curs1 INTO ic, new_node, new_name_id, junction, pa, sa, ic_t, tollgate, gate_info, service_info_flag;
	while sp <= length(gate_info)  LOOP
		IF substring(gate_info from sp for 1) = '6' THEN 
			tollgatetype := tollgatetype | 7;
			mark := 0;
		ELSEIF substring(gate_info , sp, 1) = '5' THEN
			tollgatetype := tollgatetype | 5;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '4' THEN
			tollgatetype := tollgatetype | 3;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '3' THEN
			tollgatetype := tollgatetype | 6;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '2' THEN
			tollgatetype := tollgatetype | 4;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '1' THEN
			tollgatetype := tollgatetype | 2;
		ELSEIF substring(gate_info, sp, 1) = '0' THEN
			tollgatetype := tollgatetype | 1;
			mark := 0;
		ELSE tollgatetype := tollgatetype | 1;
		    mark := 0;
		END IF;
		sp          := sp + 1;
        
	END LOOP;
	temp[1] := tollgatetype ;
	temp[2] := mark;
    return temp;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_has_additional_lane(all_lane_info varchar) -- return 0: not, 1: right-side has, 2:left-side has, 3: both-has
RETURNS smallint
LANGUAGE plpgsql
AS
$$ 
DECLARE 
	lanecount smallint;
	itor	smallint;
	current_char char;
	left_increase boolean;
	right_increase boolean;

BEGIN
	left_increase := false;
	right_increase := false;
	
	itor := 1;
	lanecount := length(all_lane_info);
	
	WHILE itor <= lanecount LOOP
		current_char := substring(all_lane_info, itor, 1);
		if current_char >= 'G' and current_char <= 'O' then
			left_increase := true;
		end if;

		if current_char >= 'R' and current_char <= 'Z' then
			right_increase := true;
		end if;

		itor := itor + 1;
	END LOOP;

	if (left_increase and right_increase) then
		return 3;
	elsif left_increase then
		return 2;
	elsif right_increase then
		return 1;
	else 
		return 0;
	end if;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_judge_highway_link(ic_node bigint, dir integer)
  RETURNS integer 
LANGUAGE plpgsql volatile
AS $$
DECLARE
	result                   integer;	
	temp_road_type_array     bigint[];
	temp_link_type_array     bigint[];
	j                        integer;
	
BEGIN	
	result = 0;
	j = 1;
	if dir is null then
		select	array_agg(link_type), array_agg(road_type)
		into temp_link_type_array, temp_road_type_array
		from link_tbl
		where s_node = ic_node
		      or
		      e_node = ic_node;
		      
	else
		select	array_agg(link_type), array_agg(road_type)
		into temp_link_type_array, temp_road_type_array
		from link_tbl
		where(
				(
					(dir = 1)
					and
					(
						(s_node = ic_node and one_way_code in (1,2))
						or
						(e_node = ic_node and one_way_code in (1,3))
					)
				)
				or
				(
					(dir = 2)
					and
					(
						(s_node = ic_node and one_way_code in (1,3))
						or
						(e_node = ic_node and one_way_code in (1,2))
					)
				)
			);
        end if;
	
	while j <= array_upper(temp_link_type_array, 1) loop
		if temp_link_type_array[j] in (0, 1, 2) and temp_road_type_array[j] in (0, 1) then
			result = result+1;
		end if;
		j = j + 1;
	end loop;
	
	return result;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_string_count(link_lid character varying, split_char character)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	cnt integer;
	i integer;
BEGIN
	IF link_lid IS NULL or split_char is null THEN 
		RETURN 0;
	END IF;
	
	cnt = 0;
	i = 1;
	while i <= length(link_lid) loop
		if substr(link_lid, i, 1) = split_char then
			cnt := cnt + 1;
		end if;
		i := i + 1;
	end loop;

	return cnt;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION pmt_purge_activities(a_id int[]) RETURNS boolean AS $$
DECLARE
  record_id int;
  error_msg text;
BEGIN 
  -- no parameter is provided, exit
  IF $1 IS NULL THEN    
    RETURN FALSE;
  END IF;
 
  IF array_length(a_id,1)>0 THEN
    -- loop through all the activity_ids and purge each activity
    FOREACH record_id IN ARRAY a_id LOOP
      EXECUTE 'SELECT * FROM pmt_purge_activity(' || record_id || ')';
    END LOOP;
  ELSE
    -- exit if array is empty
    RETURN FALSE;
  END IF;
  -- success
  RETURN TRUE;

EXCEPTION
  -- some type of error occurred, return unsuccessful
     WHEN others THEN 
       GET STACKED DIAGNOSTICS error_msg = MESSAGE_TEXT;
       RAISE NOTICE 'Error: %', error_msg;
       RETURN FALSE;
END;  
$$ LANGUAGE 'plpgsql';",cs_.3.0.10.4.sql
"CREATE OR REPLACE FUNCTION rev_to_forward_ipv4(ipv4 TEXT) RETURNS INET AS $$ 
DECLARE
	octets TEXT[4];
	octet TEXT;
	inet_string CITEXT := '';
	num_octets INTEGER := 0;
	n INTEGER;
BEGIN
	-- Regex for matching reversed ip address starting with octet and ending in "".in-addr.arpa.""
	-- All the \d+  are inside capture groups
	-- ^(\d+)\.       There should be at-least one octet at the start of the string
	-- (?:(\d+)\.)?   We use non-capturing groups for next 3 octets with ""?"" because they might not be present
	-- (?:(\d+)\.)?
	-- (?:(\d+)\.)?
	-- in-addr\.arpa\.
	-- e.g. '10.20.in-addr.arpa.' will produce array of {'10', '20', NULL, NULL}
	SELECT regexp_matches(ipv4, '^(\d+)\.(?:(\d+)\.)?(?:(\d+)\.)?(?:(\d+)\.)?in-addr\.arpa\.$') INTO octets;
	IF octets IS NULL THEN 
		RETURN NULL;
	END IF;
	-- Validated ipv4 is something like:
	-- 'x.x.x.x.in-addr.arpa.' cidr = 32
	-- 'x.x.x.in-addr.arpa.'   cidr = 24
	-- 'x.x.in-addr.arpa.'     cidr = 16
	-- 'x.in-addr.arpa.'       cidr = 8
	-- 'x' represents numbers from 0-255 inclusive (Actual number validation is done in the statements below)
	
	FOREACH octet IN ARRAY octets LOOP
		EXIT WHEN octet IS NULL;
		
		BEGIN
			num_octets := num_octets + 1;
			n = octet :: INTEGER;

            -- Ensure number is within valid range
            IF n > 255 THEN
                RETURN NULL;
            END IF;
		
		EXCEPTION 
			WHEN OTHERS THEN
				RETURN NULL;
		END;
		
		-- When appending, we add the old string last to reverse the order of octets
		inet_string :=  octet || '.' || inet_string;
  	END LOOP;

	-- Trim the leading dot we added in for loop and append CIDR
	inet_string := TRIM(BOTH '.' FROM INET_STRING) || '/' || num_octets * 8;
	
	BEGIN
		RETURN inet_string::INET;
	EXCEPTION 
		WHEN OTHERS THEN
			RETURN NULL;
	END;
END;

$$ LANGUAGE PLPGSQL IMMUTABLE;",2020-02-28-plpgsql-reverse-ip.md
"CREATE OR REPLACE FUNCTION sf_helloworld()
RETURNS VARCHAR(30)
AS $hello$
DECLARE
	var VARCHAR(30):='Hola ';
	conter INTEGER:=1;
BEGIN
   WHILE(conter<5) LOOP
		var:=var||conter||' ';
		conter:=conter+1;
	END LOOP;
   return var;
END; $hello$
LANGUAGE plpgsql;",PLPGSQL.txt
"create function U.assign( ¶a jsonb, ¶b jsonb, variadic ¶tail jsonb[] )
  returns jsonb immutable language plpgsql as $$
  declare
    R         jsonb;
    ¶element  jsonb;
  begin
    R := U.assign( ¶a, ¶b );
    foreach ¶element in array ¶tail loop
      R := U.assign( R, ¶element );
      end loop;
    return R; end; $$;",030-utilities-1.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	SELECT dblink_get_connections() into dbname;

	IF dbname IS NOT NULL THEN

		raise notice '当前所有跨数据库连接名称:%', dbname;

		dbname:=replace(dbname, '{', '');
		dbname:=replace(dbname, '}', '');
	  	dbnames:=regexp_split_to_array(dbname, ', ');

		IF array_length(dbnames, 1) > 0 THEN
			FOR i in 1..array_length(dbnames, 1)
			LOOP
				raise notice '名称:%', dbnames[i];
				perform dblink_disconnect(dbnames[i]);
			END LOOP;
		END IF;

	ELSE
		raise notice '当前没有连接';
	END IF;
END
$$ LANGUAGE plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	SELECT dblink_get_connections() into dbname;

	IF dbname IS NOT NULL THEN

		raise notice '当前所有跨数据库连接名称:%', dbname;

		dbname:=replace(dbname, '{', '');
		dbname:=replace(dbname, '}', '');
	  	dbnames:=regexp_split_to_array(dbname, ',');

		IF array_length(dbnames, 1) > 0 THEN
			FOR i in 1..array_length(dbnames, 1)
			LOOP
				raise notice '名称:%', dbnames[i];
				perform dblink_disconnect(dbnames[i]);
			END LOOP;
		END IF;

	ELSE
		raise notice '当前没有连接';
	END IF;
END

$$ LANGUAGE plpgsql;",4_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function debugger_test (i int) returns int as $$    
declare    
v_result int;    
begin    
v_result := 0;    
if i<0 then    
  raise notice 'Please enter i >=0.';    
  raise exception '';    
end if;    
for x in 0..i loop    
v_result := v_result + x;    
end loop;    
return v_result;    
exception    
when others then    
  v_result := 0;    
  return v_result;    
end;    
$$ language plpgsql;",20170424_02.md
"create or replace function gamebox_operation_favorable_calculate(
  favorable_map 	hstore,
  amount 			FLOAT
)returns hstore as $$
DECLARE
	val 				TEXT;
	keys 				TEXT[];
	key_name 			TEXT;
	favourable_grads 	TEXT:='';	-- 优惠满足梯度
	favourable_way 		TEXT:='';	-- 优惠方式(1:固定, 2:比例)
	favourable_value 	TEXT:='';	-- 优惠值
	favourable_limit 	TEXT:='';	-- 优惠上限
	actual_value		TEXT:='';	-- 实付值
	map 				hstore;
BEGIN
	IF favorable_map is null OR amount <= 0 THEN
		SELECT put(map, 'grads', '0') INTO map;
		SELECT put(map, 'limit', '0') INTO map;
		SELECT put(map, 'value', '0') INTO map;
		SELECT put(map, 'way', '0') INTO map;
	ELSE
		keys = akeys(favorable_map);
		FOR i IN REVERSE array_length(keys,  1)..1
		LOOP
			IF amount > (keys[i]::FLOAT) THEN
				key_name = keys[i];
				exit;
			END IF;
		END LOOP;

		val = favorable_map->key_name;
		--val格式:梯度下限_梯度上限_优惠类型_优惠方式_优惠值_优惠上限
		keys = regexp_split_to_array(val, '_');
		--raise info 'vals:%', keys;
		IF array_length(keys,  1) = 6 THEN
			favourable_grads = COALESCE(keys[2], '0');	-- 梯度值
			favourable_way = COALESCE(keys[4], '1');	-- 优惠方式(1:固定, 2:比例)
			favourable_value = COALESCE(keys[5], '0');	-- 优惠值
			favourable_limit = COALESCE(keys[6], '0');	-- 上限

			IF favourable_way = '2' THEN--比例
				favourable_value = (amount * (favourable_value::FLOAT) / 100)::TEXT;
			END IF;

			actual_value = favourable_value;
			IF favourable_limit::FLOAT > 0 AND favourable_value::FLOAT > favourable_limit::FLOAT THEN--超过上限
			 	actual_value = favourable_limit;
			END IF;

			SELECT put(map, 'grads', favourable_grads) INTO map;
			SELECT put(map, 'limit', favourable_limit) INTO map;
			SELECT put(map, 'value', favourable_value) INTO map;
			SELECT put(map, 'way', favourable_way) INTO map;
			SELECT put(map, 'actual', actual_value) INTO map;
		END IF;
	END IF;
	IF map is null THEN
		SELECT put(map, 'grads', '0') INTO map;
		SELECT put(map, 'limit', '0') INTO map;
		SELECT put(map, 'value', '0') INTO map;
		SELECT put(map, 'way', '0') INTO map;
	END IF;
	RETURN map;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_favorable_calculate(
favorable_map hstore
,amount FLOAT
)returns hstore as $$
DECLARE
	val TEXT;
	keys TEXT[];
	key_name TEXT;
	favourable_grads TEXT:='';--优惠满足梯度
	favourable_way TEXT:='';--优惠方式(1:固定,2:比例)
	favourable_value TEXT:='';--优惠值
	favourable_limit TEXT:='';--优惠上限
	map hstore;
BEGIN
	IF favorable_map is null OR amount<=0 THEN
		SELECT put(map,'grads','0') INTO map;
		SELECT put(map,'limit','0') INTO map;
		SELECT put(map,'value','0') INTO map;
		SELECT put(map,'way','0') INTO map;
	ELSE
		keys=akeys(favorable_map);
		FOR i IN REVERSE array_length(keys, 1)..1 LOOP

			IF amount>(keys[i]::FLOAT) THEN
				key_name=keys[i];
				exit;
			END IF;
		END LOOP;
		val=favorable_map->key_name;
		--val格式:梯度下限_梯度上限_优惠类型_优惠方式_优惠值_优惠上限
		keys=regexp_split_to_array(val,'_');
		--raise info 'vals:%',keys;
		IF array_length(keys, 1)=6 THEN
				favourable_grads=COALESCE(keys[2],'0');--梯度值
				favourable_way=COALESCE(keys[4],'1');--优惠方式(1:固定,2:比例)
				favourable_value=COALESCE(keys[5],'0');--优惠值
				favourable_limit=COALESCE(keys[6],'0');--上限
				IF favourable_way='2' THEN--比例
					favourable_value=(amount*(favourable_value::FLOAT)/100)::TEXT;
				END IF;
				IF favourable_limit::FLOAT>0 AND favourable_value::FLOAT>favourable_limit::FLOAT THEN--超过上限
					favourable_value=favourable_limit;
				END IF;
				--raise info 'way=%',favourable_way;
				SELECT put(map,'grads',favourable_grads) INTO map;
				SELECT put(map,'limit',favourable_limit) INTO map;
				SELECT put(map,'value',favourable_value) INTO map;
				SELECT put(map,'way',favourable_way) INTO map;
		END IF;
	END IF;
	IF map is null THEN
		SELECT put(map,'grads','0') INTO map;
		SELECT put(map,'limit','0') INTO map;
		SELECT put(map,'value','0') INTO map;
		SELECT put(map,'way','0') INTO map;
	END IF;
	RETURN map;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
    val 		TEXT,
    subscript 	INT
) returns FLOAT[] as $$
DECLARE
	vals 	TEXT[];
	subs 	TEXT[];
	cs 		TEXT = '_';
	rs 		TEXT = '\^&\^';
	limit_values FLOAT[];
BEGIN
	-- ""1_01""=>""0_1000000_50^&^1000000_2000000_40^&^2000000_3000000_30""
	-- API 1,GameType 01在0到1000000比例为50...
	IF val is not null THEN
		vals = regexp_split_to_array(val, rs);
		-- raise info 'vals = %', vals;

		IF vals is not null AND array_length(vals,  1) > 0 THEN

			FOR i IN 1..array_length(vals,  1) LOOP
				subs = regexp_split_to_array(vals[i], cs);

				IF subs is not null AND array_length(subs,  1) = 3 THEN
					IF limit_values is null THEN
						limit_values = array[subs[subscript]::FLOAT];
					ELSE
						limit_values = array_append(limit_values, subs[subscript]::FLOAT);
					END IF;
				END IF;

			END LOOP;

		END IF;
	END IF;
	RETURN limit_values;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
  val 		TEXT,
  subscript 	INT
) returns FLOAT[] as $$
DECLARE
	vals 	TEXT[];
	subs 	TEXT[];
	cs 		TEXT = '_';
	rs 		TEXT = '\^&\^';
	limit_values FLOAT[];
BEGIN
	-- ""1_01""=>""0_1000000_50^&^1000000_2000000_40^&^2000000_3000000_30""
	-- API 1,GameType 01在0到1000000比例为50...
	IF val is not null THEN
		vals = regexp_split_to_array(val, rs);
		-- raise info 'vals = %', vals;

		IF vals is not null AND array_length(vals,  1) > 0 THEN

			FOR i IN 1..array_length(vals,  1) LOOP
				subs = regexp_split_to_array(vals[i], cs);

				IF subs is not null AND array_length(subs,  1) = 3 THEN
					IF limit_values is null THEN
						limit_values = array[subs[subscript]::FLOAT];
					ELSE
						limit_values = array_append(limit_values, subs[subscript]::FLOAT);
					END IF;
				END IF;

			END LOOP;

		END IF;
	END IF;
	RETURN limit_values;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
val TEXT
,subscript INT
)
returns FLOAT[] as $$
DECLARE
	vals TEXT[];
	subs TEXT[];
	cs TEXT='_';
	rs TEXT='\^&\^';
	limit_values FLOAT[];
	--retios FLOAT[];
BEGIN
	--val=map->key;
	--0_100_2^&^100_200_1^&^200_300_1^&^300_400_1^&^400_500_2
	IF val is not null THEN
		vals=regexp_split_to_array(val,rs);
		raise info 'vals=%',vals;
		IF vals is not null AND array_length(vals, 1)>0 THEN
			FOR i IN 1..array_length(vals, 1) LOOP
				subs=regexp_split_to_array(vals[i],cs);
				IF subs is not null AND array_length(subs, 1)=3 THEN
					IF limit_values is null THEN
						limit_values=array[subs[subscript]::FLOAT];
						--retios=array[subs[3]::FLOAT];
					ELSE
						limit_values=array_append(limit_values, subs[subscript]::FLOAT);
						--retios=array_append(retios, subs[3]::FLOAT);
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;
	RETURN limit_values;
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
val TEXT
,subscript INT
)
returns FLOAT[] as $$
DECLARE
	vals TEXT[];
	subs TEXT[];
	cs TEXT='_';
	rs TEXT='\^&\^';
	limit_values FLOAT[];
	--retios FLOAT[];
BEGIN
	--val=map->key;
	--0_100_2^&^100_200_1^&^200_300_1^&^300_400_1^&^400_500_2
	IF val is not null THEN
		vals=regexp_split_to_array(val,rs);
		raise info 'vals=%',vals;
		IF vals is not null AND array_length(vals, 1)>0 THEN
			FOR i IN 1..array_length(vals, 1) LOOP
				subs=regexp_split_to_array(vals[i],cs);
				IF subs is not null AND array_length(subs, 1)=3 THEN
					IF limit_values is null THEN
						limit_values=array[subs[subscript]::FLOAT];
						--retios=array[subs[3]::FLOAT];
					ELSE
						limit_values=array_append(limit_values, subs[subscript]::FLOAT);
						--retios=array_append(retios, subs[3]::FLOAT);
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;
	RETURN limit_values;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text,
	startTime 	text,
	endTime 	text,
	sids 		text,
	splitchar 	text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes 	varchar[];
	endTimes 	varchar[];
	siteids 	varchar[];
	rtn 		text:='';

BEGIN
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or rtrim(ltrim(masterhost)) = '' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

  	masterhosts:=regexp_split_to_array(masterhost, splitchar);
  	startTimes:=regexp_split_to_array(startTime, splitchar);
	endTimes:=regexp_split_to_array(endTime, splitchar);
  	siteids:=regexp_split_to_array(sids, splitchar);

	IF array_length(masterhosts, 1) > 0 THEN
		FOR i in 1..array_length(masterhosts, 1)
		LOOP
			raise notice '名称:%', masterhosts[i];
		END LOOP;
		SELECT gamebox_operations_statement(mainhost, masterhosts, startTimes, endTimes, siteids) into rtn;
	END IF;

	raise info '%', rtn;
return rtn;
END;

$$ language plpgsql;",4_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text,
	startTime 	text,
	endTime 	text,
	sids 		text,
	splitchar 	text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes 	varchar[];
	endTimes 	varchar[];
	siteids 	varchar[];
	rtn 		text:='';

BEGIN
	IF mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

  	masterhosts:=regexp_split_to_array(masterhost, splitchar);
  	startTimes:=regexp_split_to_array(startTime, splitchar);
	endTimes:=regexp_split_to_array(endTime, splitchar);
  	siteids:=regexp_split_to_array(sids, splitchar);

	IF array_length(masterhosts, 1) > 0 THEN
		FOR i in 1..array_length(masterhosts, 1)
		LOOP
			raise notice '名称:%', masterhosts[i];
		END LOOP;
		SELECT gamebox_operations_statement(mainhost, masterhosts, startTimes, endTimes, siteids) into rtn;
	END IF;

	raise info '%', rtn;
return rtn;
END;

$$ language plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text[],
	startTimes 	text[],
	endTimes 	text[],
	siteids 	text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';

BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE into curday;
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or array_length(masterhost,  1) < 0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

	--关闭所有链接.
  	perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  	perform gamebox_collect_site_infor(mainhost);

	--拆分所有站点数据库信息.
  	rtn = rtn||'1.  开始执行各个站点玩家经营报表';

	FOR i in 1..array_length(masterhost,  1)
	LOOP
     	raise notice '%.当前站点库信息：%', i, masterhost[i];
		IF rtrim(ltrim(masterhost[i])) = '' THEN
			return '站点库信息不能为空';
		END IF;

		--连接站点库
	  	perform dblink_connect('master', masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息', i, masterhost[i];
		rtn = rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		SELECT gamebox_master_operation_statement('master', siteids[i]::int, startTimes[i], endTimes[i], curday, mainhost) into tmp;
		rtn = rtn||'||'||tmp;
	  	raise info '%.收集完毕', i;
		--收集站点经营报表
		rtn = rtn||'4.  开始执行站点经营报表';
		SELECT gamebox_operation_site('master', curday) into tmp;
		rtn = rtn||'||'||tmp;
		perform dblink_disconnect('master');
	END LOOP;

	rtn = rtn||'5.  开始执行站长经营报表';
	SELECT gamebox_operation_master(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;
	rtn = rtn||'6.  开始执行运营商经营报表';
	SELECT gamebox_operation_company(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;

return rtn;
END;

$$ LANGUAGE plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text[],
	startTimes 	text[],
	endTimes 	text[],
	siteids 	text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';

BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE into curday;
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or array_length(masterhost,  1) < 0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

	--关闭所有链接.
  	perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  	perform gamebox_collect_site_infor(mainhost);

	--拆分所有站点数据库信息.
  	rtn = rtn||'1.开始执行各个站点玩家经营报表';

	FOR i in 1..array_length(masterhost,  1)
	LOOP
     	raise notice '%.当前站点库信息：%', i, masterhost[i];
		IF rtrim(ltrim(masterhost[i])) = '' THEN
			return '站点库信息不能为空';
		END IF;

		--连接站点库
	  	perform dblink_connect('master', masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息', i, masterhost[i];
		rtn = rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		SELECT gamebox_master_operation_statement('master', siteids[i]::int, startTimes[i], endTimes[i], curday, mainhost) into tmp;
		rtn = rtn||'||'||tmp;
	  	raise info '%.收集完毕', i;
		--收集站点经营报表
		rtn = rtn||'4.  开始执行站点经营报表';
		SELECT gamebox_operation_site('master', curday) into tmp;
		rtn = rtn||'||'||tmp;
		perform dblink_disconnect('master');
	END LOOP;

	rtn = rtn||'5.  开始执行站长经营报表';
	SELECT gamebox_operation_master(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;
	rtn = rtn||'6.  开始执行运营商经营报表';
	SELECT gamebox_operation_company(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;

return rtn;
END;

$$ LANGUAGE plpgsql;",4_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库
		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--收集站点经营报表
			rtn=rtn||'2.  开始执行站点经营报表';
			select gamebox_operation_site('master',curday) into tmp;
			rtn=rtn||'||'||tmp;
		  perform dblink_disconnect('master');
	end loop;
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库
		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--收集站点经营报表
			rtn=rtn||'2.  开始执行站点经营报表';
			select gamebox_operation_site('master',curday) into tmp;
			rtn=rtn||'||'||tmp;
		  perform dblink_disconnect('master');
	end loop;
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
		if rtrim(ltrim(masterhost[i]))='' THEN
			return '站点库信息不能为空';
		end if;
		--连接站点库
	  	perform dblink_connect('master',masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
		rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
		rtn=rtn||'||'||tmp;
	  	raise info '%.收集完毕',i;
		--收集站点经营报表
		rtn=rtn||'4.  开始执行站点经营报表';
		select gamebox_operation_site('master',curday) into tmp;
		rtn=rtn||'||'||tmp;
		perform dblink_disconnect('master');
	end loop;
	rtn=rtn||'5.  开始执行站长经营报表';
	select gamebox_operation_master(curday::TEXT) into tmp;
	rtn=rtn||'||'||tmp;
	rtn=rtn||'6.  开始执行运营商经营报表';
	select gamebox_operation_company(curday::TEXT) into tmp;
	rtn=rtn||'||'||tmp;
return rtn;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(mainhost text,masterhost text,startTime text,endTime text,splitchar text) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(mainhost text,masterhost text[],startTimes text[],endTimes text[]) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
   rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库

		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_player_statement('master',1,startTimes[i],endTimes[i],curday) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--处理另外一些报表信息收集
			--@todo
		  perform dblink_disconnect('master');
	end loop;
			--统一执行代理以上的经营报表
			--执行代理经营报表
			rtn=rtn||'2.  开始执行代理经营报表';
			select gamebox_agent_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;
			--执行总代经营报表
			rtn=rtn||'3.  开始执行总代经营报表';
			select gamebox_topagent_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;
			--执行站点经营报表
			rtn=rtn||'4.  开始执行站点经营报表';
			select gamebox_site_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;

	--return '运营信息收集完毕';
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function gamebox_rakeback_calculator(gradshash hstore,agenthash hstore,rec json) returns FLOAT as $$
DECLARE
	--gradshash hstore;
	--agenthash hstore;
	--rec record;
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	--临时Hstore
	hash hstore;
	--梯度有效交易量
	valid_value float:=0.00;
	--上次梯度有效交易量
	pre_valid_value float:=0.00;
	--返水值.
	back_water_value float:=0.00;
	--占成
	ratio float:=0.00;
	--最大返水上限
	max_back_water float:=0.00;
	--玩家有效交易量
	effective_trade_amount float:=0.00;
	--梯度ID.
	back_water_id int:=0;
	--API
	api int:=0;
	--游戏类型
	gameType text;
	--代理ID
	agent_id text;
BEGIN
		--raise info 'gradshash=%',gradshash;
		keys=akeys(gradshash);
		--raise info 'Len=%',array_length(keys, 1);
	  --raise info 'rec=%',rec;
		for i in 1..array_length(keys, 1) loop
			subkeys=regexp_split_to_array(keys[i],'_');
			keyname=keys[i];

		  back_water_id=rec->>'rakeback_id';
			api=rec->>'api_id';
			gameType=rtrim(ltrim(rec->>'game_type'));
			--玩家未设置返水梯度,取当前玩家的代理返水梯度.
			agent_id=rec->>'owner_id';
			--raise info '代理ID:%,梯度:%',keyname,back_water_id;
			if back_water_id is null THEN
				back_water_id=agenthash->agent_id;
			end if;
			if back_water_id is null THEN
				--raise exception '%:玩家未设置返水梯度,代理也未设置',rec->>'username';
				raise info '%:玩家未设置返水梯度,代理也未设置',rec->>'username';
				return 0;
			end if;
			--raise info 'gameType=%',gameType;
			IF subkeys[1]::int=back_water_id AND subkeys[3]::int=api AND rtrim(ltrim(subkeys[4]))=gameType
			THEN
	      --raise info 'key=%',subkeys;
				--raise info '找到返水主方案:%',subkeys[1];
				--开始作比较.
			  --raise info 'val=%',gradshash->keyname;
				val=gradshash->keyname;
			  --玩家有效交易量
				effective_trade_amount=(rec->>'effective_trade_amount')::float;
				--判断是否已经比较够且有效交易量大于当前值.
				--raise info '%>%:%',effective_trade_amount,pre_valid_value,(effective_trade_amount>pre_valid_value);
				IF effective_trade_amount>pre_valid_value THEN
					select * from strToHash(val) into hash;
					--占成数
					ratio=(hash->'ratio')::float;
					--梯度有效交易量
					valid_value=(hash->'valid_value')::float;
					--返水上限
					max_back_water=(hash->'max_rakeback')::float;

					--raise info '梯度有效交易量:%,返水上限:%,占成比例:%,占成比例:%',valid_value,max_back_water,ratio,effective_trade_amount;
					--raise info '返水上限:%',max_back_water;
					--raise info '占成比例:%',ratio;
					--raise info '玩家有效值:%',effective_trade_amount;

					IF effective_trade_amount >= valid_value THEN
						--存储此次梯度有效交易量,作下次比较.
						pre_valid_value=valid_value;
						--返水计算:有效交易量*占成
						back_water_value=effective_trade_amount*ratio/100;
						--返水大于返水上限，以上限值为准.
						IF back_water_value>max_back_water THEN
								back_water_value=max_back_water;
						END IF;
						raise info '玩家信息.ID:%,API:%,GAMETYPE:%,有效交易量:%,梯度.有效交易量:%,上限:%,比例:%,返水:%'
							,rec->>'player_id',api,gameType,effective_trade_amount,valid_value,max_back_water,ratio,back_water_value;
					END IF;
					--raise info '玩家返水值:%',back_water_value;
				END IF;
			ELSE
			--	raise info '没找到返水方案';
			END IF;
		END LOOP;
	return back_water_value;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限
	max_rebate 			float:=0.00;

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';

BEGIN
  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = 'settle'
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					max_rebate		= (hash->'max_rebate')::float;		-- 返佣上限
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	flag 		TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限
	max_rebate 			float:=0.00;

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';
	settle_state 		TEXT:='settle';

BEGIN

	IF flag = 'N' THEN
		settle_state:='pending_settle';
	END IF;

  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = settle_state
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					max_rebate		= (hash->'max_rebate')::float;		-- 返佣上限
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	flag 		TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';
	settle_state 		TEXT:='settle';

BEGIN

	IF flag = 'N' THEN
		-- settle_state:='pending_settle';
	END IF;

  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = settle_state
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_agent_check(
gradshash hstore
,agenthash hstore
,start_time TIMESTAMP
,end_time TIMESTAMP
) returns hstore as $$
DECLARE
	rec record;
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	vals text[];
	param text:='';
	--临时Hstore
	hash hstore;
	tmphash hstore;
	checkhash hstore;
	--梯度有效交易量
	valid_value float:=0.00;
	--上次梯度有效交易量
	pre_valid_value float:=0.00;
	pre_player_num int=0;
	pre_profit float=0.00;
	--返水值.
	back_water_value float:=0.00;
	--占成
	ratio float:=0.00;
	--最大返佣上限
	max_rebate float:=0.00;

	--盈亏总额
  profit_amount float:=0.00;
	--有效玩家数
	player_num int:=0;
	--玩家有效交易量
	effective_trade_amount float:=0.00;
	--代理返佣主方案.
	rebate_id int:=0;

	--API
	api int:=0;
	--游戏类型
	gameType text;
	--代理ID
	agent_id text;

	--有效玩家数.
  valid_player_num int:=0;
	total_profit float:=0.00;
	col_aplit TEXT:='_';
BEGIN
  keys=akeys(gradshash);
  --raise info '%',agenthash;
	--raise info 'Len=%',array_length(keys, 1);
	FOR rec IN
            SELECT
            a.id,a.username,
						count(DISTINCT o.player_id) player_num,
						sum(-COALESCE(o.profit_amount,0)) as profit_amount,
            sum(COALESCE(o.effective_trade_amount,0)) AS effective_trade_amount
            FROM player_game_order o,sys_user u,sys_user a
	          where o.player_id=u.id
					  and u.owner_id=a.id
						and o.create_time>=start_time and o.create_time<end_time
            GROUP BY a.id,a.username
   LOOP
		  --重置变量.
			pre_valid_value=0.00;
			pre_profit=0.00;
      pre_player_num=0;
			--玩家数.
			player_num=rec.player_num;
			--代理盈亏总额
			profit_amount=rec.profit_amount;
			--代理有效交易量
			effective_trade_amount=rec.effective_trade_amount;
	    --raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;
      --如果代理盈亏总额为正时，才有返佣.
			--为了作测试.先把盈亏总额置为正数.
			--profit_amount=-profit_amount;
		  --player_num=5;
			if profit_amount<=0 THEN
				CONTINUE;
			end IF;
			--取得返佣主方案.
			agent_id:=(rec.id)::text;
		  --raise info '代理ID:%',agent_id;
			--判断代理是否设置了返佣梯度.
			--raise info 'isexists(agenthash,agent_id)=%',isexists(agenthash,agent_id);
			if isexists(agenthash,agent_id) THEN
					rebate_id=agenthash->agent_id;
				  --raise info 'rec=%',rec;
				for i in 1..array_length(keys, 1) loop
					--KEY格式. rebate_id+grads_id+api_id+game_type
					subkeys=regexp_split_to_array(keys[i],'_');
					keyname=keys[i];
					--raise info 'key=%',subkeys;
					--raise info '%,%,rebate_id=%',subkeys[1],rebate_id,((subkeys[1]::int)=rebate_id);
          --取得当前返佣梯度.

					IF subkeys[1]::int=rebate_id THEN
						--判断是否已经比较过且有效交易量大于当前值.
						--raise info '%>%:%',effective_trade_amount,pre_valid_value,(effective_trade_amount>pre_valid_value);
						--IF effective_trade_amount>pre_valid_value THEN
	             --raise info 'val=%',gradshash->keyname;
              val=gradshash->keyname;
							--raise info 'val=%',val;
							--判断如果存在多条记录，取第一条.
							vals=regexp_split_to_array(val,'\^\&\^');
							--raise info 'vals.len:%',array_length(vals, 1);
							IF array_length(vals, 1)>1 THEN
								val=vals[1];
							END IF;
							select * from strToHash(val) into hash;
							--有效玩家数
							valid_player_num=(hash->'valid_player_num')::int;
							--占成数
							ratio=(hash->'ratio')::float;
							--梯度有效交易量
							valid_value=(hash->'valid_value')::float;
							--返佣上限
							max_rebate=(hash->'max_rebate')::float;
							--盈亏总额
							total_profit=(hash->'total_profit')::float;

						 /*
							raise info '玩家数:%,盈亏:%,交易量:%,梯度.有效玩家:%,盈亏:%,交易量:%'
							,player_num,profit_amount,effective_trade_amount
							,valid_player_num,total_profit,valid_value;
						  */
							--raise info '梯度有效交易量:%,返佣上限:%,盈亏总额:%,玩家数:%,占成比例:%',valid_value,max_rebate,total_profit,valid_player_num,ratio;
							--raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;
							--有效交易量、盈亏总额、有效玩家数.进行比较.
						--因为一个返佣设置会有多个梯度.
						IF total_profit>=pre_profit OR valid_player_num>=pre_player_num THEN
							IF effective_trade_amount >= valid_value
								and profit_amount>=total_profit
								and player_num>=valid_player_num
							THEN
								--存储此次梯度有效交易量,作下次比较.
								--pre_valid_value=valid_value;
								pre_profit=total_profit;
								pre_player_num=valid_player_num;
								--代理满足第一阶条件，满足有效交易量与盈亏总额
								--param=agent_id||'=>'||'T|'||subkeys[1]||'|'||subkeys[2];
								--param=agent_id||'=>T_'||subkeys[1]||'_'||subkeys[2];
								param=agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;
							 -- raise info 'hash is null:%',(hash is null);
								if checkhash is null THEN
									select param into checkhash;
								else
									select param into tmphash;
									--合并
									checkhash=checkhash||tmphash;
								END IF;
							END IF;
						END IF;
					END IF;
				END LOOP;
			ELSE
				  raise info '代理ID:%,没有设置返佣梯度.',agent_id;
			END IF;
	END LOOP;
	return checkhash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_calculator(
rebate_grads_map hstore
,agent_check_map hstore
,operation_occupy_map hstore
,agent_id INT
,player_id INT
,api_id INT
,game_type TEXT
,profit_amount FLOAT
) returns FLOAT as $$
DECLARE
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	vals text[];
	--临时Hstore
	hash hstore;

	rebate_value float:=0.00;--返佣值.
	ratio float:=0.00;--占成
	max_rebate float:=0.00;--最大返佣上限

	rebate_id text;	--梯度ID.
	api TEXT;--API
	agent text;--代理ID
	player text;--玩家
	operation_occupy float:=0.00;--运营商API占成.

	col_split TEXT:='_';
BEGIN
		player=(player_id::TEXT);
		api=(api_id::TEXT);
		agent=(agent_id::TEXT);
		--raise info 'check_map:%,agent:%',agent_check_map,agent;
		IF isexists(agent_check_map,agent)=false THEN --梯度不满足时不返佣
			RETURN 0.00;
		ELSEIF profit_amount<=0 THEN --盈亏为负时,不返佣
			RETURN 0.00;
		END IF;

		rebate_id=agent_check_map->agent;
		vals=regexp_split_to_array(rebate_id,'_');
    --vals=regexp_split_to_array(rebate_id,col_split_char);
		rebate_id=vals[1]||'_'||vals[2];
		keys=akeys(rebate_grads_map);

		for i in 1..array_length(keys, 1) loop
			keyname=keys[i];
			subkeys=regexp_split_to_array(keyname,'_');
			--subkeys=regexp_split_to_array(keyname,col_split_char);
			/*
			if position(rebate_id in keyname)=1 then
			raise info '%,api:%,game_type:%',keyname,api,gameType;
			end if;
			*/
			--raise info 'rebate_id:%,keyname:%,api:%,game_type:%',rebate_id,keyname,api,game_type;
			IF position(rebate_id in keyname)=1 AND subkeys[3]=api AND rtrim(ltrim(subkeys[4]))=game_type
			THEN
				--开始作比较.
				val=rebate_grads_map->keyname;
				--判断如果存在多条记录，取第一条.
				vals=regexp_split_to_array(val,'\^\&\^');
				--vals=regexp_split_to_array(val,row_split_char);
				IF array_length(vals, 1)>1 THEN
					val=vals[1];
				END IF;

				select * from strToHash(val) into hash;
				ratio=(hash->'ratio')::float;--占成数
				max_rebate=(hash->'max_rebate')::float;--返佣上限

				--raise info '梯度有效交易量:%,返佣上限:%,盈亏总额:%,玩家数:%,占成比例:%',valid_value,max_rebate,total_profit,valid_player_num,ratio;
				--raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;

				--返佣计算公式如下：
				--各API各分类佣金总和
				--=[各API各分类盈亏总和-(各API各分类盈亏总和*运营商占成）]*代理的佣金比例；
				--此处需要取得各个API运营商占成.
				--@todo.运营商API占成
				--main_ratio=0;
				--根据playerId+apiId+gameType取得运营商占成.
				keyname=player||col_split||api||col_split||game_type;
				operation_occupy=(operation_occupy_map->keyname)::FLOAT;
				operation_occupy=coalesce(operation_occupy,0);

				raise info '运营商占成额:%',operation_occupy;
				rebate_value=(profit_amount-operation_occupy)*ratio/100;
        --raise info '[各API各分类盈亏总和 -(各API各分类盈亏总和*运营商占成）]*代理的佣金比例,计算:%*(1-%)*%/100=%',profit_amount,main_ratio,ratio,rebate_value;
				--返水大于返水上限，以上限值为准.
				IF max_rebate is not null and rebate_value>max_rebate THEN
					rebate_value=max_rebate;
				END IF;
				raise info '代理返佣值:%',rebate_value;
			END IF;
		END LOOP;
	return rebate_value;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_site_information(
	main_url 	TEXT,
	master_urls TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '-1, 运营商URL为空';
		RETURN '1, 运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '-1, 站点库URL为空';
		RETURN '2, 站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1, 分隔符为空';
		RETURN '3, 分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);

	IF array_length(dblink_urls, 1) > 0 THEN

		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_role_information(dblink_urls[i]);
		END LOOP;

	END IF;
	RETURN '0';
END;

$$ language plpgsql;",1_gamebox_site_information.sql
"create or replace function gamebox_site_information(
	main_url TEXT,
	master_urls TEXT,
	split TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '-1, 运营商URL为空';
		RETURN '1, 运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '-1, 站点库URL为空';
		RETURN '2, 站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1, 分隔符为空';
		RETURN '3, 分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);

	IF array_length(dblink_urls,  1) > 0 THEN

		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1)
		LOOP
			perform gamebox_role_information(dblink_urls[i]);
		END LOOP;

	END IF;
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0003__C_gamebox_site_information.sql
"create or replace function gamebox_site_information(
main_url TEXT
,master_urls TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
BEGIN
	IF ltrim(rtrim(main_url))='' THEN
		raise info '-1,运营商URL为空';
		RETURN '1,运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '-1,站点库URL为空';
		RETURN '2,站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1,分隔符为空';
		RETURN '3,分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	IF array_length(dblink_urls, 1)>0 THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_information(dblink_urls[i]);
		END LOOP;
	END IF;
	RETURN '0';
END;
$$ language plpgsql;",V1.0.1.0020__C_gamebox_site_information.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	rake_map 	hstore;
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;

BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master',  master_url);
	SELECT site_id FROM dblink('master', ' SELECT  * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
	SELECT gamebox_site_map(sid) INTO dict_map;

	date_time = end_time::TIMESTAMP;
	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month=>'||c_month)::hstore)||dict_map;

	SELECT  * FROM dblink(
		'master',
		'SELECT * FROM gamebox_rakeback_map('''||start_time||'''::TIMESTAMP, '''||end_time||'''::TIMESTAMP, '''||main_url||''', '''||category||''')'
	) as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys = akeys(rake_map);

		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i]) > 1 THEN
				sub_keys = regexp_split_to_array(keys[i], col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num = 1;
				ELSEIF exist(num_map, sub_keys[1]) = FALSE THEN
					num_map = (SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num = player_num + 1;
				END IF;
				--统计API.GAME_TYPE
				sub_key = sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map, sub_key) THEN
					val = (rake_map->keys[i])::FLOAT;
					val = val + ((api_map->sub_key)::FLOAT);
					api_map = (SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map = (SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;

		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map, dict_map);

		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);

		raise info '站点返水.玩家';
		dict_map = (SELECT ('player_num=>'||player_num)::hstore)||dict_map;

		perform gamebox_site_rakeback_player(dict_map);

	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0007__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	rake_map 	hstore;
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;

BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master', master_url);
	SELECT site_id FROM dblink('master', 'SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
	SELECT gamebox_site_map(sid) INTO dict_map;

	date_time = end_time::TIMESTAMP;
	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month=>'||c_month)::hstore)||dict_map;

	SELECT  * FROM dblink(
		'master',
		'SELECT * FROM gamebox_rakeback_map('''||start_time||'''::TIMESTAMP, '''||end_time||'''::TIMESTAMP, '''||main_url||''', '''||category||''')'
	) as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys = akeys(rake_map);

		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i]) > 1 THEN
				sub_keys = regexp_split_to_array(keys[i], col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num = 0;
				ELSEIF exist(num_map, sub_keys[1]) = FALSE THEN
					num_map = (SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num = player_num + 1;
				END IF;
				--统计API.GAME_TYPE
				sub_key = sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map, sub_key) THEN
					val = (rake_map->keys[i])::FLOAT;
					val = val + ((api_map->sub_key)::FLOAT);
					api_map = (SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map = (SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;

		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map, dict_map);

		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);

		raise info '站点返水.玩家';
		dict_map = (SELECT ('player_num=>'||player_num)::hstore)||dict_map;

		perform gamebox_site_rakeback_player(dict_map);

	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0017__U_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_site_rakeback(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0007__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_site_rakeback(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0017__U_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	rec record;
	cnum INT;
	rake_map hstore;
	category TEXT:='API';
	keys TEXT[];
	sub_keys TEXT[];
	sub_key TEXT:='';
	col_split TEXT:='_';
	num_map hstore;
	api_map hstore;
	dict_map hstore;
	param TEXT:='';
	sid INT;--站点ID.
	val FLOAT;
	date_time TIMESTAMP;
	c_year INT;
	c_month INT;
	player_num INT;
BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1,站点库URL为空';
	END IF;
	perform dblink_close_all();
	perform dblink_connect('master', master_url);
  SELECT site_id FROM dblink('master',' SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
  SELECT gamebox_site_map(sid) INTO dict_map;
	date_time=end_time::TIMESTAMP;
	select extract(year from date_time) INTO c_year;
	select extract(month from date_time) INTO c_month;
	dict_map=(SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map=(SELECT ('month=>'||c_month)::hstore)||dict_map;

	select * from dblink('master'
	,'select * from gamebox_rakeback_map(
	'''||start_time||'''::TIMESTAMP,'''||end_time||'''::TIMESTAMP
	,'''||main_url||''','''||category||''')') as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys=akeys(rake_map);
		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i])>1 THEN
				sub_keys=regexp_split_to_array(keys[i],col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num=1;
				ELSEIF exist(num_map,sub_keys[1])=FALSE THEN
					num_map=(SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num=player_num+1;
				END IF;
				--统计API.GAME_TYPE
				sub_key=sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map,sub_key) THEN
					val=(rake_map->keys[i])::FLOAT;
					val=val+((api_map->sub_key)::FLOAT);
					api_map=(SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map=(SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;
		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map,dict_map);
		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);
		raise info '站点返水.玩家';
		dict_map=(SELECT ('player_num=>'||player_num)::hstore)||dict_map;
		perform gamebox_site_rakeback_player(dict_map);
	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0021__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	rec record;
	cnum INT;
	rake_map hstore;
	category TEXT:='API';
	keys TEXT[];
	sub_keys TEXT[];
	sub_key TEXT:='';
	col_split TEXT:='_';
	num_map hstore;
	api_map hstore;
	dict_map hstore;
	param TEXT:='';
	sid INT;--站点ID.
	val FLOAT;
	date_time TIMESTAMP;
	c_year INT;
	c_month INT;
	player_num INT;
BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1,站点库URL为空';
	END IF;
	perform dblink_close_all();
	perform dblink_connect('master', master_url);
  SELECT site_id FROM dblink('master',' SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
  SELECT gamebox_site_map(sid) INTO dict_map;
	date_time=end_time::TIMESTAMP;
	select extract(year from date_time) INTO c_year;
	select extract(month from date_time) INTO c_month;
	dict_map=(SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map=(SELECT ('month=>'||c_month)::hstore)||dict_map;

	select * from dblink('master'
	,'select * from gamebox_rakeback_map(
	'''||start_time||'''::TIMESTAMP,'''||end_time||'''::TIMESTAMP
	,'''||main_url||''','''||category||''')') as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys=akeys(rake_map);
		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i])>1 THEN
				sub_keys=regexp_split_to_array(keys[i],col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num=1;
				ELSEIF exist(num_map,sub_keys[1])=FALSE THEN
					num_map=(SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num=player_num+1;
				END IF;
				--统计API.GAME_TYPE
				sub_key=sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map,sub_key) THEN
					val=(rake_map->keys[i])::FLOAT;
					val=val+((api_map->sub_key)::FLOAT);
					api_map=(SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map=(SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;
		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map,dict_map);
		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);
		raise info '站点返水.玩家';
		dict_map=(SELECT ('player_num=>'||player_num)::hstore)||dict_map;
		perform gamebox_site_rakeback_player(dict_map);
	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0034__E_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rakeback(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0021__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rakeback(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0034__E_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];
BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1) LOOP
			perform gamebox_site_rebate(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0004__C_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];
BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1) LOOP
			perform gamebox_site_rebate(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0014__U_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rebate(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0022__C_gamebox_site_rebate.sql
"create or replace function gamebox_station_bill(
    main_url    TEXT,
    master_urls TEXT,
    start_times TEXT,
    end_times 	TEXT,
    split 		TEXT,
    flag 		INT
) returns TEXT as $$
DECLARE
    dblink_urls TEXT[];
    start_time 	TEXT[];
    end_time 	TEXT[];

BEGIN
    IF ltrim(rtrim(main_url)) = '' THEN
        raise info '运营商URL为空';
        RETURN '运营商URL为空';
    ELSEIF ltrim(rtrim(master_urls)) = '' THEN
        raise info '站点库URL为空';
        RETURN '站点库URL为空';
    ELSEIF ltrim(rtrim(split)) = '' THEN
        raise info '分隔符为空';
        RETURN '分隔符为空';
    END IF;

    dblink_urls:=regexp_split_to_array(master_urls, split);
    start_time:=regexp_split_to_array(start_times, split);
    end_time:=regexp_split_to_array(end_times, split);

    IF array_length(dblink_urls, 1) > 0
        AND array_length(dblink_urls, 1) = array_length(start_time, 1)
        AND array_length(dblink_urls, 1) = array_length(end_time, 1)
    THEN
        perform dblink_close_all();
        perform gamebox_collect_site_infor(main_url);
        FOR i IN 1..array_length(dblink_urls, 1)
        LOOP
            perform gamebox_station_bill(main_url, dblink_urls[i], start_time[i], end_time[i], flag);
        END LOOP;
    ELSE
        raise info '参数格式或者数量不一致';
        RETURN '参数格式或者数量不一致';
    END IF;

    RETURN '0';
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
  main_url 	TEXT,
  master_urls TEXT,
  start_times TEXT,
  end_times 	TEXT,
  split 		TEXT,
  flag 		INT
) returns TEXT as $$
DECLARE
  dblink_urls TEXT[];
  start_time 	TEXT[];
  end_time 	TEXT[];

BEGIN
  IF ltrim(rtrim(main_url)) = '' THEN
    raise info '1-运营商URL为空';
    RETURN '1-运营商URL为空';
  ELSEIF ltrim(rtrim(master_urls)) = '' THEN
    raise info '1-站点库URL为空';
    RETURN '1-站点库URL为空';
  ELSEIF ltrim(rtrim(split)) = '' THEN
    raise info '1-分隔符为空';
    RETURN '1-分隔符为空';
  END IF;

  dblink_urls:=regexp_split_to_array(master_urls, split);
  start_time:=regexp_split_to_array(start_times, split);
  end_time:=regexp_split_to_array(end_times, split);

  IF array_length(dblink_urls, 1) > 0
     AND array_length(dblink_urls, 1) = array_length(start_time, 1)
     AND array_length(dblink_urls, 1) = array_length(end_time, 1)
  THEN
    perform dblink_close_all();
    perform gamebox_collect_site_infor(main_url);
    FOR i IN 1..array_length(dblink_urls, 1)
    LOOP
      perform gamebox_station_bill(main_url, dblink_urls[i], start_time[i], end_time[i], flag);
    END LOOP;
  ELSE
    raise info '1-参数格式或者数量不一致';
    RETURN '1-参数格式或者数量不一致';
  END IF;

  RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
,flag INT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_station_bill(main_url,dblink_urls[i],start_time[i],end_time[i],flag);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
,flag INT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_station_bill(main_url,dblink_urls[i],start_time[i],end_time[i],flag);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
    cost_map 	hstore,
    sys_map 	hstore,
    bill_id 	INT
) returns FLOAT as $$
DECLARE
	map 		hstore;
	expense_category 	TEXT[]:=array['backwater', 'refund_fee', 'favourable', 'rebate'];
	category 	TEXT:='';
	expense_code 		TEXT[]:=array['rakeback_offers', 'back_charges', 'offers_recommended', 'rebate'];
	code 		TEXT:='';
	value 		FLOAT;
	amount 		FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category = expense_category[j];
		code = expense_code[j];
		value = (cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;

		map = null;
		amount = amount + COALESCE((cost_map->(category||'_apportion'))::FLOAT, 0.00);

		SELECT put(map, 'bill_id', bill_id::TEXT) into map;
		SELECT put(map, 'payable', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'actual', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'apportion', sys_map->(category||'_percent')) into map;
		SELECT put(map, 'code', code) into map;

		perform gamebox_station_bill_other(map);

	END LOOP;
	RETURN amount;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
  cost_map 	hstore,
  sys_map 	hstore,
  bill_id 	INT
) returns FLOAT as $$
DECLARE
	map 		hstore;
	expense_category 	TEXT[]:=array['backwater', 'refund_fee', 'favourable', 'rebate'];
	category 	TEXT:='';
	expense_code 		TEXT[]:=array['rakeback_offers', 'back_charges', 'offers_recommended', 'rebate'];
	code 		TEXT:='';
	value 		FLOAT;
	amount 		FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category = expense_category[j];
		code = expense_code[j];
		value = (cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;

		map = null;
		amount = amount + COALESCE((cost_map->(category||'_apportion'))::FLOAT, 0.00);

		SELECT put(map, 'bill_id', bill_id::TEXT) into map;
		SELECT put(map, 'payable', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'actual', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'apportion', sys_map->(category||'_percent')) into map;
		SELECT put(map, 'code', code) into map;

		perform gamebox_station_bill_other(map);

	END LOOP;
	RETURN amount;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
cost_map hstore
,sys_map hstore
,bill_id INT
)
returns FLOAT as $$
DECLARE
	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	amount FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category=expense_category[j];
		value=(cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;
		map=null;
		amount=amount+COALESCE((cost_map->(category||'_apportion'))::FLOAT,0.00);
		select put(map,'bill_id',bill_id::TEXT) into map;
		select put(map,'payable',cost_map->(category||'_apportion')) into map;
		select put(map,'actual',cost_map->(category||'_apportion')) into map;
		select put(map,'apportion',sys_map->(category||'_percent')) into map;
		select put(map,'code',category) into map;
		perform gamebox_station_bill_other(map);
	END LOOP;
	RETURN amount;
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
cost_map hstore
,sys_map hstore
,bill_id INT
)
returns FLOAT as $$
DECLARE
	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	amount FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category=expense_category[j];
		value=(cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;
		map=null;
		amount=amount+COALESCE((cost_map->(category||'_apportion'))::FLOAT,0.00);
		select put(map,'bill_id',bill_id::TEXT) into map;
		select put(map,'payable',cost_map->(category||'_apportion')) into map;
		select put(map,'actual',cost_map->(category||'_apportion')) into map;
		select put(map,'apportion',sys_map->(category||'_percent')) into map;
		select put(map,'code',category) into map;
		perform gamebox_station_bill_other(map);
	END LOOP;
	RETURN amount;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function generate_node_array(s_node_list bigint[], e_node_list bigint[])
returns bigint[]
language plpgsql
as
$$
declare
    resultArray bigint[];
begin
    for i in 1..array_upper(s_node_list, 1)-1 loop
        resultArray := resultArray || get_connected_node(s_node_list[i], e_node_list[i], s_node_list[i+1], e_node_list[i+1]);
    end loop;
    return resultArray;
end;
$$;",LanePushLink.py
"create or replace function generate_uid()
  returns text as
$$
declare
  chars  text [] := '{0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := chars [11 + random() * (array_length(chars, 1) - 11)];
begin
  for i in 1..10 loop
    result := result || chars [1 + random() * (array_length(chars, 1) - 1)];
  end loop;
  return result;	
end;
$$
language plpgsql;",BazarCommands.txt
"create or replace function imt_geo_planner2(inp stdaddr, opt integer)
  returns text as
$body$
declare
  sql text;
  i integer;
  rec record;
  mm integer;
  
begin
  mm := case when opt>0 then 8 else 5 end;
  sql := '';
  <<planner>>
  for i in 0..mm loop 
    sql := sql 
      || case when i>0 then '
    union
    ' else '' end
      || 'select a.*, '
                 ||i::text||' as plan, '
                 ||coalesce(to_number(quote_literal(inp.house_num),'999999999')||'::integer%2=b.refaddr::integer%2','null')||' as parity'
      || ' from stdstreets a, streets b'
      || ' where a.id=b.gid ' 
      || imt_geo_add_where_clauses(inp, i);
  end loop planner;

--  sql := 'select distinct on (id) foo.* from (' || sql || ') as foo order by id';
  -- added sub-select to enforce an order by id, plan so all servers return the same results
  sql := 'select distinct on (id) * from (select * from (' || sql || ') as bar order by id, plan) as foo order by id';

  return sql;
end;
$body$
  language plpgsql immutable;",prep-tiger-geo-new.sql
"create or replace function mid_find_sapa_by_path(nIC integer)
	RETURNS integer[]
	LANGUAGE plpgsql
AS $$ 
DECLARE	
	tmpPathArray		varchar[];
	tmpLastNodeArray	bigint[];
	tmpPathCount		integer;
	tmpPathIndex		integer;
	tmplastLinkArray	bigint[];
	
	nStartNode              bigint;
	in_out_type             smallint;
	sapa_user_id            integer;
	start_oneway_cond       character varying;
	end_oneway_cond         character varying;
	rec			record;
BEGIN
	
	-- get new node id
	select new_node into nStartNode
	  from (
		select *
		from org_interchange
		where ic = nIC
	  ) as a
	  left join mesh_mapping_tbl as b
	  on a.mesh = b.meshid_str 
	  left join temp_node_mapping as c
	  on globl_mesh_id = c.meshid and a.node = c.node;
	if not found then 
		raise info 'IC: %', nIC;
		return null;
	end if;  
	
	-- get in/out type: 
	in_out_type := mid_get_hwy_in_out_type(nStartNode, 0::smallint, 1::smallint);

	-- out: forward
	if in_out_type = 1 then 
		start_oneway_cond := '(1, 2)';
		end_oneway_cond   := '(1, 3)';
	else -- IN: backward
		start_oneway_cond := '(1, 3)';
		end_oneway_cond   := '(1, 2)';
	end if;

	--rstPathArray
	tmpPathArray		:= ARRAY[''];
	tmpLastNodeArray	:= ARRAY[nStartNode];
	tmpPathCount		:= 1;
	tmpPathIndex		:= 1;
	sapa_user_id            := 0;
	
	--raise INFO 'ic: %', nIC;
	WHILE tmpPathIndex <= tmpPathCount LOOP
		--raise INFO '%', tmpPathIndex;
		--raise INFO '%', cast(tmpPathArray[tmpPathIndex] as varchar);
		--raise INFO 'tmpLastNodeArray[tmpPathIndex]: %', tmpLastNodeArray[tmpPathIndex];
		sapa_user_id = mid_get_sapa_user_id(tmpLastNodeArray[tmpPathIndex]);
		-- found the sapa node
		if sapa_user_id > 0 then
			exit;
		end if;
		
		if array_upper(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+'), 1) >= 12 then  -- It is longer then 15.
			--raise INFO '%', 15;
			--raise INFO '%', replace(replace(cast(tmpPathArray[tmpPathIndex] as varchar), '(2)', ''), '(3)', '');
			tmpPathIndex := tmpPathIndex + 1;
			continue;
		end if;	
		
		-- search next links
		for rec in execute
				'
				 select  nextroad, a.dir, a.nextnode
				 from
				 (
					 select link_id as nextroad, ''(2)'' as dir, e_node as nextnode
					 from link_tbl
					 where	(s_node = ' || tmpLastNodeArray[tmpPathIndex]|| ') and 
							(one_way_code in ' || start_oneway_cond ||') and 
							--(road_type in (0, 1) or 
							 link_type in (3,4, 5,7)
							-- toll = 1)
					 union
					 
					 select link_id as nextroad, ''(3)'' as dir, s_node as nextnode
					 from link_tbl
					 where	(e_node = ' || tmpLastNodeArray[tmpPathIndex]|| ') and
							(one_way_code in ' || end_oneway_cond ||') and 
							--(road_type in (0, 1) or 
							 link_type in (3,4, 5,7)
							-- toll = 1)
				 )as a
				'
		loop
			if not ((rec.nextroad::varchar) = ANY(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+'))) then
				tmpPathCount        := tmpPathCount + 1;
				tmpPathArray        := array_append(tmpPathArray, cast(tmpPathArray[tmpPathIndex]||'|'||rec.nextroad as varchar));
				tmpLastNodeArray    := array_append(tmpLastNodeArray, cast(rec.nextnode as bigint));
				tmplastLinkArray    := array_append(tmplastLinkArray, cast(rec.nextroad as bigint));
			end if;
		end loop;
		
		-- next path
		tmpPathIndex := tmpPathIndex + 1;
	END LOOP;

	-- does not find.
	if sapa_user_id = 0 then 
		return array[NULL, in_out_type];
	else
		return array[sapa_user_id, in_out_type];
	end if;
END;
$$;",create_function.sql
"create or replace function mid_get_access_lane_info(all_lane_info varchar, target_arrow_info smallint, lane_array char[], lane_info_target_direction varchar)
returns varchar
LANGUAGE plpgsql
AS
$$ 
DECLARE
	current_char char;
	ipos integer;
	rtn_value smallint;
	total_lane_no integer;
	itor_cnt integer;
BEGIN
	ipos := 1;
	rtn_value := 0;
	itor_cnt := 0;
	total_lane_no := char_length(all_lane_info);
	
	if target_arrow_info = -1 then
		while ipos <= total_lane_no  loop
			current_char := substring(all_lane_info, ipos, 1);
			if current_char = 'D' then
				rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos));
			end if;

			ipos := ipos + 1;
		end loop;
	else
		while ipos <= total_lane_no loop
			current_char := substring(all_lane_info, ipos, 1);
			if current_char = any(lane_array) then
				rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos));
			end if;

			ipos := ipos + 1;
		end loop;
	end if;

	-- feedback to adjust lane info
--	if mid_get_specific_char_num(cast(rtn_value::int::bit(16) as varchar), '1') > char_length(lane_info_target_direction) then
--		-- match real lane postion
--		ipos := position(lane_info_target_direction in all_lane_info);
--
--		while itor_cnt <= char_length(lane_info_target_direction) loop
--			rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos - itor_cnt));
--			itor_cnt := itor_cnt + 1;
--		end loop;
--	end if;

	return substring(cast(rtn_value::int::bit(16) as varchar), 17 - total_lane_no, total_lane_no);
END;
$$;",create_function.sql
"create or replace function random_a_string(x integer, y integer) returns text as $$
declare
	/* The length of the string should be between x and y characters long. */
	len			integer	= x + floor(random() * ((y + 1) - x))::integer;
	characters	text	= '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	chars_len	integer	= length(characters);
	result		text	= '';
begin
	for i in 1..len loop
		result = result || substr(characters, 1 + floor(random() * chars_len)::integer, 1);
	end loop;
	return result;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function random_n_string(x integer, y integer) returns text as $$
declare
	/* The length of the string should be between x and y characters long. */
	len			integer	= x + floor(random() * ((y + 1) - x))::integer;
	characters	text	= '0123456789';
	chars_len	integer	= length(characters);
	result		text	= '';
begin
	for i in 1..len loop
		result = result || substr(characters, 1 + floor(random() * chars_len)::integer, 1);
	end loop;
	return result;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function test_param_where() returns void as $$
DECLARE
  n varchar;
BEGIN
  FOR x IN 1..9 LOOP
    select b into n from numbers where a=x;
    raise notice 'Found number %', n;
  end loop;
  return;
END
$$ LANGUAGE plpgsql;",mysql_fdw.out
"create or replace function test_param_where() returns void as $$
DECLARE
  n varchar;
BEGIN
  FOR x IN 1..9 LOOP
    select b into n from test_numbers where a=x;
    raise notice 'Found Item %', n;
  end loop;
  return;
END
$$ LANGUAGE plpgsql;",mongo_fdw.out
