"CREATE
OR REPLACE FUNCTION gamebox_master_operation_statement (
	conn TEXT,
	siteid INT,
	startTime TEXT,
	endTime TEXT,
	curday DATE,
	url text
) RETURNS TEXT AS $$
DECLARE
	rtn TEXT := '' ;
BEGIN
	SELECT
		INTO rtn P .msg
	FROM
		dblink (conn,
			'select * from gamebox_operations_statement(
'''||url||''','||siteid||','''||startTime||''','''||endTime||''')
'
		) AS P (msg TEXT) ;
	RETURN rtn ;
	END $$ LANGUAGE plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"CREATE
OR REPLACE FUNCTION gamebox_master_operation_statement (
	conn TEXT,
	siteid INT,
	startTime TEXT,
	endTime TEXT,
	curday DATE,
	url text
) RETURNS TEXT AS $$
DECLARE
	rtn TEXT := '' ;
BEGIN
	SELECT
		INTO rtn P .msg
	FROM
		dblink (conn,
			'select * from gamebox_operations_statement(
'''||url||''','||siteid||','''||startTime||''','''||endTime||''')
'
		) AS P (msg TEXT) ;
	RETURN rtn ;
	END $$ LANGUAGE plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"CREATE
OR REPLACE FUNCTION gamebox_master_operation_statement (
	conn TEXT,
	siteid INT,
	startTime TEXT,
	endTime TEXT,
	curday DATE,
	url text
) RETURNS TEXT AS $$
DECLARE
	rtn TEXT := '' ;
BEGIN
	SELECT
		INTO rtn P .msg
	FROM
		dblink (conn,
			'select * from gamebox_operations_statement(
'''||url||''','||siteid||','''||startTime||''','''||endTime||''')
'
		) AS P (msg TEXT) ;
	RETURN rtn ;
	END $$ LANGUAGE plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"CREATE
OR REPLACE FUNCTION gamebox_master_operation_statement (conn TEXT, siteid INT, startTime TEXT, endTime TEXT, curday DATE, url text
) RETURNS TEXT AS $$
DECLARE
	rtn TEXT := '' ;
BEGIN
	SELECT
		INTO rtn P .msg
	FROM
		dblink (conn,
			'SELECT * from gamebox_operations_statement(
'''||url||''', '||siteid||', '''||startTime||''', '''||endTime||''')
'
		) AS P (msg TEXT) ;
	RETURN rtn ;
	END $$ LANGUAGE plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"CREATE FUNCTION ""AlunoDisciplinaApto""(""pAluno"" character varying, ""pDisciplina"" character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	prg ""PreRequisitoGrupo""%rowtype;
	prg_status text;	
	cr_cp integer;
	cr_cp_ea integer;
	res integer;
BEGIN
	IF ""DisciplinaTemPreRequisito""(""pDisciplina"") = FALSE OR ""AlunoDisciplinaSituacao""(""pAluno"", ""pDisciplina"") <> 'NC' THEN
		return 2;
	END IF;
	
	cr_cp := ""AlunoCreditos""(""pAluno"", 'CP');
	cr_cp_ea := cr_cp + ""AlunoCreditos""(""pAluno"", 'EA');
	res := 0;
	
	FOR prg IN (SELECT * FROM ""PreRequisitoGrupo"" WHERE ""FK_Disciplina"" = ""pDisciplina"") LOOP

		IF cr_cp_ea < prg.""CreditosMinimos"" THEN
			CONTINUE; -- res := MAX(res, 0);
		END IF;
	
		prg_status := (	
			SELECT MAX(COALESCE(ad.""FK_Status"", 'NC'))
			FROM ""PreRequisitoGrupoDisciplina"" prgd
				LEFT JOIN ""AlunoDisciplina"" ad
					ON prgd.""FK_Disciplina"" = ad.""FK_Disciplina"" AND ad.""FK_Aluno"" = ""pAluno""
			WHERE prgd.""FK_PreRequisitoGrupo"" = prg.""PK_PreRequisitoGrupo""
		);

		IF prg_status = 'NC' THEN
			CONTINUE; -- res := MAX(res, 0);
		ELSIF cr_cp < prg.""CreditosMinimos"" OR prg_status = 'EA' THEN
			res := 1; -- res := MAX(res, 1);
		ELSE
			RETURN 2; -- res := MAX(res, 2);
		END IF;
	END LOOP;

	RETURN res;
END;
$$;",prisma.sql
"CREATE FUNCTION ""CALCUL_PLACES""(enfant integer, adulte integer, etudiant integer) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$BEGIN
	RETURN enfant+adulte+etudiant;
END$$;",projet_cinema_dump.txt
"CREATE FUNCTION ""CALCUL_PRIX""(a integer, b integer, c integer) RETURNS numeric
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
PRIXENF numeric;
PRIXADU numeric;
PRIXED numeric;
PRIXTOTENF numeric;
PRIXTOTADU numeric;
PRIXTOTED numeric;
BEGIN
	SELECT INTO PRIXENF PRIX FROM PRIX WHERE nom_cat='enfant';
	SELECT INTO PRIXADU PRIX FROM PRIX WHERE nom_cat='adulte';
	SELECT INTO PRIXED PRIX FROM PRIX WHERE nom_cat='etudiant';
	PRIXTOTENF=PRIXENF*a;
	PRIXTOTADU=PRIXADU*b;
	PRIXTOTED=PRIXED*c;
	RETURN PRIXTOTENF+PRIXTOTADU+PRIXTOTED;
END$$;",projet_cinema_dump.txt
"CREATE FUNCTION ""CALCUL_PRIX""(p1 numeric, p2 numeric, p3 numeric) RETURNS numeric
    LANGUAGE plpgsql STRICT
    AS $$BEGIN
	RETURN p1+p2+p3;
END$$;",projet_cinema_dump.txt
"CREATE FUNCTION ""Food Advisor"".""Log_in""(eml text, psw text, opt integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
id integer;
cck boolean;

begin
id := -1;

if(opt = 1) then
	cck := exists(select C.""Customer Id"" from ""Food Advisor"".""Customer"" C
		where C.""Email"" = eml  and C.""Password"" = psw);
	if (cck = true) then
		select C.""Customer Id"" into id from ""Food Advisor"".""Customer"" C
		where C.""Email"" = eml  and C.""Password"" = psw;
	end if;
elsif (opt = 2) then
	cck := exists(select C.""Owner Id"" from ""Food Advisor"".""Owner"" C
		where C.""Email"" = eml  and C.""Password"" = psw);
	if(cck = true) then
		select C.""Owner Id"" into id from ""Food Advisor"".""Owner"" C
		where C.""Email"" = eml  and C.""Password"" = psw;
	end if;
end if;

return id;

end;
$$;",Table
"CREATE FUNCTION ""GetMainMenuByUId""(userid integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$    DECLARE

      ref1 refcursor:= 'listCursor';         

      QueryString varchar(4000):='';     

    BEGIN    

         OPEN ref1  FOR SELECT trim(""displayName"") as ""displayName"" ,trim(""screenName"") as ""screenName"",""isVesselMenu"" FROM smartship.""Menu"" where ""isVesselMenu""=false and ""isActive""=true order by id asc;   -- Open the first cursor

      RETURN next ref1;    

    END;

    $$;",voxac-plain.backup
"CREATE FUNCTION ""GetMenuByUId""(_userid integer, _vesselid text) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$    DECLARE

      ref1 refcursor:= 'listCursor';         

    BEGIN    

    OPEN ref1  FOR SELECT trim(m.""displayName"") as ""displayName"" ,trim(m.""screenName"") as ""screenName"",m.""isVesselMenu"" FROM smartship.""Menu"" m inner join smartship.""VesselRole"" r

on m.""id""=r.""screenXId"" inner join smartship.uservesselrole vr on vr.roleid=r.""roleXId"" where m.""isVesselMenu""=true and m.""isActive""=true and vr.userid=_userId and vr.vesselid=_vesselId order by m.id asc;

      RETURN next ref1;    

    END;

    $$;",voxac-plain.backup
"CREATE FUNCTION ""bc_get_channel_location""(IN room_name varchar, OUT lat float8, OUT lon float8) RETURNS ""record"" 
	AS $BODY$
DECLARE
	location		Geometry;
BEGIN
	SELECT cl.geom INTO location
	FROM palaver.Muc_Rooms r, palaver.Muc_Rooms_Owners o, palaver.Muc_Users u,
		Location_Users lu, Current_Locations cl
	WHERE r.name = room_name AND r.id = o.room_id AND o.user_id = u.id AND
		u.username = lu.jid AND lu.user_id = cl.user_id;
	-- (this is a somewhat expensive query as you will notice, but it's the only
	--  way to go if we don't sync user ids.)	
	lat := y(location); -- PostGIS points are (long, lat)!
	lon := x(location);
END
$BODY$
	LANGUAGE plpgsql
	COST 100
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",location-butler-database-schema.sql
"CREATE FUNCTION ""bc_nearest_channel""(IN jjid varchar, IN since timestamp, IN ""k"" int4) RETURNS SETOF ""public"".""bc_nearest_channel_type"" 
	AS $BODY$DECLARE
	location 	Geometry;
BEGIN
	-- (1) determine the channel's owner's current location, if there is such
	SELECT geom INTO location 
	FROM Current_Locations l, Location_Users u
	WHERE u.jid = jjid AND l.user_id = u.user_id AND l.""timestamp"" >= since;
	IF NOT FOUND THEN
        RAISE EXCEPTION 'There is no user with jid % in Current_Locations', jjid;
	ELSIF location IS NULL THEN
		RAISE EXCEPTION 'User % does not have a current location since %, so cannot determine nearest neighbors', jjid, since;
	END IF;
	-- (2) return all the nearest channels that the given user does not own
	RETURN QUERY
		SELECT r.name, r.roomname, r.hostname, r.subject, 
			substring(r.description from 1 for 2048)::Varchar AS description, u.username,
			cl.country, cl.region, cl.city, cl.area, cl.latitude, cl.longitude, 
			ST_Distance_Sphere(location, geom) AS distance, 
			r.popularity, r.relpop, r.rank
		FROM palaver.Muc_Rooms r, palaver.Muc_Rooms_Owners o, palaver.Muc_Users u,
			Location_Users lu, Current_Locations cl
		WHERE r.id = o.room_id AND o.user_id = u.id AND u.username = lu.jid 
			AND u.username != jjid AND lu.user_id = cl.user_id AND
			NOT (cl.geom IS NULL OR cl.geom = GeometryFromText('POINT(0 0)', 4326))
			AND cl.""timestamp"" >= since AND personal = false AND hidden != true
		ORDER BY ST_Distance_Sphere(location, cl.geom)
		LIMIT k;
	RETURN;
END
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",location-butler-database-schema.sql
"CREATE FUNCTION ""bc_nearest_channel""(IN lat float8, IN lon float8, IN since timestamp, IN ""k"" int4) RETURNS SETOF ""public"".""bc_nearest_channel_type"" 
	AS $BODY$DECLARE
	location 	Geometry;
BEGIN
	-- create the internal representation of the given lat/lon coords
	location := GeometryFromText('POINT(' || lon || ' ' || lat || ')', 4326);
	-- retrieve channels close by
	RETURN QUERY
		SELECT r.name, r.roomname, r.hostname, r.subject, 
			substring(r.description from 1 for 2048)::Varchar AS description, u.username,
			cl.country, cl.region, cl.city, cl.area, cl.latitude, cl.longitude, 
			ST_Distance_Sphere(location, geom) AS distance, 
			r.popularity, r.relpop, r.rank
		FROM palaver.Muc_Rooms r, palaver.Muc_Rooms_Owners o, palaver.Muc_Users u,
			Location_Users lu, Current_Locations cl
		WHERE r.id = o.room_id AND o.user_id = u.id AND 
			u.username = lu.jid AND lu.user_id = cl.user_id AND
			NOT (cl.geom IS NULL OR cl.geom = GeometryFromText('POINT(0 0)', 4326))
			AND cl.""timestamp"" >= since AND personal = false AND hidden != true
		ORDER BY ST_Distance_Sphere(location, cl.geom)
		LIMIT k;
END
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",location-butler-database-schema.sql
"CREATE FUNCTION ""bc_nearest_neighbor""(IN uname varchar, IN since timestamp, IN ""k"" int4) RETURNS SETOF ""public"".""bc_nearest_neighbor_type"" 
	AS $BODY$
DECLARE
    location 	Geometry;
BEGIN
	-- Determine the PostGIS representation of the given user's current location
	SELECT geom INTO location 
	FROM Current_Locations
	WHERE username = uname;
	IF NOT FOUND THEN
        RAISE EXCEPTION 'There is no user with name % in Current_Locations', uname;
	ELSIF location IS NULL THEN
		RAISE EXCEPTION 'User % does not have a current location since %, so cannot determine nearest neighbors', uid, since;
	END IF;
	RETURN QUERY
		SELECT CL.user_id, CL.place_id, CL.place, CL.country, CL.region, 
			CL.city, CL.area, ST_Distance_Sphere(loc, CL.geom)
		FROM Current_Locations CL
		WHERE CL.geom IS NOT NULL AND CL.""timestamp"" >= since 
		      AND CL.user_id <> uuid
		ORDER BY ST_Distance_Sphere(loc, CL.geom)
		LIMIT k;
	RETURN;
END
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",location-butler-database-schema.sql
"CREATE FUNCTION ""f_user""(""ids"" integer) RETURNS ""void""
    LANGUAGE ""plpgsql""
    AS $$
declare red char(10);
begin
 red:=(select c_user  from t_user where idt_user = ids) ;
 -- select red;
 -- void := red;
 -- return red;
end
$$;",BD_SIS1.SQL
"CREATE FUNCTION ""f_user1""(""ids"" integer) RETURNS character varying
    LANGUAGE ""plpgsql""
    AS $$
declare red char(10);
begin
 red:=(select c_user  from t_user where idt_user = ids) ;
 -- select red;
 -- void := red;
 return red;
end
$$;",BD_SIS1.SQL
"CREATE FUNCTION ""left""(character, integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  lpad($1,$2);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into FEgroup_credits

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_credits + otherELE_credits;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into FEgroup_credits

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into FEgroup_credits

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into FEgroup_credits

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_credits + otherELE_credits;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into FEgroup_credits

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_credits + otherELE_credits;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overFE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
FEgroup_credits numeric DEFAULT 0;
otherELE_credits numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(x * y) into FEgroup_credits
	FROM allelePass
	WHERE v.domain = 'FE'
	LIMIT 1;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(x * y) into otherELE_credits
		FROM allelePass
		WHERE v.domain <> 'FE'
		LIMIT 2;
	END IF;

	return FEgroup_credits + otherELE_credits;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into FEgroup_units

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_units + otherELE_units;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into FEgroup_units

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into FEgroup_units

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into FEgroup_units

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_units + otherELE_units;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

FEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into FEgroup_units

	FROM allelePass

	WHERE v.domain = 'FE'

	LIMIT 1;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'FE'

		LIMIT 2;

	END IF;



	return FEgroup_units + otherELE_units;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overFE_dcorrection""() RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
FEgroup_units numeric DEFAULT 0;
otherELE_units numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(y) into FEgroup_units
	FROM allelePass
	WHERE v.domain = 'FE'
	LIMIT 1;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(y) into otherELE_units
		FROM allelePass
		WHERE v.domain <> 'FE'
		LIMIT 2;
	END IF;

	return FEgroup_units + otherELE_units;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into MSEEgroup_credits

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_credits + otherELE_credits;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into MSEEgroup_credits

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into MSEEgroup_credits

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into MSEEgroup_credits

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_credits + otherELE_credits;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into MSEEgroup_credits

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_credits + otherELE_credits;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overMSEE_correction""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
MSEEgroup_credits numeric DEFAULT 0;
otherELE_credits numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(x * y) into MSEEgroup_credits
	FROM allelePass
	WHERE v.domain = 'MSEE'
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(x * y) into otherELE_credits
		FROM allelePass
		WHERE v.domain <> 'MSEE'
		LIMIT 1;
	END IF;

	return MSEEgroup_credits + otherELE_credits;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into MSEEgroup_units

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_units + otherELE_units;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into MSEEgroup_units

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into MSEEgroup_units

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into MSEEgroup_units

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_units + otherELE_units;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

MSEEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into MSEEgroup_units

	FROM allelePass

	WHERE v.domain = 'MSEE'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'MSEE'

		LIMIT 1;

	END IF;



	return MSEEgroup_units + otherELE_units;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""overMSEE_dcorrection""(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
MSEEgroup_units numeric DEFAULT 0;
otherELE_units numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(y) into MSEEgroup_units
	FROM allelePass
	WHERE v.domain = 'MSEE'
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(y) into otherELE_units
		FROM allelePass
		WHERE v.domain <> 'MSEE'
		LIMIT 1;
	END IF;

	return MSEEgroup_units + otherELE_units;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ""sp_PaginationEx""(kw character varying, querycate bigint, flg bigint, lmt bigint, intpg bigint) RETURNS SETOF record
    LANGUAGE plpgsql SECURITY DEFINER
    AS $_$DECLARE

kw alias for $1;--关键词

querycate alias for $2;--查询的部门

flg alias for $3;--0表示按关键字查询,1表示非关键词查询,2表示默认查询

lmt alias for $4;--每页显示记录数

page alias for $5;--待显示页码

recs record;--返回的集合

rowcount integer;--记录总数

pagecount integer;--总页数

intpg integer;--当前页数

pagerecs record;--统计页面的记录集合

BEGIN

rowcount:=0;

pagecount:=0;

intpg:=page;

--根据flg开判断查询类型：

IF flg = 0 THEN

RAISE NOTICE 'select by keyword %',$1;

--采用关键字来查询：

--统计总记录数:

--select from government_info

select into rowcount count(*)as n from government_info WHERE title LIKE '%'||kw||'%';

pagecount:=(rowcount+lmt-1)/lmt;

IF intpg>pagecount THEN

intpg=pagecount;

END IF;

FOR recs IN SELECT info_id,title,title as classname,input_time,columnid,0 as rc,0 as pc FROM government_info WHERE title LIKE '%'||kw||'%' LIMIT lmt OFFSET (intpg-1)*lmt LOOP

recs.classname='';

recs.rc=rowcount;

recs.pc=pagecount;

--根据columnid来查询classname<开始>

DECLARE

cs record;

BEGIN

select into cs * from column_structure where classid=recs.columnid;

if not found then

else

recs.classname=cs.classname;

end if;

END;

--根据columnid查询<结束>

raise notice '%',recs.classname;

return next recs;--返回数据集

END LOOP;

ELSEIF flg = 2 THEN

RAISE NOTICE 'SELECT BY DEFAULT';

--统计总记录数:

--select from government_info

select into rowcount count(*)as n from government_info;

pagecount:=(rowcount+lmt-1)/lmt;

IF intpg>pagecount THEN

intpg=pagecount;

END IF;

--默认查询<开始>

FOR recs IN select info_id,title,title as classname,input_time,columnid,0 as rc,0 as pc from government_info order by input_time desc LIMIT lmt OFFSET (intpg-1)*lmt LOOP

recs.classname='';

recs.rc=rowcount;

recs.pc=pagecount;

--根据columnid来查询classname<开始>

DECLARE

cs record;

BEGIN

select into cs * from column_structure where classid=recs.columnid;

if not found then

else

recs.classname=cs.classname;

end if;

END;

--根据columnid查询<结束>

return next recs;--返回数据集

END LOOP;

raise notice '%',recs.classname;

--默认查询<结束>

ELSE

RAISE NOTICE 'select by departmen %',$2;

--根据所选部门查询<开始>

--判断parentid<开始>

DECLARE

--parentid integer;--上级ID

cs record;--从column_structure中查找parentid

BEGIN

SELECT INTO cs *FROM column_structure WHERE classid=querycate;

IF FOUND THEN

RAISE NOTICE 'I found the classid %',querycate;

IF cs.parentid=0 THEN

raise notice 'The cs parentid==0';

--统计总记录数:

--select from government_info

select into rowcount count(*)as n from government_info where parentid=querycate;

pagecount:=(rowcount+lmt-1)/lmt;

IF intpg>pagecount THEN

intpg=pagecount;

END IF;

for recs in select info_id,title,title as classname,input_time,columnid,0 as rc,0 as pc from government_info where parentid=querycate order by input_time desc LIMIT lmt OFFSET (intpg-1)*lmt loop

recs.classname='';

recs.rc=rowcount;

recs.pc=pagecount;

--根据columnid来查询classname<开始>

DECLARE

cs record;

BEGIN

select into cs * from column_structure where classid=recs.columnid;

if not found then

else

recs.classname=cs.classname;

end if;

END;

--根据columnid查询<结束>*/

return next recs;--返回数据集

end loop;

ELSE

raise notice 'The cs parentid not 0';

--统计总记录数:

--select from government_info

select into rowcount count(*)as n from government_info where columnid in (select classid from column_structure where parentpath like '%,'||querycate||',%' or parentid=querycate or classid=querycate);

pagecount:=(rowcount+lmt-1)/lmt;

IF intpg>pagecount THEN

intpg=pagecount;

END IF;

for recs in select info_id,title,title as classname,input_time,columnid,0 as rc,0 as pc from government_info where columnid in (select classid from column_structure where parentpath like '%,'||querycate||',%' or parentid=querycate or classid=querycate) order by input_time desc LIMIT lmt OFFSET (intpg-1)*lmt loop

recs.classname='';

recs.rc=rowcount;

recs.pc=pagecount;

--根据columnid来查询classname<开始>

DECLARE

cs record;

BEGIN

select into cs * from column_structure where classid=recs.columnid;

if not found then

else

recs.classname=cs.classname;

end if;

END;

--根据columnid查询<结束>*/

--raise notice 'title:%',recs.title;

return next recs;--返回数据集

end loop;

END IF;--Parentid=0的判断

END IF;--FOUND

END;

--判断parentid<结束>

--根据所选部门查询<结束>

END IF;

RAISE NOTICE 'rowcount:%,pagecount:%',rowcount,pagecount;

return;--默认为空

END;$_$;",ssoSysDB(pgsql).bak
"CREATE FUNCTION ""sp_inseruser1""(""tamano"" integer) RETURNS integer
    LANGUAGE ""plpgsql""
    AS $$
declare matriz integer[][];
begin

	matriz[1][1] := 1;
	matriz[1][2] := 2;

	matriz[2][1] := 1;
	matriz[2][2] := 2;
	
 return 0;
end
$$;",BD_SIS1.SQL
"CREATE FUNCTION ""website"".""__get_file_property""(IN _file_name_link text)
 RETURNS TABLE(title text, preview text, dttmup timestamptz) AS
$BODY$
declare
	_file_data bytea;
begin
	return query
		select t28001.title, t28001.preview,COALESCE( t28001.dttmup, t28001.dttmcr )
		from public.t28001 where t28001.dttmcl is null and t28001.file_name_link = _file_name_link;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_blueimp_gallery""(IN _id text)
 RETURNS TABLE(navigation int4, preview int4, controls int4, fullscreen int4, auto_slide int4, slide_interval int4, slides jsonb) AS
$BODY$
begin
		return query
			select
				a.navigation,
				a.preview,
				a.controls,
				a.fullscreen,
				a.auto_slide,
				a.slide_interval,
				a.slides jsonb
			from website.private_gallery() as a
			where a.id  = _id;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_blueimp_slider""(IN _id int4)
 RETURNS TABLE(navigation int4, preview int4, controls int4, auto_slide int4, slide_interval int4, slides jsonb) AS
$BODY$
begin
		return query
			select 
				case when t28016.navigation=true then 1 else 0 end,
				case when t28016.preview=true then 1 else 0 end,
				case when t28016.controls=true then 1 else 0 end,
				case when t28016.auto_slide=true then 1 else 0 end,
				t28016.slide_interval,
				jsonb_agg(a.js)
			from t28016
			left join (
				select
				t28017.id28016,
				json_build_object( 
					'title',t28001.title,
					'description',t28001.description,
					'image',t28001.file_name_link,
					'url',t28017.url
				) as js
				from t28017
				left join t28001 ON t28017.id28001 = t28001.idkart
--				where t28017.idkart = -1
			) as a on a.id28016 = t28016.idkart
			where t28016.idkart  = _id
			group by 
				case when t28016.navigation=true then 1 else 0 end,
				case when t28016.preview=true then 1 else 0 end,
				case when t28016.controls=true then 1 else 0 end,
				case when t28016.auto_slide=true then 1 else 0 end,
				t28016.slide_interval;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_breadcrumb""(IN _page_link text)
 RETURNS TABLE(id_row text, link text, ""name"" text, controller text, controller_next text) AS
$BODY$
begin
	return query
		with recursive temp1 ( n, obj, obj_id, parent_obj, parent_obj_id ) as 
		(
			select -1, obj, obj_id, parent_obj, parent_obj_id
			from website.private_tree_all() a
			where a.link = _page_link
			union
			select n-1, b.obj, b.obj_id, b.parent_obj, b.parent_obj_id
			from website.private_tree_all() b
			inner join temp1 as t on (b.obj=t.parent_obj and b.obj_id=t.parent_obj_id)
		)
		select  
		a.obj_id,
		a.link,
		a.name,
		a.controller,
		a.controller_next
		from temp1 as t
		inner join  website.private_tree_all() as a on (t.obj=a.obj and t.obj_id=a.obj_id)
		order by t.n;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_careers""()
 RETURNS TABLE(title text, link text) AS
$BODY$
begin
		return query
			select 
			a.title,
			a.link
			from website.private_careers() as a
			order by a.title;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_careers_property""(IN _id text)
 RETURNS TABLE(title text, link text, ""view"" text, ""date"" date, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
begin
		return query
			select 
				a.title,
				a.link,
				a.view,
				a.date_start,
				a.meta_image, 
				a.meta_keyword,
				a.meta_title,
				a.meta_description
			from website.private_careers() as a
			where a.id = _id 
			order by a.date_start;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_catalog""(IN _id text)
 RETURNS TABLE(title text, link text, img_preview text, img_view text, preview text, price numeric, date_start date, date_finish date, ""type"" text, form_event text, city_event text) AS
$BODY$
begin
	if _id is null then 
		return query
			select 
			a.title, 
			a.link,
			a.img_preview,
			a.img_view,
			a.preview,
			a.price,
			a.date_start,
			a.date_finish,
			a.type,
			a.form_event, 
			a.city_event
			from website.private_catalog(null,null,null) as a
			where a.id28005 is null;
	else 
		return query
			select 
			a.title, 
			a.link,
			a.img_preview,
			a.img_view,
			a.preview,
			a.price,
			a.date_start,
			a.date_finish,
			a.type,
			a.form_event, 
			a.city_event
			from website.private_catalog(null,null,null) as a
			where a.id28005=_id
			order by a.date_start, a.title;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_catalog_by_tags""(IN _id1 int4, IN _id2 int4, IN _id3 int4)
 RETURNS TABLE(title text, link text, img_preview text, img_view text, preview text, price numeric, date_start date, date_finish date, ""type"" text, form_event text, city_event text) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin

	if _id1 is null and _id2 is null and _id3 is null then
		return;
	end if;

	if _realtime = 1 then
		return query
			select 
			a.title, 
			a.link,
			a.img_preview,
			a.img_view,
			a.preview,
			a.price,
			a.date_start,
			a.date_finish,
			a.type,
			a.form_event, 
			a.city_event
			from website.private_catalog( _id1, _id2, _id3 ) as a
			where a.id23004 is not null
			order by a.date_start, a.title;
	else
		return query
			select 
			t28006.catalog_title, 
			t28006.catalog_link,
			t28001.file_name_link,
			t28001.file_name_link,
			t28006.catalog_preview,
			t28006.catalog_price,
			t28006.catalog_date,
			t28006.catalog_date,
			case when t28006.is_item=true then 'item' else 'folder' end,
			null::text as form_event, 
			null::text as city_event
			from t28006
			left join t28001 ON t28006.id28001 = t28001.idkart
			where t28006.dttmcl is null and t28006.is_item=true
				and (t28006.id28011 = _id1 or _id1 is null)
				and (t28006.id28012 = _id2 or _id2 is null)
				and (t28006.id28013 = _id3 or _id3 is null)
			order by t28006.catalog_date, t28006.catalog_title;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_catalog_property""(IN _id text)
 RETURNS TABLE(title text, img_preview text, img_view text, preview text, ""view"" text, price numeric, date_start date, date_finish date, meta_image text, meta_keyword text, meta_title text, meta_description text, ""type"" text, dop_info json, form_event text, city_event text) AS
$BODY$
begin
	return query
		select 
			a.title, 
			a.img_preview,
			a.img_view,
			a.preview,
			a.view,
			a.price,
			a.date_start,
			a.date_finish,
			a.meta_image,
			a.meta_keyword,
			a.meta_title,
			a.meta_description,
			a.type,
			a.dop_info,
			a.form_event, 
			a.city_event
		from website.private_catalog(null,null,null) as a
		where a.id =_id;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_catalog_tags""(IN _id23032 int4, IN _id23033 int4, IN _id21309 int4)
 RETURNS TABLE(""id"" int4, title text, ""type"" int4) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin

	if _realtime = 1 then
		-- профиль обучения
		return query
			select 
			t23032.idkart,
			t23032.name_profile as profile_title,
			1 as type
			from public.t23032
			where t23032.dttmcl is null and 
				t23032.idkart in (select d.id23032 from website.private_events_action(COALESCE(_id23032,t23032.idkart),_id23033,_id21309) as d where d.id23032 is not null)
			order by t23032.name_profile;
		-- форма обучения
		return query
			select 
			t23033.idkart,
			t23033.name_form as form_title,
			2 as type	
			from public.t23033
			where t23033.dttmcl is null and 
				t23033.idkart in (select d.id23033 from website.private_events_action(_id23032,COALESCE(_id23033,t23033.idkart),_id21309) as d where d.id23033 is not null)
			order by t23033.name_form;
		-- место обучения
		return query
			select 
			t21309.idkart,
			t21309.city as place_title,
			3 as type	
			from public.t21309
			where t21309.dttmcl is null and
				t21309.idkart in (select d.id21309 from website.private_events_action(_id23032,_id23033,COALESCE(_id21309,t21309.idkart)) as d where d.id21309 is not null)
			order by t21309.city;
	else
		-- профиль обучения
		return query
			select 
			t28011.idkart,
			t28011.profile_title,
			1 as type
			from t28011
			where t28011.dttmcl is null;
		-- форма обучения
		return query
			select 
			t28012.idkart,
			t28012.form_title,
			2 as type
			from t28012
			where t28012.dttmcl is null;
		-- место обучения
		return query
			select 
			t28013.idkart,
			t28013.place_title,
			3 as type
			from t28013
			where t28013.dttmcl is null;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_file""(IN _file_name_link text) RETURNS ""text"" 
	AS $BODY$
declare
	_file_data text;
begin

	select encode( t28001.file_data, 'base64' ) into _file_data from public.t28001 where t28001.dttmcl is null and t28001.file_name_link = _file_name_link;
	if _file_data is null then 	-- новости новый формат
		select encode( t25162.news_image, 'base64' ) into _file_data 
		from public.t25162
		where t25162.dttmcl is null 
			and concat( 'news_img_', x_name_translate(t25162.news_title) ) = _file_name_link;
	end if;
	if _file_data is null then -- отзывы
		select encode( t25172.reviews_image, 'base64' ) into _file_data 
		from public.t25172
		where t25172.dttmcl is null 
			and concat( 'rvs_img_', x_name_translate(t25172.reviews_title) ) = _file_name_link;
	end if;
	if _file_data is null then -- акции
		select encode( t25182.shares_image, 'base64' ) into _file_data 
		from public.t25182
		where t25182.dttmcl is null 
			and concat( 'shr_img_', x_name_translate(t25182.shares_title) ) = _file_name_link;
	end if;
	if _file_data is null then -- документы - small
		select encode( t23037.image_small, 'base64' ) into _file_data 
		from public.t23037
		where t23037.dttmcl is null 
			and concat( 'dc_imgs_', x_name_translate(t23037.name_document) ) = _file_name_link;
	end if;
	if _file_data is null then -- документы - large
		select encode( t23037.image_large, 'base64' ) into _file_data 
		from public.t23037
		where t23037.dttmcl is null 
			and concat( 'dc_imgl_', x_name_translate(t23037.name_document) ) = _file_name_link;
	end if;
	if _file_data is null then -- справочник мероприятия
		select encode( t23003.image, 'base64' ) into _file_data 
		from public.t23003
		where t23003.dttmcl is null 
			and x_name_translate(concat( 'cat3-img-', t23003.idkart ) ) = _file_name_link;
		if _file_data is null and _file_name_link like 'cat3-img-%' then
			select encode( t28001.file_data, 'base64' ) into _file_data from public.t28001 
			where t28001.dttmcl is null and t28001.file_name_link = 'seminar.jpg'::text;
		end if;
	end if;
	if _file_data is null then -- главная страница
		select encode( t23039.image, 'base64' ) into _file_data 
		from public.t23039
		where t23039.dttmcl is null 
			and x_name_translate(concat( 'mn-img-', t23039.idkart ) ) = _file_name_link;
	end if;

	return _file_data;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_menu_footer""(IN ""id"" text)
 RETURNS TABLE(title text, href text, selected int4) AS
$BODY$
begin
	return query
		select 
			t28002.page_name, 
			concat( '/', t28002.page_link, '/' ), 
			case when t28002.idkart::text = id then 1 else 0 end as selected
		from public.t28002
		where t28002.page_num_sort<>0
		order by page_num_sort;

	return query
		select 
			t28002.page_name, 
			t28002.page_link,
			case when t28002.idkart::text = id then 1 else 0 end as selected
		from public.t28002
		where t28002.idkart = '11';

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_menu_header""(IN ""id"" text)
 RETURNS TABLE(title text, href text, selected int4) AS
$BODY$
begin
	return query
		select 
			t28002.page_name, 
			concat( '/', t28002.page_link, '/' ), 
			case when t28002.idkart::text = id then 1 else 0 end as selected
		from public.t28002
		where t28002.page_num_sort<>0
		order by page_num_sort;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_news""()
 RETURNS TABLE(title text, link text, image text, preview text, ""date"" timestamptz, ""source"" text, source_url text) AS
$BODY$
begin
	return query
		select 
		a.title, 
		a.link,
		a.image,
		a.preview,
		a.date,
		a.source,
		a.source_url
		from website.private_news() as a
		order by a.date desc;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_news_bookmark""()
 RETURNS TABLE(title text, link text, image text, preview text, ""date"" timestamptz, ""source"" text, source_url text) AS
$BODY$
begin
	return query
		select 
		a.title, 
		a.link,
		a.image,
		a.preview,
		a.date,
		a.source,
		a.source_url
		from website.private_news() as a
		where a.bookmark=true
		order by a.date;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_news_property""(IN _id text)
 RETURNS TABLE(title text, link text, image text, preview text, ""view"" text, ""date"" timestamptz, ""source"" text, source_url text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
begin
	return query
		select 
		a.title, 
		a.link,
		a.image,
		a.preview,
		a.view,
		a.date,
		a.source,
		a.source_url,
		a.meta_image,
		a.meta_keyword,
		a.meta_title,
		a.meta_description
		from website.private_news() as a
		where a.id =_id;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_page""(IN _id int4)
 RETURNS TABLE(title text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
begin
	return query
		select 
			t28002.page_name, 
			met.file_name_link as meta_image,
			t28002.meta_keyword,
			t28002.meta_title,
			t28002.meta_description
		from public.t28002
		left join t28001 as met ON t28002.id_meta_image = met.idkart
		where t28002.idkart = _id;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_page_property_json""(IN _id int4)
 RETURNS TABLE(""key"" text, ""value"" text) AS
$BODY$
begin
	return query
		select 
			t28003.param_name,
			t28003.param_value
		from public.t28003 
		where t28003.dttmcl is null and t28003.id28002 = _id;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_reviews""()
 RETURNS TABLE(title text, link text, preview text, company text, ""date"" date, image text) AS
$BODY$
begin
		return query
			select 
			a.title,
			a.link,
			a.preview,
			a.company,
			a.date,
			a.image
			from website.private_reviews() as a
			order by a.date;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_reviews_property""(IN _id text)
 RETURNS TABLE(title text, link text, preview text, ""view"" text, company text, ""date"" date, image text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
begin
		return query
			select 
				a.title,
				a.link,
				a.preview,
				a.view,
				a.company,
				a.date,
				a.image,
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from website.private_reviews() as a
			where a.id =_id
			order by a.date;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_shares""()
 RETURNS TABLE(title text, link text, preview text, ""date"" date, image text) AS
$BODY$
begin
		return query
			select 
			a.title,
			a.link,
			a.preview,
			a.date_start,
			a.file_name_link
			from website.private_shares() as a
			order by a.date_start;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_shares_property""(IN _id text)
 RETURNS TABLE(title text, link text, preview text, ""view"" text, ""date"" date, image text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
begin
		return query
			select 
				a.title,
				a.link,
				a.preview,
				a.view,
				a.date_start,
				a.file_name_link,
				a.meta_image, 
				a.meta_keyword,
				a.meta_title,
				a.meta_description
			from website.private_shares() as a
			where a.id =_id
			order by a.date_start;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""get_sitemap""()
 RETURNS TABLE(parent_controller_id int4, parent_id int4, controller_id int4, ""id"" int4, link text, ""name"" text, controller text) AS
$BODY$
begin
	
	return query
		select 
			a.parent_obj,
			a.parent_obj_id,
			a.obj,
			a.obj_id,
			a.link,
			a.name,
			a.controller
		from website.private_tree_all() as a;


end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_careers""()
 RETURNS TABLE(""id"" text, title text, link text, ""view"" text, date_start date, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin
--	if _realtime = 1 then
--		return query
--	else
		return query
			select
				t28019.idkart::text,
				t28019.careers_title,
				t28019.careers_link,
				t28019.careers_view,
				t28019.careers_date,
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from t28019
			where t28019.dttmcl is null
			order by t28019.careers_title;
	--end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_catalog""(IN _id23032 int4, IN _id23033 int4, IN _id21309 int4)
 RETURNS TABLE(""id"" text, id28005 text, title text, link text, img_preview text, img_view text, preview text, ""view"" text, price numeric, date_start date, date_finish date, meta_image text, meta_keyword text, meta_title text, meta_description text, ""type"" text, dop_info json, form_event text, city_event text, id23004 int4, id23003 int4) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin

	if _realtime = 1 then
		return query
			select 
				concat('mn-', a.idkart) as id,
				null::text as id28005,
				a.name_title as title,
				x_name_translate(concat( 'mn-',a.name_title) ) as link, 
				x_name_translate(concat( 'mn-img-', a.idkart) ) as img_preview, 
				x_name_translate(concat( 'mn-img-', a.idkart) ) as img_view, 
				a.preview as preview, 
				case when a.viewfile is not null then x_get_filedata(a.viewfile) else a.view end as view,
				null::numeric as price,
				null::date as date_start, 
				null::date as date_finish,
				null::text as meta_image,
				null::text as meta_keyword,
				null::text as meta_title,
				null::text as meta_description,
				'folder'::text as type,
				null::json as dop_info,
				null::text as form_event,
				null::text as city_event,
				null::integer as id23004,
				null::integer as id23003
			from t23039 as a
			join ( 
				select a.id23039
				from website.private_events_action( _id23032, _id23033, _id21309 ) as a
				group by a.id23039
			) as b ON b.id23039 = a.idkart
			order by num_sort;

		return query
			select 
				concat('cat2-', b.id23039,'-',b.id23034 ) as id,
				concat('mn-', b.id23039) as id28005,
				a.name_view as title,
				x_name_translate(concat('cat2-', b.id23039,'-',a.idkart, a.name_view) ) as link, 
				x_name_translate(concat('cat2-img-', a.idkart) ) as img_preview, 
				x_name_translate(concat('cat2-img-', a.idkart) ) as img_view, 
				null::text as preview, 
				null::text as view,
				null::numeric as price,
				null::date as date_start, 
				null::date as date_finish,
				null::text as meta_image,
				null::text as meta_keyword,
				null::text as meta_title,
				null::text as meta_description,
				'folder'::text as type,
				null::json as dop_info,
				null::text as form_event,
				null::text as city_event,
				null::integer as id23004,
				null::integer as id23003
				from t23034 as a
				join ( 
					select a.id23039, a.id23034 
					from website.private_events_action( _id23032, _id23033, _id21309 ) as a
					group by a.id23039, a.id23034 
				) as b ON b.id23034 = a.idkart;

		return query
			select 
				concat('cat3-', a.id23004, '-', a.id23031, '-', a.id23032, '-', a.id23033, '-', a.id23034, '-', a.id21309, '-', a.id23039) as id,
				concat('cat2-', a.id23039,'-',a.id23034 ) as id28005,
				a.name_event as title,
				x_name_translate(concat('cat3-', a.id23004, '-', a.id23031, '-', a.id23032, '-', a.id23033, '-', a.id23034, '-', a.id21309, '-', a.id23039, '-',
					a.name_event) ) as link, 
				x_name_translate(concat('cat3-img-', a.id23003) )  as img_preview, 
				x_name_translate(concat('cat3-img-', a.id23003) ) as img_view, 
				null::text as preview, 
				x_get_filedata(a.file_plan) as view,
				a.cost_event as price,
				a.date_event as date_start, 
				a.date_event_end as date_finish,
				null::text as meta_image,
				null::text as meta_keyword,
				null::text as meta_title,
				null::text as meta_description,
				'item'::text as type,
				website.private_catalog_json( a.id23004 ) as dop_info,
				a.form_event,
				a.city_event,
				a.id23004,
				a.id23003
			from (
				select 
				b.id23004, b.id23031, b.id23032, b.id23033, b.id23034, b.id21309, b.id23039,
				t23003.idkart as id23003,
				t23003.name_event,
				t23003.file_plan,
				t23033.name_form as form_event, 
				v21307.city as city_event,
				t23004.cost_event,
				t23004.date_event,
				t23004.date_event_end
				from t23003
				join t23004 ON t23004.id23003 = t23003.idkart
				left join t23033 on t23004.id23033 = t23033.idkart
				left join v21307 on t23004.id21307 = v21307.idkart
				join ( 
					select a.id23004, a.id23031, min(a.id23032) as id23032, a.id23033, a.id23034, a.id21309, a.id23039
					from website.private_events_action( _id23032, _id23033, _id21309 ) as a
					group by a.id23004, a.id23031, a.id23033, a.id23034, a.id21309, a.id23039
				) as b ON b.id23004 = t23004.idkart
			) as a; 		

/*		return query
			select 
				concat('cat3-', a.id23039,'-',a.id23034, a.idkart ) as id,
				concat('cat2-', a.id23039,'-',a.id23034 ) as id28005,
				a.name_event as title,
				x_name_translate(concat('cat3-', a.id23039,'-',a.id23034, a.idkart,a.name_event) ) as link, 
				x_name_translate(concat('cat3-img-', a.id23003) )  as img_preview, 
				x_name_translate(concat('cat3-img-', a.id23003) ) as img_view, 
				null::text as preview, 
				x_get_filedata(a.file_plan) as view,
				a.cost_event as price,
				a.date_event as date_start, 
				a.date_event_end as date_finish,
				null::text as meta_image,
				null::text as meta_keyword,
				null::text as meta_title,
				null::text as meta_description,
				'item'::text as type,
				website.private_catalog_json( a.idkart ) as dop_info,
				a.form_event,
				a.city_event,
				a.idkart as id23004,
				a.id23003 as id23003
			from (
				select 
				b.id23039,
				t23004.idkart,
				t23003.idkart as id23003,
				t23003.id23031,
				t23003.id23034,
				t23003.name_event,
				t23003.file_plan,
				t23033.name_form as form_event, 
				v21307.city as city_event,
				t23004.cost_event,
				t23004.date_event,
				t23004.date_event_end
				from t23003
				join t23004 ON t23004.id23003 = t23003.idkart
				left join t23033 on t23004.id23033 = t23033.idkart
				left join v21307 on t23004.id21307 = v21307.idkart
				join ( 
					select a.id23039, a.id23034 , a.id23004 
					from website.private_events_action( _id23032, _id23033, _id21309 ) as a
					group by a.id23039, a.id23034 , a.id23004 
				) as b ON b.id23004 = t23004.idkart
			) as a; */
	else
		return query
			select 
				t28006.idkart::text,
				t28006.id28005::text,
				t28006.catalog_title, 
				t28006.catalog_link, 
				t28001.file_name_link,
				t28001.file_name_link,
				t28006.catalog_preview,
				t28006.catalog_view,
				t28006.catalog_price,
				t28006.catalog_date,
				t28006.catalog_date,
				met.file_name_link as meta_image,
				t28006.meta_keyword,
				t28006.meta_title,
				t28006.meta_description,
				case when t28006.is_item=true then 'item' else 'folder' end,
				json_build_object( 'Количество часов:', '20 ак.ч.', 'Стоимость:', '4 000 рублей', 'Документ:', 'Сертификат', 'Форма обучения:', 'Групповая, индивидуальная', 'Место проведения:', 'г. Уфа' ),
			null::text as form_event, 
			null::text as city_event,
			null::integer as id23004,
			null::integer as id23003
			from t28006
			left join t28001 ON t28006.id28001 = t28001.idkart
			left join t28001 as met ON t28006.id_meta_image = met.idkart
			where t28006.dttmcl is null;
	end if;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_catalog_json""(IN _idkart int4) RETURNS ""json"" 
	AS $BODY$
declare 
	_js json;
begin
		select json_strip_nulls( row_to_json(a) ) into  _js
		from (
		select 
		t23004.time_event as ""Начало"",
		t23004.total_time as ""Продолжительность"",
		t23004.cost_event::money as ""Стоимость"",
		t23038.type_docum  as ""Документ"" ,
		t23033.name_form as ""Форма обучения"",
		v21307.address_full as ""Место проведения""
		from t23003
		join t23004 on t23004.id23003 = t23003.idkart
		left join t23033 on t23004.id23033 = t23033.idkart
		left join t23038 on t23004.id23038 = t23038.idkart
		left join v21307 on t23004.id21307 = v21307.idkart
		where t23004.idkart = _idkart
		) as a;

		return _js;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_events_action""(IN _id23032 int4, IN _id23033 int4, IN _id21309 int4)
 RETURNS TABLE(id23004 int4, id23031 int4, id23032 int4, id23033 int4, id23034 int4, id21309 int4, id23039 int4) AS
$BODY$
begin
	return query
			select a.id23004, a.id23031, a.id23032, a.id23033, a.id23034, a.id21309, COALESCE(t23039.idkart,9) as id23039
			from (
				select t23004.idkart as id23004, t23003.id23031, t23035.id23032, t23004.id23033, t23003.id23034, t21307.id21309
				from t23003
				join t23004 on t23004.id23003 = t23003.idkart
				left join t23035 on t23003.idkart = t23035.id23003 and t23035.dttmcl is null
				left join t21307 on t23004.id21307 = t21307.idkart
				where t23003.dttmcl is null 
					and t23004.cancel is null 
					and t23003.date_archive is null 
					and (t23004.date_event is null or t23004.date_event >= 'now'::text::date)
					and t23003.file_plan is not null
					and (
						(t23035.id23032 = _id23032 or _id23032 is null) and
						(t23004.id23033 = _id23033 or _id23033 is null) and
						(t21307.id21309 = _id21309 or _id21309 is null)
					)
			) as a
			left join ( select * from t23039 where idkart <>9 ) as t23039 on 
				(t23039.id23031=a.id23031 or t23039.id23031 is null ) and
				(t23039.id23032=a.id23032 or t23039.id23032 is null ) and
				(t23039.id23033=a.id23033 or t23039.id23033 is null ) and
				(t23039.id23034=a.id23034 or t23039.id23034 is null );
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_gallery""()
 RETURNS TABLE(""id"" text, navigation int4, preview int4, controls int4, fullscreen int4, auto_slide int4, slide_interval int4, slides jsonb) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin
	if _realtime = 1 then
		return query
			select 
				case when a.id23036 = 1 then '3'::text else '2'::text end,
				0,
				0,
				0,
				0,
				0,
				0,
				jsonb_agg(a.js)
			from (
				select t23037.id23036,
				json_build_object( 
					'title',t23037.name_document,
					'description','Описание - ' || t23037.name_document,
					'img_view',concat( 'dc_imgl_' ,x_name_translate(t23037.name_document) ),
					'img_preview',concat( 'dc_imgs_' ,x_name_translate(t23037.name_document) )
				) as js
				from t23037
				where t23037.dttmcl is null
				group by t23037.id23036,t23037.name_document
				order by t23037.name_document
			) as a
			group by a.id23036;

	else
		return query
			select 
				t28016.idkart::text,
				case when t28016.navigation=true then 1 else 0 end,
				case when t28016.preview=true then 1 else 0 end,
				case when t28016.controls=true then 1 else 0 end,
				case when t28016.fullscreen=true then 1 else 0 end,
				case when t28016.auto_slide=true then 1 else 0 end,
				t28016.slide_interval,
				jsonb_agg(a.js)
			from t28016
			left join (
				select
				t28017.id28016,
				json_build_object( 
					'title',t28001.title,
					'description',t28001.description,
					'img_view',t28010.file_name_link,
					'img_preview',t28001.file_name_link
				) as js
				from t28017
				left join t28001 ON t28017.id28001 = t28001.idkart
				left join t28001 as t28010 ON t28017.id28010 = t28010.idkart
			) as a on a.id28016 = t28016.idkart
			where t28016.dttmcl is null
			group by 
				t28016.idkart,
				case when t28016.navigation=true then 1 else 0 end,
				case when t28016.preview=true then 1 else 0 end,
				case when t28016.controls=true then 1 else 0 end,
				case when t28016.fullscreen=true then 1 else 0 end,
				case when t28016.auto_slide=true then 1 else 0 end,
				t28016.slide_interval;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_get_functions""()
 RETURNS TABLE(proname name, proargnames _text, proargtypes oidvector, prosrc text) AS
$BODY$
begin
	return query
		SELECT p.proname, p.proargnames, p.proargtypes, p.prosrc 
		FROM pg_catalog.pg_namespace n 
		LEFT JOIN pg_catalog.pg_proc p ON p.pronamespace = n.oid 
		WHERE n.nspname = 'website' AND p.proname NOT LIKE 'private_%';
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_news""()
 RETURNS TABLE(""id"" text, title text, link text, image text, preview text, ""view"" text, ""date"" timestamptz, ""source"" text, source_url text, meta_image text, meta_keyword text, meta_title text, meta_description text, bookmark bool) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin
	if _realtime = 1 then
		return query
			select 
			concat( 'news_', t25162.idkart) as id,
			t25162.news_title, 
			x_name_translate(t25162.news_title),
			concat( 'news_img_', x_name_translate(t25162.news_title) ) ,
			t25162.news_preview,
			case when t25162.news_viewfile is not null then x_get_filedata(t25162.news_viewfile) else t25162.news_view end,
			t25162.news_date,
			t25162.news_source,
			t25162.news_source_url,
			null::text as meta_image,
			null::text as meta_keyword,
			null::text as meta_title,
			null::text as meta_description,
			t25162.news_bookmark
			from t25162
			where t25162.dttmcl is null;
	else
		return query
			select 
			t28008.idkart::text as id,
			t28008.news_title, 
			t28008.news_link,
			t28001.file_name_link,
			t28008.news_preview,
			t28008.news_view,
			t28008.news_date,
			t28008.news_source,
			t28008.news_source_url,
			met.file_name_link as meta_image,
			t28008.meta_keyword,
			t28008.meta_title,
			t28008.meta_description,
			t28008.bookmark
			from t28008
			left join t28001 ON t28008.id28001 = t28001.idkart
			left join t28001 as met ON t28008.id_meta_image = met.idkart
			where t28008.dttmcl is null;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_real""() RETURNS ""int4"" 
	AS $BODY$
begin
	
	return 1;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_reviews""()
 RETURNS TABLE(""id"" text, title text, link text, preview text, ""view"" text, company text, ""date"" date, image text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin
--	if _realtime = 1 then	
		return query
			select
				concat( 'rvs_', t25172.idkart),
				t25172.reviews_title,
				x_name_translate(t25172.reviews_title),
				t25172.reviews_preview,
				case when t25172.reviews_viewfile is not null then x_get_filedata(t25172.reviews_viewfile) else t25172.reviews_view end,
				t25172.reviews_company,
				t25172.reviews_date,
				concat( 'rvs_img_', x_name_translate(t25172.reviews_title) ),
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from t25172
			where t25172.dttmcl is null;
--	else
		return query
			select
				t28014.idkart::text,
				t28014.reviews_title,
				t28014.reviews_link,
				t28014.reviews_preview,
				t28014.reviews_view,
				t28014.reviews_company,
				t28014.reviews_date,
				t28001.file_name_link,
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from t28014
			left join t28001 ON t28014.id28001 = t28001.idkart
			where t28014.dttmcl is null;
--	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_shares""()
 RETURNS TABLE(""id"" text, title text, link text, preview text, ""view"" text, date_start date, date_end date, file_name_link text, meta_image text, meta_keyword text, meta_title text, meta_description text) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin
	if _realtime = 1 then
		return query
			select
				concat( 'shr_', t25182.idkart),
				t25182.shares_title,
				concat( 'shr_' ,x_name_translate(t25182.shares_title) ),
				t25182.shares_preview,
				case when t25182.shares_viewfile is not null then x_get_filedata(t25182.shares_viewfile) else t25182.shares_view end,
				t25182.shares_date_start,
				t25182.shares_date_end,
				concat( 'shr_img_', x_name_translate(t25182.shares_title) ) ,
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from t25182
			where t25182.dttmcl is null and t25182.shares_date_start <= current_date and 
				(t25182.shares_date_end is null or t25182.shares_date_end >= current_date);
	else
		return query
			select
				t28015.idkart::text,
				t28015.shares_title,
				t28015.shares_link,
				t28015.shares_preview,
				t28015.shares_view,
				t28015.shares_date,
				null::date as shares_date,
				t28001.file_name_link,
				null::text meta_image, 
				null::text meta_keyword,
				null::text meta_title,
				null::text meta_description
			from t28015
			left join t28001 ON t28015.id28001 = t28001.idkart
			where t28015.dttmcl is null
			order by t28015.shares_date;
	end if;
end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""website"".""private_tree_all""()
 RETURNS TABLE(parent_obj text, parent_obj_id text, obj text, obj_id text, link text, ""name"" text, controller text, controller_next text) AS
$BODY$
declare 
	_realtime integer := website.private_real();
begin

	return query
		select 
			null::text,
			null::text,
			0::text,
			t28002.idkart::text,
			t28002.page_link,
			t28002.page_name,
			'page'::text,
			t28002.page_controller
		from t28002
		where t28002.dttmcl is null and t28002.page_num_sort is not null;
	-- каталог
	return query
		select 
			case when a.id28005 is null then 0 else 4 end::text,
			COALESCE(a.id28005,4::text),
			4::text,
			a.id,
			a.link,
			a.title,
			'catalog'::text,
			'catalog'::text
		from website.private_catalog(null,null,null) as a;
	-- новости
	return query
		select 
			0::text,
			7::text,
			7::text,
			a.id,
			a.link,
			a.title,
			'news'::text,
			'news'::text
		from website.private_news() as a;
	-- отзывы
	return query
		select 
			0::text,
			5::text,
			5::text,
			a.id,
			a.link,
			a.title,
			'reviews'::text,
			'reviews'::text
		from website.private_reviews() as a;
	-- акции
	return query
		select 
			0::text,
			8::text,
			8::text,
			a.id,
			a.link,
			a.title,
			'shares'::text,
			'shares'::text
		from website.private_shares() as a;
	-- вакансии
	return query
		select 
			0::text,
			9::text,
			9::text,
			a.id,
			a.link,
			a.title,
			'careers'::text,
			'careers'::text
		from website.private_careers() as a;

end;
$BODY$
	LANGUAGE plpgsql
	COST 100
	ROWS 1000
	CALLED ON NULL INPUT
	SECURITY INVOKER
	VOLATILE;",website.sql
"CREATE FUNCTION ""xoverFE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 	SELECT v.gradevalue as x, v.credits as y



-- 	FROM viewclasses v 



-- 	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 	ORDER BY v.termid ASC;







	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverFE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 	SELECT v.gradevalue as x, v.credits as y



-- 	FROM viewclasses v 



-- 	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 	ORDER BY v.termid ASC;







	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverFE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 	SELECT v.gradevalue as x, v.credits as y



-- 	FROM viewclasses v 



-- 	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 	ORDER BY v.termid ASC;







	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""xoverFE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 

-- 

-- 		SELECT v.gradevalue as x, v.credits as y

-- 

-- 		FROM viewclasses v 

-- 

-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

-- 

-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverFE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 

-- 

-- 		SELECT v.gradevalue as x, v.credits as y

-- 

-- 		FROM viewclasses v 

-- 

-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

-- 

-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverFE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 

-- 

-- 		SELECT v.gradevalue as x, v.credits as y

-- 

-- 		FROM viewclasses v 

-- 

-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

-- 

-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'FE'



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'FE'



-- 		LIMIT 2;



-- 	END IF;







	return FEgroup_units + otherELE_units;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""xoverMSEE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverMSEE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverMSEE_correction""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""xoverMSEE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverMSEE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION ""xoverMSEE_dcorrection""(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'MSEE'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'MSEE'



-- 		LIMIT 1;



-- 	END IF;







	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ""year""(date) RETURNS integer
    AS $_$
DECLARE
    pDate ALIAS FOR $1;
    vResult integer;
  BEGIN
    vResult := EXTRACT('year' FROM pDate);
    RETURN vResult;
  END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION ""year""(date) RETURNS integer
    AS $_$
DECLARE
    pDate ALIAS FOR $1;
    vResult integer;
  BEGIN
    vResult := EXTRACT('year' FROM pDate);
    RETURN vResult;
  END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION __inventory__init() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _test_head CONSTANT common.inventory_head[] := ARRAY[(103, 'cf77e3ea-0b5c-4e62-be62-63704f4071b7', 'fl-25-50', '20.25.50-001', 2, '2018-01-16', 'pcs', 'PROPOSED', 'INVENTORY')]::common.inventory_head[];
  _test_meas CONSTANT common.unit_conversion_type[] := ARRAY[('pcs', 'pcs', 1), ('pcs', 'g', 1000)]::common.unit_conversion_type[];
  _test_kind CONSTANT common.inventory_kind[] := ARRAY[('ASSEMBLY'), ('STORABLE')]::common.inventory_kind[];
  _head common.inventory_head;
  _meas common.unit_conversion_type[];
  _kind common.inventory_kind[];
  _document_id bigint;
BEGIN

  RAISE DEBUG '#trace Check __inventory__init()';
  
  _document_id := inventory.init(_test_head[1], _test_meas, _test_kind);
  _head := inventory.get_head(_document_id);
  _meas := inventory.get_meas_spec(_document_id);
  _kind := inventory.get_kind_spec(_document_id);

  PERFORM pgunit.assert_array_equals(_test_meas, _meas, 'Incorrect _meas value');
  PERFORM pgunit.assert_array_equals(_test_kind, _kind, 'Incorrect _kind value');


END;
$$;",mdm.sql
"CREATE FUNCTION __inventory__reinit() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _test_head CONSTANT common.inventory_head[] := ARRAY[(103, 'cf77e3ea-0b5c-4e62-be62-63704f4071b7', 'fl-25-50', '20.25.50-001', 2, '2018-01-16', 'pcs', 'PROPOSED', 'INVENTORY')]::common.inventory_head[];
  _test_meas_init CONSTANT common.unit_conversion_type[] := ARRAY[('pcs', 'pcs', 1), ('pcs', 'g', 1000)]::common.unit_conversion_type[];
  _test_meas_reinit CONSTANT common.unit_conversion_type[] := ARRAY[('pcs', 'pcs', 1), ('pcs', 'kg', 10)]::common.unit_conversion_type[];
  _test_kind_init CONSTANT common.inventory_kind[] := ARRAY[('ASSEMBLY'), ('STORABLE')]::common.inventory_kind[];
  _test_kind_reinit CONSTANT common.inventory_kind[] := ARRAY[('PART'), ('CONSUMABLE')]::common.inventory_kind[];
  _head common.inventory_head;
  _meas common.unit_conversion_type[];
  _kind common.inventory_kind[];
  _document_id bigint;
BEGIN

  RAISE DEBUG '#trace Check __inventory__reinit()';
  
  _document_id := inventory.init(_test_head[1], _test_meas_init, _test_kind_init);
  PERFORM inventory.reinit(_document_id, _test_meas_reinit, _test_kind_reinit);
  _head := inventory.get_head(_document_id);
  _meas := inventory.get_meas_spec(_document_id);
  _kind := inventory.get_kind_spec(_document_id);

  PERFORM pgunit.assert_array_equals(_meas, _test_meas_reinit, 'Incorrect _meas_reinit value');
  PERFORM pgunit.assert_array_equals(_kind, _test_kind_reinit, 'Incorrect _kind_reinit value');

END;
$$;",mdm.sql
"CREATE FUNCTION _add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_overview_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_overview_constraint(' || quote_ident($3)
			|| ',' || $7
			|| ',' || quote_literal($4)
			|| ',' || quote_literal($5)
			|| ',' || quote_literal($6)
			|| '))';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_overview_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_overview_constraint(' || quote_ident($3)
			|| ',' || $7
			|| ',' || quote_literal($4)
			|| ',' || quote_literal($5)
			|| ',' || quote_literal($6)
			|| '))';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_overview_constraint(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, factor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_overview_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_overview_constraint(' || quote_ident($3)
			|| ',' || $7
			|| ',' || quote_literal($4)
			|| ',' || quote_literal($5)
			|| ',' || quote_literal($6)
			|| '))';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_same_alignment_' || $3;

		sql := 'SELECT st_makeemptyraster(1, 1, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid) FROM st_metadata((SELECT '
			|| quote_ident($3)
			|| ' FROM ' || fqtn || ' LIMIT 1))';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the alignment of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_samealignment(' || quote_ident($3) || ', ''' || attr || '''::raster))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_same_alignment_' || $3;

		sql := 'SELECT st_makeemptyraster(1, 1, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid) FROM st_metadata((SELECT '
			|| quote_ident($3)
			|| ' FROM ' || fqtn || ' LIMIT 1))';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the alignment of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_samealignment(' || quote_ident($3) || ', ''' || attr || '''::raster))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_alignment(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_same_alignment_' || $3;

		sql := 'SELECT st_makeemptyraster(1, 1, upperleftx, upperlefty, scalex, scaley, skewx, skewy, srid) FROM st_metadata((SELECT '
			|| quote_ident($3)
			|| ' FROM ' || fqtn || ' LIMIT 1))';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the alignment of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn ||
			' ADD CONSTRAINT ' || quote_ident(cn) ||
			' CHECK (st_samealignment(' || quote_ident($3) || ', ''' || attr || '''::raster))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_' || $4 || '_' || $3;

		sql := 'SELECT st_' || $4 || '('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the % of a sample raster', $4;
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_' || $4 || '('
			|| quote_ident($3)
			|| ') = ' || attr || ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_' || $4 || '_' || $3;

		sql := 'SELECT st_' || $4 || '('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the % of a sample raster', $4;
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_' || $4 || '('
			|| quote_ident($3)
			|| ') = ' || attr || ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_' || $4 || '_' || $3;

		sql := 'SELECT st_' || $4 || '('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the % of a sample raster', $4;
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_' || $4 || '('
			|| quote_ident($3)
			|| ') = ' || attr || ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_max_extent_' || $3;

		sql := 'SELECT st_ashexewkb(st_convexhull(st_collect(st_convexhull('
			|| quote_ident($3)
			|| ')))) FROM '
			|| fqtn;
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the extent of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_coveredby(st_convexhull('
			|| quote_ident($3)
			|| '), ''' || attr || '''::geometry))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_max_extent_' || $3;

		sql := 'SELECT st_ashexewkb(st_convexhull(st_collect(st_convexhull('
			|| quote_ident($3)
			|| ')))) FROM '
			|| fqtn;
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the extent of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_coveredby(st_convexhull('
			|| quote_ident($3)
			|| '), ''' || attr || '''::geometry))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_extent(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_max_extent_' || $3;

		sql := 'SELECT st_ashexewkb(st_convexhull(st_collect(st_convexhull('
			|| quote_ident($3)
			|| ')))) FROM '
			|| fqtn;
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the extent of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_coveredby(st_convexhull('
			|| quote_ident($3)
			|| '), ''' || attr || '''::geometry))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_nodata_values_' || $3;

		sql := 'SELECT _raster_constraint_nodata_values(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_nodata_values(' || quote_ident($3)
			|| ')::numeric(16,10)[] = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS NULL THEN
				sql := sql || 'NULL';
			ELSE
				sql := sql || attr[x];
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::numeric(16,10)[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_nodata_values_' || $3;

		sql := 'SELECT _raster_constraint_nodata_values(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_nodata_values(' || quote_ident($3)
			|| ')::numeric(16,10)[] = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS NULL THEN
				sql := sql || 'NULL';
			ELSE
				sql := sql || attr[x];
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::numeric(16,10)[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_nodata_values(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_nodata_values_' || $3;

		sql := 'SELECT _raster_constraint_nodata_values(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the nodata values of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_nodata_values(' || quote_ident($3)
			|| ')::numeric(16,10)[] = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS NULL THEN
				sql := sql || 'NULL';
			ELSE
				sql := sql || attr[x];
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::numeric(16,10)[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_num_bands_' || $3;

		sql := 'SELECT st_numbands(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the number of bands of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_numbands(' || quote_ident($3)
			|| ') = ' || attr
			|| ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_num_bands_' || $3;

		sql := 'SELECT st_numbands(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the number of bands of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_numbands(' || quote_ident($3)
			|| ') = ' || attr
			|| ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_num_bands(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_num_bands_' || $3;

		sql := 'SELECT st_numbands(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the number of bands of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_numbands(' || quote_ident($3)
			|| ') = ' || attr
			|| ')';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr boolean[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_out_db_' || $3;

		sql := 'SELECT _raster_constraint_out_db(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_out_db(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS FALSE THEN
				sql := sql || 'FALSE';
			ELSE
				sql := sql || 'TRUE';
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::boolean[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr boolean[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_out_db_' || $3;

		sql := 'SELECT _raster_constraint_out_db(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_out_db(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS FALSE THEN
				sql := sql || 'FALSE';
			ELSE
				sql := sql || 'TRUE';
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::boolean[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_out_db(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr boolean[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_out_db_' || $3;

		sql := 'SELECT _raster_constraint_out_db(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the out-of-database bands of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_out_db(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			IF attr[x] IS FALSE THEN
				sql := sql || 'FALSE';
			ELSE
				sql := sql || 'TRUE';
			END IF;
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::boolean[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_pixel_types_' || $3;

		sql := 'SELECT _raster_constraint_pixel_types(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_pixel_types(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			sql := sql || '""' || attr[x] || '""';
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::text[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_pixel_types_' || $3;

		sql := 'SELECT _raster_constraint_pixel_types(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_pixel_types(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			sql := sql || '""' || attr[x] || '""';
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::text[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_pixel_types(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr text[];
		max int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_pixel_types_' || $3;

		sql := 'SELECT _raster_constraint_pixel_types(' || quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END;
		max := array_length(attr, 1);
		IF max < 1 OR max IS NULL THEN
			RAISE NOTICE 'Unable to get the pixel types of a sample raster';
			RETURN FALSE;
		END IF;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (_raster_constraint_pixel_types(' || quote_ident($3)
			|| ') = ''{';
		FOR x in 1..max LOOP
			sql := sql || '""' || attr[x] || '""';
			IF x < max THEN
				sql := sql || ',';
			END IF;
		END LOOP;
		sql := sql || '}''::text[])';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN

		RAISE INFO 'The regular_blocking constraint is just a flag indicating that the column ""%"" is regularly blocked.  It is up to the end-user to ensure that the column is truely regularly blocked.', quote_ident($3);

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_regular_blocking_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (TRUE)';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN

		RAISE INFO 'The regular_blocking constraint is just a flag indicating that the column ""%"" is regularly blocked.  It is up to the end-user to ensure that the column is truely regularly blocked.', quote_ident($3);

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_regular_blocking_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (TRUE)';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
	BEGIN

		RAISE INFO 'The regular_blocking constraint is just a flag indicating that the column ""%"" is regularly blocked.  It is up to the end-user to ensure that the column is truely regularly blocked.', quote_ident($3);

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_regular_blocking_' || $3;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (TRUE)';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision;
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_scale' || $4 || '_' || $3;

		sql := 'SELECT st_scale' || $4 || '('
			|| quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the %-scale of a sample raster', upper($4);
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_scale' || $4 || '('
			|| quote_ident($3)
			|| ')::numeric(16,10) = (' || attr || ')::numeric(16,10))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision;
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_scale' || $4 || '_' || $3;

		sql := 'SELECT st_scale' || $4 || '('
			|| quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the %-scale of a sample raster', upper($4);
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_scale' || $4 || '('
			|| quote_ident($3)
			|| ')::numeric(16,10) = (' || attr || ')::numeric(16,10))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr double precision;
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_scale' || $4 || '_' || $3;

		sql := 'SELECT st_scale' || $4 || '('
			|| quote_ident($3)
			|| ') FROM '
			|| fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the %-scale of a sample raster', upper($4);
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_scale' || $4 || '('
			|| quote_ident($3)
			|| ')::numeric(16,10) = (' || attr || ')::numeric(16,10))';
		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_srid_' || $3;

		sql := 'SELECT st_srid('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the SRID of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_srid('
			|| quote_ident($3)
			|| ') = ' || attr || ')';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_srid_' || $3;

		sql := 'SELECT st_srid('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the SRID of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_srid('
			|| quote_ident($3)
			|| ') = ' || attr || ')';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _add_raster_constraint_srid(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
		cn name;
		sql text;
		attr int;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		cn := 'enforce_srid_' || $3;

		sql := 'SELECT st_srid('
			|| quote_ident($3)
			|| ') FROM ' || fqtn
			|| ' LIMIT 1';
		BEGIN
			EXECUTE sql INTO attr;
		EXCEPTION WHEN OTHERS THEN
			RAISE NOTICE 'Unable to get the SRID of a sample raster';
			RETURN FALSE;
		END;

		sql := 'ALTER TABLE ' || fqtn
			|| ' ADD CONSTRAINT ' || quote_ident(cn)
			|| ' CHECK (st_srid('
			|| quote_ident($3)
			|| ') = ' || attr || ')';

		RETURN _add_raster_constraint(cn, sql);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _drop_raster_constraint(rastschema name, rasttable name, cn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		BEGIN
			EXECUTE 'ALTER TABLE '
				|| fqtn
				|| ' DROP CONSTRAINT '
				|| quote_ident(cn);
			RETURN TRUE;
		EXCEPTION
			WHEN undefined_object THEN
				RAISE NOTICE 'The constraint ""%"" does not exist.  Skipping', cn;
			WHEN OTHERS THEN
				RAISE NOTICE 'Unable to drop constraint ""%""', cn;
				RETURN FALSE;
		END;

		RETURN TRUE;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _drop_raster_constraint(rastschema name, rasttable name, cn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		BEGIN
			EXECUTE 'ALTER TABLE '
				|| fqtn
				|| ' DROP CONSTRAINT '
				|| quote_ident(cn);
			RETURN TRUE;
		EXCEPTION
			WHEN undefined_object THEN
				RAISE NOTICE 'The constraint ""%"" does not exist.  Skipping', cn;
			WHEN OTHERS THEN
				RAISE NOTICE 'Unable to drop constraint ""%""', cn;
				RETURN FALSE;
		END;

		RETURN TRUE;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _drop_raster_constraint(rastschema name, rasttable name, cn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		fqtn text;
	BEGIN
		fqtn := '';
		IF length($1) > 0 THEN
			fqtn := quote_ident($1) || '.';
		END IF;
		fqtn := fqtn || quote_ident($2);

		BEGIN
			EXECUTE 'ALTER TABLE '
				|| fqtn
				|| ' DROP CONSTRAINT '
				|| quote_ident(cn);
			RETURN TRUE;
		EXCEPTION
			WHEN undefined_object THEN
				RAISE NOTICE 'The constraint ""%"" does not exist.  Skipping', cn;
			WHEN OTHERS THEN
				RAISE NOTICE 'Unable to drop constraint ""%""', cn;
				RETURN FALSE;
		END;

		RETURN TRUE;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_' || $4 || '_' || $3);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_' || $4 || '_' || $3);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _drop_raster_constraint_blocksize(rastschema name, rasttable name, rastcolumn name, axis text) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'width' AND lower($4) != 'height' THEN
			RAISE EXCEPTION 'axis must be either ""width"" or ""height""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_' || $4 || '_' || $3);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_scale' || $4 || '_' || $3);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_scale' || $4 || '_' || $3);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _drop_raster_constraint_scale(rastschema name, rasttable name, rastcolumn name, axis character) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	BEGIN
		IF lower($4) != 'x' AND lower($4) != 'y' THEN
			RAISE EXCEPTION 'axis must be either ""x"" or ""y""';
			RETURN FALSE;
		END IF;

		RETURN _drop_raster_constraint($1, $2, 'enforce_scale' || $4 || '_' || $3);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _get_config_var(name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
begin
  return (select value from config where key=name);
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION _raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		cn text;
		sql text;
		rtn boolean;
	BEGIN
		cn := 'enforce_regular_blocking_' || $3;

		sql := 'SELECT TRUE FROM pg_class c, pg_namespace n, pg_constraint s'
			|| ' WHERE n.nspname = ' || quote_literal($1)
			|| ' AND c.relname = ' || quote_literal($2)
			|| ' AND s.connamespace = n.oid AND s.conrelid = c.oid'
			|| ' AND s.conname = ' || quote_literal(cn);
		EXECUTE sql INTO rtn;
		RETURN rtn;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		cn text;
		sql text;
		rtn boolean;
	BEGIN
		cn := 'enforce_regular_blocking_' || $3;

		sql := 'SELECT TRUE FROM pg_class c, pg_namespace n, pg_constraint s'
			|| ' WHERE n.nspname = ' || quote_literal($1)
			|| ' AND c.relname = ' || quote_literal($2)
			|| ' AND s.connamespace = n.oid AND s.conrelid = c.oid'
			|| ' AND s.conname = ' || quote_literal(cn);
		EXECUTE sql INTO rtn;
		RETURN rtn;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _raster_constraint_info_regular_blocking(rastschema name, rasttable name, rastcolumn name) RETURNS boolean
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		cn text;
		sql text;
		rtn boolean;
	BEGIN
		cn := 'enforce_regular_blocking_' || $3;

		sql := 'SELECT TRUE FROM pg_class c, pg_namespace n, pg_constraint s'
			|| ' WHERE n.nspname = ' || quote_literal($1)
			|| ' AND c.relname = ' || quote_literal($2)
			|| ' AND s.connamespace = n.oid AND s.conrelid = c.oid'
			|| ' AND s.conname = ' || quote_literal(cn);
		EXECUTE sql INTO rtn;
		RETURN rtn;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _reset_data() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  /*
  SELECT 'TRUNCATE TABLE ' || table_schema || '.' ||table_name || ' CASCADE;'
  FROM information_schema.tables
  WHERE table_schema NOT IN ('pg_catalog', 'information_schema', 'public', 'tests', 'common')
  ORDER BY table_schema,table_name;
  */
  TRUNCATE TABLE binding.mbom_to_operation CASCADE;
  TRUNCATE TABLE component.assembly CASCADE;
  TRUNCATE TABLE component.buyable CASCADE;
  TRUNCATE TABLE component.information CASCADE;
  TRUNCATE TABLE component.part CASCADE;
  TRUNCATE TABLE ebom.assembly CASCADE;
  TRUNCATE TABLE ebom.buyable CASCADE;
  TRUNCATE TABLE ebom.definition CASCADE;
  TRUNCATE TABLE ebom.information CASCADE;
  TRUNCATE TABLE ebom.part CASCADE;
  TRUNCATE TABLE equipment.information CASCADE;
  TRUNCATE TABLE inspection.equipment CASCADE;
  TRUNCATE TABLE inspection.personnel CASCADE;
  TRUNCATE TABLE inspection.segment CASCADE;
  TRUNCATE TABLE inventory.assembly CASCADE;
  TRUNCATE TABLE inventory.buyable CASCADE;
  TRUNCATE TABLE inventory.consumable CASCADE;
  TRUNCATE TABLE inventory.information CASCADE;
  TRUNCATE TABLE inventory.part CASCADE;
  TRUNCATE TABLE inventory.primal CASCADE;
  TRUNCATE TABLE inventory.producible CASCADE;
  TRUNCATE TABLE inventory.salable CASCADE;
  TRUNCATE TABLE inventory.storable CASCADE;
  TRUNCATE TABLE maintenance.demand CASCADE;
  TRUNCATE TABLE maintenance.request CASCADE;
  TRUNCATE TABLE maintenance.response CASCADE;
  TRUNCATE TABLE material.consumable CASCADE;
  TRUNCATE TABLE material.information CASCADE;
  TRUNCATE TABLE material.primal CASCADE;
  TRUNCATE TABLE material.producible CASCADE;
  TRUNCATE TABLE mbom.consumable CASCADE;
  TRUNCATE TABLE mbom.definition CASCADE;
  TRUNCATE TABLE mbom.information CASCADE;
  TRUNCATE TABLE mbom.primal CASCADE;
  TRUNCATE TABLE movement.equipment CASCADE;
  TRUNCATE TABLE movement.personnel CASCADE;
  TRUNCATE TABLE movement.segment CASCADE;
  TRUNCATE TABLE operation.consumable CASCADE;
  TRUNCATE TABLE operation.definition CASCADE;
  TRUNCATE TABLE operation.equipment CASCADE;
  TRUNCATE TABLE operation.material CASCADE;
  TRUNCATE TABLE operation.personnel CASCADE;
  TRUNCATE TABLE operation.primal CASCADE;
  TRUNCATE TABLE operation.producible CASCADE;
  TRUNCATE TABLE operation.segment CASCADE;
  TRUNCATE TABLE operation.tool CASCADE;
  TRUNCATE TABLE personnel.information CASCADE;
  TRUNCATE TABLE process.definition CASCADE;
  TRUNCATE TABLE process.equipment CASCADE;
  TRUNCATE TABLE process.information CASCADE;
  TRUNCATE TABLE process.personnel CASCADE;
  TRUNCATE TABLE process.segment CASCADE;
  TRUNCATE TABLE process.specification CASCADE;
  TRUNCATE TABLE product.definition CASCADE;
  TRUNCATE TABLE product.dependency CASCADE;
  TRUNCATE TABLE product.equipment CASCADE;
  TRUNCATE TABLE product.information CASCADE;
  TRUNCATE TABLE product.material CASCADE;
  TRUNCATE TABLE product.personnel CASCADE;
  TRUNCATE TABLE product.segment CASCADE;
  TRUNCATE TABLE production.equipment CASCADE;
  TRUNCATE TABLE production.personnel CASCADE;
  TRUNCATE TABLE production.segment CASCADE;
  TRUNCATE TABLE production.specification CASCADE;
  /*SELECT 'ALTER SEQUENCE ' || sequence_schema || '.' || sequence_name || ' RESTART WITH 1;' 
  FROM information_schema.sequences
  WHERE sequence_catalog = 'wms' AND sequence_schema != 'common'
  ORDER by sequence_schema, sequence_name;*/
  ALTER SEQUENCE ebom.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE equipment.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE inventory.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE maintenance.demand_id_seq RESTART WITH 1;
  ALTER SEQUENCE maintenance.request_id_seq RESTART WITH 1;
  ALTER SEQUENCE maintenance.response_id_seq RESTART WITH 1;
  ALTER SEQUENCE mbom.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE operation.definition_id_seq RESTART WITH 1;
  ALTER SEQUENCE operation.segment_id_seq RESTART WITH 1;
  ALTER SEQUENCE personnel.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE process.definition_id_seq RESTART WITH 1;
  ALTER SEQUENCE process.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE process.segment_id_seq RESTART WITH 1;
  ALTER SEQUENCE product.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE product.segment_id_seq RESTART WITH 1;

END;
$$;",mes-idea.sql
"CREATE FUNCTION _reset_data() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  /*
  SELECT 'TRUNCATE TABLE ' || table_schema || '.' ||table_name || ' CASCADE;'
  FROM information_schema.tables
  WHERE table_schema NOT IN ('pg_catalog', 'information_schema', 'public', 'tests', 'common')
  ORDER BY table_schema,table_name;
  */
  TRUNCATE TABLE equipment.information CASCADE;
  TRUNCATE TABLE facility.area CASCADE;
  TRUNCATE TABLE facility.enterprise CASCADE;
  TRUNCATE TABLE facility.information CASCADE;
  TRUNCATE TABLE facility.line CASCADE;
  TRUNCATE TABLE facility.site CASCADE;
  TRUNCATE TABLE facility.zone CASCADE;
  TRUNCATE TABLE inventory.definition CASCADE;
  TRUNCATE TABLE inventory.information CASCADE;
  TRUNCATE TABLE inventory.measurement CASCADE;
  TRUNCATE TABLE inventory.variety CASCADE;
  TRUNCATE TABLE personnel.information CASCADE;
  TRUNCATE TABLE tooling.information CASCADE;
  TRUNCATE TABLE transactor.customer CASCADE;
  TRUNCATE TABLE transactor.information CASCADE;
  TRUNCATE TABLE transactor.supplier CASCADE;
  --TRUNCATE TABLE uom.assignment CASCADE;
  --TRUNCATE TABLE uom.information CASCADE;
  /*
  SELECT 'ALTER SEQUENCE ' || sequence_schema || '.' || sequence_name || ' RESTART WITH 1;'
  FROM information_schema.sequences
  WHERE sequence_catalog = 'mdm' AND sequence_schema != 'common'
  ORDER by sequence_schema, sequence_name;
  */
  ALTER SEQUENCE equipment.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE facility.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE inventory.definition_id_seq RESTART WITH 1;
  ALTER SEQUENCE inventory.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE personnel.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE tooling.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE transactor.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE uom.information_id_seq RESTART WITH 1;
  ALTER SEQUENCE uom.uom_role_uom_role_id_seq RESTART WITH 1;
END;
$$;",mdm.sql
"CREATE FUNCTION _run_all() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _result text;
  _routines record;
  --_function_to_run text;
  _ok_count int DEFAULT 0;
  _error_count int DEFAULT 0;
  _failed_tests text[];
BEGIN
  SET search_path = tests, pg_catalog;
  SET client_min_messages = 'debug';
  FOR _routines IN
    SELECT
      routines.routine_name || '()' AS _function_to_run
    FROM
      information_schema.routines
    WHERE
      routines.specific_schema = 'tests' AND routines.routine_name like '\_\_%'
    ORDER BY
      routines.specific_schema, routines.routine_name
  LOOP
    _result := pgunit.run_test(_routines._function_to_run);
    RAISE NOTICE 'PERFORMING: % , RESULT: %', _routines._function_to_run, _result;
    IF (_result = '#OK') THEN
      _ok_count := _ok_count + 1;
    ELSE
      _error_count := _error_count + 1;
      _failed_tests := array_append(_failed_tests, _routines._function_to_run);
    END IF;
  END LOOP;
  RAISE NOTICE 'OK - %; ERROR - %;', _ok_count, _error_count;
  IF (_error_count > 0) THEN
  RAISE NOTICE 'FAILED: %;', _failed_tests;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION _run_all() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _result text;
  _routines record;
  --_function_to_run text;
  _ok_count int DEFAULT 0;
  _error_count int DEFAULT 0;
  _failed_tests text[];
BEGIN
  SET search_path = tests, pg_catalog;
  SET client_min_messages = 'debug';
  FOR _routines IN
    SELECT
      routines.routine_name || '()' AS _function_to_run
    FROM
      information_schema.routines
    WHERE
      routines.specific_schema = 'tests' AND routines.routine_name like '\_\_%'
    ORDER BY
      routines.specific_schema, routines.routine_name
  LOOP
    _result := pgunit.run_test(_routines._function_to_run);
    RAISE NOTICE 'PERFORMING: % , RESULT: %', _routines._function_to_run, _result;
    IF (_result = '#OK') THEN
      _ok_count := _ok_count + 1;
    ELSE
      _error_count := _error_count + 1;
      _failed_tests := array_append(_failed_tests, _routines._function_to_run);
    END IF;
  END LOOP;
  RAISE NOTICE 'OK - %; ERROR - %;', _ok_count, _error_count;
  IF (_error_count > 0) THEN
  RAISE NOTICE 'FAILED: %;', _failed_tests;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION _st_aspect4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        aspect float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        IF abs(dz_dx) = 0::float AND abs(dz_dy) = 0::float THEN
            RETURN -1;
        END IF;

        aspect := atan2(dz_dy, -dz_dx);
        IF aspect > (pi() / 2.0) THEN
            RETURN (5.0 * pi() / 2.0) - aspect;
        ELSE
            RETURN (pi() / 2.0) - aspect;
        END IF;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION _st_aspect4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        aspect float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        IF abs(dz_dx) = 0::float AND abs(dz_dy) = 0::float THEN
            RETURN -1;
        END IF;

        aspect := atan2(dz_dy, -dz_dx);
        IF aspect > (pi() / 2.0) THEN
            RETURN (5.0 * pi() / 2.0) - aspect;
        ELSE
            RETURN (pi() / 2.0) - aspect;
        END IF;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION _st_aspect4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        aspect float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        IF abs(dz_dx) = 0::float AND abs(dz_dy) = 0::float THEN
            RETURN -1;
        END IF;

        aspect := atan2(dz_dy, -dz_dx);
        IF aspect > (pi() / 2.0) THEN
            RETURN (5.0 * pi() / 2.0) - aspect;
        ELSE
            RETURN (pi() / 2.0) - aspect;
        END IF;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION _st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) RETURNS bigint
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		curs refcursor;

		ctable text;
		ccolumn text;
		rast raster;
		stats summarystats;

		rtn bigint;
		tmp bigint;
	BEGIN
		-- nband
		IF nband < 1 THEN
			RAISE WARNING 'Invalid band index (must use 1-based). Returning NULL';
			RETURN NULL;
		END IF;

		-- sample percent
		IF sample_percent < 0 OR sample_percent > 1 THEN
			RAISE WARNING 'Invalid sample percentage (must be between 0 and 1). Returning NULL';
			RETURN NULL;
		END IF;

		-- exclude_nodata_value IS TRUE
		IF exclude_nodata_value IS TRUE THEN
			SELECT count INTO rtn FROM _st_summarystats($1, $2, $3, $4, $5);
			RETURN rtn;
		END IF;

		-- clean rastertable and rastercolumn
		ctable := quote_ident(rastertable);
		ccolumn := quote_ident(rastercolumn);

		BEGIN
			OPEN curs FOR EXECUTE 'SELECT '
					|| ccolumn
					|| ' FROM '
					|| ctable
					|| ' WHERE '
					|| ccolumn
					|| ' IS NOT NULL';
		EXCEPTION
			WHEN OTHERS THEN
				RAISE WARNING 'Invalid table or column name. Returning NULL';
				RETURN NULL;
		END;

		rtn := 0;
		LOOP
			FETCH curs INTO rast;
			EXIT WHEN NOT FOUND;

			SELECT (width * height) INTO tmp FROM ST_Metadata(rast);
			rtn := rtn + tmp;
		END LOOP;

		CLOSE curs;

		RETURN rtn;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION _st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) RETURNS bigint
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		curs refcursor;

		ctable text;
		ccolumn text;
		rast raster;
		stats summarystats;

		rtn bigint;
		tmp bigint;
	BEGIN
		-- nband
		IF nband < 1 THEN
			RAISE WARNING 'Invalid band index (must use 1-based). Returning NULL';
			RETURN NULL;
		END IF;

		-- sample percent
		IF sample_percent < 0 OR sample_percent > 1 THEN
			RAISE WARNING 'Invalid sample percentage (must be between 0 and 1). Returning NULL';
			RETURN NULL;
		END IF;

		-- exclude_nodata_value IS TRUE
		IF exclude_nodata_value IS TRUE THEN
			SELECT count INTO rtn FROM _st_summarystats($1, $2, $3, $4, $5);
			RETURN rtn;
		END IF;

		-- clean rastertable and rastercolumn
		ctable := quote_ident(rastertable);
		ccolumn := quote_ident(rastercolumn);

		BEGIN
			OPEN curs FOR EXECUTE 'SELECT '
					|| ccolumn
					|| ' FROM '
					|| ctable
					|| ' WHERE '
					|| ccolumn
					|| ' IS NOT NULL';
		EXCEPTION
			WHEN OTHERS THEN
				RAISE WARNING 'Invalid table or column name. Returning NULL';
				RETURN NULL;
		END;

		rtn := 0;
		LOOP
			FETCH curs INTO rast;
			EXIT WHEN NOT FOUND;

			SELECT (width * height) INTO tmp FROM ST_Metadata(rast);
			rtn := rtn + tmp;
		END LOOP;

		CLOSE curs;

		RETURN rtn;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION _st_count(rastertable text, rastercolumn text, nband integer DEFAULT 1, exclude_nodata_value boolean DEFAULT true, sample_percent double precision DEFAULT 1) RETURNS bigint
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
	DECLARE
		curs refcursor;

		ctable text;
		ccolumn text;
		rast raster;
		stats summarystats;

		rtn bigint;
		tmp bigint;
	BEGIN
		-- nband
		IF nband < 1 THEN
			RAISE WARNING 'Invalid band index (must use 1-based). Returning NULL';
			RETURN NULL;
		END IF;

		-- sample percent
		IF sample_percent < 0 OR sample_percent > 1 THEN
			RAISE WARNING 'Invalid sample percentage (must be between 0 and 1). Returning NULL';
			RETURN NULL;
		END IF;

		-- exclude_nodata_value IS TRUE
		IF exclude_nodata_value IS TRUE THEN
			SELECT count INTO rtn FROM _st_summarystats($1, $2, $3, $4, $5);
			RETURN rtn;
		END IF;

		-- clean rastertable and rastercolumn
		ctable := quote_ident(rastertable);
		ccolumn := quote_ident(rastercolumn);

		BEGIN
			OPEN curs FOR EXECUTE 'SELECT '
					|| ccolumn
					|| ' FROM '
					|| ctable
					|| ' WHERE '
					|| ccolumn
					|| ' IS NOT NULL';
		EXCEPTION
			WHEN OTHERS THEN
				RAISE WARNING 'Invalid table or column name. Returning NULL';
				RETURN NULL;
		END;

		rtn := 0;
		LOOP
			FETCH curs INTO rast;
			EXIT WHEN NOT FOUND;

			SELECT (width * height) INTO tmp FROM ST_Metadata(rast);
			rtn := rtn + tmp;
		END LOOP;

		CLOSE curs;

		RETURN rtn;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;

BEGIN

  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN

    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;

    END LOOP;

    RETURN;
  END IF;


  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;

    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;

    RETURN;
  END IF;


  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;

END
$$;",database.sql
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;",fearth_db.sql
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;",postgres.sql.txt
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;",schema.sql
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;",snow_db_postgres.sql
"CREATE FUNCTION _st_dumppoints(the_geom geometry, cur_path integer[]) RETURNS SETOF geometry_dump
    LANGUAGE plpgsql
    AS $$
DECLARE
  tmp geometry_dump;
  tmp2 geometry_dump;
  nb_points integer;
  nb_geom integer;
  i integer;
  j integer;
  g geometry;
  
BEGIN
  
  RAISE DEBUG '%,%', cur_path, ST_GeometryType(the_geom);

  -- Special case (MULTI* OR GEOMETRYCOLLECTION) : iterate and return the DumpPoints of the geometries
  SELECT ST_NumGeometries(the_geom) INTO nb_geom;

  IF (nb_geom IS NOT NULL) THEN
    
    i = 1;
    FOR tmp2 IN SELECT (ST_Dump(the_geom)).* LOOP

      FOR tmp IN SELECT * FROM _ST_DumpPoints(tmp2.geom, cur_path || tmp2.path) LOOP
	    RETURN NEXT tmp;
      END LOOP;
      i = i + 1;
      
    END LOOP;

    RETURN;
  END IF;
  

  -- Special case (POLYGON) : return the points of the rings of a polygon
  IF (ST_GeometryType(the_geom) = 'ST_Polygon') THEN

    FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_ExteriorRing(the_geom), cur_path || ARRAY[1]) LOOP
      RETURN NEXT tmp;
    END LOOP;
    
    j := ST_NumInteriorRings(the_geom);
    FOR i IN 1..j LOOP
        FOR tmp IN SELECT * FROM _ST_DumpPoints(ST_InteriorRingN(the_geom, i), cur_path || ARRAY[i+1]) LOOP
          RETURN NEXT tmp;
        END LOOP;
    END LOOP;
    
    RETURN;
  END IF;

    
  -- Special case (POINT) : return the point
  IF (ST_GeometryType(the_geom) = 'ST_Point') THEN

    tmp.path = cur_path || ARRAY[1];
    tmp.geom = the_geom;

    RETURN NEXT tmp;
    RETURN;

  END IF;


  -- Use ST_NumPoints rather than ST_NPoints to have a NULL value if the_geom isn't
  -- a LINESTRING or CIRCULARSTRING.
  SELECT ST_NumPoints(the_geom) INTO nb_points;

  -- This should never happen
  IF (nb_points IS NULL) THEN
    RAISE EXCEPTION 'Unexpected error while dumping geometry %', ST_AsText(the_geom);
  END IF;

  FOR i IN 1..nb_points LOOP
    tmp.path = cur_path || ARRAY[i];
    tmp.geom := ST_PointN(the_geom, i);
    RETURN NEXT tmp;
  END LOOP;
   
END
$$;",vkdb-schema.sql
"CREATE FUNCTION _st_hillshade4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        zenith float;
        azimuth float;
        slope float;
        aspect float;
        max_bright float;
        elevation_scale float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        azimuth := (5.0 * pi() / 2.0) - args[3]::float;
        zenith := (pi() / 2.0) - args[4]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        elevation_scale := args[6]::float;
        slope := atan(sqrt(elevation_scale * pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
        -- handle special case of 0, 0
        IF abs(dz_dy) = 0::float AND abs(dz_dy) = 0::float THEN
            -- set to pi as that is the expected PostgreSQL answer in Linux
            aspect := pi();
        ELSE
            aspect := atan2(dz_dy, -dz_dx);
        END IF;
        max_bright := args[5]::float;

        IF aspect < 0 THEN
            aspect := aspect + (2.0 * pi());
        END IF;

        RETURN max_bright * ( (cos(zenith)*cos(slope)) + (sin(zenith)*sin(slope)*cos(azimuth - aspect)) );
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION _st_hillshade4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        zenith float;
        azimuth float;
        slope float;
        aspect float;
        max_bright float;
        elevation_scale float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        azimuth := (5.0 * pi() / 2.0) - args[3]::float;
        zenith := (pi() / 2.0) - args[4]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        elevation_scale := args[6]::float;
        slope := atan(sqrt(elevation_scale * pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
        -- handle special case of 0, 0
        IF abs(dz_dy) = 0::float AND abs(dz_dy) = 0::float THEN
            -- set to pi as that is the expected PostgreSQL answer in Linux
            aspect := pi();
        ELSE
            aspect := atan2(dz_dy, -dz_dx);
        END IF;
        max_bright := args[5]::float;

        IF aspect < 0 THEN
            aspect := aspect + (2.0 * pi());
        END IF;

        RETURN max_bright * ( (cos(zenith)*cos(slope)) + (sin(zenith)*sin(slope)*cos(azimuth - aspect)) );
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION _st_hillshade4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
        zenith float;
        azimuth float;
        slope float;
        aspect float;
        max_bright float;
        elevation_scale float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        azimuth := (5.0 * pi() / 2.0) - args[3]::float;
        zenith := (pi() / 2.0) - args[4]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        elevation_scale := args[6]::float;
        slope := atan(sqrt(elevation_scale * pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
        -- handle special case of 0, 0
        IF abs(dz_dy) = 0::float AND abs(dz_dy) = 0::float THEN
            -- set to pi as that is the expected PostgreSQL answer in Linux
            aspect := pi();
        ELSE
            aspect := atan2(dz_dy, -dz_dx);
        END IF;
        max_bright := args[5]::float;

        IF aspect < 0 THEN
            aspect := aspect + (2.0 * pi());
        END IF;

        RETURN max_bright * ( (cos(zenith)*cos(slope)) + (sin(zenith)*sin(slope)*cos(azimuth - aspect)) );
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION _st_slope4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        RETURN atan(sqrt(pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION _st_slope4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        RETURN atan(sqrt(pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION _st_slope4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        pwidth float;
        pheight float;
        dz_dx float;
        dz_dy float;
    BEGIN
        pwidth := args[1]::float;
        pheight := args[2]::float;
        dz_dx := ((matrix[3][1] + 2.0 * matrix[3][2] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[1][2] + matrix[1][3])) / (8.0 * pwidth);
        dz_dy := ((matrix[1][3] + 2.0 * matrix[2][3] + matrix[3][3]) - (matrix[1][1] + 2.0 * matrix[2][1] + matrix[3][1])) / (8.0 * pheight);
        RETURN atan(sqrt(pow(dz_dx, 2.0) + pow(dz_dy, 2.0)));
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION _svc_reset_db() RETURNS void
    LANGUAGE plpgsql
    AS $$begin
  truncate table tf cascade;
  truncate table doc_term cascade;
  truncate table docs cascade;
  truncate table terms cascade;
  truncate table index_queue cascade;
  truncate table neuron_doc cascade;
  truncate table neuron_neuron cascade;
  truncate table neuron_vectors cascade;
  truncate table neurons cascade;
  
  perform setval('index_queue_id_seq',1);
  perform setval('docs_id_seq',1);
  perform setval('terms_id_seq',1);
  perform setval('neurons_id_seq',1);
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION _svc_reset_index() RETURNS void
    LANGUAGE plpgsql
    AS $$begin
  truncate table tf cascade;
  truncate table doc_term cascade;
  truncate table docs cascade;
  truncate table terms cascade;
  truncate table index_queue cascade;
  
  perform setval('index_queue_id_seq',1);
  perform setval('docs_id_seq',1);
  perform setval('terms_id_seq',1);
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION _svc_reset_net() RETURNS void
    LANGUAGE plpgsql
    AS $$begin
  truncate table neuron_doc cascade;
  truncate table neuron_neuron cascade;
  truncate table neuron_vectors cascade;
  truncate table neurons cascade;
  
  perform setval('neurons_id_seq',1);
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION _sys_optimize_all() RETURNS numeric
LANGUAGE plpgsql
AS $$
BEGIN

vacuum full verbose ad_municipality;
vacuum full verbose ad_state;
vacuum full verbose ad_canton;

vacuum full verbose cb_common;
vacuum full verbose cb_by_ages_rq;
vacuum full verbose cb_by_ages_ch;
vacuum full verbose cb_by_ages_ch_in_q;
vacuum full verbose cb_by_ages_ch_in_q_w_ben;
vacuum full verbose cb_by_ages_ch_in_q_w_hel;
vacuum full verbose cb_by_ages_ch_in_q_w_place;
vacuum full verbose cb_by_ages_ch_in_q_wo_place;
vacuum full verbose cb_by_ages_ch_in_q_next_year;
vacuum full verbose cb_by_ages_ch_in_org;
vacuum full verbose cb_by_ages_ch_in_org_w_ben;
vacuum full verbose cb_by_ages_ch_in_org_w_hel;
vacuum full verbose cb_by_ages_fr_pl_in_org;
vacuum full verbose cb_by_ages_additional;

vacuum full verbose cb_value_for_organization;
vacuum full verbose cb_value_for_municipality;
vacuum full verbose cm_organization_parameter;
vacuum full verbose cm_municipality_parameter;

--

reindex table ad_municipality;
reindex table ad_state;
reindex table ad_canton;

reindex table cb_common;
reindex table cb_by_ages_rq;
reindex table cb_by_ages_ch;
reindex table cb_by_ages_ch_in_q;
reindex table cb_by_ages_ch_in_q_w_ben;
reindex table cb_by_ages_ch_in_q_w_hel;
reindex table cb_by_ages_ch_in_q_w_place;
reindex table cb_by_ages_ch_in_q_wo_place;
reindex table cb_by_ages_ch_in_q_next_year;
reindex table cb_by_ages_ch_in_org;
reindex table cb_by_ages_ch_in_org_w_ben;
reindex table cb_by_ages_ch_in_org_w_hel;
reindex table cb_by_ages_fr_pl_in_org;
reindex table cb_by_ages_additional;

reindex table cm_organization;
reindex table cm_organization_place;

reindex table cb_value_for_organization;
reindex table cb_value_for_municipality;

reindex table cm_organization_parameter;
reindex table cm_municipality_parameter;

reindex table cb_value_for_organization;
reindex table cb_value_for_municipality;
reindex table cm_organization_parameter;
reindex table cm_municipality_parameter;

--

reindex table v_combination;
reindex table v_cube_common;
reindex table v_cube_ages;
reindex table v_cube_ages_agg;
reindex table v_cube_common_for_canton;
reindex table v_cube_common_for_state;
reindex table v_cube_common_for_municipality;
reindex table v_cube_common_for_organization;
reindex table v_cube_ages_for_canton;
reindex table v_cube_ages_for_state;
reindex table v_cube_ages_for_municipality;
reindex table v_cube_ages_for_organization;
reindex table v_cube_ages_agg_for_canton;
reindex table v_cube_ages_agg_for_state;
reindex table v_cube_ages_agg_for_municipality;
reindex table v_cube_ages_agg_for_organization;
reindex table v_cube_common_for_state_wo;
reindex table v_cube_common_for_organization_wo;
reindex table v_cube_ages_for_state_wo;
reindex table v_cube_ages_for_organization_wo;

END
$$;",functions.sql
"CREATE FUNCTION _sys_optimize_organization_parameter(v_parameter_name character varying, v_year integer, v_month integer) RETURNS numeric
LANGUAGE plpgsql
AS $$
 DECLARE
  v_count integer;
  v_rc2 cursor for
  select state_id from ad_state order by state_id;
 BEGIN
 --ver. 1.0.0.0
 for rec in v_rc2 loop
  perform _sys_optimize_organization_parameter_by_month_2(rec.state_id, v_parameter_name, v_year, v_month);
 end loop;
 --
 return 0;
END
$$;",functions.sql
"CREATE FUNCTION _trained_docs_percent() RETURNS numeric
    LANGUAGE plpgsql
    AS $$begin
  return (select (100.0*(select count(1) from docs d
  join neuron_doc nd
  on nd.doc_id = d.id))/
  (select count(1) from docs));
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION aaa() RETURNS void AS $$
DECLARE
    tmp VARCHAR(512);
DECLARE names CURSOR FOR 
    select tablename from pg_tables where schemaname='public' ;
BEGIN
  FOR stmt IN names LOOP
    tmp := 'DROP TABLE '|| quote_ident(stmt.tablename) || ' CASCADE;';
RAISE NOTICE 'notice: %', tmp;
    EXECUTE 'DROP TABLE '|| quote_ident(stmt.tablename) || ' CASCADE;';
  END LOOP;
  RAISE NOTICE 'finished .....';
END;
$$ LANGUAGE plpgsql;",Postgres%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.md
"CREATE FUNCTION abscmp(int, int) RETURNS int AS
$$
  begin return btint4cmp(abs($1),abs($2)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca.out
"CREATE FUNCTION abscmp(int, int) RETURNS int AS
$$
  begin return btint4cmp(abs($1),abs($2)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca_optimizer.out
"CREATE FUNCTION abseq(int, int) RETURNS BOOL AS
$$
  begin return abs($1) = abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca.out
"CREATE FUNCTION abseq(int, int) RETURNS BOOL AS
$$
  begin return abs($1) = abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca_optimizer.out
"CREATE FUNCTION absgt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) > abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca.out
"CREATE FUNCTION absgt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) > abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca_optimizer.out
"CREATE FUNCTION abshashfunc(int) RETURNS int AS
$$
  begin return hashint4(abs($1)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca.out
"CREATE FUNCTION abshashfunc(int) RETURNS int AS
$$
  begin return hashint4(abs($1)); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca_optimizer.out
"CREATE FUNCTION abslt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) < abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca.out
"CREATE FUNCTION abslt(int, int) RETURNS BOOL AS
$$
  begin return abs($1) < abs($2); end;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;",gporca_optimizer.out
"CREATE FUNCTION accent_remove(text_input character varying) RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$
			DECLARE 
				text_output varchar;
			BEGIN	
				text_output = text_input;

				text_output = replace(text_output,'Á','A');
				text_output = replace(text_output,'á','a');
				text_output = replace(text_output,'à','a');
				text_output = replace(text_output,'À','A');
				text_output = replace(text_output,'â','a');
				text_output = replace(text_output,'Â','A');
				text_output = replace(text_output,'ä','a');
				text_output = replace(text_output,'Ä','A');
				text_output = replace(text_output,'ã','a');
				text_output = replace(text_output,'Ã','A');
				text_output = replace(text_output,'å','a');
				text_output = replace(text_output,'Å','A');
				text_output = replace(text_output,'ð','o');
				text_output = replace(text_output,'é','e');
				text_output = replace(text_output,'É','E');
				text_output = replace(text_output,'È','E');
				text_output = replace(text_output,'è','e');
				text_output = replace(text_output,'Ê','E');
				text_output = replace(text_output,'ê','e');
				text_output = replace(text_output,'Ë','E');
				text_output = replace(text_output,'ë','e');
				text_output = replace(text_output,'í','i');
				text_output = replace(text_output,'Í','I');
				text_output = replace(text_output,'ì','i');
				text_output = replace(text_output,'Ì','I');
				text_output = replace(text_output,'î','i');
				text_output = replace(text_output,'Î','I');
				text_output = replace(text_output,'ï','i');
				text_output = replace(text_output,'Ï','I');
				text_output = replace(text_output,'ñ','n');
				text_output = replace(text_output,'Ñ','N');
				text_output = replace(text_output,'ó','o');
				text_output = replace(text_output,'Ó','O');
				text_output = replace(text_output,'Ò','O');
				text_output = replace(text_output,'ò','o');
				text_output = replace(text_output,'Ô','O');
				text_output = replace(text_output,'ô','o');
				text_output = replace(text_output,'Ö','O');
				text_output = replace(text_output,'ö','o');
				text_output = replace(text_output,'õ','o');
				text_output = replace(text_output,'Õ','O');
				text_output = replace(text_output,'Ú','U');
				text_output = replace(text_output,'ú','u');
				text_output = replace(text_output,'ù','u');
				text_output = replace(text_output,'Ù','U');
				text_output = replace(text_output,'û','u');
				text_output = replace(text_output,'Û','U');
				text_output = replace(text_output,'ü','u');
				text_output = replace(text_output,'Ü','U');
				text_output = replace(text_output,'ý','y');
				text_output = replace(text_output,'Ý','Y');
				text_output = replace(text_output,'ÿ','y');
				text_output = replace(text_output,'Ç','C');
				text_output = replace(text_output,'ç','c');
				return text_output;
			end; $$;",financeiro_11-04-2011.sql
"CREATE FUNCTION acl_has_right(name, integer, character varying, name) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	result Boolean;
BEGIN
	SELECT INTO result usesuper FROM pg_user WHERE usename IN ($4);

	IF result THEN
		RETURN true;
	END IF;

	FOR result IN EXECUTE 'SELECT _' || $3 || ' FROM ' || $1 || '_acl WHERE object_id IN (0, ' || $2 || ') AND username IN (''*'', ''' || CURRENT_DATABASE() || '_' || $4 || ''') ORDER BY _' || $3 || ' DESC LIMIT 1' LOOP END LOOP;


	RETURN COALESCE(result, FALSE);
END;
$_$;",yala.sql
"CREATE FUNCTION activatesummsubass(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('activatesummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, null, true));

	

	PERFORM (SELECT activatepart(	pItemNumber,

					pRevision,

					pSerialNumber));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT activatepart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber));

		END IF;

	END LOOP;

		  

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name ""%(%)"" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
	ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
    END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
            EXECUTE sql;
        END IF;
    END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$;",hr_database.pgsql
"CREATE FUNCTION addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name ""%(%)"" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
	ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
    END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
            EXECUTE sql;
        END IF;
    END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$;",pgex_backup.sql
"CREATE FUNCTION addgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying, new_srid_in integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	rec RECORD;
	sr varchar;
	real_schema name;
	sql text;
	new_srid integer;

BEGIN

	-- Verify geometry type
	IF (postgis_type_name(new_type,new_dim) IS NULL )
	THEN
		RAISE EXCEPTION 'Invalid type name ""%(%)"" - valid ones are:
	POINT, MULTIPOINT,
	LINESTRING, MULTILINESTRING,
	POLYGON, MULTIPOLYGON,
	CIRCULARSTRING, COMPOUNDCURVE, MULTICURVE,
	CURVEPOLYGON, MULTISURFACE,
	GEOMETRY, GEOMETRYCOLLECTION,
	POINTM, MULTIPOINTM,
	LINESTRINGM, MULTILINESTRINGM,
	POLYGONM, MULTIPOLYGONM,
	CIRCULARSTRINGM, COMPOUNDCURVEM, MULTICURVEM
	CURVEPOLYGONM, MULTISURFACEM, TRIANGLE, TRIANGLEM,
	POLYHEDRALSURFACE, POLYHEDRALSURFACEM, TIN, TINM
	or GEOMETRYCOLLECTIONM', new_type, new_dim;
		RETURN 'fail';
	END IF;


	-- Verify dimension
	IF ( (new_dim >4) OR (new_dim <2) ) THEN
		RAISE EXCEPTION 'invalid dimension';
		RETURN 'fail';
	END IF;

	IF ( (new_type LIKE '%M') AND (new_dim!=3) ) THEN
		RAISE EXCEPTION 'TypeM needs 3 dimensions';
		RETURN 'fail';
	END IF;


	-- Verify SRID
	IF ( new_srid_in > 0 ) THEN
		IF new_srid_in > 998999 THEN
			RAISE EXCEPTION 'AddGeometryColumn() - SRID must be <= %', 998999;
		END IF;
		new_srid := new_srid_in;
		SELECT SRID INTO sr FROM spatial_ref_sys WHERE SRID = new_srid;
		IF NOT FOUND THEN
			RAISE EXCEPTION 'AddGeometryColumn() - invalid SRID';
			RETURN 'fail';
		END IF;
	ELSE
		new_srid := ST_SRID('POINT EMPTY'::geometry);
		IF ( new_srid_in != new_srid ) THEN
			RAISE NOTICE 'SRID value % converted to the officially unknown SRID value %', new_srid_in, new_srid;
		END IF;
	END IF;


	-- Verify schema
	IF ( schema_name IS NOT NULL AND schema_name != '' ) THEN
		sql := 'SELECT nspname FROM pg_namespace ' ||
			'WHERE text(nspname) = ' || quote_literal(schema_name) ||
			'LIMIT 1';
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Schema % is not a valid schemaname', quote_literal(schema_name);
			RETURN 'fail';
		END IF;
	END IF;

	IF ( real_schema IS NULL ) THEN
		RAISE DEBUG 'Detecting schema';
		sql := 'SELECT n.nspname AS schemaname ' ||
			'FROM pg_catalog.pg_class c ' ||
			  'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace ' ||
			'WHERE c.relkind = ' || quote_literal('r') ||
			' AND n.nspname NOT IN (' || quote_literal('pg_catalog') || ', ' || quote_literal('pg_toast') || ')' ||
			' AND pg_catalog.pg_table_is_visible(c.oid)' ||
			' AND c.relname = ' || quote_literal(table_name);
		RAISE DEBUG '%', sql;
		EXECUTE sql INTO real_schema;

		IF ( real_schema IS NULL ) THEN
			RAISE EXCEPTION 'Table % does not occur in the search_path', quote_literal(table_name);
			RETURN 'fail';
		END IF;
	END IF;


	-- Add geometry column to table
	IF use_typmod THEN
	     sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry(' || postgis_type_name(new_type, new_dim) || ', ' || new_srid::text || ')';
        RAISE DEBUG '%', sql;
	ELSE
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD COLUMN ' || quote_ident(column_name) ||
            ' geometry ';
        RAISE DEBUG '%', sql;
    END IF;
	EXECUTE sql;

	IF NOT use_typmod THEN
        -- Add table CHECKs
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_srid_' || column_name)
            || ' CHECK (st_srid(' || quote_ident(column_name) ||
            ') = ' || new_srid::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        sql := 'ALTER TABLE ' ||
            quote_ident(real_schema) || '.' || quote_ident(table_name)
            || ' ADD CONSTRAINT '
            || quote_ident('enforce_dims_' || column_name)
            || ' CHECK (st_ndims(' || quote_ident(column_name) ||
            ') = ' || new_dim::text || ')' ;
        RAISE DEBUG '%', sql;
        EXECUTE sql;
    
        IF ( NOT (new_type = 'GEOMETRY')) THEN
            sql := 'ALTER TABLE ' ||
                quote_ident(real_schema) || '.' || quote_ident(table_name) || ' ADD CONSTRAINT ' ||
                quote_ident('enforce_geotype_' || column_name) ||
                ' CHECK (GeometryType(' ||
                quote_ident(column_name) || ')=' ||
                quote_literal(new_type) || ' OR (' ||
                quote_ident(column_name) || ') is null)';
            RAISE DEBUG '%', sql;
            EXECUTE sql;
        END IF;
    END IF;

	RETURN
		real_schema || '.' ||
		table_name || '.' || column_name ||
		' SRID:' || new_srid::text ||
		' TYPE:' || new_type ||
		' DIMS:' || new_dim::text || ' ';
END;
$$;",sqlex_backup.pgsql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STABLE STRICT;",dbsetup.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STABLE STRICT;",xenia_all.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",database.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",eas.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",nlp.dump
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",villages.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$ 
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",database_setup.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$ 
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6) into ret;
	RETURN ret;
END;
$_$;",trajectories.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",dbsetup.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",xenia_all.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",database.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",eas.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",nlp.dump
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",villages.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",database_setup.sql
"CREATE FUNCTION addgeometrycolumn(character varying, character varying, integer, character varying, integer) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$ 
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5) into ret;
	RETURN ret;
END;
$_$;",trajectories.sql
"CREATE FUNCTION addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
	RETURN ret;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
	RETURN ret;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION addgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('',$1,$2,$3,$4,$5,$6,$7) into ret;
	RETURN ret;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
	RETURN ret;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
	RETURN ret;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION addgeometrycolumn(table_name character varying, column_name character varying, new_srid integer, new_type character varying, new_dim integer, use_typmod boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret  text;
BEGIN
	SELECT AddGeometryColumn('','',$1,$2,$3,$4,$5, $6) into ret;
	RETURN ret;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		x int;
		s name;
		t name;
		oschema name;
		rschema name;
		sql text;
		rtn boolean;
	BEGIN
		FOR x IN 1..2 LOOP
			s := '';

			IF x = 1 THEN
				s := $1;
				t := $2;
			ELSE
				s := $4;
				t := $5;
			END IF;

			-- validate user-provided schema
			IF length(s) > 0 THEN
				sql := 'SELECT nspname FROM pg_namespace '
					|| 'WHERE nspname = ' || quote_literal(s)
					|| 'LIMIT 1';
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The value % is not a valid schema', quote_literal(s);
					RETURN FALSE;
				END IF;
			END IF;

			-- no schema, determine what it could be using the table
			IF length(s) < 1 THEN
				sql := 'SELECT n.nspname AS schemaname '
					|| 'FROM pg_catalog.pg_class c '
					|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
					|| 'WHERE c.relkind = ' || quote_literal('r')
					|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
					|| ', ' || quote_literal('pg_toast')
					|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
					|| ' AND c.relname = ' || quote_literal(t);
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal(t);
					RETURN FALSE;
				END IF;
			END IF;

			IF x = 1 THEN
				oschema := s;
			ELSE
				rschema := s;
			END IF;
		END LOOP;

		-- reference raster
		rtn := _add_overview_constraint(oschema, $2, $3, rschema, $5, $6, $7);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to add the overview constraint.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		x int;
		s name;
		t name;
		oschema name;
		rschema name;
		sql text;
		rtn boolean;
	BEGIN
		FOR x IN 1..2 LOOP
			s := '';

			IF x = 1 THEN
				s := $1;
				t := $2;
			ELSE
				s := $4;
				t := $5;
			END IF;

			-- validate user-provided schema
			IF length(s) > 0 THEN
				sql := 'SELECT nspname FROM pg_namespace '
					|| 'WHERE nspname = ' || quote_literal(s)
					|| 'LIMIT 1';
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The value % is not a valid schema', quote_literal(s);
					RETURN FALSE;
				END IF;
			END IF;

			-- no schema, determine what it could be using the table
			IF length(s) < 1 THEN
				sql := 'SELECT n.nspname AS schemaname '
					|| 'FROM pg_catalog.pg_class c '
					|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
					|| 'WHERE c.relkind = ' || quote_literal('r')
					|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
					|| ', ' || quote_literal('pg_toast')
					|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
					|| ' AND c.relname = ' || quote_literal(t);
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal(t);
					RETURN FALSE;
				END IF;
			END IF;

			IF x = 1 THEN
				oschema := s;
			ELSE
				rschema := s;
			END IF;
		END LOOP;

		-- reference raster
		rtn := _add_overview_constraint(oschema, $2, $3, rschema, $5, $6, $7);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to add the overview constraint.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION addoverviewconstraints(ovschema name, ovtable name, ovcolumn name, refschema name, reftable name, refcolumn name, ovfactor integer) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		x int;
		s name;
		t name;
		oschema name;
		rschema name;
		sql text;
		rtn boolean;
	BEGIN
		FOR x IN 1..2 LOOP
			s := '';

			IF x = 1 THEN
				s := $1;
				t := $2;
			ELSE
				s := $4;
				t := $5;
			END IF;

			-- validate user-provided schema
			IF length(s) > 0 THEN
				sql := 'SELECT nspname FROM pg_namespace '
					|| 'WHERE nspname = ' || quote_literal(s)
					|| 'LIMIT 1';
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The value % is not a valid schema', quote_literal(s);
					RETURN FALSE;
				END IF;
			END IF;

			-- no schema, determine what it could be using the table
			IF length(s) < 1 THEN
				sql := 'SELECT n.nspname AS schemaname '
					|| 'FROM pg_catalog.pg_class c '
					|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
					|| 'WHERE c.relkind = ' || quote_literal('r')
					|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
					|| ', ' || quote_literal('pg_toast')
					|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
					|| ' AND c.relname = ' || quote_literal(t);
				EXECUTE sql INTO s;

				IF s IS NULL THEN
					RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal(t);
					RETURN FALSE;
				END IF;
			END IF;

			IF x = 1 THEN
				oschema := s;
			ELSE
				rschema := s;
			END IF;
		END LOOP;

		-- reference raster
		rtn := _add_overview_constraint(oschema, $2, $3, rschema, $5, $6, $7);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to add the overview constraint.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		cnt int;
		sql text;
		schema name;
		x int;
		kw text;
		rtn boolean;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be added.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Adding SRID constraint';
						rtn := _add_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Adding alignment constraint';
						rtn := _add_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Adding regular blocking constraint';
						rtn := _add_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Adding number of bands constraint';
						rtn := _add_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Adding pixel type constraint';
						rtn := _add_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Adding nodata value constraint';
						rtn := _add_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Adding out-of-database constraint';
						rtn := _add_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Adding maximum extent constraint';
						rtn := _add_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to add constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be added.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		cnt int;
		sql text;
		schema name;
		x int;
		kw text;
		rtn boolean;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be added.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Adding SRID constraint';
						rtn := _add_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Adding alignment constraint';
						rtn := _add_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Adding regular blocking constraint';
						rtn := _add_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Adding number of bands constraint';
						rtn := _add_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Adding pixel type constraint';
						rtn := _add_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Adding nodata value constraint';
						rtn := _add_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Adding out-of-database constraint';
						rtn := _add_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Adding maximum extent constraint';
						rtn := _add_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to add constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be added.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		cnt int;
		sql text;
		schema name;
		x int;
		kw text;
		rtn boolean;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be added.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Adding SRID constraint';
						rtn := _add_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Adding scale-X constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Adding scale-Y constraint';
						rtn := _add_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Adding blocksize-X constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Adding blocksize-Y constraint';
						rtn := _add_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Adding alignment constraint';
						rtn := _add_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Adding regular blocking constraint';
						rtn := _add_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Adding number of bands constraint';
						rtn := _add_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Adding pixel type constraint';
						rtn := _add_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Adding nodata value constraint';
						rtn := _add_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Adding out-of-database constraint';
						rtn := _add_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Adding maximum extent constraint';
						rtn := _add_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to add constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be added.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN AddRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN AddRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION addrasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT false, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN AddRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION addroleprivmodule(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pModule			ALIAS FOR $1;

	pRole 		ALIAS FOR $2;

	_r			RECORD;

	_moduleId 		INTEGER;

	_roleId			INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('addroleprivmodule'));

	_moduleId := (SELECT getmoduleid(pModule));

	_roleId := (SELECT getroleid(pRole));



	FOR _r IN

		SELECT priv_name

		FROM priv

		WHERE priv_module_id = _moduleId

	LOOP

		IF _r.priv_name IS NOT NULL THEN

			PERFORM (SELECT addrolepriv(	_r.priv_name,

							pRole));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION addusrprivmodule(text, text DEFAULT ""current_user""()) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pModule			ALIAS FOR $1;

	pUserName 		ALIAS FOR $2;

	_r			RECORD;

	_moduleId 		INTEGER;

	_usrId			INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('addusrprivmodule'));

	_moduleId := (SELECT getmoduleid(pModule));

	_usrId := (SELECT getusrid(pUserName));



	FOR _r IN

		SELECT priv_name

		FROM priv

		WHERE priv_module_id = _moduleId

	LOOP

		IF _r.priv_name IS NOT NULL THEN

			PERFORM (SELECT addusrpriv(	_r.priv_name,

							pUserName));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION adjust_year_week(p_week_str text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	strlen integer;
	ret_str text;
	
BEGIN

	--SET strlen =0;
	--SET strlen = length(p_week_str);

	if length(p_week_str) = 5 then

		ret_str = SUBSTRING(p_week_str,1,4) ||  '0' || SUBSTRING(p_week_str,5,5);


	else

		ret_str = p_week_str;
	end if;


	return ret_str;
	
END;
$$;",bgtTest.backup
"CREATE FUNCTION adjusted_date(x timestamp with time zone) RETURNS date AS $$
BEGIN
  IF extract(hour from x) < 4 THEN 
    RETURN date( x - interval '24 hours' );    
  ELSE 
    RETURN date(x);
  END IF;
END;
$$ LANGUAGE plpgsql;",NOTES
"CREATE FUNCTION adjusted_time(x timestamp with time zone) RETURNS character(8) AS $$
DECLARE
  h integer;
  m integer;
  s  integer;
BEGIN
  h := extract(hour from x);
  m := extract(minutes from x);
  IF h  < 4 THEN 
    h := h + 24;
  END IF;
  RETURN lpad(h::text, 2, '0') || ':' || m || ':00';
END;
$$ LANGUAGE plpgsql;",NOTES
"CREATE FUNCTION adom_integer(_state integer) RETURNS TABLE(val integer)
    LANGUAGE plpgsql IMMUTABLE ROWS 1000000
    AS $$BEGIN
	RETURN QUERY 
		SELECT DISTINCT trvlmaxamnt_1.""maxAmnt"" 
				FROM ""TrvlMaxAmnt"" AS trvlmaxamnt_1, ""TrvlMaxAmnt_state_log"" AS trvlmaxamnt_state_log_1
				WHERE trvlmaxamnt_state_log_1.""state""=""_state""
				AND trvlmaxamnt_1.""rid""=trvlmaxamnt_state_log_1.""rid""
		UNION
		SELECT DISTINCT trvlcost_1.""cost""
				FROM ""TrvlCost"" AS trvlcost_1, ""TrvlCost_state_log"" AS trvlcost_state_log_1
				WHERE trvlcost_state_log_1.""state""=""_state""
				AND trvlcost_1.""rid""=trvlcost_state_log_1.""rid""
		UNION
		SELECT DISTINCT accepted_1.""amount""
				FROM ""Accepted"" AS accepted_1, ""Accepted_state_log"" AS accepted_state_log_1
				WHERE accepted_state_log_1.""state""=""_state"" 
				AND accepted_1.""rid""=accepted_state_log_1.""rid""
		--UNION
		--SELECT ""value"" FROM ""maxamnt_allowed_values""
		ORDER BY 1 ASC;
END$$;",dcds128.sql
"CREATE FUNCTION adom_string(_state integer) RETURNS TABLE(val character varying)
    LANGUAGE plpgsql IMMUTABLE ROWS 1000000
    AS $$BEGIN
	RETURN QUERY 
		SELECT DISTINCT pending_1.""empl""
				FROM ""Pending"" AS pending_1, ""Pending_state_log"" AS pending_state_log_1
				WHERE pending_state_log_1.""state""=""_state""
				AND pending_1.""rid"" = pending_state_log_1.""rid""
		UNION
		SELECT DISTINCT pending_1.""dest""
				FROM ""Pending"" AS pending_1, ""Pending_state_log"" AS pending_state_log_1
				WHERE pending_state_log_1.""state""=""_state""
				AND pending_1.""rid"" = pending_state_log_1.""rid""
		UNION
		SELECT DISTINCT currreq_1.""empl""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""=""_state""
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
		UNION
		SELECT DISTINCT currreq_1.""dest""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""=""_state""
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
		UNION
		SELECT DISTINCT currreq_1.""status""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""=""_state""
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
		ORDER BY 1 ASC;
END$$;",dcds128.sql
"CREATE FUNCTION andre(entrou integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$begin 
return entrou*4;
end$$;",database.sql
"CREATE FUNCTION ansestros_out(varconceptid numeric, OUT conceptid numeric, OUT term character varying, OUT depth integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
    reg RECORD;
BEGIN
    FOR REG IN  select d.conceptid, d.term, t.depth
		from snomed.descriptions d 
		Inner join snomed.languages l on d.id = l.referencedcomponentid
		inner join snomed.transitiveclosure t on t.supertypeid = d.conceptid
		where 
		d.active = TRUE
		and l.active = TRUE
		and l.refsetid =  450828004 --conjunto de referencias de lenguaje castellano para América Latina (metadato fundacional) 
		and t.subtypeid = varconceptid --valor para buscar
		--and d.typeId = 900000000000003001 --FSN
		order by t.depth, char_length(d.term) LOOP
	conceptid := reg.conceptid;
	term := reg.term;
	depth := reg.depth;
       RETURN NEXT;
    END LOOP;
    RETURN;
END
$$;",simulador.txt
"CREATE FUNCTION answer_ranking(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE publicationvotecount INTEGER;
BEGIN
  SELECT SUM(votes.values) FROM votes WHERE votes.publicationid = aid
  INTO publicationvotecount;

  IF publicationvotecount is null THEN
    publicationvotecount := 0;
  END IF;

  return publicationvotecount;
END
$$;",dbm
"CREATE FUNCTION answer_ranking(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE publicationvotecount INTEGER;
BEGIN
  SELECT SUM(votes.values) FROM votes WHERE votes.publicationid = aid
  INTO publicationvotecount;

  IF publicationvotecount is null THEN
    publicationvotecount := 0;
  END IF;

  return publicationvotecount;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION answer_total_comments(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM answers
    INNER JOIN answercomments
      ON answers.publicationid = answercomments.answerid
  WHERE answers.publicationid = aid
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",dbm
"CREATE FUNCTION answer_total_comments(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM answers
    INNER JOIN answercomments
      ON answers.publicationid = answercomments.answerid
  WHERE answers.publicationid = aid
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION any_id_query(qtext text, qnumber integer, OUT content text, OUT ttl integer, OUT prio integer, OUT type text, OUT domain_id integer, OUT disabled boolean, OUT name text, OUT auth boolean) RETURNS SETOF record
    LANGUAGE plpgsql STABLE ROWS 1
    AS $_$
DECLARE
  ip integer[];
BEGIN

ip := REGEXP_MATCHES(qtext, '^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.in-addr\.arpa$');

IF ip IS NOT NULL THEN

RETURN QUERY EXECUTE format('SELECT
  format(templ, %2$s, %3$s, %4$s, %5$s),
  ttl, 0, type::text, domain_id, false, name, true
FROM (
  SELECT *,
    ''%1$s''::text AS name
  FROM cpe_pseudo_records
  WHERE
    range >> ''%2$s.%3$s.%4$s.%5$s''::ipaddress
    AND domain_id = %6$s
)
AS foo;', qtext, ip[4], ip[3], ip[2], ip[1], qnumber);

ELSE

ip := REGEXP_MATCHES(qtext, '(\d{1,3})\D(\d{1,3})\D(\d{1,3})\D(\d{1,3})');

IF ip IS NOT NULL THEN

RETURN QUERY EXECUTE format('SELECT
  ''%2$s.%3$s.%4$s.%5$s''::text,
  ttl, 0, type::text, domain_id, false, name, true
FROM (
  SELECT *,
    ''%1$s''::text AS name
  FROM cpe_pseudo_records
  WHERE
    range >> ''%2$s.%3$s.%4$s.%5$s''::ipaddress
    AND domain_id = %6$s
)
AS foo
WHERE format(templ, %2$s, %3$s, %4$s, %5$s) = ''%1$s''
;', qtext, ip[1], ip[2], ip[3], ip[4], qnumber);


END IF;

END IF;

RETURN;

END
$_$;",schema.sql
"CREATE FUNCTION any_query(qtext text, OUT content text, OUT ttl integer, OUT prio integer, OUT type text, OUT domain_id integer, OUT disabled boolean, OUT name text, OUT auth boolean) RETURNS SETOF record
    LANGUAGE plpgsql STABLE ROWS 1
    AS $_$
DECLARE
  ip integer[];
BEGIN

ip := REGEXP_MATCHES(qtext, '^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.in-addr\.arpa$');

IF ip IS NOT NULL THEN

RETURN QUERY EXECUTE format('SELECT
  concat(format(templ, %2$s, %3$s, %4$s, %5$s),''.'',basedomain),
  ttl, 0, ''PTR''::text, h_int(basedomain), false, ''%1$s''::text, true
  FROM cpe_ranges INNER JOIN cpe_formats ON (cpe_formats.id = cpe_ranges.format_id)
  WHERE
    range >> ''%2$s.%3$s.%4$s.%5$s''::ipaddress
;', qtext, ip[4], ip[3], ip[2], ip[1]);

ELSE

ip := REGEXP_MATCHES(qtext, '(\d{1,3})\D(\d{1,3})\D(\d{1,3})\D(\d{1,3})');

IF ip IS NOT NULL THEN

RETURN QUERY EXECUTE format('SELECT
  ''%2$s.%3$s.%4$s.%5$s''::text,
  ttl, 0, ''A''::text, h_int(basedomain), false, ''%1$s''::text, true
  FROM cpe_ranges INNER JOIN cpe_formats ON (cpe_formats.id = cpe_ranges.format_id)
  WHERE 1=1
    AND range >> ''%2$s.%3$s.%4$s.%5$s''::ipaddress
    AND concat(format(templ, %2$s, %3$s, %4$s, %5$s),''.'',basedomain) = ''%1$s''
;', qtext, ip[1], ip[2], ip[3], ip[4]);


END IF;

END IF;

RETURN;

END
$_$;",schema.sql
"CREATE FUNCTION api_mac_address.login(email text, pass text) RETURNS basic_auth.jwt_token
    LANGUAGE plpgsql
    AS $$
declare
  _role name;
  result basic_auth.jwt_token;
begin
  -- check email and password
  select basic_auth.user_role(email, pass) into _role;
  if _role is null then
    raise invalid_password using message = 'invalid user or password';
  end if;

  select sign(
      row_to_json(r), current_setting('app.jwt_secret')
    ) as token
    from (
      select _role as role, login.email as email,
         extract(epoch from now())::integer + 60*60 as exp
    ) r
    into result;
  return result;
end;
$$;",README.md
"CREATE FUNCTION apply_rules(item text) RETURNS text
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res text := item;
     rule renaming_rules;
  BEGIN

    FOR rule IN Select * from gsc_db.renaming_rules LOOP
       res := replace(res, rule.term, rule.target);
    END LOOP;

    RETURN res;
  END;
$$;",test.sql
"CREATE FUNCTION arg_month(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
	mes integer;
	mes_salida character varying;
BEGIN 
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN mes_salida;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION arg_month(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
	mes integer;
	mes_salida character varying;
BEGIN 
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN mes_salida;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION arg_month(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
	mes integer;
	mes_salida character varying;
BEGIN 
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN mes_salida;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION arg_month(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
	mes integer;
	mes_salida character varying;
BEGIN 
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN mes_salida;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION arg_month(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE 
	mes integer;
	mes_salida character varying;
BEGIN 
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN mes_salida;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION array_add_item(p_list character varying, p_item character varying, p_place character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_list varchar;
BEGIN
    -- if invalid param
    IF (Coalesce(p_item, '') = '') THEN
	   Return p_list;
    END IF;
    -- no duplicates allowed
    IF (fx.unique_text_in_first(p_item, p_list) = '') THEN
       Return p_list;
    END IF;

    v_list = Trim(both ',' from p_list);
    v_list = Trim(both ' ' from v_list);
    -- return new delimited list based on p_place param
    IF Lower(p_place) = 'first' THEN
       Return p_item || ',' || v_list;
     ELSIF Lower(p_place) = 'last' THEN
       Return v_list || ',' || p_item;
     ELSE
       Return v_list || ',' || p_item;
	END IF;
END;
$$;",utils.sql
"CREATE FUNCTION array_contains(p_int_arr integer[], p_value integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  FOR i IN array_lower(p_int_arr, 1)..array_upper(p_int_arr, 1) LOOP
   	-- null array value never matches
      IF p_int_arr[i] Is Null THEN
      	Return false;
      ElsIf p_int_arr[i] = p_value THEN
      	Return true;
      END IF;
	END LOOP;
   -- no match found
   Return false;
END;
$$;",utils.sql
"CREATE FUNCTION array_contains(p_str_arr character varying[], p_value integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
	FOR i IN array_lower(p_str_arr, 1)..array_upper(p_str_arr, 1) LOOP
   	-- handle nulls separately
      IF p_str_arr[i] Is Null THEN
      	IF p_value Is Null THEN
      		Return true;
          Else
         	Return false;
         END IF;
      ElsIf p_int_arr[i] = p_value THEN
      	Return true;
      END IF;
	END LOOP;
   -- no match found
   Return false;
END;
$$;",utils.sql
"CREATE FUNCTION array_pop(a anyarray, element character varying) RETURNS anyarray
    LANGUAGE plpgsql
    AS $$
DECLARE 
    result a%TYPE;
BEGIN
SELECT ARRAY(
    SELECT b.e FROM (SELECT unnest(a)) AS b(e) WHERE b.e <> element) INTO result;
RETURN result;
END;
$$;",BASE_KAFEINE_BACK.sql
"CREATE FUNCTION assemly_to_consumable(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'CONSUMABLE'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION assemly_to_producible(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'PRODUCIBLE'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION assert(pred BOOLEAN) RETURNS void AS
$$
BEGIN
  IF NOT pred THEN
    RAISE 'Assertion failure';
  END IF;
END;
$$
LANGUAGE plpgsql;",autocollector_populate_metadata.sql
"CREATE FUNCTION assert_array_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF NOT (_expected::varchar[] @> _actual::varchar[] AND _actual::varchar[] @> _expected::varchar[])
     OR _actual IS NULL
     OR (array_dims(_expected) <> array_dims(_actual))
  THEN
    RAISE EXCEPTION E'#assert_array_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_array_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF NOT (_expected::varchar[] @> _actual::varchar[] AND _actual::varchar[] @> _expected::varchar[])
     OR _actual IS NULL
     OR (array_dims(_expected) <> array_dims(_actual))
  THEN
    RAISE EXCEPTION E'#assert_array_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF _expected IS DISTINCT FROM _actual THEN
    RAISE EXCEPTION E'#assert_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF _expected IS DISTINCT FROM _actual THEN
    RAISE EXCEPTION E'#assert_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_false(_value boolean, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value OR _value IS NULL THEN
    RAISE EXCEPTION E'#assert_false\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_false(_value boolean, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value OR _value IS NULL THEN
    RAISE EXCEPTION E'#assert_false\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_not_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF _expected IS NOT DISTINCT FROM _actual THEN
    RAISE EXCEPTION E'#assert_not_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_not_equals(_expected anyelement, _actual anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _expected IS NULL THEN
    RAISE EXCEPTION '#incorrect_expected_value NULL';
  END IF;
  IF _expected IS NOT DISTINCT FROM _actual THEN
    RAISE EXCEPTION E'#assert_not_equals\n%\nExpected: %\nActual: %', _message, _expected, _actual;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_not_null(_value anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value IS NULL THEN
    RAISE EXCEPTION E'#assert_not_null\n%', _message;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_not_null(_value anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value IS NULL THEN
    RAISE EXCEPTION E'#assert_not_null\n%', _message;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_null(_value anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value IS NOT NULL THEN
    RAISE EXCEPTION E'#assert_null\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_null(_value anyelement, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF _value IS NOT NULL THEN
    RAISE EXCEPTION E'#assert_null\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION assert_true(_value boolean, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NOT _value OR _value IS NULL THEN
    RAISE EXCEPTION E'#assert_true\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION assert_true(_value boolean, _message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF NOT _value OR _value IS NULL THEN
    RAISE EXCEPTION E'#assert_true\n%\nValue: %', _message, _value;
  END IF;
END;
$$;",mes-idea.sql
"CREATE FUNCTION asserty(text, boolean) RETURNS void
    LANGUAGE plpgsql IMMUTABLE COST 10
    AS $_$DECLARE 
	e alias for $1;
	v alias for $2;
BEGIN

	if not v then
		raise exception '%', e;
	end if;

END$_$;",streetking-database.sql
"CREATE FUNCTION average_transfer_speed(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE result double precision;
BEGIN
  result = SUM(amount_of_memory*transfer_rate)/SUM(amount_of_memory) FROM memorymodule JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON memorymodule.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN result;
END;$$;",database
"CREATE FUNCTION avgcost(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$

DECLARE

v_cost numeric;
v_qty numeric;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost, v_qty SUM(i.sellprice * i.qty), SUM(i.qty)
  FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id;
  
  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

  IF NOT v_qty IS NULL THEN
    IF v_qty = 0 THEN
      v_cost := 0;
    ELSE
      v_cost := v_cost/v_qty;
    END IF;
  END IF;

RETURN v_cost;
END;
$_$;",empty.sql
"CREATE FUNCTION basic_auth.user_role(email text, pass text) RETURNS name
    LANGUAGE plpgsql
    AS $$
begin
  return (
  select role from basic_auth.users
   where users.email = user_role.email
     and users.pass = crypt(user_role.pass, users.pass)
  );
end;
$$;",README.md
"CREATE FUNCTION basic_query(qtype text, qtext text, OUT content text, OUT ttl integer, OUT prio integer, OUT type text, OUT domain_id integer, OUT disabled boolean, OUT name text, OUT auth boolean) RETURNS SETOF record
    LANGUAGE plpgsql STABLE ROWS 1
    AS $_$
DECLARE
  ip integer[];
BEGIN

  CASE qtype
    WHEN 'SOA', 'NS' THEN

        ip := REGEXP_MATCHES(qtext, '^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.in-addr\.arpa$');

        IF ip IS NOT NULL THEN

            RETURN QUERY EXECUTE format('
SELECT
content::text,cpe_authorities.ttl,prio,type::text,h_int(''%1$s''::text),false,''%1$s''::text,true
FROM cpe_authorities,cpe_ranges
WHERE 1=1
AND range >> ''%5$s.%4$s.%3$s.0''::ipaddress
AND type = ''%2$s''
', qtext, qtype, ip[1], ip[2], ip[3]);

        ELSE

            ip := REGEXP_MATCHES(qtext, '^(\d{1,3})\.(\d{1,3})\.in-addr\.arpa$');

            IF ip IS NOT NULL THEN

                RETURN QUERY EXECUTE format('
SELECT
content::text,cpe_authorities.ttl,prio,type::text,h_int(''%1$s''::text),false,''%1$s''::text,true
FROM cpe_authorities,cpe_ranges
WHERE 1=1
AND range >> ''%4$s.%3$s.0.0''::ipaddress
AND type = ''%2$s''
', qtext, qtype, ip[1], ip[2]);


            ELSE

                RETURN QUERY EXECUTE format('
SELECT
content::text,cpe_authorities.ttl,prio,type::text,h_int(''%1$s''::text),false,basedomain::text,true
FROM cpe_authorities,cpe_formats
WHERE 1=1
AND basedomain = ''%1$s''
AND type = ''%2$s''
', qtext, qtype);


            END IF;

        END IF;

  ELSE

RETURN;

  END CASE;

END
$_$;",schema.sql
"CREATE FUNCTION battery_capacity(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE result double precision;
BEGIN
	result = SUM(battery.capacity) FROM battery JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON battery.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN result;
END;$$;",database
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",database.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",schema.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",villages.sql
"CREATE FUNCTION bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",database.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",schema.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",villages.sql
"CREATE FUNCTION bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION bdproject.aux_competitors(id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
  return array_to_string(
      array (select team
    from bdproject.matchcandidatures
    where match = id
    and confirmed notnull),
    ' vs ',
    '*'
  );
END;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.aux_ispremium(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return $1 in (select username from bdproject.users where uprivilege = 'premium');
END;
$_$;",pgbak.sql
"CREATE FUNCTION bdproject.aux_outcomesinmatch(_id bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  return (
      select count(*)
      from outcomes o
      where o.match = _id
    ) <=2;
END;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.aux_referee(bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return (
    select applicant
    from matches
    left outer join refereecandidatures r on matches.id = r.match
    where id = $1 and confirmed notnull 
  );
END;
$_$;",pgbak.sql
"CREATE FUNCTION bdproject.aux_samecat(m bigint, t character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  return(
    select category
    from matches
    where id = m
  ) = (
    select category
    from teams
    where name = t
  );
END;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.aux_workingdays(cdate date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
  cmonth integer:= date_part('month', (cdate));
  cyear integer:= date_part('year', (cdate));
  daysnum integer:= (select date_part('days',
                                      (cyear::text ||'-'|| cmonth::text ||'-01')::date
                                        + '1 month' :: interval
                                        - '1 day' :: interval
                                )
                    );
BEGIN
  return (with days as
  (
      select dd, extract(DOW from dd) dw
      from generate_series((cyear :: text ||'-'|| cmonth :: text ||'-01') :: date,
                           (cyear :: text ||'-'|| cmonth :: text || '-' ||daysnum :: text) :: date, '1 day' :: interval) dd
  )
  select count(*) from days where dw not in (6, 0)
  );
END;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.calcola_squadre_vincitrici(_tour character varying, _phase integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare
  teamset refcursor;
BEGIN
open teamset for
  select team
    from outcomes o1 join matches m1  on o1.match = m1.id
    where m1.tournament=_tour
    and m1.phase=_phase
    and
      (
        (
          (m1.category='calcio'or m1.category='basket')
          and
          (o1.score>(select o2.score from outcomes o2 where o2.match=m1.id and o2.team<>o1.team))

        )
        or
        (
          (m1.category='tennis'or m1.category='volley')
          and
          (o1.win>(select o3.score from outcomes o3 where o3.match=m1.id and o3.team<>o1.team))

        )


      );
return teamset;
END;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.count_match_played_by_category(_username character varying, _categoria bdproject.sport) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	select count(*)
	from matches
	left join matchcandidatures on matches.id=matchcandidatures.match
	left join teamscandidatures on matchcandidatures.team=teamcandidatures.team
	where 
	matches.mstate='closed' 
	and matches.category=_categoria 
	and matchcandidatures.confirmed is not null
	and teamcandidatures.applicant=_username;
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.count_player(teamname character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	return (
	select count(*)
	from TeamCandidatures
	where teamcandidatures.team = teamName and teamcandidatures.admin is not null 
			);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.int_simpl_open_events(buildingname character varying) RETURNS TABLE(matchid bigint, category bdproject.sport, freeslot bigint)
    LANGUAGE plpgsql
    AS $$
begin
  select matches.id as MatchId,categories.name as Category, 2*categories.max-count() as FreeSlot
  from matches
  inner join categories  on matches.category = categories.name
  inner join matchcandidatures  on matches.id = matchcandidatures.match
  inner join teamcandidatures on matchcandidatures.team=teamcandidatures.team
  where matches.mstate='open'
  and teamcandidatures.admin is not null
  and matches.building=buildingName
  and matchcandidatures.confirmed is not null 
  group by matches.id,categories.name,categories.max;

end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.is_match_closed(matchno bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	
	return 'closed'=
	(
		select matches.mstate
		from matches
		where matchno=matches.id
	);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.match_full(matchno bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return
		(select count (*)
			from (
					select team 
					from matchcandidatures
					where match = matchno 
						and confirmed is not null
			) AS aux
		) > 2;--le partite in questo caso sono sempre giocate da 2 squadre
end;


$$;",pgbak.sql
"CREATE FUNCTION bdproject.match_full_plus_1(matchno bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return
		(select count (*)
			from (
					select team 
					from matchcandidatures
					where match = matchno 
						and confirmed is not null
			) AS aux
		) >=2;--le partite in questo caso sono sempre giocate da 2 squadre
end;


$$;",pgbak.sql
"CREATE FUNCTION bdproject.referee_assigned(matchno bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return
		(select count (*)
			from (
					select applicant 
					from refereecandidatures
					where match = matchno
						and confirmed is not null
			) AS aux
		) <> 0;
end;



$$;",pgbak.sql
"CREATE FUNCTION bdproject.remaning_slot_match(matchno bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin
	return
		2-(select count (*)
			from (
					select team 
					from matchcandidatures
					where match = matchno 
						and confirmed is not null
			) as AUX 
		);
end;

$$;",pgbak.sql
"CREATE FUNCTION bdproject.remaning_slot_team(teamname character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
begin

  return (select Categories.max
		from Teams join Categories on Teams.category = Categories.name
		where Teams.name = TeamName) -count_player(teamname);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.sameadminmatch(bigint, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(
		select * from matches
		where id = $1 and admin = $2
		);
end;


$_$;",pgbak.sql
"CREATE FUNCTION bdproject.sameadminteam(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$begin
	return exists(
		select * from teams
		where name = $1 and admin = $2
		);
end;
$_$;",pgbak.sql
"CREATE FUNCTION bdproject.sameadmintournaments(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(
		select * from tournaments
		where name = $1 and manager = $2
		);
end;


$_$;",pgbak.sql
"CREATE FUNCTION bdproject.team_full(teamname character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return count_player(TeamName) >
	(
		select Categories.max
		from Teams join Categories on Teams.category = Categories.name
		where Teams.name = TeamName
	);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.team_is_registered_tournament(team character varying, tournament character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return team<@(select from tournaments where tournaments.name=tournament);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.team_min(teamname character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
	return count_player(TeamName) =
	(
		select Categories.min
		from Teams join Categories on Teams.category = Categories.name
		where Teams.name = TeamName
	);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.tournament_full(_tournament character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
numerosquadre int;
n int:= (select teamsnumber  from tournaments where tournaments.name=_tournament);
begin
	select count(*)
	from tournamentscandidatures where tournamentscandidatures.tournament=_tournament and confirmed is not null into numerosquadre;
	return (numerosquadre=n);
end;
$$;",pgbak.sql
"CREATE FUNCTION bdproject.valid_team(teamname character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
	numero_giocatori numeric;
begin
	numero_giocatori:=count_player(TeamName);
	
	return numero_giocatori >=
	(
		select Categories.min
		from Teams join Categories on Teams.category = Categories.name
		where Teams.name = TeamName
	) 
	and numero_giocatori <=
	(
		select Categories.max
		from Teams join Categories on Teams.category = Categories.name
		where Teams.name = TeamName
	);
end;
$$;",pgbak.sql
"CREATE FUNCTION betweendays(fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	output integer;
BEGIN
	IF fecha IS NOT NULL THEN
		SELECT current_date - fecha INTO output;
	ELSE
		RAISE EXCEPTION 'La fecha es nula';
	END IF;
	RETURN output;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION betweendays(fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	output integer;
BEGIN
	IF fecha IS NOT NULL THEN
		SELECT current_date - fecha INTO output;
	ELSE
		RAISE EXCEPTION 'La fecha es nula';
	END IF;
	RETURN output;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION betweendays(fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	output integer;
BEGIN
	IF fecha IS NOT NULL THEN
		SELECT current_date - fecha INTO output;
	ELSE
		RAISE EXCEPTION 'La fecha es nula';
	END IF;
	RETURN output;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION betweendays(fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	output integer;
BEGIN
	IF fecha IS NOT NULL THEN
		SELECT current_date - fecha INTO output;
	ELSE
		RAISE EXCEPTION 'La fecha es nula';
	END IF;
	RETURN output;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION betweendays(fecha date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	output integer;
BEGIN
	IF fecha IS NOT NULL THEN
		SELECT current_date - fecha INTO output;
	ELSE
		RAISE EXCEPTION 'La fecha es nula';
	END IF;
	RETURN output;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION bigger_date(date1 timestamp without time zone DEFAULT NULL::timestamp without time zone, date2 timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
        BEGIN
		if (date1 = NULL) then
			return date2;
		end if;
		if (date1 > date2) then 
			RETURN date1;
                else 
			RETURN date2;
		END IF;
        END;
$$;",sql.base
"CREATE FUNCTION bit_to_ip(ip bit) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
        RETURN cast(ip >> 24 as integer) || '.' || cast((ip >> 16) & 255::bit(32) as integer) || '.' || cast((ip >> 8) & 255::bit(32) as integer) 
         || '.' || cast(ip & 255::bit(32) as integer) ;
END;
$$;",data_analysis.psql
"CREATE FUNCTION bol_search_id(i integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE found_id INTEGER;
BEGIN
 SELECT id INTO found_id FROM tbarticle where id=i;
 IF found_id ISNULL THEN
	RETURN false;
 ELSE RETURN true;
 END if;

END
$$;",05072015235607.sql
"CREATE FUNCTION boolean2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res xml;
  BEGIN
     res := xmlelement(name ""simpleType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                        xmlattributes('en' as ""xml:lang""), 
                        'Implementation of ' ||item.item || '. Defined as: ' || item.definition)),
          
             xmlelement(name restriction, 
                        xmlattributes('boolean' as base))
              );


     return res;
  END;
$$;",test.sql
"CREATE FUNCTION build_histogram2d(histogram2d, text, text, text) RETURNS histogram2d
    AS $_$
BEGIN
	EXECUTE 'SET local search_path = '||$2||',public';
	RETURN public.build_histogram2d($1,$3,$4);
END
$_$
    LANGUAGE plpgsql STABLE STRICT;",dbsetup.sql
"CREATE FUNCTION build_histogram2d(histogram2d, text, text, text) RETURNS histogram2d
    AS $_$
BEGIN
	EXECUTE 'SET local search_path = '||$2||',public';
	RETURN public.build_histogram2d($1,$3,$4);
END
$_$
    LANGUAGE plpgsql STABLE STRICT;",xenia_all.sql
"CREATE FUNCTION buscar_auto(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.chapa=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_auto(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.chapa=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_auto(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.chapa=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_auto(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.chapa=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_auto(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.chapa=$1;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_auto(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.id_auto=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_auto(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.id_auto=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_auto(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.id_auto=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_auto(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.id_auto=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_auto(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT autos.chapa,
modelos.nombre_modelo,
marcas.nombre_marca,
situaciones.tipo_situacion,
autos.color,
autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto
 WHERE autos.id_auto=$1;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_autos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT autos.chapa,modelos.nombre_modelo,marcas.nombre_marca,situaciones.tipo_situacion,autos.color,autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_autos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT autos.chapa,modelos.nombre_modelo,marcas.nombre_marca,situaciones.tipo_situacion,autos.color,autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_autos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT autos.chapa,modelos.nombre_modelo,marcas.nombre_marca,situaciones.tipo_situacion,autos.color,autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_autos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT autos.chapa,modelos.nombre_modelo,marcas.nombre_marca,situaciones.tipo_situacion,autos.color,autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_autos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT autos.chapa,modelos.nombre_modelo,marcas.nombre_marca,situaciones.tipo_situacion,autos.color,autos.kilometros,
autos.id_auto
 FROM autos JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo
JOIN marcas on marcas.id_marca=modelos.modelo_id_marca JOIN situaciones ON
situaciones.id_sit=autos.id_situacion_auto;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_carteras(""xnomcartera$"" character varying, OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
     declare xnomcartera varchar;

    begin
        numerror := 0;
        msjerror := ' ';

        xnomcartera := coalesce(upper(trim(xnomcartera$)),'') || '%';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        where 
            upper(des_cartera) like '%' || xnomcartera ||'%'
         order by
            id_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_carteras(""xnomcartera$"" character varying, OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
     declare xnomcartera varchar;

    begin
        numerror := 0;
        msjerror := ' ';

        xnomcartera := coalesce(upper(trim(xnomcartera$)),'') || '%';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        where 
            upper(des_cartera) like '%' || xnomcartera ||'%'
         order by
            id_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_carteras(OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open carteras for

        select
            cod_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak-04-11-2014.sql
"CREATE FUNCTION buscar_carteras(OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open carteras for

        select
            cod_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak-06-11-2014.sql
"CREATE FUNCTION buscar_carteras(OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open carteras for

        select
            cod_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak18.11.sql
"CREATE FUNCTION buscar_carteras_productos(OUT carteras refcursor, OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    begin
        numerror := '0';
        msjerror := ' ';

        open carteras for

        select
            cod_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras_productos] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
		msjerror := ' ';

        open productos for

        select
            cod_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras_productos] error al buscar productos(sql) ' ||sqlerrm;
                return;	
    end;
end;
$$;",bak-06-11-2014.sql
"CREATE FUNCTION buscar_categorias() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT categorias.tipo_categoria FROM categorias;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_categorias() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT categorias.tipo_categoria FROM categorias;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_categorias() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT categorias.tipo_categoria FROM categorias;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_categorias() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT categorias.tipo_categoria FROM categorias;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_categorias() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT categorias.tipo_categoria FROM categorias;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_chat_grupal(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	IDR INTEGER;
BEGIN	
	IDR := (ID) FROM ROM WHERE ROM.DESCRIPCION = $1;
	IF IDR!=0 THEN
		RETURN IDR;
	ELSE
		IDR := 0;
		RETURN IDR;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION buscar_choferes() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT choferes.numero_id,
choferes.nombre,
choferes.apellidos,
categorias.tipo_categoria,
choferes.direccion,
choferes.id_chofer
FROM choferes JOIN categorias ON choferes.categoria=categorias.id_cat;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_choferes() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT choferes.numero_id,
choferes.nombre,
choferes.apellidos,
categorias.tipo_categoria,
choferes.direccion,
choferes.id_chofer
FROM choferes JOIN categorias ON choferes.categoria=categorias.id_cat;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_choferes() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT choferes.numero_id,
choferes.nombre,
choferes.apellidos,
categorias.tipo_categoria,
choferes.direccion,
choferes.id_chofer
FROM choferes JOIN categorias ON choferes.categoria=categorias.id_cat;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_choferes() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT choferes.numero_id,
choferes.nombre,
choferes.apellidos,
categorias.tipo_categoria,
choferes.direccion,
choferes.id_chofer
FROM choferes JOIN categorias ON choferes.categoria=categorias.id_cat;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_choferes() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT choferes.numero_id,
choferes.nombre,
choferes.apellidos,
categorias.tipo_categoria,
choferes.direccion,
choferes.id_chofer
FROM choferes JOIN categorias ON choferes.categoria=categorias.id_cat;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_contrato(plate character varying, tur character varying, fi date) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
var refcursor;
BEGIN
open var for 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
choferes.numero_id,
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago join choferes on contratos.cont_id_chof=choferes.id_chofer
WHERE autos.chapa=plate AND turista.pasaporte=tur AND contratos.fecha_i=fi;
RETURN var;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_contrato(plate character varying, tur character varying, fi date) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
var refcursor;
BEGIN
open var for 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
choferes.numero_id,
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago join choferes on contratos.cont_id_chof=choferes.id_chofer
WHERE autos.chapa=plate AND turista.pasaporte=tur AND contratos.fecha_i=fi;
RETURN var;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_contrato(plate character varying, tur character varying, fi date) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
var refcursor;
BEGIN
open var for 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
choferes.numero_id,
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago join choferes on contratos.cont_id_chof=choferes.id_chofer
WHERE autos.chapa=plate AND turista.pasaporte=tur AND contratos.fecha_i=fi;
RETURN var;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_contrato(plate character varying, tur character varying, fi date) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
var refcursor;
BEGIN
open var for 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
choferes.numero_id,
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago join choferes on contratos.cont_id_chof=choferes.id_chofer
WHERE autos.chapa=plate AND turista.pasaporte=tur AND contratos.fecha_i=fi;
RETURN var;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_contrato(plate character varying, tur character varying, fi date) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
var refcursor;
BEGIN
open var for 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
choferes.numero_id,
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago join choferes on contratos.cont_id_chof=choferes.id_chofer
WHERE autos.chapa=plate AND turista.pasaporte=tur AND contratos.fecha_i=fi;
RETURN var;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_contratos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
identidad_del_chofer(contratos.cont_id_chof),
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_contratos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
identidad_del_chofer(contratos.cont_id_chof),
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_contratos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
identidad_del_chofer(contratos.cont_id_chof),
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_contratos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
identidad_del_chofer(contratos.cont_id_chof),
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_contratos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT autos.chapa,
turista.pasaporte,
contratos.fecha_i,
contratos.fecha_f,
identidad_del_chofer(contratos.cont_id_chof),
contratos.fecha_entrega,
forma_pago.tipo_pago,
contratos.importe_total
  FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN turista ON turista.id_tur=contratos.cont_id_tur JOIN forma_pago
ON contratos.cont_id_forma_pago=forma_pago.id_pago;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_documentos(""xnombre$"" character varying, ""xnum_folio$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_producto$"" numeric, ""xcod_area$"" character varying, OUT documentos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;
    declare xnum_folio varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_producto numeric;
    declare xcod_area varchar;

    begin
        numerror := 0;
        msjerror := ' ';


        /*filtros*/
        xnombre := '%' || coalesce(upper(trim(xnombre$)),'') || '%';
        xnum_folio :=  coalesce(upper(trim(xnum_folio$)),'')   ;
        xnum_adherente :=  coalesce(upper(trim(xnum_adherente$)),'')   ;
        xid_cartera := xid_cartera$;
        xid_producto := xid_producto$;
        
	
        if trim(xnum_folio$) = '' then
            xnum_folio := ' ';
            end if;
            
        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
            end if;
            

        if trim(xcod_area$) = '' then
            xcod_area := ' ';
        else
            xcod_area := upper(trim(xcod_area$));
        end if;

        open documentos for

        select
            id_documento,
            nombre,
            num_folio,
            num_adherente,
            descripcion,
            d.id_cartera as id_cartera,
            c.des_cartera as des_cartera,
            d.id_producto as id_producto,
            p.des_producto as des_producto,
            d.cod_area as cod_area,
            a.des_area as des_area,
            fec_creacion
        from 
            documento d 
        inner join area as a 
            on d.cod_area = a.cod_area
        inner join cartera as c 
            on d.id_cartera = c.id_cartera
        inner join producto as p 
            on d.id_producto = p.id_producto
where
            upper(d.nombre) like '%' || xnombre ||'%'         and
            (xnum_folio = ' ' or upper(d.num_folio) = xnum_folio) and
            (xnum_adherente = ' ' or upper(d.num_adherente) = xnum_adherente) and
            (xid_cartera = 0  or d.id_cartera = xid_cartera) and
            (xid_producto = 0 or d.id_producto = xid_producto) and
            (xcod_area =  ' ' or upper(d.cod_area) = xcod_area)
        order by
            id_documento;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_documentos] error al buscar documentos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_documentos(""xnombre$"" character varying, ""xnum_folio$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_producto$"" numeric, ""xcod_area$"" character varying, OUT documentos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;
    declare xnum_folio varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_producto numeric;
    declare xcod_area varchar;

    begin
        numerror := 0;
        msjerror := ' ';


        /*filtros*/
        xnombre := '%' || coalesce(upper(trim(xnombre$)),'') || '%';
        xnum_folio :=  coalesce(upper(trim(xnum_folio$)),'')   ;
        xnum_adherente :=  coalesce(upper(trim(xnum_adherente$)),'')   ;
        xid_cartera := xid_cartera$;
        xid_producto := xid_producto$;
        
	
        if trim(xnum_folio$) = '' then
            xnum_folio := ' ';
            end if;
            
        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
            end if;
            

        if trim(xcod_area$) = '' then
            xcod_area := ' ';
        else
            xcod_area := upper(trim(xcod_area$));
        end if;

        open documentos for

        select
            id_documento,
            nombre,
            num_folio,
            num_adherente,
            descripcion,
            d.id_cartera as id_cartera,
            c.des_cartera as des_cartera,
            d.id_producto as id_producto,
            p.des_producto as des_producto,
            d.cod_area as cod_area,
            a.des_area as des_area,
            fec_creacion
        from 
            documento d 
        inner join area as a 
            on d.cod_area = a.cod_area
        inner join cartera as c 
            on d.id_cartera = c.id_cartera
        inner join producto as p 
            on d.id_producto = p.id_producto
where
            upper(d.nombre) like '%' || xnombre ||'%'         and
            (xnum_folio = ' ' or upper(d.num_folio) = xnum_folio) and
            (xnum_adherente = ' ' or upper(d.num_adherente) = xnum_adherente) and
            (xid_cartera = 0  or d.id_cartera = xid_cartera) and
            (xid_producto = 0 or d.id_producto = xid_producto) and
            (xcod_area =  ' ' or upper(d.cod_area) = xcod_area)
        order by
            id_documento;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_documentos] error al buscar documentos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_empresas(""xnombre$"" character varying, ""xnum_adherente$"" character varying, OUT empresas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;
    declare xnum_adherente varchar;

    begin

        numerror := 0;
		msjerror := ' ';

        xnombre := coalesce(upper(trim(xnombre$)),'') || '%';

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;

     


        open empresas for

        select
            id_empresa,
            num_adherente,
            nombre
        from 
            empresa
        where
             upper(nombre) like '%' || xnombre ||'%' and
            (xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente) 
            
        order by
            nombre;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_empresas] error al buscar empresas(sql) ' ||sqlerrm;
                return;	
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_empresas(""xnombre$"" character varying, ""xnum_adherente$"" character varying, OUT empresas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;
    declare xnum_adherente varchar;

    begin

        numerror := 0;
		msjerror := ' ';

        xnombre := coalesce(upper(trim(xnombre$)),'') || '%';

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;

     


        open empresas for

        select
            id_empresa,
            num_adherente,
            nombre
        from 
            empresa
        where
             upper(nombre) like '%' || xnombre ||'%' and
            (xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente) 
            
        order by
            nombre;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_empresas] error al buscar empresas(sql) ' ||sqlerrm;
                return;	
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_estados(""xnomestado$"" character varying, OUT estados refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomestado varchar;
    begin
        xnomestado := coalesce(upper(trim(xnomestado$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open estados for

        select
            id_estado,
            des_estado
        from 
            estado
        where
             upper(des_estado) like '%' || xnomestado ||'%' 
        order by
            des_estado;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_estados] error al buscar estados(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_estados(""xnomestado$"" character varying, OUT estados refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomestado varchar;
    begin
        xnomestado := coalesce(upper(trim(xnomestado$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open estados for

        select
            id_estado,
            des_estado
        from 
            estado
        where
             upper(des_estado) like '%' || xnomestado ||'%' 
        order by
            des_estado;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_estados] error al buscar estados(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_formas_de_pago() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT forma_pago.tipo_pago FROM forma_pago;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_formas_de_pago() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT forma_pago.tipo_pago FROM forma_pago;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_formas_de_pago() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT forma_pago.tipo_pago FROM forma_pago;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_formas_de_pago() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT forma_pago.tipo_pago FROM forma_pago;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_formas_de_pago() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT forma_pago.tipo_pago FROM forma_pago;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_marcas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT marcas.nombre_marca FROM marcas;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_marcas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT marcas.nombre_marca FROM marcas;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_marcas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT marcas.nombre_marca FROM marcas;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_marcas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT marcas.nombre_marca FROM marcas;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_marcas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT marcas.nombre_marca FROM marcas;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_medios(""xnommedio$"" character varying, OUT medios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommedio varchar;
    begin
        xnommedio := coalesce(upper(trim(xnommedio$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open medios for

        select
            id_medio_respuesta,
            des_medio_respuesta
        from 
            medios_respuesta
        where
             upper(des_medio_respuesta) like '%' || xnommedio ||'%'                  
        order by
            des_medio_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios] error al buscar medios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_medios(""xnommedio$"" character varying, OUT medios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommedio varchar;
    begin
        xnommedio := coalesce(upper(trim(xnommedio$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open medios for

        select
            id_medio_respuesta,
            des_medio_respuesta
        from 
            medios_respuesta
        where
             upper(des_medio_respuesta) like '%' || xnommedio ||'%'                  
        order by
            des_medio_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios] error al buscar medios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_medios_respuestas(""xnommedios_respuesta$"" character varying, OUT medios_respuestas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommedios_respuesta varchar;
    begin
        xnommedios_respuesta := coalesce(upper(trim(xnommedios_respuesta$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open medios_respuestas for

        select
            cod_medios_respuesta,
            des_medios_respuesta
        from 
            medios_respuesta
        where
             upper(des_medios_respuesta) like '%' || xnommedios_respuesta ||'%' 
        order by
            des_medios_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios_respuestas] error al buscar medios_respuestas(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_medios_respuestas(""xnommedios_respuesta$"" character varying, OUT medios_respuestas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommedios_respuesta varchar;
    begin
        xnommedios_respuesta := coalesce(upper(trim(xnommedios_respuesta$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open medios_respuestas for

        select
            cod_medios_respuesta,
            des_medios_respuesta
        from 
            medios_respuesta
        where
             upper(des_medios_respuesta) like '%' || xnommedios_respuesta ||'%' 
        order by
            des_medios_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios_respuestas] error al buscar medios_respuestas(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_modelo(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,marcas.nombre_marca,
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar
WHERE modelos.nombre_modelo=$1 and marcas.nombre_marca=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_modelo(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,marcas.nombre_marca,
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar
WHERE modelos.nombre_modelo=$1 and marcas.nombre_marca=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_modelo(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,marcas.nombre_marca,
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar
WHERE modelos.nombre_modelo=$1 and marcas.nombre_marca=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_modelo(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,marcas.nombre_marca,
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar
WHERE modelos.nombre_modelo=$1 and marcas.nombre_marca=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_modelo(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,marcas.nombre_marca,
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar
WHERE modelos.nombre_modelo=$1 and marcas.nombre_marca=$2;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_modelos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,
marcas.nombre_marca,(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca 
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_modelos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,
marcas.nombre_marca,(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca 
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_modelos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,
marcas.nombre_marca,(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca 
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_modelos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,
marcas.nombre_marca,(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca 
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_modelos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur refcursor;
BEGIN
OPEN cur FOR
SELECT modelos.nombre_modelo,
marcas.nombre_marca,(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
 FROM modelos JOIN marcas ON modelos.modelo_id_marca=marcas.id_marca 
JOIN tarifa on tarifa.id_tarifa=modelos.modelo_id_tar;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_motivos(""xnommotivo$"" character varying, OUT motivos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommotivo varchar;
    begin
        xnommotivo := coalesce(upper(trim(xnommotivo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open motivos for

        select
            id_motivo,
            des_motivo
        from 
            motivo
        where
             upper(des_motivo) like '%' || xnommotivo ||'%' 
        order by
            des_motivo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_motivos] error al buscar motivos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_motivos(""xnommotivo$"" character varying, OUT motivos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnommotivo varchar;
    begin
        xnommotivo := coalesce(upper(trim(xnommotivo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open motivos for

        select
            id_motivo,
            des_motivo
        from 
            motivo
        where
             upper(des_motivo) like '%' || xnommotivo ||'%' 
        order by
            des_motivo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_motivos] error al buscar motivos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_pais(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

cur refcursor;
BEGIN
OPEN cur for select pais.nombre_pais FROM pais WHERE nombre_pais=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_pais(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

cur refcursor;
BEGIN
OPEN cur for select pais.nombre_pais FROM pais WHERE nombre_pais=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_pais(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

cur refcursor;
BEGIN
OPEN cur for select pais.nombre_pais FROM pais WHERE nombre_pais=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_pais(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

cur refcursor;
BEGIN
OPEN cur for select pais.nombre_pais FROM pais WHERE nombre_pais=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_pais(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

cur refcursor;
BEGIN
OPEN cur for select pais.nombre_pais FROM pais WHERE nombre_pais=$1;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_paises() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT pais.nombre_pais FROM pais;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_paises() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT pais.nombre_pais FROM pais;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_paises() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT pais.nombre_pais FROM pais;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_paises() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT pais.nombre_pais FROM pais;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_paises() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT pais.nombre_pais FROM pais;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_par_reclamos(OUT tipos refcursor, OUT motivos refcursor, OUT prioridades refcursor, OUT carteras refcursor, OUT estados refcursor, OUT medios_respuestas refcursor, OUT regiones refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    
    begin
        numerror := 0;
        msjerror := ' ';

        open tipos for

        select
            id_tipo,
            des_tipo
        from 
            tipo
        order by
            des_tipo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open motivos for

        select
            id_motivo,
            des_motivo
        from 
            motivo
        order by
            des_motivo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_motivos] error al buscar motivos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open prioridades for

        select
            id_prioridad,
            des_prioridad
        from 
            prioridad
        order by
            des_prioridad;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_prioridades] error al buscar prioridades(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open estados for

        select
            id_estado,
            des_estado
        from 
            estado
        order by
            des_estado;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_estados] error al buscar estados(sql) ' ||sqlerrm;
                return; 
    end;


    begin
        numerror := '0';
        msjerror := ' ';

        open medios_respuestas for

        select
            id_medio_respuesta,
            des_medio_respuesta
        from 
            medios_respuesta
        order by
            des_medio_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios_respuestas] error al buscar medios_respuestas(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open regiones for

        select
            cod_region,
            des_region
               
         from 
            region
        order by
            cod_region;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_comunas] error al buscar comunas(sql) ' ||sqlerrm;
                return; 
    end;
end;
$$;",3-2-15.sql
"CREATE FUNCTION buscar_par_reclamos(OUT tipos refcursor, OUT motivos refcursor, OUT prioridades refcursor, OUT carteras refcursor, OUT estados refcursor, OUT medios_respuestas refcursor, OUT regiones refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    
    begin
        numerror := 0;
        msjerror := ' ';

        open tipos for

        select
            id_tipo,
            des_tipo
        from 
            tipo
        order by
            des_tipo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open motivos for

        select
            id_motivo,
            des_motivo
        from 
            motivo
        order by
            des_motivo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_motivos] error al buscar motivos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open prioridades for

        select
            id_prioridad,
            des_prioridad
        from 
            prioridad
        order by
            des_prioridad;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_prioridades] error al buscar prioridades(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_carteras] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open estados for

        select
            id_estado,
            des_estado
        from 
            estado
        order by
            des_estado;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_estados] error al buscar estados(sql) ' ||sqlerrm;
                return; 
    end;


    begin
        numerror := '0';
        msjerror := ' ';

        open medios_respuestas for

        select
            id_medio_respuesta,
            des_medio_respuesta
        from 
            medios_respuesta
        order by
            des_medio_respuesta;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_medios_respuestas] error al buscar medios_respuestas(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open regiones for

        select
            cod_region,
            des_region
               
         from 
            region
        order by
            cod_region;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_comunas] error al buscar comunas(sql) ' ||sqlerrm;
                return; 
    end;
end;
$$;",bkup.sql
"CREATE FUNCTION buscar_parametros(OUT carteras refcursor, OUT productos refcursor, OUT areas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    begin
        numerror := '0';
        msjerror := ' ';

        open carteras for

        select
            cod_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open productos for

        select
            cod_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar productos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open areas for

        select
            cod_area,
            des_area
        from 
            area
        order by
            des_area;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar areas(sql) ' ||sqlerrm;
                return; 
    end;
end;
$$;",bak18.11.sql
"CREATE FUNCTION buscar_parametros(OUT carteras refcursor, OUT productos refcursor, OUT areas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    begin
        numerror := 0;
        msjerror := ' ';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open productos for

        select
            id_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar productos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open areas for

        select
            cod_area,
            des_area
        from 
            area
        order by
            des_area;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar areas(sql) ' ||sqlerrm;
                return; 
    end;
end;
$$;",3-2-15.sql
"CREATE FUNCTION buscar_parametros(OUT carteras refcursor, OUT productos refcursor, OUT areas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
    begin
        numerror := 0;
        msjerror := ' ';

        open carteras for

        select
            id_cartera,
            des_cartera
        from 
            cartera
        order by
            des_cartera;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar carteras(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open productos for

        select
            id_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar productos(sql) ' ||sqlerrm;
                return; 
    end;

    begin
        numerror := '0';
        msjerror := ' ';

        open areas for

        select
            cod_area,
            des_area
        from 
            area
        order by
            des_area;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[buscar_parametros] error al buscar areas(sql) ' ||sqlerrm;
                return; 
    end;
end;
$$;",bkup.sql
"CREATE FUNCTION buscar_perfiles(""xnombre$"" character varying, OUT perfiles refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;

    begin

        numerror := 0;
		msjerror := ' ';

        xnombre := coalesce(upper(trim(xnombre$)),'') || '%';   

        open perfiles for

        select
            id_perfil,
            des_perfil
        from 
            perfil
        where
             upper(des_perfil) like '%' || xnombre ||'%'
            
        order by
            id_perfil;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_perfiles] error al buscar perfiles(sql) ' ||sqlerrm;
                return;	
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_perfiles(""xnombre$"" character varying, OUT perfiles refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnombre varchar;

    begin

        numerror := 0;
		msjerror := ' ';

        xnombre := coalesce(upper(trim(xnombre$)),'') || '%';   

        open perfiles for

        select
            id_perfil,
            des_perfil
        from 
            perfil
        where
             upper(des_perfil) like '%' || xnombre ||'%'
            
        order by
            id_perfil;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_perfiles] error al buscar perfiles(sql) ' ||sqlerrm;
                return;	
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_perfiles_usuario(in_idusuario numeric, OUT out_perfiles refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
    declare xnombre varchar;
    begin
        numerror := 0;
		msjerror := ' ';
		
        open out_perfiles for
        select
            perfil.des_perfil
        from 
            perfil_usuario, perfil
        where
			perfil_usuario.id_perfil = perfil.id_perfil
			and perfil_usuario.idusuario = in_idusuario;
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_perfiles_usuario] error al buscar perfiles(sql) ' ||sqlerrm;
                return;	
    end;
$$;",3-2-15.sql
"CREATE FUNCTION buscar_perfiles_usuario(in_idusuario numeric, OUT out_perfiles refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
    declare xnombre varchar;
    begin
        numerror := 0;
		msjerror := ' ';
		
        open out_perfiles for
        select
            perfil.des_perfil
        from 
            perfil_usuario, perfil
        where
			perfil_usuario.id_perfil = perfil.id_perfil
			and perfil_usuario.idusuario = in_idusuario;
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_perfiles_usuario] error al buscar perfiles(sql) ' ||sqlerrm;
                return;	
    end;
$$;",bkup.sql
"CREATE FUNCTION buscar_prioridades(""xnomprioridad$"" character varying, OUT prioridades refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomprioridad varchar;
    begin
        xnomprioridad := coalesce(upper(trim(xnomprioridad$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open prioridades for

        select
            id_prioridad,
            des_prioridad
        from 
            prioridad
        where
             upper(des_prioridad) like '%' || xnomprioridad ||'%' 
        order by
            des_prioridad;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_prioridads] error al buscar prioridads(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_prioridades(""xnomprioridad$"" character varying, OUT prioridades refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomprioridad varchar;
    begin
        xnomprioridad := coalesce(upper(trim(xnomprioridad$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open prioridades for

        select
            id_prioridad,
            des_prioridad
        from 
            prioridad
        where
             upper(des_prioridad) like '%' || xnomprioridad ||'%' 
        order by
            des_prioridad;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_prioridads] error al buscar prioridads(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_productos(""xnomproducto$"" character varying, OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomproducto varchar;
    begin
        xnomproducto := coalesce(upper(trim(xnomproducto$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open productos for

        select
            id_producto,
            des_producto
        from 
            producto
        where
             upper(des_producto) like '%' || xnomproducto ||'%' 
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_productos] error al buscar productos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_productos(""xnomproducto$"" character varying, OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomproducto varchar;
    begin
        xnomproducto := coalesce(upper(trim(xnomproducto$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open productos for

        select
            id_producto,
            des_producto
        from 
            producto
        where
             upper(des_producto) like '%' || xnomproducto ||'%' 
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_productos] error al buscar productos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_productos(OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open productos for

        select
            cod_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_productos] error al buscar productos(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak-04-11-2014.sql
"CREATE FUNCTION buscar_productos(OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open productos for

        select
            cod_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_productos] error al buscar productos(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak-06-11-2014.sql
"CREATE FUNCTION buscar_productos(OUT productos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := '0';
		msjerror := ' ';

        open productos for

        select
            cod_producto,
            des_producto
        from 
            producto
        order by
            des_producto;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_productos] error al buscar productos(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bak18.11.sql
"CREATE FUNCTION buscar_reclamos(""xnombre_solicitante$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_tipo$"" numeric, ""xid_estado$"" numeric, ""xid_prioridad$"" numeric, ""xid_reclamo$"" numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xid_reclamo numeric;
    declare xnombre_solicitante varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_tipo numeric;
    declare xid_estado numeric;
    declare xid_prioridad numeric;

    begin
        numerror := 0;
        msjerror := ' ';

        
        xnombre_solicitante := coalesce(upper(trim(xnombre_solicitante$)),'') || '%';
    
       
        xid_reclamo=xid_reclamo$;
    

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;

          
        xid_cartera=xid_cartera$;
        xid_tipo=xid_tipo$;
        xid_estado=xid_estado$;
        xid_prioridad=xid_prioridad$;
       

        open reclamos for

        select
            id_reclamo,
            num_adherente,
            nombre_solicitante,
            email_solicitante,
            fono_solicitante,
            region_solicitante,
            r.id_tipo as id_tipo,
            t.des_tipo as des_tipo,
            r.id_motivo as id_motivo,
            m.des_motivo as des_motivo,
	    r.id_prioridad as id_prioridad,
            p.des_prioridad as des_prioridad,
            r.id_cartera as id_cartera,
            c.des_cartera as des_cartera,
            fec_ingreso,
            glosa,
            adjunto,
            observaciones,
            r.id_estado as id_estado,
            e.des_estado as des_estado,
            responsable_ingreso,
            responsable_actual,
            dias_bandeja,
            dias_sistema,
            r.id_medio_respuesta as id_medio_respuesta,
            me.des_medio_respuesta as des_medio_respuesta,
            fec_respuesta
        from 
            reclamo r
         inner join tipo as t
                on r.id_tipo = t.id_tipo
           inner join motivo as m
                on r.id_motivo = m.id_motivo
            inner join prioridad as p
                on r.id_prioridad = p.id_prioridad
            inner join cartera as c
                on r.id_cartera = c.id_cartera
            inner join estado as e
                on r.id_estado = e.id_estado
            inner join medios_respuesta me
                on r.id_medio_respuesta = me.id_medio_respuesta   
      where
          upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%'            and
		(xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente)and
         (xid_cartera =   0 or r.id_cartera = xid_cartera) and
	(xid_tipo =      0 or r.id_tipo = xid_tipo) and
           (xid_estado =    0 or r.id_estado = xid_estado) and
            (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
          (xid_reclamo = 0 or id_reclamo = xid_reclamo)
        
          order by
            id_reclamo;           
             
    
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_reclamos] error al buscar reclamos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_reclamos(""xnombre_solicitante$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_tipo$"" numeric, ""xid_estado$"" numeric, ""xid_prioridad$"" numeric, ""xid_reclamo$"" numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xid_reclamo numeric;
    declare xnombre_solicitante varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_tipo numeric;
    declare xid_estado numeric;
    declare xid_prioridad numeric;

    begin
        numerror := 0;
        msjerror := ' ';

        
        xnombre_solicitante := coalesce(upper(trim(xnombre_solicitante$)),'') || '%';
    
       
        xid_reclamo=xid_reclamo$;
    

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;

          
        xid_cartera=xid_cartera$;
        xid_tipo=xid_tipo$;
        xid_estado=xid_estado$;
        xid_prioridad=xid_prioridad$;
       

        open reclamos for

        select
            id_reclamo,
            num_adherente,
            nombre_solicitante,
            email_solicitante,
            fono_solicitante,
            region_solicitante,
            r.id_tipo as id_tipo,
            t.des_tipo as des_tipo,
            r.id_motivo as id_motivo,
            m.des_motivo as des_motivo,
	    r.id_prioridad as id_prioridad,
            p.des_prioridad as des_prioridad,
            r.id_cartera as id_cartera,
            c.des_cartera as des_cartera,
            fec_ingreso,
            glosa,
            adjunto,
            observaciones,
            r.id_estado as id_estado,
            e.des_estado as des_estado,
            responsable_ingreso,
            responsable_actual,
            dias_bandeja,
            dias_sistema,
            r.id_medio_respuesta as id_medio_respuesta,
            me.des_medio_respuesta as des_medio_respuesta,
            fec_respuesta
        from 
            reclamo r
         inner join tipo as t
                on r.id_tipo = t.id_tipo
           inner join motivo as m
                on r.id_motivo = m.id_motivo
            inner join prioridad as p
                on r.id_prioridad = p.id_prioridad
            inner join cartera as c
                on r.id_cartera = c.id_cartera
            inner join estado as e
                on r.id_estado = e.id_estado
            inner join medios_respuesta me
                on r.id_medio_respuesta = me.id_medio_respuesta   
      where
          upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%'            and
		(xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente)and
         (xid_cartera =   0 or r.id_cartera = xid_cartera) and
	(xid_tipo =      0 or r.id_tipo = xid_tipo) and
           (xid_estado =    0 or r.id_estado = xid_estado) and
            (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
          (xid_reclamo = 0 or id_reclamo = xid_reclamo)
        
          order by
            id_reclamo;           
             
    
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_reclamos] error al buscar reclamos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_reclamos_paginacion(""xnombre_solicitante$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_tipo$"" numeric, ""xid_estado$"" numeric, ""xid_prioridad$"" numeric, ""xid_reclamo$"" numeric, ""ordenarpor$"" character varying, ""orden$"" character varying, ""pagactual$"" numeric, ""canregxpag$"" numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying, OUT ""totalregistros$"" numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xid_reclamo numeric;
    declare xnombre_solicitante varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_tipo numeric;
    declare xid_estado numeric;
    declare xid_prioridad numeric;
    declare  xncantregdesde$ numeric;
    declare  xncantreghasta$ numeric;
    declare  xordenarpor$  varchar;
    declare  xorden$ varchar;    

    begin
        numerror := 0;
        msjerror := ' ';

        
        xnombre_solicitante := coalesce(upper(trim(xnombre_solicitante$)),'') || '%';
        xordenarpor$ := upper(trim(ordenarpor$));
        xorden$      := upper(trim(orden$));
        xid_reclamo=xid_reclamo$;
        xid_cartera=xid_cartera$;
        xid_tipo=xid_tipo$;
        xid_estado=xid_estado$;
        xid_prioridad=xid_prioridad$;

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;


    
       begin        
            select 
                count(*)
            into
                totalregistros$
            from            
            (
                select
                    id_reclamo,
                    num_adherente,
                    nombre_solicitante,
                    email_solicitante,
                    fono_solicitante,
                    region_solicitante,
                    r.id_tipo as id_tipo,
                    t.des_tipo as des_tipo,
                    r.id_motivo as id_motivo,
                    m.des_motivo as des_motivo,
                    r.id_prioridad as id_prioridad,
                    p.des_prioridad as des_prioridad,
                    r.id_cartera as id_cartera,
                    c.des_cartera as des_cartera,
                    fec_ingreso,
                    glosa,
                    adjunto,
                    observaciones,
                    r.id_estado as id_estado,
                    e.des_estado as des_estado,
                    responsable_ingreso,
                    responsable_actual,
                    dias_bandeja,
                    dias_sistema,
                    r.id_medio_respuesta as id_medio_respuesta,
                    me.des_medio_respuesta as des_medio_respuesta,
                    fec_respuesta
                from 
                    reclamo r
                    inner join tipo as t
                        on r.id_tipo = t.id_tipo
                    inner join motivo as m
                        on r.id_motivo = m.id_motivo
                    inner join prioridad as p
                        on r.id_prioridad = p.id_prioridad
                    inner join cartera as c
                        on r.id_cartera = c.id_cartera
                    inner join estado as e
                        on r.id_estado = e.id_estado
                    inner join medios_respuesta me
                        on r.id_medio_respuesta = me.id_medio_respuesta 
                where
                  upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%' and
                   (xnum_adherente =  ' ' or num_adherente = xnum_adherente) and
                    (xid_cartera = 0 or c.id_cartera = xid_cartera) and
                    (xid_tipo = 0 or r.id_tipo = xid_tipo) and
                    (xid_estado =  0 or r.id_estado = xid_estado) and
                    (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
                  (xid_reclamo = 0 or id_reclamo = xid_reclamo)
                
            )as subrutina;          
                 
        
            exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_reclamos] error al buscar reclamos(sql) ' ||sqlerrm;
                return; 
        end;


         if canregxpag$ = 0 then
            --todos
            xncantreghasta$ := totalregistros$;
            xncantregdesde$ := 0;
        else
            --parcial (paginacion)
            xncantreghasta$ := pagactual$ * canregxpag$;
            xncantregdesde$ := xncantreghasta$ - canregxpag$;
        end if;


 begin    
            open reclamos for

            select 
                *
            from 
            (   
                select 
                    row_number()over ()  as fila,       
                    consulta1
                from
                (
                    select
                        id_reclamo,
                        num_adherente,
                        nombre_solicitante,
                        email_solicitante,
                        fono_solicitante,
                        region_solicitante,
                        r.id_tipo as id_tipo,
                        t.des_tipo as des_tipo,
                        r.id_motivo as id_motivo,
                        m.des_motivo as des_motivo,
                        r.id_prioridad as id_prioridad,
                        p.des_prioridad as des_prioridad,
                        r.id_cartera as id_cartera,
                        c.des_cartera as des_cartera,
                        fec_ingreso,
                        glosa,
                        adjunto,
                        observaciones,
                        r.id_estado as id_estado,
                        e.des_estado as des_estado,
                        responsable_ingreso,
                        responsable_actual,
                        dias_bandeja,
                        dias_sistema,
                        r.id_medio_respuesta as id_medio_respuesta,
                        me.des_medio_respuesta as des_medio_respuesta,
                        fec_respuesta
                    from 
                       reclamo r
                        inner join tipo as t
                            on r.id_tipo = t.id_tipo
                        inner join motivo as m
                            on r.id_motivo = m.id_motivo
                        inner join prioridad as p
                            on r.id_prioridad = p.id_prioridad
                        inner join cartera as c
                            on r.id_cartera = c.id_cartera
                        inner join estado as e
                            on r.id_estado = e.id_estado
                        inner join medios_respuesta me
                            on r.id_medio_respuesta = me.id_medio_respuesta 
                    where
                        upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%' and
                        (xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente) and
                        (xid_cartera =   0 or r.id_cartera = xid_cartera) and
                        (xid_tipo =      0 or r.id_tipo = xid_tipo) and
                        (xid_estado =    0 or r.id_estado = xid_estado) and
                        (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
                        (xid_reclamo = 0 or id_reclamo = xid_reclamo)
                    order by
                        nombre_solicitante
                )as consulta1  
            )as consulta2 where fila > xncantregdesde$ and fila <= xncantreghasta$;           

            exception
            when others then           
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
        end;
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_reclamos_paginacion(""xnombre_solicitante$"" character varying, ""xnum_adherente$"" character varying, ""xid_cartera$"" numeric, ""xid_tipo$"" numeric, ""xid_estado$"" numeric, ""xid_prioridad$"" numeric, ""xid_reclamo$"" numeric, ""ordenarpor$"" character varying, ""orden$"" character varying, ""pagactual$"" numeric, ""canregxpag$"" numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying, OUT ""totalregistros$"" numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xid_reclamo numeric;
    declare xnombre_solicitante varchar;
    declare xnum_adherente varchar;
    declare xid_cartera numeric;
    declare xid_tipo numeric;
    declare xid_estado numeric;
    declare xid_prioridad numeric;
    declare  xncantregdesde$ numeric;
    declare  xncantreghasta$ numeric;
    declare  xordenarpor$  varchar;
    declare  xorden$ varchar;    

    begin
        numerror := 0;
        msjerror := ' ';

        
        xnombre_solicitante := coalesce(upper(trim(xnombre_solicitante$)),'') || '%';
        xordenarpor$ := upper(trim(ordenarpor$));
        xorden$      := upper(trim(orden$));
        xid_reclamo=xid_reclamo$;
        xid_cartera=xid_cartera$;
        xid_tipo=xid_tipo$;
        xid_estado=xid_estado$;
        xid_prioridad=xid_prioridad$;

        if trim(xnum_adherente$) = '' then
            xnum_adherente := ' ';
        else
            xnum_adherente := upper(trim(xnum_adherente$));
        end if;


    
       begin        
            select 
                count(*)
            into
                totalregistros$
            from            
            (
                select
                    id_reclamo,
                    num_adherente,
                    nombre_solicitante,
                    email_solicitante,
                    fono_solicitante,
                    region_solicitante,
                    r.id_tipo as id_tipo,
                    t.des_tipo as des_tipo,
                    r.id_motivo as id_motivo,
                    m.des_motivo as des_motivo,
                    r.id_prioridad as id_prioridad,
                    p.des_prioridad as des_prioridad,
                    r.id_cartera as id_cartera,
                    c.des_cartera as des_cartera,
                    fec_ingreso,
                    glosa,
                    adjunto,
                    observaciones,
                    r.id_estado as id_estado,
                    e.des_estado as des_estado,
                    responsable_ingreso,
                    responsable_actual,
                    dias_bandeja,
                    dias_sistema,
                    r.id_medio_respuesta as id_medio_respuesta,
                    me.des_medio_respuesta as des_medio_respuesta,
                    fec_respuesta
                from 
                    reclamo r
                    inner join tipo as t
                        on r.id_tipo = t.id_tipo
                    inner join motivo as m
                        on r.id_motivo = m.id_motivo
                    inner join prioridad as p
                        on r.id_prioridad = p.id_prioridad
                    inner join cartera as c
                        on r.id_cartera = c.id_cartera
                    inner join estado as e
                        on r.id_estado = e.id_estado
                    inner join medios_respuesta me
                        on r.id_medio_respuesta = me.id_medio_respuesta 
                where
                  upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%' and
                   (xnum_adherente =  ' ' or num_adherente = xnum_adherente) and
                    (xid_cartera = 0 or c.id_cartera = xid_cartera) and
                    (xid_tipo = 0 or r.id_tipo = xid_tipo) and
                    (xid_estado =  0 or r.id_estado = xid_estado) and
                    (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
                  (xid_reclamo = 0 or id_reclamo = xid_reclamo)
                
            )as subrutina;          
                 
        
            exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_reclamos] error al buscar reclamos(sql) ' ||sqlerrm;
                return; 
        end;


         if canregxpag$ = 0 then
            --todos
            xncantreghasta$ := totalregistros$;
            xncantregdesde$ := 0;
        else
            --parcial (paginacion)
            xncantreghasta$ := pagactual$ * canregxpag$;
            xncantregdesde$ := xncantreghasta$ - canregxpag$;
        end if;


 begin    
            open reclamos for

            select 
                *
            from 
            (   
                select 
                    row_number()over ()  as fila,       
                    consulta1
                from
                (
                    select
                        id_reclamo,
                        num_adherente,
                        nombre_solicitante,
                        email_solicitante,
                        fono_solicitante,
                        region_solicitante,
                        r.id_tipo as id_tipo,
                        t.des_tipo as des_tipo,
                        r.id_motivo as id_motivo,
                        m.des_motivo as des_motivo,
                        r.id_prioridad as id_prioridad,
                        p.des_prioridad as des_prioridad,
                        r.id_cartera as id_cartera,
                        c.des_cartera as des_cartera,
                        fec_ingreso,
                        glosa,
                        adjunto,
                        observaciones,
                        r.id_estado as id_estado,
                        e.des_estado as des_estado,
                        responsable_ingreso,
                        responsable_actual,
                        dias_bandeja,
                        dias_sistema,
                        r.id_medio_respuesta as id_medio_respuesta,
                        me.des_medio_respuesta as des_medio_respuesta,
                        fec_respuesta
                    from 
                       reclamo r
                        inner join tipo as t
                            on r.id_tipo = t.id_tipo
                        inner join motivo as m
                            on r.id_motivo = m.id_motivo
                        inner join prioridad as p
                            on r.id_prioridad = p.id_prioridad
                        inner join cartera as c
                            on r.id_cartera = c.id_cartera
                        inner join estado as e
                            on r.id_estado = e.id_estado
                        inner join medios_respuesta me
                            on r.id_medio_respuesta = me.id_medio_respuesta 
                    where
                        upper(nombre_solicitante) like '%' || xnombre_solicitante ||'%' and
                        (xnum_adherente =  ' ' or upper(trim(num_adherente)) = xnum_adherente) and
                        (xid_cartera =   0 or r.id_cartera = xid_cartera) and
                        (xid_tipo =      0 or r.id_tipo = xid_tipo) and
                        (xid_estado =    0 or r.id_estado = xid_estado) and
                        (xid_prioridad = 0 or r.id_prioridad = xid_prioridad) and
                        (xid_reclamo = 0 or id_reclamo = xid_reclamo)
                    order by
                        nombre_solicitante
                )as consulta1  
            )as consulta2 where fila > xncantregdesde$ and fila <= xncantreghasta$;           

            exception
            when others then           
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
        end;
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_regiones(OUT regiones refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := 0;
	msjerror := ' ';

        open regiones for

        select
	    reg_snombre,
            reg_nidregion
           
         from 
            region
        order by
            reg_snombre;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_comunas] error al buscar comunas(sql) ' ||sqlerrm;
                return;	
    end;

$$;",3-2-15.sql
"CREATE FUNCTION buscar_regiones(OUT regiones refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    begin
        numerror := 0;
	msjerror := ' ';

        open regiones for

        select
	    reg_snombre,
            reg_nidregion
           
         from 
            region
        order by
            reg_snombre;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_comunas] error al buscar comunas(sql) ' ||sqlerrm;
                return;	
    end;

$$;",bkup.sql
"CREATE FUNCTION buscar_rol_usuario(tipo character varying, usern character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
id_r int;
id_u int;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol WHERE rol.tipo_rol=tipo;
SELECT usuarios.id_user INTO id_u FROM usuarios WHERE userN=usuarios.usuario;
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user
WHERE usuarios.id_user=id_u AND rol.id_rol=id_r;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_rol_usuario(tipo character varying, usern character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
id_r int;
id_u int;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol WHERE rol.tipo_rol=tipo;
SELECT usuarios.id_user INTO id_u FROM usuarios WHERE userN=usuarios.usuario;
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user
WHERE usuarios.id_user=id_u AND rol.id_rol=id_r;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_rol_usuario(tipo character varying, usern character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
id_r int;
id_u int;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol WHERE rol.tipo_rol=tipo;
SELECT usuarios.id_user INTO id_u FROM usuarios WHERE userN=usuarios.usuario;
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user
WHERE usuarios.id_user=id_u AND rol.id_rol=id_r;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_rol_usuario(tipo character varying, usern character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
id_r int;
id_u int;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol WHERE rol.tipo_rol=tipo;
SELECT usuarios.id_user INTO id_u FROM usuarios WHERE userN=usuarios.usuario;
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user
WHERE usuarios.id_user=id_u AND rol.id_rol=id_r;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_rol_usuario(tipo character varying, usern character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
id_r int;
id_u int;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol WHERE rol.tipo_rol=tipo;
SELECT usuarios.id_user INTO id_u FROM usuarios WHERE userN=usuarios.usuario;
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user
WHERE usuarios.id_user=id_u AND rol.id_rol=id_r;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_roles() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT rol.tipo_rol FROM rol;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_roles() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT rol.tipo_rol FROM rol;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_roles() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT rol.tipo_rol FROM rol;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_roles() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT rol.tipo_rol FROM rol;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_roles() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT rol.tipo_rol FROM rol;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_roles_asosiados(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur for
SELECT rol.id_rol,rol.tipo_rol FROM rol JOIN rol_usuario ON rol.id_rol=rol_usuario.rol_id_rol
JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE usuarios.usuario=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_roles_asosiados(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur for
SELECT rol.id_rol,rol.tipo_rol FROM rol JOIN rol_usuario ON rol.id_rol=rol_usuario.rol_id_rol
JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE usuarios.usuario=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_roles_asosiados(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur for
SELECT rol.id_rol,rol.tipo_rol FROM rol JOIN rol_usuario ON rol.id_rol=rol_usuario.rol_id_rol
JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE usuarios.usuario=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_roles_asosiados(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur for
SELECT rol.id_rol,rol.tipo_rol FROM rol JOIN rol_usuario ON rol.id_rol=rol_usuario.rol_id_rol
JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE usuarios.usuario=$1;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_roles_asosiados(character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur for
SELECT rol.id_rol,rol.tipo_rol FROM rol JOIN rol_usuario ON rol.id_rol=rol_usuario.rol_id_rol
JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE usuarios.usuario=$1;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_roles_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_roles_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_roles_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_roles_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_roles_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT rol.tipo_rol,
usuarios.usuario
FROM rol_usuario JOIN rol ON rol_usuario.rol_id_rol=rol.id_rol
JOIN usuarios on rol_usuario.usuario_id_user=usuarios.id_user;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_rom(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	IDR INTEGER;
BEGIN	
	IDR := (ID) FROM ROM WHERE ROM.DESCRIPCION = $1;
	IF IDR!=0 THEN
		RETURN IDR;
	ELSE
		IDR := 0;
		RETURN IDR;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION buscar_situaciones() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT situaciones.tipo_situacion FROM situaciones;

RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_situaciones() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT situaciones.tipo_situacion FROM situaciones;

RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_situaciones() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT situaciones.tipo_situacion FROM situaciones;

RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_situaciones() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT situaciones.tipo_situacion FROM situaciones;

RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_situaciones() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT situaciones.tipo_situacion FROM situaciones;

RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_tarifa(tar_n character varying, tar_e character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa
WHERE tarifa.tarifa_normal=(tar_n)::money AND tarifa.tarifa_especial=(tar_e)::money;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_tarifa(tar_n character varying, tar_e character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa
WHERE tarifa.tarifa_normal=(tar_n)::money AND tarifa.tarifa_especial=(tar_e)::money;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_tarifa(tar_n character varying, tar_e character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa
WHERE tarifa.tarifa_normal=(tar_n)::money AND tarifa.tarifa_especial=(tar_e)::money;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_tarifa(tar_n character varying, tar_e character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa
WHERE tarifa.tarifa_normal=(tar_n)::money AND tarifa.tarifa_especial=(tar_e)::money;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_tarifa(tar_n character varying, tar_e character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa
WHERE tarifa.tarifa_normal=(tar_n)::money AND tarifa.tarifa_especial=(tar_e)::money;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_tarifas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa ;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_tarifas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa ;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_tarifas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa ;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_tarifas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa ;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_tarifas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
open cur for 
SELECT 
(tarifa.tarifa_normal)::VARCHAR,(tarifa.tarifa_especial)::VARCHAR
FROM tarifa ;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_tipos(""xnomtipo$"" character varying, OUT tipos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomtipo varchar;
    begin
        xnomtipo := coalesce(upper(trim(xnomtipo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open tipos for

        select
            id_tipo,
            des_tipo
        from 
            tipo
        where
             upper(des_tipo) like '%' || xnomtipo ||'%' 
        order by
            des_tipo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_tipos(""xnomtipo$"" character varying, OUT tipos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$
        declare xnomtipo varchar;
    begin
        xnomtipo := coalesce(upper(trim(xnomtipo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';

        open tipos for

        select
            id_tipo,
            des_tipo
        from 
            tipo
        where
             upper(des_tipo) like '%' || xnomtipo ||'%' 
        order by
            des_tipo;
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_tipos_prueba(""xnomtipo$"" character varying, ""ordenarpor$"" character varying, ""orden$"" character varying, ""pagactual$"" numeric, ""canregxpag$"" numeric, OUT tipos refcursor, OUT numerror character varying, OUT msjerror character varying, OUT ""totalregistros$"" numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnomtipo varchar;
    declare  xncantregdesde$ numeric;
    declare  xncantreghasta$ numeric;
    declare  xordenarpor$  varchar;
    declare  xorden$ varchar;    

    begin
        xnomtipo := coalesce(upper(trim(xnomtipo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';
        begin        
            select 
                count(*)
            into
                totalregistros$
            from            
            (            
                select
                    cod_tipo,
                    des_tipo
                from 
                    tipo
                where
                     upper(des_tipo) like '%' || xnomtipo ||'%' 
            )as subquery;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                    return; 
        end;

        if canregxpag$ = 0 then
            --todos
            xncantreghasta$ := totalregistros$;
            xncantregdesde$ := 0;
        else
            --parcial (paginacion)
            xncantreghasta$ := pagactual$ * canregxpag$;
            xncantregdesde$ := xncantreghasta$ - canregxpag$;
        end if;

        begin    
            open tipos for

            select 
                *
            from 
            (   
                select 
                    row_number()over ()  as fila,       
                    consulta1
                from
                (
                    select
                        cod_tipo,
                        des_tipo
                    from 
                        tipo
                    where
                         upper(des_tipo) like '%' || xnomtipo ||'%' 
                    order by
                        des_tipo
                )as consulta1  
            )as consulta2 where fila > xncantregdesde$ and fila <= xncantreghasta$;           

            exception
            when others then           
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
        end;
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_tipos_prueba(""xnomtipo$"" character varying, ""ordenarpor$"" character varying, ""orden$"" character varying, ""pagactual$"" numeric, ""canregxpag$"" numeric, OUT tipos refcursor, OUT numerror character varying, OUT msjerror character varying, OUT ""totalregistros$"" numeric) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xnomtipo varchar;
    declare  xncantregdesde$ numeric;
    declare  xncantreghasta$ numeric;
    declare  xordenarpor$  varchar;
    declare  xorden$ varchar;    

    begin
        xnomtipo := coalesce(upper(trim(xnomtipo$)),'') || '%';
        numerror := 0;
        msjerror := ' ';
        begin        
            select 
                count(*)
            into
                totalregistros$
            from            
            (            
                select
                    cod_tipo,
                    des_tipo
                from 
                    tipo
                where
                     upper(des_tipo) like '%' || xnomtipo ||'%' 
            )as subquery;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                    return; 
        end;

        if canregxpag$ = 0 then
            --todos
            xncantreghasta$ := totalregistros$;
            xncantregdesde$ := 0;
        else
            --parcial (paginacion)
            xncantreghasta$ := pagactual$ * canregxpag$;
            xncantregdesde$ := xncantreghasta$ - canregxpag$;
        end if;

        begin    
            open tipos for

            select 
                *
            from 
            (   
                select 
                    row_number()over ()  as fila,       
                    consulta1
                from
                (
                    select
                        cod_tipo,
                        des_tipo
                    from 
                        tipo
                    where
                         upper(des_tipo) like '%' || xnomtipo ||'%' 
                    order by
                        des_tipo
                )as consulta1  
            )as consulta2 where fila > xncantregdesde$ and fila <= xncantreghasta$;           

            exception
            when others then           
                numerror := sqlstate;
                msjerror := '[busca_tipos] error al buscar tipos(sql) ' ||sqlerrm;
                return; 
        end;
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_turista(pass character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais
WHERE turista.pasaporte=pass;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_turista(pass character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais
WHERE turista.pasaporte=pass;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_turista(pass character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais
WHERE turista.pasaporte=pass;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_turista(pass character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais
WHERE turista.pasaporte=pass;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_turista(pass character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais
WHERE turista.pasaporte=pass;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_turistas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_turistas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_turistas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_turistas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_turistas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR
SELECT turista.pasaporte,
turista.nombre,
turista.apellidos,
turista.edad,
turista.telefono,
turista.sexo,
pais.nombre_pais,
turista.id_tur
 FROM turista JOIN pais on pais.id_pais=turista.tur_id_pais;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscar_usuario(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	IDR INTEGER;
BEGIN	
	IDR := (ID) FROM USUARIO WHERE USUARIO.NOMBREUSUARIO = $1;
	IF IDR!=0 THEN
		RETURN IDR;
	ELSE
		IDR := 0;
		RETURN IDR;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION buscar_usuario(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT * FROM usuarios WHERE usuarios.usuario=$1 AND usuarios.password_usuario=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_usuario(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT * FROM usuarios WHERE usuarios.usuario=$1 AND usuarios.password_usuario=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_usuario(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT * FROM usuarios WHERE usuarios.usuario=$1 AND usuarios.password_usuario=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_usuario(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT * FROM usuarios WHERE usuarios.usuario=$1 AND usuarios.password_usuario=$2;
RETURN cur;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_usuario(character varying, character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT * FROM usuarios WHERE usuarios.usuario=$1 AND usuarios.password_usuario=$2;
RETURN cur;
END
$_$;",backup1.sql
"CREATE FUNCTION buscar_usuario_id(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	ID VARCHAR;
BEGIN	
	ID := (nombreusuario) FROM USUARIO WHERE USUARIO.ID = $1;
	RETURN ID;
END;
$_$;",todo.sql
"CREATE FUNCTION buscar_usuarios(""rut$"" character varying, ""dv$"" character varying, ""nombres$"" character varying, ""apepaterno$"" character varying, ""apematerno$"" character varying, ""nomusuario$"" character varying, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xrut varchar; 
    declare xdv varchar;
    declare xnombres varchar;
    declare xapepaterno varchar;
    declare xapematerno varchar;
    declare xnomusuario varchar;

    begin
        numerror := '0';
        msjerror := ' ';

        
        xrut := coalesce(upper(trim(rut$)),'') || '%';
        xnombres := '%' || coalesce(upper(trim(nombres$)),'') || '%';
        xapepaterno := '%' || coalesce(upper(trim(apepaterno$)),'') || '%';
        xapematerno := '%' || coalesce(upper(trim(apematerno$)),'') || '%';
        xnomusuario := '%' || coalesce(upper(trim(nomusuario$)),'') || '%';

        open usuarios for

        select
            idusuario,
            rut,
            dv,
            nombres,
            apepaterno,
            apematerno,
            nomusuario,
            contrasena,
            codgenero,
            fecnacimiento,        
            telefono,
            celular,
            email,
            cantintentos,
            feccreacion,
            feccontrasena,
            indvigencia
        from 
            usuario
        where
            rut like xrut and
            upper(nombres) like xnombres and
            upper(apepaterno) like xapepaterno and
            upper(apematerno) like xapematerno and
            upper(nomusuario) like xnomusuario
        order by
            idusuario; 
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_usuarios] error al buscar usuarios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bak-04-11-2014.sql
"CREATE FUNCTION buscar_usuarios(""rut$"" character varying, ""dv$"" character varying, ""nombres$"" character varying, ""apepaterno$"" character varying, ""apematerno$"" character varying, ""nomusuario$"" character varying, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xrut varchar; 
    declare xdv varchar;
    declare xnombres varchar;
    declare xapepaterno varchar;
    declare xapematerno varchar;
    declare xnomusuario varchar;

    begin
        numerror := '0';
        msjerror := ' ';

        
        xrut := coalesce(upper(trim(rut$)),'') || '%';
        xnombres := '%' || coalesce(upper(trim(nombres$)),'') || '%';
        xapepaterno := '%' || coalesce(upper(trim(apepaterno$)),'') || '%';
        xapematerno := '%' || coalesce(upper(trim(apematerno$)),'') || '%';
        xnomusuario := '%' || coalesce(upper(trim(nomusuario$)),'') || '%';

        open usuarios for

        select
            idusuario,
            rut,
            dv,
            nombres,
            apepaterno,
            apematerno,
            nomusuario,
            contrasena,
            codgenero,
            fecnacimiento,        
            telefono,
            celular,
            email,
            cantintentos,
            feccreacion,
            feccontrasena,
            indvigencia
        from 
            usuario
        where
            rut like xrut and
            upper(nombres) like xnombres and
            upper(apepaterno) like xapepaterno and
            upper(apematerno) like xapematerno and
            upper(nomusuario) like xnomusuario
        order by
            idusuario; 
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_usuarios] error al buscar usuarios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bak-06-11-2014.sql
"CREATE FUNCTION buscar_usuarios(""rut$"" character varying, ""dv$"" character varying, ""nombres$"" character varying, ""apepaterno$"" character varying, ""apematerno$"" character varying, ""nomusuario$"" character varying, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xrut varchar; 
    declare xdv varchar;
    declare xnombres varchar;
    declare xapepaterno varchar;
    declare xapematerno varchar;
    declare xnomusuario varchar;

    begin
        numerror := '0';
        msjerror := ' ';

        
        xrut := coalesce(upper(trim(rut$)),'') || '%';
        xnombres := '%' || coalesce(upper(trim(nombres$)),'') || '%';
        xapepaterno := '%' || coalesce(upper(trim(apepaterno$)),'') || '%';
        xapematerno := '%' || coalesce(upper(trim(apematerno$)),'') || '%';
        xnomusuario := '%' || coalesce(upper(trim(nomusuario$)),'') || '%';

        open usuarios for

        select
            idusuario,
            rut,
            dv,
            nombres,
            apepaterno,
            apematerno,
            nomusuario,
            contrasena,
            codgenero,
            fecnacimiento,        
            telefono,
            celular,
            email,
            cantintentos,
            feccreacion,
            feccontrasena,
            indvigencia
        from 
            usuario
        where
            rut like xrut and
            upper(nombres) like xnombres and
            upper(apepaterno) like xapepaterno and
            upper(apematerno) like xapematerno and
            upper(nomusuario) like xnomusuario
        order by
            idusuario; 
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_usuarios] error al buscar usuarios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bak18.11.sql
"CREATE FUNCTION buscar_usuarios(""rut$"" character varying, ""dv$"" character varying, ""nombres$"" character varying, ""apepaterno$"" character varying, ""apematerno$"" character varying, ""nomusuario$"" character varying, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xrut varchar; 
    declare xdv varchar;
    declare xnombres varchar;
    declare xapepaterno varchar;
    declare xapematerno varchar;
    declare xnomusuario varchar;

    begin
        numerror := 0;
        msjerror := ' ';

        /*filtros*/
        xrut := '%' || coalesce(upper(trim(rut$)),'') || '%';
        xnombres    := '%' ||coalesce(upper(trim(nombres$)),'') || '%';
        xapepaterno := '%' || coalesce(upper(trim(apepaterno$)),'') || '%';
        xapematerno := '%' || coalesce(upper(trim(apematerno$)),'') || '%';
        xnomusuario := '%' || coalesce(upper(trim(nomusuario$)),'') || '%';

        open usuarios for

        select
            idusuario,
            rut,
            dv,
            nombres,
            apepaterno,
            apematerno,
            nomusuario,
            contrasena,
            codgenero,
            fecnacimiento,        
            telefono,
            celular,
            email,
            cantintentos,
            feccreacion,
            feccontrasena,
            indvigencia
        from 
            usuario
        where
            rut like xrut and
            upper(nombres) like '%' || xnombres ||'%' and
            upper(apepaterno) like xapepaterno and
            upper(apematerno) like xapematerno and
            upper(nomusuario) like xnomusuario
        order by
            idusuario; 
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_usuarios] error al buscar usuarios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",3-2-15.sql
"CREATE FUNCTION buscar_usuarios(""rut$"" character varying, ""dv$"" character varying, ""nombres$"" character varying, ""apepaterno$"" character varying, ""apematerno$"" character varying, ""nomusuario$"" character varying, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xrut varchar; 
    declare xdv varchar;
    declare xnombres varchar;
    declare xapepaterno varchar;
    declare xapematerno varchar;
    declare xnomusuario varchar;

    begin
        numerror := 0;
        msjerror := ' ';

        /*filtros*/
        xrut := '%' || coalesce(upper(trim(rut$)),'') || '%';
        xnombres    := '%' ||coalesce(upper(trim(nombres$)),'') || '%';
        xapepaterno := '%' || coalesce(upper(trim(apepaterno$)),'') || '%';
        xapematerno := '%' || coalesce(upper(trim(apematerno$)),'') || '%';
        xnomusuario := '%' || coalesce(upper(trim(nomusuario$)),'') || '%';

        open usuarios for

        select
            idusuario,
            rut,
            dv,
            nombres,
            apepaterno,
            apematerno,
            nomusuario,
            contrasena,
            codgenero,
            fecnacimiento,        
            telefono,
            celular,
            email,
            cantintentos,
            feccreacion,
            feccontrasena,
            indvigencia
        from 
            usuario
        where
            rut like xrut and
            upper(nombres) like '%' || xnombres ||'%' and
            upper(apepaterno) like xapepaterno and
            upper(apematerno) like xapematerno and
            upper(nomusuario) like xnomusuario
        order by
            idusuario; 
        
        exception
            when others then
                numerror := sqlstate;
                msjerror := '[busca_usuarios] error al buscar usuarios(sql) ' ||sqlerrm;
                return; 
    end;

$_$;",bkup.sql
"CREATE FUNCTION buscar_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT usuarios.id_user, usuarios.usuario,usuarios.password_usuario,usuarios.nombre,usuarios.apellidos FROM usuarios;
RETURN cur;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION buscar_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT usuarios.id_user, usuarios.usuario,usuarios.password_usuario,usuarios.nombre,usuarios.apellidos FROM usuarios;
RETURN cur;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION buscar_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT usuarios.id_user, usuarios.usuario,usuarios.password_usuario,usuarios.nombre,usuarios.apellidos FROM usuarios;
RETURN cur;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION buscar_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT usuarios.id_user, usuarios.usuario,usuarios.password_usuario,usuarios.nombre,usuarios.apellidos FROM usuarios;
RETURN cur;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION buscar_usuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cur refcursor;
BEGIN
OPEN cur FOR 
SELECT usuarios.id_user, usuarios.usuario,usuarios.password_usuario,usuarios.nombre,usuarios.apellidos FROM usuarios;
RETURN cur;
END
$$;",backup1.sql
"CREATE FUNCTION buscarcadena(cadena character varying, esquema character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 tabla character varying;
 columna character varying;
 r record;
    BEGIN
    FOR tabla IN
        select table_name from information_schema.tables where table_schema = esquema 
    LOOP
        FOR columna IN
            SELECT column_name FROM information_schema.columns WHERE table_schema = 'public' 
                AND table_name = tabla and data_type = 'character varying'
        LOOP
            FOR r IN EXECUTE format('SELECT 1 FROM %I where %I = ''%I''', tabla,columna,cadena)
            LOOP
                return 'tabla: '|| tabla||' || columna: '||columna;
            END LOOP;

        END LOOP;
    END LOOP;
    return 'No encontrada';
    END;
$$;",create_db_postgres.sql
"CREATE FUNCTION buyable_to_consumable(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'CONSUMABLE'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION buyable_to_primal(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'PRIMAL'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION bytea_import(p_path text, OUT p_result bytea) RETURNS bytea
    LANGUAGE plpgsql
    AS $$
declare
  l_oid oid;
  r record;
begin
  p_result := '';
  select lo_import(p_path) into l_oid;
  for r in ( select data 
             from pg_largeobject 
             where loid = l_oid 
             order by pageno ) loop
    p_result = p_result || r.data;
  end loop;
  perform lo_unlink(l_oid);
end;$$;",TBDB.bck
"CREATE FUNCTION bytea_import(p_path text, OUT p_result bytea) RETURNS bytea
    LANGUAGE plpgsql
    AS $$
declare
  l_oid oid;
  r record;
begin
  p_result := '';
  select lo_import(p_path) into l_oid;
  for r in ( select data 
             from pg_largeobject 
             where loid = l_oid 
             order by pageno ) loop
    p_result = p_result || r.data;
  end loop;
  perform lo_unlink(l_oid);
end;$$;",mayo%2023%20del%202017.sql
"CREATE FUNCTION bytea_import(p_path text, OUT p_result bytea) RETURNS bytea
    LANGUAGE plpgsql
    AS $$
declare
  l_oid oid;
  r record;
begin
  p_result := '';
  select lo_import(p_path) into l_oid;
  for r in ( select data 
             from pg_largeobject 
             where loid = l_oid 
             order by pageno ) loop
    p_result = p_result || r.data;
  end loop;
  perform lo_unlink(l_oid);
end;$$;",pg.sql
"CREATE FUNCTION c_crosstab(eavsql_inarg character varying, resview character varying, rowid character varying, colid character varying, val character varying, agr character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$


DECLARE


    casesql varchar;


    dynsql varchar;    


    r record;


BEGIN   


 dynsql='';


 for r in 


      select * from pg_views where lower(viewname) = lower(resview)


  loop


      execute 'DROP VIEW ' || resview;


  end loop;   


 casesql='SELECT DISTINCT ' || colid || ' AS v from (' || eavsql_inarg || ') eav ORDER BY ' || colid;


 FOR r IN EXECUTE casesql Loop


    dynsql = dynsql || ', ' || agr || '(CASE WHEN ' || colid || '=''' || r.v || ''' THEN ' || val || ' ELSE NULL END) AS ' || replace(r.v , '-', '_');


 END LOOP;


 dynsql = 'CREATE VIEW ' || resview || ' AS SELECT ' || rowid || dynsql || ' from (' || eavsql_inarg || ') eav GROUP BY ' || rowid ;


 RAISE NOTICE 'dynsql %', dynsql; 


 EXECUTE dynsql;


END


$$;",b2bac_final_12.11.15-preST-AWS.sql
"CREATE FUNCTION c_crosstab(eavsql_inarg character varying, resview character varying, rowid character varying, colid character varying, val character varying, agr character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE

    casesql varchar;

    dynsql varchar;    

    r record;

BEGIN   

 dynsql='';

 for r in 

      select * from pg_views where lower(viewname) = lower(resview)

  loop

      execute 'DROP VIEW ' || resview;

  end loop;   

 casesql='SELECT DISTINCT ' || colid || ' AS v from (' || eavsql_inarg || ') eav ORDER BY ' || colid;

 FOR r IN EXECUTE casesql Loop

    dynsql = dynsql || ', ' || agr || '(CASE WHEN ' || colid || '=''' || r.v || ''' THEN ' || val || ' ELSE NULL END) AS ' || replace(r.v , '-', '_');

 END LOOP;

 dynsql = 'CREATE VIEW ' || resview || ' AS SELECT ' || rowid || dynsql || ' from (' || eavsql_inarg || ') eav GROUP BY ' || rowid ;

 RAISE NOTICE 'dynsql %', dynsql; 

 EXECUTE dynsql;

END

$$;",b2bac_schema_only.sql
"CREATE FUNCTION c_crosstab(eavsql_inarg character varying, resview character varying, rowid character varying, colid character varying, val character varying, agr character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    casesql varchar;
    dynsql varchar;    
    r record;
BEGIN   
 dynsql='';

 for r in 
      select * from pg_views where lower(viewname) = lower(resview)
  loop
      execute 'DROP VIEW ' || resview;
  end loop;   

 casesql='SELECT DISTINCT ' || colid || ' AS v from (' || eavsql_inarg || ') eav ORDER BY ' || colid;
 FOR r IN EXECUTE casesql Loop
    dynsql = dynsql || ', ' || agr || '(CASE WHEN ' || colid || '=''' || r.v || ''' THEN ' || val || ' ELSE NULL END) AS ' || replace(r.v , '-', '_');
 END LOOP;
 dynsql = 'CREATE VIEW ' || resview || ' AS SELECT ' || rowid || dynsql || ' from (' || eavsql_inarg || ') eav GROUP BY ' || rowid ;
 RAISE NOTICE 'dynsql %', dynsql; 
 EXECUTE dynsql;
END

$$;",b2bac_schema.sql
"CREATE FUNCTION cache_size_per_core(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE result double precision;
BEGIN
	result = SUM(processor.cores_num*processor.cache_size)/SUM(processor.cores_num) FROM processor JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON processor.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN result;
END;$$;",database
"CREATE FUNCTION calc_account(_acc integer, _since date DEFAULT f_period_begin(f_period_current()), _finish date DEFAULT f_period_end(f_period_current())) RETURNS TABLE(acc integer, since date, days integer, srv_id integer, isod boolean, credsum real, countsum real, rclcsum real)
    LANGUAGE plpgsql
    AS $$
declare 
	rec record; -- Курсор, который проходит все даты, относящиеся к лицевому счёту
	srec record; -- Курсор, который проходит все услуги, относящиеся к лицевому счёту
	horec record; -- Курсор для таблицы Houses
	prev_date date; -- Переменная для запоминания предыдущей даты, для нахождения еоличества дней
	hrec gks.histories%RowTYPE; -- Курсор для таблицы Histories
	srv_price real; -- Стоимость услуги
	per_days int; -- Количество дней в периоде
	accs_for_counter int; -- Количество счётов к которым подключен счётчик
	acc_since date; -- дата начала действия счёта
	acc_finish date; -- дата окончания действия счёта
	counter_val real; -- Объём по счётчику
	val_for_house real; -- Объём по счётчику и по нормативу услуг для дома
	house_sql real; -- Отапливаемая площадь дома
BEGIN
	prev_date = null; 
	per_days = _finish - _since;

-- id дома
	SELECT houses.* INTO horec FROM gks.houses LEFT JOIN gks.accounts ON houses.id = accounts.hou_id WHERE accounts.acc = _acc;
-- Запрос для определения границ начисления по ЛС
	SELECT accounts.since, accounts.finish into acc_since, acc_finish FROM gks.accounts	WHERE accounts.acc = _acc;
/*В этот запрос сводятся все даты, имеющие отношения к этому ЛС.*/

-- цикл по всем датам, относящимся к лицевому счёту
	for rec IN
		SELECT accounts.acc, accounts.since FROM gks.accounts
		WHERE accounts.acc = _acc 
		AND accounts.since between _since and _finish
		UNION  
		SELECT accounts.acc, accounts.finish FROM gks.accounts
		WHERE accounts.acc = _acc
		AND accounts.finish between _since and _finish
		UNION 
		SELECT histories.acc_id, chdate FROM gks.histories 
		WHERE histories.acc_id = _acc
		AND chdate between _since and _finish
		UNION 
		SELECT serv_applications.acc_id, serv_applications.since
		from gks.serv_applications 
		WHERE serv_applications.acc_id = _acc
		AND serv_applications.since between _since and _finish
		UNION 
		SELECT serv_applications.acc_id, serv_applications.finish
		from gks.serv_applications 
		WHERE serv_applications.acc_id = _acc
		AND serv_applications.finish between _since and _finish
		UNION 
		SELECT acc_id, checkdate
		FROM gks.serv_applications JOIN  gks.counter_values ON serv_applications.cnt_id = counter_values.cnt_id 	
		WHERE acc_id = _acc
		AND checkdate between _since and _finish
		UNION 
		SELECT _acc, periods.since FROM gks.periods
		WHERE periods.since between _since and _finish
		UNION 
		SELECT _acc, _since
		UNION 
		SELECT _acc, _finish
		ORDER BY since
	loop
-- первый проход пропускаем, сохраняя дату в prev_date 
		if (prev_date is not null) then
raise notice '1 %', prev_date;
		   if (prev_date between coalesce(acc_since, '-infinity') and coalesce(acc_finish, 'infinity')) then 
raise notice '2 %', prev_date;

-- получаем суммарную отапливаемую площадь дома на дату prev_date
				house_sql = (SELECT sum(sql) 
					FROM gks.accounts 
					LEFT JOIN gks.histories on accounts.acc=acc_id 
					WHERE hou_id=horec.id
					AND histories.chdate = ( SELECT max(h.chdate) AS max
						FROM gks.histories h
						WHERE h.acc_id = histories.acc_id AND h.chdate <= prev_date)
					GROUP BY hou_id);
				
-- Получаем текущую историю
				SELECT * INTO hrec from gks.histories WHERE histories.acc_id = _acc AND chdate <= prev_date ORDER BY chdate DESC LIMIT 1;
			
-- цикл по услугам лицевого счёта
				for srec IN 
					SELECT serv_applications.id, serv_applications.srv_id, serv_applications.coef, services.kind, serv_applications.isod, serv_applications.cnt_id 
					from gks.serv_applications LEFT JOIN gks.services ON serv_applications.srv_id = services.id 
					WHERE acc_id = _acc 
					AND prev_date between coalesce(serv_applications.since, '-infinity') 
						and coalesce(serv_applications.finish, 'infinity')
				loop
raise notice '3 % %', prev_date, srec.id;
-- присваивание начальных значений
					acc = _acc;
					since = prev_date;
					srv_id = srec.srv_id;
					days = rec.since - prev_date;
					isod = srec.isod;
-- выбираем цену услуги
					SELECT coalesce(sum, 0) into srv_price from gks.prices WHERE prices.srv_id = srec.srv_id AND date <= prev_date ORDER BY date DESC LIMIT 1;
-- расчёт начисления по норме
					if srec.cnt_id is null or srec.cnt_id = 0 then
						credsum = srec.coef*(days::real/per_days::real)*
							case srec.kind 
							when 1 then srv_price*hrec.sql -- на размер площади
							when 2 then srv_price*hrec.pes -- на количество проживающих
							else srv_price end;
						raise notice 'prev_date:% srec.coef:% days:% per_days:% srec.kind:% srv_price:% hrec.pes:% hrec.sql:% = %',
							prev_date, srec.coef, days, per_days, srec.kind, srv_price, hrec.pes, hrec.sql, credsum;

-- если услуга общедомовая, то дополнительно умножаем на коэффициент, полученный из деления отапливаемой площади на общею отапливаемую площадь дома
						if srec.isod then
-- по хорошему, надосмотреть на kind и если 0 - то делить на колво ЛСЧ в этом доме с этой услугой, 1 - на площади, и 2 - на колво человек
							credsum = credsum * (horec.sqstair*hrec.sql/house_sql);
						end if;
						countsum = 0;
-- расчёт начисления по счётчику
					else
						credsum = 0;
						countsum = 0;
--1. Находим объём по этому счётчику
						counter_val = gks.f_get_counter_value(srec.cnt_id, prev_date);
--2. Проверить, если в эту дату есть показание, иначе лесом./
						if counter_val <> 0 then
--3а. Если это не общедомовой, то находим кол-во лиц.счетов, к которым подключен это счётчик и делим поровну.
							accs_for_counter = 0;
							if NOT srec.isod then
								accs_for_counter = (SELECT count(*) FROM gks.serv_applications WHERE cnt_id = srec.cnt_id);
								countsum = srec.coef*srv_price*counter_val/accs_for_counter;
/*3б. Если общедомовой, то по дому суммируем:
	- все нормы(коэффициенты) по этой услуге за текущий период для не счётчика, 
	- все объёмы по счётчикам по этой услуге за текущий период, 
	- отнимаем из объёма счётчика этот объём. 
	Остаток, если положительный, умножаем на цену и на коэффициент, полученный от деления общей площади на площадь дома. */					
							else
								val_for_house = counter_val-
									(SELECT sum(case when serv_applications.cnt_id is null then coalesce(coef,0) else coalesce(coef,0)*coalesce(gks.f_get_counter_current_sum(serv_applications.cnt_id), 0) end)
										FROM gks.accounts 
										LEFT JOIN gks.serv_applications ON serv_applications.acc_id = accounts.acc
										WHERE hou_id = horec.id
										AND serv_applications.srv_id = srec.srv_id
										AND serv_applications.isod = false
										AND prev_date between coalesce(serv_applications.since, '-infinity') and coalesce(serv_applications.finish, 'infinity')
										AND (coalesce(serv_applications.since, '-infinity'), coalesce(serv_applications.finish, 'infinity')) overlaps (_since, _finish)); 
								countsum = srec.coef * srv_price * val_for_house * (horec.sqstair*hrec.sql/house_sql);
raise notice 'srec.coef=(%) * srv_price(%) * val_for_house(%) * (horec.sqstair(%)*hrec.sql(%)/house_sql(%))(%)', 
	srec.coef, srv_price, val_for_house, horec.sqstair, hrec.sql, house_sql, (horec.sqstair*hrec.sql/house_sql);
							end if;
						else
							credsum = 0;
							countsum = 0;
						end if;
					end if;
-- расчёт перерасчёта
					rclcsum = srec.coef*(days::real/per_days::real);
					return next;
				end loop;
			end if; -- проверка на границы начисления лицевого счёта
		end if;
		prev_date = rec.since;
	end loop;
END;
$$;",db.backup
"CREATE FUNCTION calc_age_category(p_date_of_birth timestamp without time zone, p_age_category character) RETURNS character
    AS $$
DECLARE
    v_age    integer;
BEGIN

    IF NOT (p_date_of_birth IS NULL) THEN
        SELECT into v_age
            extract (year from age(now(), p_date_of_birth));
        IF (v_age < 10) THEN
            RETURN 'C';
        ELSIF (v_age < 15) THEN
            RETURN 'J';
        ELSIF (v_age < 21) THEN
            RETURN 'Y';
        ELSE
            RETURN 'A';
        END IF;
    ELSIF NOT (p_age_category IS NULL) THEN
        RETURN p_age_category;
    ELSE
        RETURN 'A';
    END IF;

END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION calc_cum_gpa_mp(character varying) RETURNS integer
    AS $_$DECLARE
  mp_id ALIAS for $1;
  mpinfo marking_periods%ROWTYPE;
  s student_mp_stats%ROWTYPE;
BEGIN
  FOR s in select student_id from student_mp_stats where marking_period_id = CAST(mp_id as integer) LOOP
   
    PERFORM calc_cum_gpa(mp_id, s.student_id);
    PERFORM calc_cum_cr_gpa(mp_id, s.student_id);
  END LOOP;
  RETURN 1;
END;

$_$
    LANGUAGE plpgsql;",centre.sql
"CREATE FUNCTION calcolofasciaeta(eta numeric) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 fasciaeta CHARACTER VARYING(9);
BEGIN
 IF eta <= 17 THEN
  fasciaeta := 'minorenne';
 ELSIF eta >=18 AND eta<=39 THEN
  fasciaeta := 'giovane';
 ELSIF eta >=40 AND eta<=59 THEN
  fasciaeta := 'mezza età';
 ELSE
  fasciaeta := 'anziano';
 END IF;
 RETURN fasciaeta;
END;
$$;",procurawarehouse.sql
"CREATE FUNCTION calcoloorganizzazionecriminale(imput integer, inizioindagine date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
 orgcrim RECORD;
 periodopiulungo INTEGER := 0;
 migliororgcrim CHARACTER VARYING;
BEGIN
  FOR orgcrim IN SELECT * FROM dblink('SELECT nome, COALESCE(fineappartenenza, CURRENT_DATE)-inizioappartenenza FROM varorganizzazionecriminale WHERE idimputato=' || imput)
              AS o(nome CHARACTER VARYING, giorniappartenenza INTEGER) LOOP
              
   IF periodopiulungo < orgcrim.giorniappartenenza THEN
    migliororgcrim := orgcrim.nome;
    periodopiulungo := orgcrim.giorniappartenenza;
   END IF;
  END LOOP;
  RETURN migliororgcrim;
END;
$$;",procurawarehouse.sql
"CREATE FUNCTION calcular_dias_prorroga_contrato(id_con integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
dia int;
ff date;
fe date;
BEGIN
SELECT contratos.fecha_f into ff FROM contratos WHERE contratos.id_contrato=id_con;
SELECT contratos.fecha_entrega into fe FROM contratos WHERE contratos.id_contrato=id_con;
if(fe ISNULL)THEN
dia=0;
ELSIF(fe<ff)THEN
dia=0;
ELSE
dia=(fe-ff)::INT;
END IF;
RETURN dia;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_dias_prorroga_contrato(id_con integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
dia int;
ff date;
fe date;
BEGIN
SELECT contratos.fecha_f into ff FROM contratos WHERE contratos.id_contrato=id_con;
SELECT contratos.fecha_entrega into fe FROM contratos WHERE contratos.id_contrato=id_con;
if(fe ISNULL)THEN
dia=0;
ELSIF(fe<ff)THEN
dia=0;
ELSE
dia=(fe-ff)::INT;
END IF;
RETURN dia;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_dias_prorroga_contrato(id_con integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
dia int;
ff date;
fe date;
BEGIN
SELECT contratos.fecha_f into ff FROM contratos WHERE contratos.id_contrato=id_con;
SELECT contratos.fecha_entrega into fe FROM contratos WHERE contratos.id_contrato=id_con;
if(fe ISNULL)THEN
dia=0;
ELSIF(fe<ff)THEN
dia=0;
ELSE
dia=(fe-ff)::INT;
END IF;
RETURN dia;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_dias_prorroga_contrato(id_con integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
dia int;
ff date;
fe date;
BEGIN
SELECT contratos.fecha_f into ff FROM contratos WHERE contratos.id_contrato=id_con;
SELECT contratos.fecha_entrega into fe FROM contratos WHERE contratos.id_contrato=id_con;
if(fe ISNULL)THEN
dia=0;
ELSIF(fe<ff)THEN
dia=0;
ELSE
dia=(fe-ff)::INT;
END IF;
RETURN dia;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_dias_prorroga_contrato(id_con integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
dia int;
ff date;
fe date;
BEGIN
SELECT contratos.fecha_f into ff FROM contratos WHERE contratos.id_contrato=id_con;
SELECT contratos.fecha_entrega into fe FROM contratos WHERE contratos.id_contrato=id_con;
if(fe ISNULL)THEN
dia=0;
ELSIF(fe<ff)THEN
dia=0;
ELSE
dia=(fe-ff)::INT;
END IF;
RETURN dia;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe(id_cont integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe(id_cont integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe(id_cont integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe(id_cont integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe(id_cont integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe2(id_cont integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe2(id_cont integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe2(id_cont integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe2(id_cont integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe2(id_cont integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;
aux float;
tar_n float;
tar_e float;
id_ta INT;
fi date;
ff date;
fe date;
BEGIN
total=0;

SELECT tarifa.id_tarifa INTO id_ta 
FROM tarifa JOIN modelos on modelos.modelo_id_tar=tarifa.id_tarifa
JOIN autos ON autos.id_modelo_auto=modelos.id_modelo JOIN
 contratos on contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=id_cont;

SELECT (tarifa.tarifa_normal) INTO tar_n FROM tarifa WHERE id_tarifa=id_ta;
SELECT (tarifa.tarifa_especial) INTO tar_e FROM tarifa WHERE id_tarifa=id_ta;

SELECT contratos.fecha_f INTO ff FROM contratos WHERE id_contrato=id_cont;
SELECT contratos.fecha_i INTO fi FROM contratos WHERE id_contrato=id_cont; 
SELECT contratos.fecha_entrega INTO fe FROM contratos WHERE id_contrato=id_cont;

if(fe NOTNULL)THEN
if(ff>fe) THEN
total:=((fe-fi)*tar_n)::float;
ELSE
aux:=((fe-ff)*tar_e)::float;
total:=((ff-fi)*tar_n)::float;
total:=(total+aux)::float;
END IF;
ELSE
total:=((ff-fi)*tar_n)::float;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe_cheque(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='cheque';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_cheque(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='cheque';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_cheque(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='cheque';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_cheque(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='cheque';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_cheque(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='cheque';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe_efectivo(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='efectivo';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_efectivo(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='efectivo';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_efectivo(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='efectivo';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_efectivo(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='efectivo';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_efectivo(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='efectivo';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe_marca(character varying) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total 
FROM contratos JOIN autos 
								ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=$1;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_marca(character varying) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total 
FROM contratos JOIN autos 
								ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=$1;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_marca(character varying) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total 
FROM contratos JOIN autos 
								ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=$1;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_marca(character varying) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total 
FROM contratos JOIN autos 
								ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=$1;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_marca(character varying) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total 
FROM contratos JOIN autos 
								ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=$1;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$_$;",backup1.sql
"CREATE FUNCTION calcular_importe_tarjeta(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='tarjeta de credito';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_tarjeta(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='tarjeta de credito';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_tarjeta(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='tarjeta de credito';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_tarjeta(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='tarjeta de credito';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_tarjeta(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float:=0;
id_mo INT;
id_ma int;
id_fp int;
BEGIN
SELECT marcas.id_marca INTO id_ma FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_mo FROM modelos WHERE modelos.nombre_modelo=model and modelos.modelo_id_marca=id_ma;
SELECT forma_pago.id_pago INTO id_fp FROM forma_pago WHERE forma_pago.tipo_pago='tarjeta de credito';

SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto 
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_ma AND modelos.id_modelo=id_mo and contratos.cont_id_forma_pago=id_fp;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe_total(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;

BEGIN
SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo 
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=marc AND modelos.nombre_modelo=model;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_total(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;

BEGIN
SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo 
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=marc AND modelos.nombre_modelo=model;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_total(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;

BEGIN
SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo 
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=marc AND modelos.nombre_modelo=model;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_total(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;

BEGIN
SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo 
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=marc AND modelos.nombre_modelo=model;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_total(model character varying, marc character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
total float;

BEGIN
SELECT sum(contratos.importe_total) into total 
FROM contratos JOIN autos ON contratos.cont_id_auto=autos.id_auto
JOIN modelos ON autos.id_modelo_auto=modelos.id_modelo 
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.nombre_marca=marc AND modelos.nombre_modelo=model;
if(total ISNULL)THEN
total=0;
END IF;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_importe_total_turista(id_t character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
id_turis int;
BEGIN
SELECT turista.id_tur INTO id_turis FROM turista WHERE turista.pasaporte=id_t;
SELECT sum(contratos.importe_total) INTO tot from contratos where contratos.cont_id_tur=id_turis ;
return tot;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_importe_total_turista(id_t character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
id_turis int;
BEGIN
SELECT turista.id_tur INTO id_turis FROM turista WHERE turista.pasaporte=id_t;
SELECT sum(contratos.importe_total) INTO tot from contratos where contratos.cont_id_tur=id_turis ;
return tot;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_importe_total_turista(id_t character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
id_turis int;
BEGIN
SELECT turista.id_tur INTO id_turis FROM turista WHERE turista.pasaporte=id_t;
SELECT sum(contratos.importe_total) INTO tot from contratos where contratos.cont_id_tur=id_turis ;
return tot;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_importe_total_turista(id_t character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
id_turis int;
BEGIN
SELECT turista.id_tur INTO id_turis FROM turista WHERE turista.pasaporte=id_t;
SELECT sum(contratos.importe_total) INTO tot from contratos where contratos.cont_id_tur=id_turis ;
return tot;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_importe_total_turista(id_t character varying) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
id_turis int;
BEGIN
SELECT turista.id_tur INTO id_turis FROM turista WHERE turista.pasaporte=id_t;
SELECT sum(contratos.importe_total) INTO tot from contratos where contratos.cont_id_tur=id_turis ;
return tot;
END
$$;",backup1.sql
"CREATE FUNCTION calcular_total_carros_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
contador INT;
id_mar int;
id_m int;
BEGIN
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

select count(autos.id_auto) into contador
FROM autos JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar AND modelos.id_modelo=id_m;
RETURN contador;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION calcular_total_carros_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
contador INT;
id_mar int;
id_m int;
BEGIN
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

select count(autos.id_auto) into contador
FROM autos JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar AND modelos.id_modelo=id_m;
RETURN contador;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION calcular_total_carros_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
contador INT;
id_mar int;
id_m int;
BEGIN
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

select count(autos.id_auto) into contador
FROM autos JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar AND modelos.id_modelo=id_m;
RETURN contador;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION calcular_total_carros_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
contador INT;
id_mar int;
id_m int;
BEGIN
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

select count(autos.id_auto) into contador
FROM autos JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar AND modelos.id_modelo=id_m;
RETURN contador;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION calcular_total_carros_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
contador INT;
id_mar int;
id_m int;
BEGIN
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

select count(autos.id_auto) into contador
FROM autos JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto
JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar AND modelos.id_modelo=id_m;
RETURN contador;
END
$$;",backup1.sql
"CREATE FUNCTION calculatedailystock() RETURNS character
    LANGUAGE plpgsql
    AS $$
declare
	v_status character varying(10) ;
    total integer;
BEGIN
   SELECT count(*) into total FROM CDMS.datewise_prdct_stock_summery;
   v_status:='S';
   RETURN total;
END;
$$;",cdms_dump_30SEP.sql
"CREATE FUNCTION calculatedailystock(OUT out_status character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare
	v_status VARCHAR(10) ;
    total integer;
BEGIN	
   SELECT count(*) into total FROM CDMS.datewise_prdct_stock_summery;
   v_status:='S';
   out_status:=v_status;
END;

$$;",cdms_dump_30SEP.sql
"CREATE FUNCTION call_turnover() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
book record;
turn double precision;
book2 record;
turn2 double precision;
barticle integer;
BEGIN
turn:=0;
for book in 
SELECT amount FROM booking where date=CURRENT_DATE
LOOP
	turn:=turn+(book.amount);
END LOOP;
RAISE NOTICE 'Daily Sales: %',turn;

turn2:=0;
for book2 in
SELECT amount FROM booking where date > CURRENT_DATE - INTERVAL '12 months'
LOOP
  turn2:=turn2+(book2.amount);
END LOOP;
RAISE NOTICE 'Year Sales: %',turn2;

END; $$;",db2eshop_dump.sql
"CREATE FUNCTION canaccesstourl(selipaddr inet, url text) RETURNS text
    LANGUAGE plpgsql COST 99
    AS $$
DECLARE
	result text;
	did integer;
BEGIN
	
/* функция проверки возможности доступа в интернет 
	принимаемые параметры - ip устройства и запрашиваемый url 
*/
if isblackdomain(url)=true then
-- если домен в черном списке то перенаправим пользователя на какойто url
	return 'http://gu.spb.ru';
end if;

if iswhitedomain(url)=true then
--если домен в белом списке - дадим доступ к нему в любом случае
	return url;

end if;
select into did  id from devices where ipaddr=selipaddr;

if exists (select 1 from seanses where (servicetypeid=1 and accesstime > LOCALTIMESTAMP and deviceid=did) ) then
	return url;

else
--если платный url
	return 'http://192.168.0.150/pay.php?url='||url;

end if;



RETURN result;
END;
$$;",02.sql
"CREATE FUNCTION canaddmission(_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
    IF ( (SELECT ""rank"" FROM ""ranks"" WHERE ""rankId"" = getUserRank(_id)) = 'Champion' ) THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END
$$;",MiMissionMVC_20171210_193535.sql
"CREATE FUNCTION cant_carros_manejados_chofer(id_chof integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;

BEGIN

SELECT count(contratos.cont_id_chof) into tot
from contratos WHERE contratos.cont_id_chof=id_chof;
return tot;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION cant_carros_manejados_chofer(id_chof integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;

BEGIN

SELECT count(contratos.cont_id_chof) into tot
from contratos WHERE contratos.cont_id_chof=id_chof;
return tot;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION cant_carros_manejados_chofer(id_chof integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;

BEGIN

SELECT count(contratos.cont_id_chof) into tot
from contratos WHERE contratos.cont_id_chof=id_chof;
return tot;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION cant_carros_manejados_chofer(id_chof integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;

BEGIN

SELECT count(contratos.cont_id_chof) into tot
from contratos WHERE contratos.cont_id_chof=id_chof;
return tot;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION cant_carros_manejados_chofer(id_chof integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;

BEGIN

SELECT count(contratos.cont_id_chof) into tot
from contratos WHERE contratos.cont_id_chof=id_chof;
return tot;
END
$$;",backup1.sql
"CREATE FUNCTION cantidad_de_autos_alquilados_turista(id_t character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;
tur int;
BEGIN
SELECT turista.id_tur INTO tur FROM turista WHERE turista.pasaporte=id_t;
SELECT count(contratos.cont_id_tur) into tot
from contratos WHERE contratos.cont_id_tur=tur;
return tot;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION cantidad_de_autos_alquilados_turista(id_t character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;
tur int;
BEGIN
SELECT turista.id_tur INTO tur FROM turista WHERE turista.pasaporte=id_t;
SELECT count(contratos.cont_id_tur) into tot
from contratos WHERE contratos.cont_id_tur=tur;
return tot;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION cantidad_de_autos_alquilados_turista(id_t character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;
tur int;
BEGIN
SELECT turista.id_tur INTO tur FROM turista WHERE turista.pasaporte=id_t;
SELECT count(contratos.cont_id_tur) into tot
from contratos WHERE contratos.cont_id_tur=tur;
return tot;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION cantidad_de_autos_alquilados_turista(id_t character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;
tur int;
BEGIN
SELECT turista.id_tur INTO tur FROM turista WHERE turista.pasaporte=id_t;
SELECT count(contratos.cont_id_tur) into tot
from contratos WHERE contratos.cont_id_tur=tur;
return tot;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION cantidad_de_autos_alquilados_turista(id_t character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
tot INTEGER;
tur int;
BEGIN
SELECT turista.id_tur INTO tur FROM turista WHERE turista.pasaporte=id_t;
SELECT count(contratos.cont_id_tur) into tot
from contratos WHERE contratos.cont_id_tur=tur;
return tot;
END
$$;",backup1.sql
"CREATE FUNCTION car_get_missing_parts(bigint) RETURNS SETOF part_type
    LANGUAGE plpgsql STABLE ROWS 5
    AS $_$DECLARE 
	cid alias for $1;
	p part_type;
BEGIN

	for p in select * from part_type where required = true and id not in (select part_type_id from car_instance_parts where car_instance_id = cid) loop
		return next p;
	end loop;

END$_$;",streetking-database.sql
"CREATE FUNCTION car_get_worn_parts(bigint) RETURNS SETOF car_instance_parts
    LANGUAGE plpgsql STABLE ROWS 5
    AS $_$DECLARE 
	cid alias for $1;
	p car_instance_parts;
BEGIN

	for p in select * from car_instance_parts where car_instance_id = cid and wear > 9999 loop
		return next p;
	end loop;

END$_$;",streetking-database.sql
"CREATE FUNCTION car_properties(double precision, part_properties) RETURNS car_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 

	weight alias for $1;
	props alias for $2;

	res car_properties;
    
BEGIN

	select * into res from car_properties_empty();

	res.power = props.power * props.power_m;
	res.traction = props.traction * props.traction_m;
	res.handling = props.handling * props.handling_m;
	res.braking = props.braking * props.braking_m;
	res.aero = props.aero * props.aero_m;
	res.nos = props.nos * props.nos_m;

	return res;

END$_$;",streetking-database.sql
"CREATE FUNCTION car_properties_empty() RETURNS car_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $$DECLARE 

    res car_properties;
    
BEGIN

    res.top_speed = 0;
    res.acceleration = 0;
    res.cornering = 0;
    res.stopping = 0;
    res.nitrous = 0;
    
    res.power = 0;
    res.traction = 0;
    res.handling = 0;
    res.braking = 0;
    res.aero = 0;
    res.nos = 0;
    
    return res;
    

END$$;",streetking-database.sql
"CREATE FUNCTION cargar_cartera(xid_cartera numeric, OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
	numerror := 0;
        msjerror := ' ';
        open carteras for

            select
                id_cartera,
                des_cartera
            from 
                cartera
            where
                id_cartera = xid_cartera;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_cartera] error al cargar cartera(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_cartera(xid_cartera numeric, OUT carteras refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
	numerror := 0;
        msjerror := ' ';
        open carteras for

            select
                id_cartera,
                des_cartera
            from 
                cartera
            where
                id_cartera = xid_cartera;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_cartera] error al cargar cartera(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_documento(xniddocumento numeric, OUT documentos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open documentos for

            select
                id_documento,
                nombre,
                num_folio,
                num_adherente,
                descripcion,
                id_cartera,
                id_producto,
                cod_area,
                fec_creacion
            from 
                documento
            where
                id_documento = xniddocumento;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_documento] error al cargar documento(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_documento(xniddocumento numeric, OUT documentos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open documentos for

            select
                id_documento,
                nombre,
                num_folio,
                num_adherente,
                descripcion,
                id_cartera,
                id_producto,
                cod_area,
                fec_creacion
            from 
                documento
            where
                id_documento = xniddocumento;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_documento] error al cargar documento(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_empresa(xid_empresa numeric, OUT empresas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin

        numerror := 0;
        msjerror := '';
        open empresas for

            select
                num_adherente,
                id_empresa,
                nombre
            from 
                empresa
            where
                id_empresa = xid_empresa;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_empresa] error al cargar empresa(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_empresa(xid_empresa numeric, OUT empresas refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin

        numerror := 0;
        msjerror := '';
        open empresas for

            select
                num_adherente,
                id_empresa,
                nombre
            from 
                empresa
            where
                id_empresa = xid_empresa;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_empresa] error al cargar empresa(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_estado(xid_estado numeric, OUT estado refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open estado  for

            select
                id_estado,
                des_estado                
            from 
                estado             
                where
                id_estado = xid_estado; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_estado  error al cargar estado sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_estado(xid_estado numeric, OUT estado refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open estado  for

            select
                id_estado,
                des_estado                
            from 
                estado             
                where
                id_estado = xid_estado; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_estado  error al cargar estado sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_medio(xid_medio numeric, OUT medios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open medios for

            select
                id_medio_respuesta,
                des_medio_respuesta                
            from 
                medios_respuesta             
                where
                    id_medio_respuesta = xid_medio; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_medio  error al cargar medio sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_medio(xid_medio numeric, OUT medios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open medios for

            select
                id_medio_respuesta,
                des_medio_respuesta                
            from 
                medios_respuesta             
                where
                    id_medio_respuesta = xid_medio; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_medio  error al cargar medio sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_medio_respuesta(xcod_medio_respuesta character varying, OUT medio_respuesta refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open medio_respuesta  for

            select
                cod_medio_respuesta,
                des_medio_respuesta                
            from 
                medio_respuesta             
                where
                cod_medio_respuesta = xcod_medio_respuesta; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_medio_respuesta  error al cargar medio_respuesta sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_medio_respuesta(xcod_medio_respuesta character varying, OUT medio_respuesta refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open medio_respuesta  for

            select
                cod_medio_respuesta,
                des_medio_respuesta                
            from 
                medio_respuesta             
                where
                cod_medio_respuesta = xcod_medio_respuesta; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_medio_respuesta  error al cargar medio_respuesta sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_motivo(xid_motivo numeric, OUT motivo refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open motivo  for

            select
                id_motivo,
                des_motivo                
            from 
                motivo             
                where
                id_motivo = xid_motivo; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_motivo  error al cargar motivo sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_motivo(xid_motivo numeric, OUT motivo refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open motivo  for

            select
                id_motivo,
                des_motivo                
            from 
                motivo             
                where
                id_motivo = xid_motivo; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_motivo  error al cargar motivo sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_perfil(xid_perfil numeric, OUT perfil refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open perfil for

            select
                id_perfil,
                des_perfil                
            from 
                perfil             
                where
                id_perfil = xid_perfil; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_perfil] error al cargar perfil sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_perfil(xid_perfil numeric, OUT perfil refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open perfil for

            select
                id_perfil,
                des_perfil                
            from 
                perfil             
                where
                id_perfil = xid_perfil; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_perfil] error al cargar perfil sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_prioridad(xid_prioridad numeric, OUT prioridad refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open prioridad  for

            select
                id_prioridad,
                des_prioridad                
            from 
                prioridad             
                where
                id_prioridad = xid_prioridad; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_prioridad  error al cargar prioridad sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_prioridad(xid_prioridad numeric, OUT prioridad refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open prioridad  for

            select
                id_prioridad,
                des_prioridad                
            from 
                prioridad             
                where
                id_prioridad = xid_prioridad; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_prioridad  error al cargar prioridad sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_producto(xid_producto numeric, OUT producto refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open producto  for

            select
                id_producto,
                des_producto                
            from 
                producto             
                where
                id_producto = xid_producto; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_producto  error al cargar producto sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_producto(xid_producto numeric, OUT producto refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open producto  for

            select
                id_producto,
                des_producto                
            from 
                producto             
                where
                id_producto = xid_producto; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_producto  error al cargar producto sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_reclamo(xid_reclamo numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open reclamos for

            select
                id_reclamo,
                num_adherente,
                nombre_solicitante,
                email_solicitante,
                fono_solicitante,
                region_solicitante,
                id_tipo,
                id_motivo,
                id_prioridad,
                id_cartera,
                fec_ingreso,
                glosa,
                adjunto,
                observaciones,
                id_estado,
                responsable_ingreso,
                responsable_actual,
                dias_bandeja,
                dias_sistema,
                id_medio_respuesta,
                fec_respuesta
            from 
                reclamo
            where
                id_reclamo = xid_reclamo;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_reclamo] error al cargar reclamo(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_reclamo(xid_reclamo numeric, OUT reclamos refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open reclamos for

            select
                id_reclamo,
                num_adherente,
                nombre_solicitante,
                email_solicitante,
                fono_solicitante,
                region_solicitante,
                id_tipo,
                id_motivo,
                id_prioridad,
                id_cartera,
                fec_ingreso,
                glosa,
                adjunto,
                observaciones,
                id_estado,
                responsable_ingreso,
                responsable_actual,
                dias_bandeja,
                dias_sistema,
                id_medio_respuesta,
                fec_respuesta
            from 
                reclamo
            where
                id_reclamo = xid_reclamo;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_reclamo] error al cargar reclamo(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_tipo(xid_tipo numeric, OUT tipo refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open tipo  for

            select
                id_tipo,
                des_tipo                
            from 
                tipo             
                where
                id_tipo = xid_tipo; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_tipo  error al cargar tipo sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_tipo(xid_tipo numeric, OUT tipo refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open tipo  for

            select
                id_tipo,
                des_tipo                
            from 
                tipo             
                where
                id_tipo = xid_tipo; 

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[cargar_tipo  error al cargar tipo sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION cargar_usuario(xnidusuario numeric, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
        open usuarios for

            select
                idusuario,
                rut,
                dv,
                nombres,
                apepaterno,
                apematerno,
                nomusuario,
                contrasena,
                codgenero,
                fecnacimiento,
                direccion,
                idcomuna,
                idprovincia, 
                idregion,
                codpais,
                telefono,
                celular,
                email,
                cantintentos,
                feccreacion,
                feccontrasena,
                indvigencia
            from 
                usuario
            where
                idusuario = xnidusuario;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_usuarios] error al cargar usuario(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bak-04-11-2014.sql
"CREATE FUNCTION cargar_usuario(xnidusuario numeric, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
        open usuarios for

            select
                idusuario,
                rut,
                dv,
                nombres,
                apepaterno,
                apematerno,
                nomusuario,
                contrasena,
                codgenero,
                fecnacimiento,
                direccion,
                idcomuna,
                idprovincia, 
                idregion,
                codpais,
                telefono,
                celular,
                email,
                cantintentos,
                feccreacion,
                feccontrasena,
                indvigencia
            from 
                usuario
            where
                idusuario = xnidusuario;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_usuarios] error al cargar usuario(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bak-06-11-2014.sql
"CREATE FUNCTION cargar_usuario(xnidusuario numeric, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
        open usuarios for

            select
                idusuario,
                rut,
                dv,
                nombres,
                apepaterno,
                apematerno,
                nomusuario,
                contrasena,
                codgenero,
                fecnacimiento,
                direccion,
                idcomuna,
                idprovincia, 
                idregion,
                codpais,
                telefono,
                celular,
                email,
                cantintentos,
                feccreacion,
                feccontrasena,
                indvigencia
            from 
                usuario
            where
                idusuario = xnidusuario;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_usuarios] error al cargar usuario(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bak18.11.sql
"CREATE FUNCTION cargar_usuario(xnidusuario numeric, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open usuarios for

            select
                idusuario,
                rut,
                dv,
                nombres,
                apepaterno,
                apematerno,
                nomusuario,
                contrasena,
                codgenero,
                fecnacimiento,
                direccion,
                idcomuna,
                idprovincia, 
                idregion,
                codpais,
                telefono,
                celular,
                email,
                cantintentos,
                feccreacion,
                feccontrasena,
                indvigencia
            from 
                usuario
            where
                idusuario = xnidusuario;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_usuarios] error al cargar usuario(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",3-2-15.sql
"CREATE FUNCTION cargar_usuario(xnidusuario numeric, OUT usuarios refcursor, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

begin
    
    begin
    numerror := 0;
        msjerror := ' ';
        open usuarios for

            select
                idusuario,
                rut,
                dv,
                nombres,
                apepaterno,
                apematerno,
                nomusuario,
                contrasena,
                codgenero,
                fecnacimiento,
                direccion,
                idcomuna,
                idprovincia, 
                idregion,
                codpais,
                telefono,
                celular,
                email,
                cantintentos,
                feccreacion,
                feccontrasena,
                indvigencia
            from 
                usuario
            where
                idusuario = xnidusuario;

            exception
                when others then
                    numerror := sqlstate;
                    msjerror := '[carga_usuarios] error al cargar usuario(sql) ' ||sqlerrm;
                    return;	
    end;

end;

$$;",bkup.sql
"CREATE FUNCTION carregacomboremedio() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_remedio_fk from medicacao  ;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION carregacomboremedio() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_remedio_fk from medicacao  ;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION carregacomboremedio(cod integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_remedio, nome_remedio from remedios  inner join medicacao on cod_remedio = cod_remedio_fk where cod_remedio_fk = cod;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION carregacomboremedio(cod integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_remedio_fk from medicacao  where cod_tratamento_fk = cod;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION carregapaciente() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_paciente, nome_paciente,especie_paciente from paciente  inner join consulta on cod_paciente = cod_paciente_fk;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION carregapaciente(cod integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT cod_paciente, nome_paciente,especie_paciente from paciente  inner join consulta on cod_paciente = cod_paciente_fk where cod_consulta = cod;
 	
reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION category_getlist() RETURNS json
    LANGUAGE plpgsql
    AS $$
DECLARE
	vResult json;
	vStatus INT;
	vErrorCode INT;
	vErrorMsg varchar;
BEGIN
	vStatus = 0;

	SELECT json_build_object('status',vStatus,'result',array_to_json(array_agg(temp))) INTO vResult
	FROM (SELECT
		  c.cat_id,c.cat_name,c.cat_desc, c.cat_type,c.cat_parent,
		  CASE WHEN f.cat_id is not NULL THEN json_agg(f.*) ELSE null END AS file
		FROM category c
		LEFT OUTER JOIN (select file_id,file_name,file_desc,file_type,file_path,cat_id from file) f USING (cat_id)
		GROUP BY c.cat_id,c.cat_name,c.cat_desc, c.cat_type,c.cat_parent,f.cat_id)as temp;

	RETURN vResult;
	
EXCEPTION WHEN OTHERS THEN
	vErrorCode = 120;
	vStatus = -1;
	GET STACKED DIAGNOSTICS vErrorMsg = MESSAGE_TEXT;
	SELECT json_build_object('status',vStatus,'error_code',vErrorCode,'error_msg',vErrorMsg,'result',null) into vResult;
	RETURN vResult;
END
$$;",backup_local_db.sql
"CREATE FUNCTION caucionmain(indocumentado integer, scedula integer, pn character varying, pa character varying, sn character varying, sa character varying, sexo character, nacion character, parro integer, lug character varying, parrot integer, lugt character varying, num_delito integer, descdelito character varying, telef character varying, edc character varying, profe character varying, fechan date, img character varying, num integer) RETURNS void
    LANGUAGE plpgsql
    AS $$

DECLARE
Indo integer;
FN integer;

 BEGIN 
 
  Select (LEAST(COALESCE(MIN(Ind.Cedula),1),0)-1) from view_Individuos AS Ind INTO Indo;
  Select (COALESCE(MAX(ID_Ficha),-1)+1) from view_Fichas INTO FN;

  IF Indocumentado = 1 THEN
  
  PERFORM RegistrarIndividuo(Indo,PN,PA,SN,SA,Sexo,Nacion,Parro,Lug,ParroT,LugT);
  PERFORM RegistrarFicha(Indo,Num_Delito,DescDelito,Telef,EdC,Profe,(CAST(FechaN AS Date)),null);
  PERFORM RegistrarCaucion(FN,IMG,Num);

  ELSE
  
   IF exists(Select * from individuos AS Ind WHERE Ind.cedula = SCedula) THEN
   
   PERFORM RegistrarFicha(SCedula,Num_Delito,DescDelito,Telef,EdC,Profe,(CAST(FechaN AS Date)),null);
   PERFORM RegistrarCaucion(FN,IMG,Num);
   
   ELSE 
   
   PERFORM RegistrarIndividuo(SCedula,PN,PA,SN,SA,Sexo,Nacion,Parro,Lug,ParroT,LugT);
   PERFORM RegistrarFicha(SCedula,Num_Delito,DescDelito,Telef,EdC,Profe,(CAST(FechaN AS Date)),null);
   PERFORM RegistrarCaucion(FN,IMG,Num);
  
   END IF;
  END IF;
 
 END;
$$;",respaldo_001.sql
"CREATE FUNCTION census_data_search(in_search_type integer, in_ward_no integer, in_block_no text, in_gender text, in_community text, in_age integer, in_house_no text) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
    result refcursor := 'cur';
    cmale int;
    cfemale int;
    csc int;
    cgn int;
    cbc int;
    ctotal int;
    
BEGIN
	IF in_search_type = 1
	THEN	
	   OPEN result
	   FOR  SELECT * FROM census_details WHERE     (ward_no = in_ward_no OR in_ward_no = 'All')
						   AND (block_no = in_block_no OR in_block_no = 'All')
						   AND (gender = in_gender OR in_gender = 'All')
						   AND (community = in_community  OR in_community = 'All')
						   AND (age >= in_age OR in_age = 0)
						   AND (house_no = in_house_no OR in_house_no = 'All');
	  RETURN result; 					   
	ELSE
	 RETURN 1;																			   
	END IF;    
	
END;
$$;",census_details1.txt
"CREATE FUNCTION census_data_summary(in_ward_no integer, in_block_no text, in_age integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
declare
	r_gender refcursor := 'gcur';
	r_community refcursor := 'rcur';
begin
	open r_gender
	for select gender,count(1)
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 0)
	       and(block_no = in_block_no or in_block_no = 'All')
	       and(age >= in_age)
	    group by gender;   
	return next r_gender;    

	open r_community
	for select community,count(1)
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 0)
	       and(block_no = in_block_no or in_block_no = 'All')
	       and(age >= in_age)
	    group by community;   
	return next r_community;    
end;
$$;",census_details1.txt
"CREATE FUNCTION census_data_summary(in_ward_no text, in_block_no text, in_age integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
declare
	r_gender refcursor := 'gcur';
	r_community refcursor := 'rcur';
begin
	open r_gender
	for select gender,count(1),ward_no
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 'All')
	       and(block_no = in_block_no or in_block_no = 'All')
	       and(age >= in_age)
	    group by gender;   
	return next r_gender;    

	open r_community
	for select community,count(1),ward_no
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 'All')
	       and(block_no = in_block_no or in_block_no = 'All')
	       and(age >= in_age)
	    group by community;   
	return next r_community;    
end;
$$;",census_details1.txt
"CREATE FUNCTION censusdatasearch(insearchtype integer, inwardno integer, inblockno text, ingender text, incommunity text, inage integer, inhouseno text) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
    result refcursor := 'cur';
    cmale int;
    cfemale int;
    csc int;
    cgn int;
    cbc int;
    ctotal int;
    
BEGIN
	IF inSearchType = 1
	THEN	
	   OPEN result
	   FOR  SELECT * FROM ""CensusDetails"" WHERE    (""WardNo"" = inWardNo OR inWardNo = 0)
						   AND (""BlockNo"" = inBlockNo OR inBlockNo = 'All')
						   AND (""Gender"" = inGender OR inGender = 'All')
						   AND (""Community"" = inCommunity  OR inCommunity = 'All')
						   AND (""Age"" >= inAge OR inAge = 0)
						   AND (""HouseNo"" = inHouseNo OR inHouseNo = 'All');
	  RETURN result; 					   
	ELSE

	   SELECT COUNT(*) from ""CensusDetails"" INTO cmale WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0)
							     AND ""Gender"" = 'Male';
							     
	   SELECT COUNT(*) from ""CensusDetails"" INTO cfemale WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0)
							     AND ""Gender"" = 'Female';
							     
	   SELECT COUNT(*) from ""CensusDetails"" INTO csc WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0)
							     AND ""Community"" = 'SC';	
							     						     					     
	   SELECT COUNT(*) from ""CensusDetails"" INTO cbc WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0)
							     AND ""Community"" = 'BC';

	   SELECT COUNT(*) from ""CensusDetails"" INTO cgn WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0)
							     AND ""Community"" = 'GN';
							     
	   SELECT COUNT(*) from ""CensusDetails"" INTO ctotal WHERE (""WardNo"" = inWardNo OR inWardNo = 0)
							     AND (""BlockNo"" = inBlockno OR inBlockNo = 'All')
							     AND (""Age"" >= inAge OR inAge = 0);
								     								     	
	   					   
	END IF;    
	
END;
$$;",census_details1.txt
"CREATE FUNCTION censusdatasearch1(insearchtype integer, inwardno integer, inblockno text, ingender text, incommunity text, inage integer, inhouseno text) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
    result refcursor := 'cur';
    
BEGIN
	IF inSearchType = 1
	THEN	
	   OPEN result
	   FOR  SELECT * FROM ""CensusDetails"" WHERE    (""WardNo"" = inWardNo OR inWardNo = 0)
						   AND (""BlockNo"" = inBlockNo OR inBlockNo = 'All')
						   AND (""Gender"" = inGender OR inGender = 'All')
						   AND (""Community"" = inCommunity  OR inCommunity = 'All')
						   AND (""Age"" >= inAge OR inAge = 0)
						   AND (""HouseNo"" = inHouseNo OR inHouseNo = 'All');
	  RETURN result; 					   
	ELSE
	   return 1;
	END IF;    
	
END;
$$;",census_details1.txt
"CREATE FUNCTION cesnsus_data_summary(in_ward_no integer, in_block_no text, in_age integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
declare
	r_gender refcursor := 'gcur';
	r_community refcursor := 'rcur';
begin
	open r_gender
	for select gender,count(1)
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 0)
	       and(block_no = in_block_no or in_block_no = 0)
	       and(age >= in_age)
	    group by gender;   
	return next r_gender;    

	open r_community
	for select community,count(1)
	    from census_details
	    where (ward_no = in_ward_no or in_ward_no = 0)
	       and(block_no = in_block_no or in_block_no = 0)
	       and(age >= in_age)
	    group by community;   
	return next r_community;    
end;
$$;",census_details1.txt
"CREATE FUNCTION changecustsummsubass(text, text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	pCustNumber ALIAS FOR $4;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('changecustsummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber));



	PERFORM (SELECT changecustpart(	pItemNumber,

					pRevision,

					pSerialNumber,

					pCustNumber));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT changecustpart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber,

							pCustNumber));

		END IF;

	END LOOP;

		  

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION changelocsummsubass(text, text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	pLocNumber ALIAS FOR $4;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('changelocsummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber));

	

	PERFORM (SELECT changelocpart(	pItemNumber,

					pRevision,

					pSerialNumber,

					pLocNumber));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT changelocpart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber,

							pLocNumber));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION changelog_type_to_name(changelog_type changelog_types) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	case changelog_type
		when 'control_date_changed'     then return 'Изменена дата контроля';
		when 'comment_added'            then return 'Добавлен комментарий';
		when 'opened'                   then return 'Открыто';
		when 'closed'                   then return 'Закрыто';
		when 'control_member_changed'   then return 'Изменен контроллёр';
		when 'performer_member_changed' then return 'Изменен исполнитель';
		when 'owner_member_changed'     then return 'Изменен владелец';
		when 'document_added'           then return 'Добавлен документ';
		when 'description_edited'       then return 'Изменено описание';
		when 'member_created'           then return 'Создан пользователь';
		when 'priority_changed'         then return 'Изменён приоритет';
		when 'member_edited'            then return 'Отредактирован пользователь';
		when 'member_right_changed'     then return 'Изменены права пользователя';
		when 'division_created'         then return 'Создано подразделение';
		when 'division_edited'          then return 'Изменено подразделение';
		when 'file_uploaded'            then return 'Загружен файл';
		when 'caption_edited'           then return 'Изменён заголовок';
		when 'division_changed'         then return 'Изменено целевое подразделение';
		when 'coworker_added'           then return 'Добавлен исполнитель в рабочую группу';
		when 'coworker_removed'         then return 'Исполнитель удален из рабочей группы';
	end case;
	return concat('Функция changelog_type_to_name требует исправлений. Тип: ', changelog_type);
end
$$;",shema.sql
"CREATE FUNCTION changestatesummsubass(text, text, text, text, boolean DEFAULT false, boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	pTargetPartState ALIAS FOR $4;

	pOverride ALIAS FOR $5;

	pForce ALIAS FOR $6;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('changestatesummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber));

	

	PERFORM (SELECT changestatepart(pItemNumber,

					pRevision,

					pSerialNumber,

					pTargetPartState,

					pOverride,

					pForce));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT changestatepart(_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber,

							pTargetPartState,

							pOverride,

							pForce));

		END IF;

	END LOOP;

		  

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION char_add(character, character) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  $1||$2;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION check_automatic_maintenance_value (p_automatic_maintenance text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $$
DECLARE
v_result    boolean;
BEGIN
/* 
 * Check for valid config values for automatic maintenance
 * (not boolean to allow future values)
 */
    SELECT p_automatic_maintenance IN ('on', 'off') INTO v_result;
    RETURN v_result;
END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE FUNCTION check_email(par_email character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
    declare
      local_response text;
      local_id bigint;
    begin
      select into local_id id
      from User_contacts
      where User_contacts.email = par_email;

      if local_id isnull then
        local_response = 'OK';
      else
        local_response = 'ALREADY EXISTS';
      end if;

      return local_response;
    end;
  $$;",foodcart.backup
"CREATE FUNCTION check_email_password(par_email character varying, par_password character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
    declare
      local_response text;
    begin
      select into local_response email
      from Users, User_contacts
      where User_contacts.email = par_email
      and Users.user_password = par_password;

      if local_response isnull then
        local_response = 'FAILED';
      else
        local_response = 'OK';
      end if;

      return local_response;
    end;
  $$;",foodcart.backup
"CREATE FUNCTION check_for_deviation_of_measurements() RETURNS void
    LANGUAGE plpgsql
    AS $$
declare

	min_measured_value aems.""MeterData"".measured_value%type;
	max_measured_value aems.""MeterData"".measured_value%type;
	avg_measured_value aems.""MeterData"".measured_value%type;
	min_negative_deviation aems.""Notifications"".min_negative_deviation%type;
	min_positive_deviation aems.""Notifications"".min_positive_deviation%type;

	negative_deviation_present boolean;
	positive_deviation_present boolean;

	deviation_period aems.""Periods"".id%type;
	
	meter_row record;
	notification_exception record;
	meter_data record;
	substraction_days decimal(3, 0);
begin

	for meter_row in (select meter as ""id"", notification
			  from aems.""NotificationMeters"") loop

		deviation_period := -1;
		negative_deviation_present := false;
		positive_deviation_present := false;

		select avg(measured_value), min(measured_value), max(measured_value) into avg_measured_value, min_measured_value, max_measured_value
		from aems.""MeterData""
		where meter = meter_row.id;

		select n.""min_negative_deviation"", n.""min_positive_deviation"" into min_negative_deviation, min_positive_deviation
		from aems.""Notifications"" n
		where id = meter_row.notification;

		if min_measured_value < avg_measured_value - (avg_measured_value * (min_negative_deviation / 100.0)) then
			-- raise notice 'negative deviation detected: %', notification_exception.period;
			deviation_period := 0;
			negative_deviation_present := true;
		end if;

		if max_measured_value > avg_measured_value + (avg_measured_value * (min_positive_deviation / 100.0)) then
			-- raise notice 'positive deviation detected: %', notification_exception.period;
			deviation_period := 0;
			positive_deviation_present := true;
		end if;

		for notification_exception in (select a.period, a.min_positive_deviation, a.min_negative_deviation
						from aems.""NotificationExceptions"" a
						inner join aems.""Notifications"" b on (a.notification = b.id)
						where meter_row.notification = b.id
						order by a.period desc ) loop

			-- raise notice 'period: %', notification_exception.period;

			if notification_exception.period = 1 then -- daily
				substraction_days := 1;
			elsif notification_exception.period = 2 then -- weekly
				substraction_days := 7;
			elsif notification_exception.period = 3 then -- monthly
				substraction_days := 31;
			elsif notification_exception.period = 4 then -- yearly
				substraction_days := 365;
			end if;
		
			for meter_data in (select avg(measured_value) as avg, min(measured_value) as min, max(measured_value) as max
					   from aems.""MeterData""
					   where meter = meter_row.id and ""timestamp"" between (now()::timestamp - (substraction_days || ' days')::interval) and now()::timestamp) loop

				-- raise notice '%', meter_data;

				negative_deviation_present := meter_data.min < meter_data.avg - (meter_data.avg * (notification_exception.min_negative_deviation / 100.0));
				positive_deviation_present := meter_data.max > meter_data.avg + (meter_data.avg * (notification_exception.min_positive_deviation / 100.0));

				if negative_deviation_present or positive_deviation_present then
					
				end if;

				if negative_deviation_present then
					-- raise notice 'negative deviation detected: %', notification_exception.period;
					deviation_period := notification_exception.period;
					min_measured_value := meter_data.min;
				end if;

				if positive_deviation_present then
					-- raise notice 'positive deviation detected: %', notification_exception.period;
					deviation_period := notification_exception.period;
					max_measured_value := meter_data.max;
				end if;
				
			end loop;

		end loop;

		-- raise notice 'deviation min: % max: % period: %', min_measured_value, max_measured_value, deviation_period;
		perform aems.""archive_meter_notification""(meter_row.id, meter_row.notification, positive_deviation_present, negative_deviation_present, min_measured_value, max_measured_value, deviation_period);			

	end loop;

end;

$$;",AEMS%2027-03-2018.backup
"CREATE FUNCTION check_hex_range(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_temp text;
    c_r1 integer;
    c_r2 integer;
begin

    c_temp := split_part(i_rule, '-', 1);
    while length(c_temp) < 4 loop
        c_temp := '0' || c_temp;
    end loop;
    c_r1 := cast(cast('x' || cast(c_temp as text) as bit(16)) as integer);
    c_temp := split_part(i_rule, '-', 2);
    while length(c_temp) < 4 loop
        c_temp := '0' || c_temp;
    end loop;
    c_r2 := cast(cast('x' || cast(c_temp as text) as bit(16)) as integer);
    if i_octet between c_r1 and c_r2 then
        return 't';
    end if;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_hex_rule(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_element text;
    c_work  text;
begin
    if i_rule = '*' then   -- * matches anything!
        return 't';
    end if;

    c_work := i_rule;
    while c_work <> '' loop
        -- raise notice 'c_work = %',c_work;
        if c_work ~ ',' then
            c_element := substr(c_work, 0, strpos(c_work, ','));
            c_work := substr(c_work, strpos(c_work, ',')+1);
        else
            c_element := c_work;
            c_work := '';
        end if;

        if c_element ~ '-' then
            if check_hex_range(i_octet, c_element) then
                return 't';
            end if;
        else
            while length(c_element) < 4 loop
                c_element := '0' || c_element;
            end loop;
            if i_octet = cast(cast('x' || cast(c_element as text) as bit(16)) as integer) then
                return 't';
            end if;
        end if;
    end loop;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_id_exists(col character varying, val integer, uid integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
declare
result int[];
begin
execute format('SELECT %I FROM users WHERE user_id = $1 AND $I @> ''{$2}''::int[]', col, col) USING uid, val INTO result;
end
$_$;",database.pgsql
"CREATE FUNCTION check_printer_perm(character varying, inet, character varying, character varying) RETURNS boolean
    AS $_$
    DECLARE
        printer_id INTEGER;
    BEGIN
        printer_id := (select printers.id 
			from printers 
				INNER JOIN printers_mandat ON (printers.mandat_id = printers_mandat.id) 
				INNER JOIN rel_mandat2doc_level ON ( rel_mandat2doc_level.mandat_id =printers_mandat.id) 
				INNER JOIN document_level ON (document_level.id = rel_mandat2doc_level.doclevel_id)
			where 
				printers.printer_name=$1 and 
				printers.ip_adress=$2 and 
				printers_mandat.mandat=$3 and 
				document_level.marker=$4
			); 
        IF printer_id ISNULL THEN
            RETURN 0;
        END IF;
        RETURN 1;
    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup
"CREATE FUNCTION check_printer_perm(character varying, inet, character varying, character varying) RETURNS integer
    AS $_$
    DECLARE
        printer_id INTEGER;
    BEGIN
        printer_id := (select printers.id 
			from printers 
				INNER JOIN printers_mandat ON (printers.mandat_id = printers_mandat.id) 
				INNER JOIN rel_mandat2doc_level ON ( rel_mandat2doc_level.mandat_id =printers_mandat.id) 
				INNER JOIN document_level ON (document_level.id = rel_mandat2doc_level.doclevel_id)
			where 
				printers.printer_name=$1 and 
				printers.ip_adress=$2 and 
				printers_mandat.mandat=$3 and 
				document_level.marker=$4
			); 
        IF printer_id ISNULL THEN
            RETURN 0;
        END IF;
        RETURN 1;
    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup.sql
"CREATE FUNCTION check_range(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_r1 integer;
    c_r2 integer;
begin

    c_r1 := to_number(split_part(i_rule, '-', 1), '999');
    c_r2 := to_number(split_part(i_rule, '-', 2), '999');
    if i_octet between c_r1 and c_r2 then
        return 't';
    end if;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_restaurant(par_restoname character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
		declare
			local_name varchar;
			local_id bigint;

		begin
			select into local_name resto_name
			from Restaurants
			where resto_name = par_restoName;

			if local_name isnull
			then
				local_id = 0;
			else
				select into local_id id
				from Restaurants
				where resto_name = par_restoName;

			end if;

			return local_id;

		end;

	$$;",foodcart.backup
"CREATE FUNCTION check_restaurant_branch(par_bldg character varying, par_street character varying, par_room character varying, par_restoid bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
    declare
      local_id int;
      local_response boolean;

    begin
      select into local_id id
      from Resto_branch_address
      where id in (select id
		               from Restaurant_branch
		               where resto_id = par_restoID)
		               and bldg_number = par_bldg and street = par_street and room_number = par_room;

      if local_id isnull
      then
        local_response = false; --does not exist

      else
        local_response = true; --does exist

      end if;

      return local_response;

    end;
  $$;",foodcart.backup
"CREATE FUNCTION check_rule(i_octet integer, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
    c_element text;
    c_work	text;
begin
    if i_rule = '*' then   -- * matches anything!
        return 't';
    end if;

    c_work := i_rule;
    while c_work <> '' loop
        -- raise notice 'c_work = %',c_work;
        if c_work ~ ',' then
            c_element := substr(c_work, 0, strpos(c_work, ','));
            c_work := substr(c_work, strpos(c_work, ',')+1);
        else
            c_element := c_work;
            c_work := '';
        end if;

        if c_element ~ '-' then
            if check_range(i_octet, c_element) then
                return 't';
            end if;
        else
            if i_octet = to_number(c_element, '99999') then
                return 't';
            end if;
        end if;
    end loop;
    return 'f';
end;
$$;",init-opennms.sql
"CREATE FUNCTION check_state_device() RETURNS boolean
    LANGUAGE plpgsql
    AS $$DECLARE
stateRow RECORD;
    BEGIN
	for stateRow IN SELECT * FROM state WHERE state_id = NEW.state_id
	LOOP
        return !(stateRow.battery_charge > battery_capacity(NEW.device_id) OR
        stateRow.amount_of_free_memory > device_memory_amount(NEW.device_id) OR stateRow.download_speed > total_network_speed(NEW.device_id)
         OR stateRow.upload_speed > total_network_speed(NEW.device_id));
        END LOOP;
     RAISE EXCEPTION 'Invalid query - returned more than one state';
END$$;",database
"CREATE FUNCTION check_state_device(st_id integer, dev_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$DECLARE
stateRow RECORD;
deviceRow RECORD;
    BEGIN
	SELECT * INTO stateRow FROM state WHERE state_id = st_id;
	SELECT * INTO deviceRow FROM device_full_data WHERE device_id = dev_id;
        return NOT(stateRow.battery_charge > deviceRow.battery_capacity OR
        stateRow.amount_of_free_memory > device_memory_amount(dev_id) OR stateRow.download_speed > deviceRow.networkadapter_max_speed
         OR stateRow.upload_speed > deviceRow.networkadapter_max_speed);
END$$;",database
"CREATE FUNCTION checkadminpwd(pwd_in character varying) RETURNS integer
    AS $$
 DECLARE
	r_id integer;
BEGIN
	select id into r_id from adminpwd where pwd=md5(pwd_in);
	if r_id IS NULL THEN
		return -1;
	ELSE
		return r_id;
	END if;
	
EXCEPTION
	WHEN OTHERS THEN 
		RETURN -1;
END;
$$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION checkalloc(text, text, text, text, text, text, integer DEFAULT 1) RETURNS TABLE(ocode text, omessage text)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pParentItemNumber ALIAS FOR $1;

	pParentRevision ALIAS FOR $2;

	pParentSerialNumber ALIAS FOR $3;

	pItemNumber ALIAS FOR $4;

	pRevision ALIAS FOR $5;

	pSerialNumber ALIAS FOR $6;

	pAllocPos ALIAS FOR $7;

	_parentviewpart RECORD;

	_viewpart RECORD;

	_qtyPerCurrent INTEGER;

	_qtyAllocCurrent INTEGER;

	_qtyPerAny INTEGER;

	_qtyAllocAny INTEGER;

	_locationId INTEGER;

	_partStateId INTEGER;

	_r RECORD;

	_error BOOLEAN;

  

BEGIN

	PERFORM (SELECT checkpriv('checkalloc'));

	BEGIN

		PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, 'Child'));

	EXCEPTION

		WHEN raise_exception THEN

			oCode := 	'AMDA008';

			oMessage := 	'Child Item Number ' || pItemNumber || 

					' Revision ' || pRevision || 

					' Serial Number ' || pSerialNumber || 

					' does not exist.';

			RETURN NEXT;

			RETURN;

			

	END;

	PERFORM (SELECT validatepart(pParentItemNumber, pParentRevision, pParentSerialNumber, 'Parent'));



	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_serialnumber, 

		part_sequencenumber,

		part_allocpos,

		parent_part_id,

		parent_item_number,

		parent_part_rev,

		parent_part_serialnumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;



	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_serialnumber, 

		part_sequencenumber

		parent_part_id

	INTO _parentviewpart

	FROM viewpart

	WHERE item_number = pParentItemNumber 

	AND part_serialnumber = pParentSerialNumber 

	AND part_rev = pParentRevision;



	_error := false;



	IF _viewpart.parent_part_id = _parentviewpart.part_id AND _viewpart.part_allocpos = pAllocPos THEN

		oCode := 	'AMDA002';

		oMessage := 	'Child Item Number ' || pItemNumber || 

				' Revision ' || pRevision || 

				' Serial Number ' || pSerialNumber || 

				' is already allocated to Parent Item Number ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'.';

		RETURN NEXT;

		RETURN;

	END IF;



	IF _viewpart.parent_part_id IS NOT NULL THEN

		oCode := 	'AMDA001';

		oMessage := 	'Child Item Number ' || pItemNumber || 

				' Revision ' || pRevision || 

				' Serial Number ' || pSerialNumber || 

				' is allocated to Parent Item Number ' || _viewpart.parent_item_number || 

				' Revision ' || _viewpart.parent_part_rev || 

				' Serial Number ' || _viewpart.parent_part_serialnumber || 

				' in allocation position ' || _viewpart.part_allocpos || 

				'.';

		RETURN NEXT;

		_error = true;

	END IF;



	_qtyPerCurrent := (SELECT checkserialbom(pParentItemNumber, pParentRevision, pItemNumber, pRevision));

	_qtyPerAny := (SELECT checkserialbom(pParentItemNumber, pParentRevision, pItemNumber, null));



	IF _qtyPerAny <= 0 THEN

		oCode := 	'AMDA003';

		oMessage := 	'Child Item Number ' || pItemNumber || 

				' Revision ANY Serial Number ' || pSerialNumber || 

				' not found in BOM of Parent Item Number  ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'.'; 

		RETURN NEXT;

		_error = true;

	ELSIF _qtyPerCurrent <= 0 THEN

		oCode := 	'AMDA004';

		oMessage := 	'Child Item Number ' || pItemNumber || 

				' Revision ' || pRevision || 

				' Serial Number ' || pSerialNumber || 

				' not found in BOM of Parent Item Number ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'.';

		RETURN NEXT;

		_error = true;

	END IF;



	_qtyAllocCurrent := 	(SELECT COUNT(c_item_number) 

				FROM serialsubass(pParentItemNumber, pParentRevision, pParentSerialNumber) 

				WHERE p_item_number = pParentItemNumber 

				AND c_item_number = pItemNumber

				AND c_part_rev = pRevision);

	_qtyAllocAny	:= 	(SELECT COUNT(c_item_number) 

				FROM serialsubass(pParentItemNumber, pParentRevision, pParentSerialNumber) 

				WHERE p_item_number = pParentItemNumber 

				AND c_item_number = pItemNumber);



	IF (_qtyPerCurrent > 0 AND _qtyAllocCurrent >= _qtyPerCurrent) THEN

		oCode := 	'AMDA005';

		oMessage := 	'Qty ' || _qtyAllocCurrent || 

				' of Item Number ' || pItemNumber || 

				' Revision ' || pRevision || 

				' already allocted to Parent Item Number ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'. Only ' || _qtyPerCurrent || 

				' may be allocated as per BOM Qty Per.';

		RETURN NEXT;

		_error = true;

	ELSIF (_qtyPerAny > 0 AND _qtyAllocAny >= _qtyPerAny) THEN

		oCode := 	'AMDA006';

		oMessage := 	'Qty ' || _qtyAllocAny || 

				' of Item Number ' || pItemNumber || 

				' Revision ANY already allocted to Parent Item Number ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'. Only ' || _qtyPerAny || 

				' may be allocated as per BOM Qty Per.';

		RETURN NEXT;

		_error = true;

	END IF;



	IF (NOT _error) THEN

		oCode := 	'AMDA007';

		oMessage := 	'Child Item Number ' || pItemNumber || 

				' Revision ' || pRevision || 

				' Serial Number ' || pSerialNumber || 

				' can be allocated to Parent Item Number ' || pParentItemNumber || 

				' Revision ' || pParentRevision || 

				' Serial Number ' || pParentSerialNumber || 

				'.';

		RETURN NEXT;

	END IF;



	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION checkkickoff(mission integer) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$
DECLARE
	ret TIMESTAMP with time zone;
BEGIN
	SELECT INTO ret ""kickoff"" FROM ""missions"" WHERE ""missionId"" = mission;
	RETURN ret;
END
$$;",MiMissionMVC_20171210_193535.sql
"CREATE FUNCTION checkpartstateflow(text, text, boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pCurrentState	ALIAS FOR $1;

	pTargetState	ALIAS FOR $2;

	pOverride	ALIAS FOR $3;

	_stateInfo	RECORD;

BEGIN

	PERFORM (SELECT checkpriv('checkpartstateflow'));

	PERFORM (SELECT getpartstateid(pCurrentState));

	PERFORM (SELECT getpartstateid(pTargetState));



	IF pCurrentState = pTargetState THEN

		RETURN true;

	END IF;

		

	SELECT 	start_partstate_id,

		start_partstate_name,

		start_partstate_active,

		end_partstate_id,

		end_partstate_name,

		end_partstate_active,

		partstateflow_id,

		partstateflow_active,

		partstateflow_overridereq

	INTO _stateInfo

	FROM viewpartstateflow

	WHERE start_partstate_name = pCurrentState

	AND end_partstate_name = pTargetState;



	IF _stateInfo.partstateflow_id IS NULL THEN

		RAISE EXCEPTION 'checkpartstateflow: Part State Flow does not exist for Current State % to Target State %.', 

			pCurrentState,

			pTargetState;

	ELSIF _stateInfo.partstateflow_active = false THEN

		RAISE EXCEPTION 'checkpartstateflow: Part State Flow is not active for Current State % to Target State %.', 

			pCurrentState,

			pTargetState;

	ELSIF _stateInfo.end_partstate_active = false THEN

		RAISE EXCEPTION 'checkpartstateflow: Target Part State % is not active.', 

			pTargetState;

	ELSIF _stateInfo.partstateflow_overridereq = true AND pOverride = false THEN

		RAISE EXCEPTION 'checkpartstateflow: Part State Flow requires override for Current State % to Target State %.', 

			pCurrentState,

			pTargetState;

	ELSIF _stateInfo.partstateflow_overridereq = true AND pOverride = true THEN

		PERFORM (SELECT checkpriv('checkpartstateflowoverride'));

	END IF;



	RETURN true;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION checkpriv(text, text DEFAULT ""current_user""()) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pPriv 		ALIAS FOR $1;

	pUserName	ALIAS FOR $2;

	_privGranted 	RECORD;

	_usrId		INTEGER;

BEGIN		

	SELECT usr_username, priv_name

	INTO _privGranted

	FROM viewprivgranted

	WHERE usr_username = pUserName

	AND priv_name = pPriv;



	IF _privGranted.usr_username IS NULL 

	OR (_privGranted.usr_username != pUserName) 

	OR (_privGranted.priv_name != pPriv) THEN

		RAISE EXCEPTION 'checkpriv: User Name % does not have Privilege %.', 

			pUserName,

			pPriv;

	END IF;



	RETURN true;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION checkserialbom(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pParentItemNumber ALIAS FOR $1;

	pParentRevision ALIAS FOR $2;

	pItemNumber ALIAS FOR $3;

	pRevision ALIAS FOR $4;

	_parentitem RECORD;

	_item RECORD;

	_serialbom RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('checkserialbom'));

	

	IF pRevision IS NULL THEN

		pRevision = '%';

	END IF;



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _parentitem

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pParentItemNumber 

	AND item_active = true;



	IF _parentitem.item_id IS NULL THEN

		RAISE EXCEPTION 'checkserialbom: Parent Item Number % not found in AeryonMES', pParentItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _parentitem.item_id

	    AND itemrev_rev = pParentRevision) IS NULL THEN

		RAISE EXCEPTION 'checkserialbom: Parent Revision % of Selected Parent Item % Not Found in AeryonMES', pParentRevision, pParentItemNumber;

	END IF;



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'checkserialbom: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev LIKE pRevision LIMIT 1) IS NULL THEN

		RAISE EXCEPTION 'checkserialbom: Revision % of Selected Item % Not Found in AeryonMES', pRevision, pItemNumber;

	END IF;



	SELECT *

	INTO _serialbom

	FROM serialbom(pParentItemNumber, pParentRevision)

	WHERE c_item_number = pItemNumber

	AND c_bom_itemrev LIKE pRevision;





	IF _serialbom.c_item_number IS NULL THEN

		RETURN 0; 

	END IF;

	

	RETURN _serialbom.c_bom_qtyper;

END;$_$;",ames_dev.backup
"CREATE FUNCTION checksummbom(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pParentItemNumber ALIAS FOR $1;

	pParentRevision ALIAS FOR $2;

	pItemNumber ALIAS FOR $3;

	pRevision ALIAS FOR $4;

	_parentitem RECORD;

	_item RECORD;

	_summbom RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('checksummbom'));



	IF pRevision IS NULL THEN

		pRevision = '%';

	END IF;



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _parentitem

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pParentItemNumber 

	AND item_active = true;



	IF _parentitem.item_id IS NULL THEN

		RAISE EXCEPTION 'checksummbom: Parent Item Number % not found in AeryonMES', pParentItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _parentitem.item_id

	    AND itemrev_rev = pParentRevision) IS NULL THEN

		RAISE EXCEPTION 'checksummbom: Parent Revision % of Selected Parent Item % Not Found in AeryonMES', pParentRevision, pParentItemNumber;

	END IF;



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'checksummbom: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev LIKE pRevision LIMIT 1) IS NULL THEN

		RAISE EXCEPTION 'checksummbom: Revision % of Selected Item % Not Found in AeryonMES', pRevision, pItemNumber;

	END IF;



	SELECT *

	INTO _summbom

	FROM summbom(pParentItemNumber, pParentRevision)

	WHERE c_item_number = pItemNumber

	AND c_bom_itemrev LIKE pRevision;





	IF _summbom.c_item_number IS NULL THEN

		RETURN 0; 

	END IF;

	

	RETURN _summbom.c_bom_qtyper;

END;$_$;",ames_dev.backup
"CREATE FUNCTION checkuser(username character varying, pwd character varying) RETURNS integer
    AS $$
 DECLARE
	r_id integer;
BEGIN
	select id into r_id from ""user"" where strname=username AND password=md5(pwd);
	if r_id IS NULL THEN
		return -1;
	ELSE
		return r_id;
	END if;
	
EXCEPTION
	WHEN OTHERS THEN 
		RETURN -1;
END;
$$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION chktimediffer(seltime timestamp with time zone, exttime timestamp with time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$ DECLARE 
BEGIN
RETURN  (locum_db.getintervaltointeger($2) - locum_db.getintervaltointeger($1));
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION clean_ids() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
allOkey integer default 1;
BEGIN
PERFORM setval('acos_id_seq', (SELECT MAX(id) FROM acos)+1);
PERFORM setval('aros_id_seq', (SELECT MAX(id) FROM aros)+1);
PERFORM setval('aros_acos_id_seq', (SELECT MAX(id) FROM aros_acos)+1);
PERFORM setval('basicstatus_id_seq', (SELECT MAX(id) FROM basicstatus)+1);
PERFORM setval('secassigns_id_seq', (SELECT MAX(id) FROM secassigns)+1);
PERFORM setval('secorganizations_id_seq', (SELECT MAX(id) FROM secorganizations)+1);
PERFORM setval('secpasswords_id_seq', (SELECT MAX(id) FROM secpasswords)+1);
PERFORM setval('secpeople_id_seq', (SELECT MAX(id) FROM secpeople)+1);
PERFORM setval('secprograms_id_seq', (SELECT MAX(id) FROM secprograms)+1);
PERFORM setval('secprojects_id_seq', (SELECT MAX(id) FROM secprojects)+1);
PERFORM setval('secroles_id_seq', (SELECT MAX(id) FROM secroles)+1);
PERFORM setval('worclients_id_seq', (SELECT MAX(id) FROM worclients)+1);
PERFORM setval('worcurrencies_id_seq', (SELECT MAX(id) FROM worcurrencies)+1);
PERFORM setval('wordocuments_id_seq', (SELECT MAX(id) FROM wordocuments)+1);
PERFORM setval('wordocumenttypes_id_seq', (SELECT MAX(id) FROM wordocumenttypes)+1);
PERFORM setval('wordollartypechanges_id_seq', (SELECT MAX(id) FROM wordollartypechanges)+1);
PERFORM setval('worentrynotedetails_id_seq', (SELECT MAX(id) FROM worentrynotedetails)+1);
PERFORM setval('worentrynotes_id_seq', (SELECT MAX(id) FROM worentrynotes)+1);
PERFORM setval('worentrynotes_worparameters_id_seq', (SELECT MAX(id) FROM worentrynotes_worparameters)+1);
PERFORM setval('worestimatedetails_id_seq', (SELECT MAX(id) FROM worestimatedetails)+1);
PERFORM setval('worestimates_id_seq', (SELECT MAX(id) FROM worestimates)+1);
PERFORM setval('worestimatestatus_id_seq', (SELECT MAX(id) FROM worestimatestatus)+1);
PERFORM setval('worinsurances_id_seq', (SELECT MAX(id) FROM worinsurances)+1);
PERFORM setval('worinvoicedetails_id_seq', (SELECT MAX(id) FROM worinvoicedetails)+1);
PERFORM setval('worinvoices_id_seq', (SELECT MAX(id) FROM worinvoices)+1);
PERFORM setval('workardexes_id_seq', (SELECT MAX(id) FROM workardexes)+1);
PERFORM setval('worothers_id_seq', (SELECT MAX(id) FROM worothers)+1);
PERFORM setval('woroutputticketdetails_id_seq', (SELECT MAX(id) FROM woroutputticketdetails)+1);
PERFORM setval('woroutputtickets_id_seq', (SELECT MAX(id) FROM woroutputtickets)+1);
PERFORM setval('woroutputtickets_worparameters_id_seq', (SELECT MAX(id) FROM woroutputtickets_worparameters)+1);
PERFORM setval('worparameters_id_seq', (SELECT MAX(id) FROM worparameters)+1);
PERFORM setval('worpaymenttipes_id_seq', (SELECT MAX(id) FROM worpaymenttipes)+1);
PERFORM setval('worpurchaseorderdetails_id_seq', (SELECT MAX(id) FROM worpurchaseorderdetails)+1);
PERFORM setval('worpurchaseorders_id_seq', (SELECT MAX(id) FROM worpurchaseorders)+1);
PERFORM setval('worpurchaseorderstatus_id_seq', (SELECT MAX(id) FROM worpurchaseorderstatus)+1);
PERFORM setval('worreasons_id_seq', (SELECT MAX(id) FROM worreasons)+1);
PERFORM setval('worseries_id_seq', (SELECT MAX(id) FROM worseries)+1);
PERFORM setval('worservices_id_seq', (SELECT MAX(id) FROM worservices)+1);
PERFORM setval('worservicetipes_id_seq', (SELECT MAX(id) FROM worservicetipes)+1);
PERFORM setval('worspareparts_id_seq', (SELECT MAX(id) FROM worspareparts)+1);
PERFORM setval('worstocks_id_seq', (SELECT MAX(id) FROM worstocks)+1);
PERFORM setval('worsuppliers_id_seq', (SELECT MAX(id) FROM worsuppliers)+1);
PERFORM setval('worubigeos_id_seq', (SELECT MAX(id) FROM worubigeos)+1);
PERFORM setval('worvehicles_id_seq', (SELECT MAX(id) FROM worvehicles)+1);
PERFORM setval('worwarehouses_id_seq', (SELECT MAX(id) FROM worwarehouses)+1);
PERFORM setval('worworkorderdetails_id_seq', (SELECT MAX(id) FROM worworkorderdetails)+1);
PERFORM setval('worworkorders_id_seq', (SELECT MAX(id) FROM worworkorders)+1);
PERFORM setval('worworkorderstatus_id_seq', (SELECT MAX(id) FROM worworkorderstatus)+1);
PERFORM setval('woworkordersdetails_id_seq', (SELECT MAX(id) FROM woworkordersdetails)+1);

return 1;
END;
$$;",tableropostgres.sql
"CREATE FUNCTION clearnonpersonusername() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
begin
        perform relname from pg_class where relname='lanenonpersonusername' and relnamespace=pg_my_temp_schema();
        if not found then
           return true;
        end if;
	drop table lanenonpersonusername;
       	return true;
end;
$$;",db.sql
"CREATE FUNCTION cliente_tiene_creditos(_id_persona bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
  _id_credito bigint := 0;
BEGIN
	SELECT c.id_credito INTO _id_credito FROM persona_credito pc
	INNER JOIN creditos c
	ON pc.id_credito = c.id_credito
	WHERE PC.id_persona = _id_persona AND c.credito_activo = TRUE AND pc.tipo_persona = 'CLIENTE';

	IF _id_credito is null THEN
		_id_credito = -1;
	END IF;

--	EXCEPTION
--	  WHEN raise exception THEN
--	   return false;

	RETURN _id_credito;
END $$;",creditosDBv5_schema.sql
"CREATE FUNCTION clinic.fun_scal_building(pstreet character varying, pbuilding character) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
	id int;
BEGIN
	SET SCHEMA 'clinic';
	SELECT id_address INTO id FROM addresses 
	WHERE street = pstreet and building = pbuilding;
	RETURN id;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_scal_get_nak(ppatient character) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
	nak int;
BEGIN 
	SET SCHEMA 'clinic';	
	nak = 0;	
	SELECT p.nak INTO nak FROM patients as p
	WHERE p.number_policy = ppatient;
	RETURN nak;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_scal_is_doc(ppost integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
	is_doc boolean;
BEGIN
	SET SCHEMA 'clinic';
	SELECT p.is_doc INTO is_doc
	FROM posts as p WHERE p.id_post = ppost;
	RETURN is_doc;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_scal_is_null_temp(ptemp_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
	count_notnull_rows int;
BEGIN   
	SET SCHEMA 'clinic';
	SELECT count(*) INTO count_notnull_rows 
	FROM  templates 
	WHERE (temp_name = ptemp_name) and (begin_time IS NOT NULL) and
		  (end_time IS NOT NULL) and  (time IS NOT NULL);
		  
	IF count_notnull_rows = 5 THEN RETURN true;
	ELSE RETURN false;
	END IF;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_scal_number_ak() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	index_ak int;
	exist int;
BEGIN
	index_ak = 99;
	exist = 1;
	WHILE exist <> 0 LOOP
		index_ak = index_ak +1;
		SELECT count(*) INTO exist FROM patients WHERE nak = index_ak;
	END LOOP;
	RETURN 	index_ak;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_scal_who_is_this(plogin character) RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE 
	exist int;
BEGIN
    SET SCHEMA 'clinic';
    SELECT count(*) INTO exist FROM med_workers WHERE worker = plogin;
    
    IF exist = 0 THEN
		RETURN 'W';
    ELSE
		SELECT count(*) INTO exist FROM doctors WHERE worker = plogin;
        IF exist = 0 THEN
			RETURN 'M';
        ELSE
			RETURN 'D';
        END IF;
    END IF;
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clinic.fun_upd_ins_graph_with_temp(ptemp_name character varying, pdoctor integer, pbegin_date date, pcount_day integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE 
	i int;
	notnull boolean;
BEGIN
	SET SCHEMA 'clinic';
	
		SELECT EXTRACT(DOW FROM pbegin_date) INTO i;
		pcount_day = pcount_day + i;
	
		BEGIN
			WHILE i <> pcount_day LOOP
				IF i%7 <> 6 and  i%7 <> 0 THEN
					PERFORM fun_upd_ins_graph(
						pbegin_date,
						pdoctor,
						(SELECT begin_time FROM templates WHERE week_day = i%7 and temp_name = ptemp_name),
						(SELECT end_time FROM templates WHERE week_day = i%7 and temp_name = ptemp_name),
						(SELECT time FROM templates WHERE week_day = i%7 and temp_name = ptemp_name)
					);
				END IF;
				pbegin_date = pbegin_date + 1;
				i = i+1;
			END LOOP; 
		END;  
END;
$$;",dumpClinic.sql
"CREATE FUNCTION clock_now() RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$

  DECLARE

    clock_mocked_at TIMESTAMP;

  BEGIN

    SELECT INTO clock_mocked_at key_value::TIMESTAMP FROM parameters WHERE category_name = 'Tests' AND key_name = 'clock_mocked_at';

    IF clock_mocked_at ISNULL OR NOT (inet_server_addr()::TEXT LIKE '192.168%') THEN

      RETURN clock_timestamp();

    END IF;

    RETURN clock_mocked_at;

  END;

$$;",dump20171228.sql
"CREATE FUNCTION clock_now() RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$

  DECLARE

    clock_mocked_at TIMESTAMP;

  BEGIN

    SELECT INTO clock_mocked_at key_value::TIMESTAMP FROM parameters WHERE category_name = 'Tests' AND key_name = 'clock_mocked_at';

    IF clock_mocked_at ISNULL OR NOT (inet_server_addr()::TEXT LIKE '192.168%') THEN

      RETURN clock_timestamp();

    END IF;

    RETURN clock_mocked_at;

  END;

$$;",dump_23-09-2017_10_26_25.sql
"CREATE FUNCTION clock_speed_per_core(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE result double precision;
BEGIN
	result = SUM(processor.cores_num*processor.clock_speed)/SUM(processor.cores_num) FROM processor JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON processor.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN result;
END;$$;",database
"CREATE FUNCTION cmdfindtopdeploymentid(integer, integer, date) RETURNS integer
    AS $_$ 

DECLARE 

-- Declare aliases for user input.
childId ALIAS FOR $1; 
deployId ALIAS FOR $2; 
onBeforeDate ALIAS FOR $3; 

-- Declare a variable to hold the returned record & deployment ID number.
itemLink RECORD; 
deploymentId INTEGER; 

BEGIN 

  -- Find the Parent of the given Child if they exist
  SELECT INTO itemLink CMDIL_ParentIDid, CMDIL_ChildIDid, CMDIL_DDid 
    FROM CMDItemLink 
    WHERE CMDIL_ChildIDid = childId and CMDILdate = (SELECT max(cmdildate) 
                                                     FROM CMDItemLink 
                                                     WHERE CMDIL_ChildIDid = childId and CMDILdate <= onBeforeDate); 

  -- if no record is returned or parent and child are the same then return passed in DeploymentId 
  IF itemLink.CMDIL_ParentIDid is null OR (itemLink.CMDIL_ParentIDid = itemLink.CMDIL_ChildIDid) THEN 
    deploymentId := itemLink.CMDIL_DDid;
  ELSE 
    -- if a parent exists for the given child look to see if this parent has a parent
    IF itemLink.CMDIL_ParentIDid <> childId THEN 
      deploymentId := cmdfindtopdeploymentid(itemLink.CMDIL_ParentIDid, itemLink.CMDIL_DDid, onBeforeDate); 
    END IF; 
  END IF; 

  RETURN deploymentId; 

END; 

$_$
    LANGUAGE plpgsql;",ABOS20110308.sql
"CREATE FUNCTION cmdfindtopparentid(integer, date) RETURNS integer
    AS $_$ 

DECLARE 

-- Declare aliases for user input.
childId ALIAS FOR $1; 
onBeforeDate ALIAS FOR $2; 

-- Declare a variable to hold the parent ID number.
parentId INTEGER; 

BEGIN 

  -- Find the Parent of the given Child if they exist
  SELECT INTO parentId CMDIL_ParentIDid 
    FROM CMDItemLink 
    WHERE CMDIL_ChildIDid = childId and CMDILdate = (SELECT max(cmdildate) 
                                                     FROM CMDItemLink 
                                                     WHERE CMDIL_ChildIDid = childId and CMDILdate <= onBeforeDate); 

  IF parentId <> childId and parentId > 0 THEN 
    -- if a parent exists for the given child look to see if this parent has a parent
    parentId := CMDfindTopParentId(ParentId, $2); 
  ELSE 
    -- otherwise just return the child id as being the top parent
    parentId = childId; 
  END IF; 

  RETURN parentId; 

END; 

$_$
    LANGUAGE plpgsql;",ABOS20110308.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v1.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v2.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v3.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v4.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",db-core-v5.sql
"CREATE FUNCTION colpivot(out_table character varying, in_query character varying, key_cols character varying[], class_cols character varying[], value_e character varying, col_order character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
    declare
        in_table varchar;
        col varchar;
        ali varchar;
        on_e varchar;
        i integer;
        rec record;
        query varchar;
        -- This is actually an array of arrays but postgres does not support an array of arrays type so we flatten it.
        -- We could theoretically use the matrix feature but it's extremly cancerogenous and we would have to involve
        -- custom aggrigates. For most intents and purposes postgres does not have a multi-dimensional array type.
        clsc_cols text[] := array[]::text[];
        n_clsc_cols integer;
        n_class_cols integer;
    begin
        in_table := quote_ident('__' || out_table || '_in');
        execute ('create temp table ' || in_table || ' on commit drop as ' || in_query);
        -- get ordered unique columns (column combinations)
        query := 'select array[';
        i := 0;
        foreach col in array class_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || 'quote_literal(' || quote_ident(col) || ')';
            i := i + 1;
        end loop;
        query := query || '] x from ' || in_table;
        for j in 1..2 loop
            if j = 1 then
                query := query || ' group by ';
            else
                query := query || ' order by ';
                if col_order is not null then
                    query := query || col_order || ' ';
                    exit;
                end if;
            end if;
            i := 0;
            foreach col in array class_cols loop
                if i > 0 then
                    query := query || ', ';
                end if;
                query := query || quote_ident(col);
                i := i + 1;
            end loop;
        end loop;
        -- raise notice '%', query;
        for rec in
            execute query
        loop
            clsc_cols := array_cat(clsc_cols, rec.x);
        end loop;
        n_class_cols := array_length(class_cols, 1);
        n_clsc_cols := array_length(clsc_cols, 1) / n_class_cols;
        -- build target query
        query := 'select ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || '_key.' || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        for j in 1..n_clsc_cols loop
            query := query || ', ';
            col := '';
            for k in 1..n_class_cols loop
                if k > 1 then
                    col := col || ', ';
                end if;
                col := col || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            ali := '_clsc_' || j::text;
            query := query || '(' || replace(value_e, '#', ali) || ')' || ' as ' || quote_ident(col) || ' ';
        end loop;
        query := query || ' from (select distinct ';
        i := 0;
        foreach col in array key_cols loop
            if i > 0 then
                query := query || ', ';
            end if;
            query := query || quote_ident(col) || ' ';
            i := i + 1;
        end loop;
        query := query || ' from ' || in_table || ') _key ';
        for j in 1..n_clsc_cols loop
            ali := '_clsc_' || j::text;
            on_e := '';
            i := 0;
            foreach col in array key_cols loop
                if i > 0 then
                    on_e := on_e || ' and ';
                end if;
                on_e := on_e || ali || '.' || quote_ident(col) || ' = _key.' || quote_ident(col) || ' ';
                i := i + 1;
            end loop;
            for k in 1..n_class_cols loop
                on_e := on_e || ' and ';
                on_e := on_e || ali || '.' || quote_ident(class_cols[k]) || ' = ' || clsc_cols[(j - 1) * n_class_cols + k];
            end loop;
            query := query || 'left join ' || in_table || ' as ' || ali || ' on ' || on_e || ' ';
        end loop;
        -- raise notice '%', query;
        execute ('create temp table ' || quote_ident(out_table) || ' on commit drop as ' || query);
        -- cleanup temporary in_table before we return
        execute ('drop table ' || in_table)
        return;
    end;
$$;",hog-database-start.sql
"CREATE FUNCTION column_has_default(column_name name, table_name oid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$DECLARE
	result pg_attribute.atthasdef%TYPE;
BEGIN
	SELECT atthasdef
	INTO result
	FROM pg_attribute
	WHERE attrelid=table_name
	  AND attstattarget=-1
	  AND attisdropped=false
	  AND attnum>0
	  AND attname=column_name;
	RETURN result;
END;
$$;",schema-html.sql
"CREATE FUNCTION column_is_required(column_name name, table_name oid) RETURNS boolean
    LANGUAGE plpgsql
    AS $$DECLARE
	result pg_attribute.attnotnull%TYPE;
BEGIN
	SELECT attnotnull
	INTO result
	FROM pg_attribute
	WHERE attrelid=table_name
	  AND attstattarget=-1
	  AND attisdropped=false
	  AND attnum>0
	  AND attname=column_name;
	RETURN result;
END;
$$;",schema-html.sql
"CREATE FUNCTION column_is_required(in_schema_name information_schema.sql_identifier, in_table_name information_schema.sql_identifier, in_column_name information_schema.sql_identifier) RETURNS boolean
    LANGUAGE plpgsql
    AS $$DECLARE
	result boolean := false;
	b information_schema.yes_or_no;
BEGIN
	SELECT is_nullable
	INTO b
	FROM information_schema.columns c
	WHERE c.table_schema=in_schema_name
	AND c.table_name=in_table_name
	AND c.column_name=in_column_name;

	IF (b = 'NO') THEN
		result := true;
	END IF;

	RETURN result;
END;
$$;",schema-html.sql
"CREATE FUNCTION commacat(acc text, instr text) RETURNS text
    LANGUAGE plpgsql
    AS $$
  BEGIN
    IF acc IS NULL OR acc = '' THEN
      RETURN instr;
    ELSE
      RETURN acc || ', ' || instr;
    END IF;
  END;
$$;",sql_template.sql
"CREATE FUNCTION commacat2(acc text, instr text) RETURNS text
    LANGUAGE plpgsql
    AS $$
  BEGIN
    IF acc IS NULL OR acc = '' THEN
      RETURN instr;
    ELSE
      RETURN acc || ',' || instr;
    END IF;
  END;
$$;",sql_template.sql
"CREATE FUNCTION compare_fecha_hoy(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION compare_fecha_hoy(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION compare_fecha_hoy(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION compare_fecha_hoy(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION compare_fecha_hoy(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION compravalortotal(p_compraid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_total double precision;

BEGIN

    SELECT
           SUM(E.quantidade * E.valorunitario) INTO v_total
      FROM estoquemovimento E
INNER JOIN compra C
        ON C.compraid = E.compraid
       AND C.compraid = p_compraid
INNER JOIN produto P
        ON P.produtoid = E.produtoid;
    
RETURN v_total;

END;
$$;",almoxarifado.sql
"CREATE FUNCTION comproba_pacient(camp character varying, valor character varying) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
	sql text;
	res varchar := '';
	res_select record;
BEGIN
	sql := 'SELECT * FROM pacients WHERE ' || $1 || ' = ''' || $2 || ''';';
	FOR res_select IN EXECUTE(sql) LOOP
		IF res = '' THEN
			res := res_select;
		END IF;
	END LOOP;
	IF res = '' THEN
		RETURN '1';
	END IF;
RETURN '0';
END;

$_$;",lab_clinic.sql
CREATE FUNCTION concat(anyelement) RETURNS text     AS $_$ BEGIN  RETURN $1::text; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;,2.8.2_postgresql.sql
"CREATE FUNCTION concat(text, text) RETURNS text
    AS $_$
DECLARE
  pTxt1 ALIAS FOR $1;
  pTxt2 ALIAS FOR $2;
BEGIN
  RETURN (pTxt1 || pTxt2);
END;

$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION concat(text, text) RETURNS text
    AS $_$
DECLARE
  pTxt1 ALIAS FOR $1;
  pTxt2 ALIAS FOR $2;
BEGIN
  RETURN (pTxt1 || pTxt2);
END;

$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION concat(text, text) RETURNS text     AS $_$ BEGIN  RETURN $1 || $2; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION concat(text, text, text) RETURNS text
    AS $_$
DECLARE
  pTxt1 ALIAS FOR $1;
  pTxt2 ALIAS FOR $2;
  pTxt3 ALIAS FOR $3;
BEGIN
  RETURN (pTxt1 || pTxt2 || pTxt3);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION concat(text, text, text) RETURNS text
    AS $_$
DECLARE
  pTxt1 ALIAS FOR $1;
  pTxt2 ALIAS FOR $2;
  pTxt3 ALIAS FOR $3;
BEGIN
  RETURN (pTxt1 || pTxt2 || pTxt3);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION consultaUsuario (id integer) RETURNS varchar AS
$$
DECLARE
registro RECORD;
BEGIN
SELECT * INTO registro FROM usuario WHERE id_usuario = id;
IF not FOUND THEN
RAISE EXCEPTION 'não existe aluno com a matricula %', id;
END IF;
RETURN registro.nome_completo;
END;
$$
LANGUAGE 'plpgsql';",ativid%20rangel%20biblioteca.sql
"CREATE FUNCTION consulta_descuento(id_registro integer, aplicar_a_q character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
	DECLARE
	dia_semana character varying;
	result record;
	existe integer;
		

	BEGIN 

	-- Esta funcion recibe un ID de un registro y un string (aplicar_a) y consulta si existe algun descuento que aplique a dicho registro
	-- Dado el caso de que al registro aplique varios descuento se selecciona el descuento de mayor %
	-- Retorna el % descuento y el ID del descuento
	-- si no encuentra descuentos retorna null,null	
	
	existe=0;

	-- El id_registro debe existir. Si no retorna (0,0)
	if upper(aplicar_a_q) = upper('productos') then		
		existe = COALESCE((select p.id from producto p where p.id=id_registro),0);
	end if;
	if upper(aplicar_a_q) = upper('tipos productos') then
		existe = COALESCE((select tp.id from tipo_producto tp where tp.id=id_registro),0);
	end if;
	if upper(aplicar_a_q) = upper('marcas productos') then
		existe = COALESCE((select mp.id from marca_producto mp where mp.id=id_registro),0);
	end if;

	if  existe =null or existe=0 then select into result cast( 0 as double precision) porcentaje_descuento ,0 id; return result; end if;

	
	IF EXTRACT(DOW FROM current_date)=1 THEN dia_semana='LUNES';
	ELSIF EXTRACT(DOW FROM current_date)=2 THEN dia_semana='MARTES'; 
	ELSIF EXTRACT(DOW FROM current_date)=3 THEN dia_semana='MIERCOLES'; 
	ELSIF EXTRACT(DOW FROM current_date)=4 THEN dia_semana='JUEVES'; 
	ELSIF EXTRACT(DOW FROM current_date)=5 THEN dia_semana='VIERNES'; 
	ELSIF EXTRACT(DOW FROM current_date)=6 THEN dia_semana='SABADO'; 
	ELSIF EXTRACT(DOW FROM current_date)=0 THEN dia_semana='DOMINGO'; END IF;

	select into result
	t.porcentaje_descuento, t.id from(
		select COALESCE(max(d.porcentaje_descuento), 0) porcentaje_descuento,
		d.id
		from descuento d
		where  ((upper(d.ids_a_aplicar_descuento)=upper('todos')) or 
			(d.ids_a_aplicar_descuento like '%,'||id_registro||',%') and upper(d.aplicar_a)=upper(aplicar_a_q))
		and d.fecha_inicio<=current_date
		and d.fecha_fin >=current_date
		and COALESCE(d.hora_dia_inicio,'00:00:00')<=localtime
		and COALESCE(d.hora_dia_fin,'23:59:59')>=localtime
		and (upper(d.dias_semana) like upper('%todos%')
			or (upper(d.dias_semana) like upper('%'||dia_semana||'%')))	
	group by id order by porcentaje_descuento desc) as t limit 1;		

	if result.porcentaje_descuento>0 then return result; end if;

	select into result cast( 0 as double precision) porcentaje_descuento ,0 id;

	return result;
	      
	END;
	$$;",backup%20invselb%202017-07-28.sql
"CREATE FUNCTION consulta_descuento_del_producto(id_producto integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
		DECLARE
		 result_temp record;
		 result record;
		 id_marca_producto integer;
		 id_tipo_producto integer;


		BEGIN 
		-- Esta funcion recibe un ID de un producto y consulta si existe algun descuento que aplique a dicho producto
		-- Dado el caso de que al producto aplique varios descuento se selecciona el descuento de mayor %
	        -- Retorna el % descuento y el ID del descuento
		-- si no encuentra descuentos retorna null, null
		select into result 0 as porcentaje_descuento, 0 as id;		

		--Consulta el descuento mayor que aplica directamente sobre el producto
		result_temp= consulta_descuento(id_producto, 'Productos');

		raise notice 'desc producto: %' , result_temp;

		begin
			if result_temp.porcentaje_descuento>result.porcentaje_descuento then result=result_temp; end if;
		EXCEPTION WHEN OTHERS  then
		end;
			
		--Se consulta el id de la marca del producto
		select into id_marca_producto 
		COALESCE(p.id_marca_producto, 0)
		from producto p 
		where p.id=id_producto;
		
		--Consulta el descuento mayor que aplica sobre marcas de producto (se valida que el producto sea de la marca)
		if id_marca_producto>0 then
			result_temp= consulta_descuento(id_marca_producto, 'Marcas Productos');
			raise notice 'desc marca producto: %' , result_temp;
			begin
				if result_temp.porcentaje_descuento>result.porcentaje_descuento then result=result_temp; end if;
			EXCEPTION WHEN OTHERS  then
			end;
		end if;

		--Se consulta el id del tipo producto
		select into id_tipo_producto 
		COALESCE(p.id_tipo_producto, 0)
		from producto p 
		where p.id=id_producto;

		-- mientras el id_tipo_producto sea >0 se ejecutara el while
		WHILE id_tipo_producto>0 LOOP
			result_temp= consulta_descuento(id_tipo_producto, 'Tipos Productos');
			raise notice 'desc tipo producto: %' , result_temp; 
			
			begin
				if result_temp.porcentaje_descuento>result.porcentaje_descuento then 				
				result=result_temp; end if;
			EXCEPTION WHEN OTHERS  then
			end;

			--se consulta el id_tipo_producto padre y vuele a ejecutar el while
			select into id_tipo_producto 
			COALESCE(tp.id_tipo_producto_padre, 0)
			from tipo_producto tp 
			where tp.id=id_tipo_producto;
		END LOOP;
		      
		 RETURN result;
		END;
		$$;",backup%20invselb%202017-07-28.sql
"CREATE FUNCTION consulta_siguiente_numero_factura_por_resolucion(nombre_resolucion character varying) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE
 numero_inicio_r INT;
 numero_fin_r INT;
 numero_siguiente_r bigint;
 i_r INT;
 numero_temp_r INT;
        BEGIN 
        

 --Se consulta el siguiente numero de factura segun el campo numero_ultima_factura
 SELECT INTO numero_siguiente_r rf.numero_ultima_factura 
 FROM resolucion_facturacion rf 
 WHERE rf.nombre= nombre_resolucion
 AND rf.numero_ultima_factura>=rf.numero_inicio 
 AND  rf.numero_ultima_factura< numero_fin 
 and (rf.numero_ultima_factura+1)  not in (
  select fv.numero_factura from factura_venta fv 
  where fv.resolucion_facturacion =rf.nombre  
  and fv.resolucion_facturacion =nombre_resolucion);

 --Si la consulta anterior arroja resultado lo retorna
 IF numero_siguiente_r IS NOT NULL THEN
  RETURN numero_siguiente_r+1;
 END IF;

 -- si la parte anterior no arrojo resultados se consulta el inicio y fin de la resolucion
 -- la idea es recorrer preguntando que no exista el numero en alguna factura antigua
 SELECT
 INTO numero_inicio_r, numero_fin_r numero_inicio,numero_fin 
 FROM resolucion_facturacion WHERE nombre =nombre_resolucion;

 RAISE NOTICE 'numero inicio: %',numero_inicio_r;
 RAISE NOTICE 'numero fin: %',numero_fin_r;

 --Se recorre desde el inicio hasta el fin de la resolucion buscando que numero no se ha hecho factura
 i_r:=numero_inicio_r;
 WHILE(i_r<=numero_fin_r)
 LOOP
  
  SELECT INTO numero_temp_r fv.numero_factura 
  FROM factura_venta fv 
  where fv.resolucion_facturacion = nombre_resolucion
  AND fv.numero_factura=i_r;
 
  IF NOT numero_temp_r IS NULL  THEN
    numero_siguiente_r:=i_r;
  END IF;
  i_r:=i_r+1;
 END LOOP;

 RETURN numero_inicio_r;
END;
$$;",backup%20invselb%202017-07-28.sql
"CREATE FUNCTION consumable_to_assembly(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'ASSEMBLY'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION consumable_to_buyable(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'BUYABLE'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION consumable_to_part(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'PART'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION conta_cerca_dipendenti(nomecognome character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE c int;
BEGIN
SELECT COUNT(*) into c FROM dipendente
WHERE (LOWER(nome || ' ' || cognome) LIKE LOWER('%' || nomecognome || '%'))
OR (LOWER(cognome || ' ' || nome) LIKE LOWER('%' || nomecognome || '%'));
RETURN c;
END;
$$;",script.sql
"CREATE FUNCTION conta_user(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare 
   method ALIAS for $1;
   startime ALIAS for $2;
   stoptime ALIAS for $3;
   numero INTEGER;
begin 
   select into numero count(*) from d_user, d_tempo 
          where data_id=d_user.data_attivaz_id and data_cap <= stoptime  and mod_registr_cap = method;
   return numero;
end;$_$;",dwschema
"CREATE FUNCTION contactos_usuario(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR select * FROM CONTACTOS inner join usuario on contactos.idusuariocontacto = usuario.id where usuario.id= $1 order by usuario.nombreusuario;
	RETURN MYCURS;
END;
$_$;",todo.sql
"CREATE FUNCTION contrato_to_string(id_contrato integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
resultado VARCHAR;
chapa VARCHAR;
turist VARCHAR;
fechai VARCHAR;
fechaf VARCHAR;
fechae VARCHAR;
chofer VARCHAR;
fp VARCHAR;
import VARCHAR;
BEGIN
SELECT autos.chapa INTO chapa FROM autos JOIN contratos ON contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=$1;

SELECT turista.pasaporte INTO turist FROM turista JOIN contratos ON contratos.cont_id_tur=turista.id_tur
WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_i::VARCHAR INTO fechai FROM contratos WHERE contratos.id_contrato=$1;


SELECT contratos.fecha_f::VARCHAR INTO fechaf FROM contratos WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_entrega::VARCHAR INTO fechae FROM contratos WHERE contratos.id_contrato=$1;

if(fechae ISNULL)THEN
fechae:='-';
end if;

SELECT choferes.numero_id::VARCHAR INTO chofer FROM contratos JOIN choferes ON contratos.cont_id_chof=choferes.id_chofer
WHERE contratos.id_contrato=$1;
if(chofer ISNULL)THEN
chofer:='no';
end if;
SELECT forma_pago.tipo_pago INTO fp FROM forma_pago JOIN contratos on contratos.cont_id_forma_pago=forma_pago.id_pago
WHERE contratos.id_contrato=$1;

SELECT contratos.importe_total::VARCHAR INTO import FROM contratos WHERE contratos.id_contrato=$1;
 
resultado:=chapa || '/ '|| turist || '/ ' || fechai || '/ ' || fechaf || '/ ' || fechae || '/ ' || chofer || '/ ' || fp || '/ ' || import; 
RETURN resultado;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION contrato_to_string(id_contrato integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
resultado VARCHAR;
chapa VARCHAR;
turist VARCHAR;
fechai VARCHAR;
fechaf VARCHAR;
fechae VARCHAR;
chofer VARCHAR;
fp VARCHAR;
import VARCHAR;
BEGIN
SELECT autos.chapa INTO chapa FROM autos JOIN contratos ON contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=$1;

SELECT turista.pasaporte INTO turist FROM turista JOIN contratos ON contratos.cont_id_tur=turista.id_tur
WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_i::VARCHAR INTO fechai FROM contratos WHERE contratos.id_contrato=$1;


SELECT contratos.fecha_f::VARCHAR INTO fechaf FROM contratos WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_entrega::VARCHAR INTO fechae FROM contratos WHERE contratos.id_contrato=$1;

if(fechae ISNULL)THEN
fechae:='-';
end if;

SELECT choferes.numero_id::VARCHAR INTO chofer FROM contratos JOIN choferes ON contratos.cont_id_chof=choferes.id_chofer
WHERE contratos.id_contrato=$1;
if(chofer ISNULL)THEN
chofer:='no';
end if;
SELECT forma_pago.tipo_pago INTO fp FROM forma_pago JOIN contratos on contratos.cont_id_forma_pago=forma_pago.id_pago
WHERE contratos.id_contrato=$1;

SELECT contratos.importe_total::VARCHAR INTO import FROM contratos WHERE contratos.id_contrato=$1;
 
resultado:=chapa || '/ '|| turist || '/ ' || fechai || '/ ' || fechaf || '/ ' || fechae || '/ ' || chofer || '/ ' || fp || '/ ' || import; 
RETURN resultado;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION contrato_to_string(id_contrato integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
resultado VARCHAR;
chapa VARCHAR;
turist VARCHAR;
fechai VARCHAR;
fechaf VARCHAR;
fechae VARCHAR;
chofer VARCHAR;
fp VARCHAR;
import VARCHAR;
BEGIN
SELECT autos.chapa INTO chapa FROM autos JOIN contratos ON contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=$1;

SELECT turista.pasaporte INTO turist FROM turista JOIN contratos ON contratos.cont_id_tur=turista.id_tur
WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_i::VARCHAR INTO fechai FROM contratos WHERE contratos.id_contrato=$1;


SELECT contratos.fecha_f::VARCHAR INTO fechaf FROM contratos WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_entrega::VARCHAR INTO fechae FROM contratos WHERE contratos.id_contrato=$1;

if(fechae ISNULL)THEN
fechae:='-';
end if;

SELECT choferes.numero_id::VARCHAR INTO chofer FROM contratos JOIN choferes ON contratos.cont_id_chof=choferes.id_chofer
WHERE contratos.id_contrato=$1;
if(chofer ISNULL)THEN
chofer:='no';
end if;
SELECT forma_pago.tipo_pago INTO fp FROM forma_pago JOIN contratos on contratos.cont_id_forma_pago=forma_pago.id_pago
WHERE contratos.id_contrato=$1;

SELECT contratos.importe_total::VARCHAR INTO import FROM contratos WHERE contratos.id_contrato=$1;
 
resultado:=chapa || '/ '|| turist || '/ ' || fechai || '/ ' || fechaf || '/ ' || fechae || '/ ' || chofer || '/ ' || fp || '/ ' || import; 
RETURN resultado;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION contrato_to_string(id_contrato integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
resultado VARCHAR;
chapa VARCHAR;
turist VARCHAR;
fechai VARCHAR;
fechaf VARCHAR;
fechae VARCHAR;
chofer VARCHAR;
fp VARCHAR;
import VARCHAR;
BEGIN
SELECT autos.chapa INTO chapa FROM autos JOIN contratos ON contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=$1;

SELECT turista.pasaporte INTO turist FROM turista JOIN contratos ON contratos.cont_id_tur=turista.id_tur
WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_i::VARCHAR INTO fechai FROM contratos WHERE contratos.id_contrato=$1;


SELECT contratos.fecha_f::VARCHAR INTO fechaf FROM contratos WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_entrega::VARCHAR INTO fechae FROM contratos WHERE contratos.id_contrato=$1;

if(fechae ISNULL)THEN
fechae:='-';
end if;

SELECT choferes.numero_id::VARCHAR INTO chofer FROM contratos JOIN choferes ON contratos.cont_id_chof=choferes.id_chofer
WHERE contratos.id_contrato=$1;
if(chofer ISNULL)THEN
chofer:='no';
end if;
SELECT forma_pago.tipo_pago INTO fp FROM forma_pago JOIN contratos on contratos.cont_id_forma_pago=forma_pago.id_pago
WHERE contratos.id_contrato=$1;

SELECT contratos.importe_total::VARCHAR INTO import FROM contratos WHERE contratos.id_contrato=$1;
 
resultado:=chapa || '/ '|| turist || '/ ' || fechai || '/ ' || fechaf || '/ ' || fechae || '/ ' || chofer || '/ ' || fp || '/ ' || import; 
RETURN resultado;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION contrato_to_string(id_contrato integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
resultado VARCHAR;
chapa VARCHAR;
turist VARCHAR;
fechai VARCHAR;
fechaf VARCHAR;
fechae VARCHAR;
chofer VARCHAR;
fp VARCHAR;
import VARCHAR;
BEGIN
SELECT autos.chapa INTO chapa FROM autos JOIN contratos ON contratos.cont_id_auto=autos.id_auto
WHERE contratos.id_contrato=$1;

SELECT turista.pasaporte INTO turist FROM turista JOIN contratos ON contratos.cont_id_tur=turista.id_tur
WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_i::VARCHAR INTO fechai FROM contratos WHERE contratos.id_contrato=$1;


SELECT contratos.fecha_f::VARCHAR INTO fechaf FROM contratos WHERE contratos.id_contrato=$1;

SELECT contratos.fecha_entrega::VARCHAR INTO fechae FROM contratos WHERE contratos.id_contrato=$1;

if(fechae ISNULL)THEN
fechae:='-';
end if;

SELECT choferes.numero_id::VARCHAR INTO chofer FROM contratos JOIN choferes ON contratos.cont_id_chof=choferes.id_chofer
WHERE contratos.id_contrato=$1;
if(chofer ISNULL)THEN
chofer:='no';
end if;
SELECT forma_pago.tipo_pago INTO fp FROM forma_pago JOIN contratos on contratos.cont_id_forma_pago=forma_pago.id_pago
WHERE contratos.id_contrato=$1;

SELECT contratos.importe_total::VARCHAR INTO import FROM contratos WHERE contratos.id_contrato=$1;
 
resultado:=chapa || '/ '|| turist || '/ ' || fechai || '/ ' || fechaf || '/ ' || fechae || '/ ' || chofer || '/ ' || fp || '/ ' || import; 
RETURN resultado;
END
$_$;",backup1.sql
"CREATE FUNCTION convert_quantity(_part_code character varying, _version_num integer, _quantity common.quantity, _uom_code_from character varying, _uom_code_to character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

DECLARE
  __uom_domain_to character varying;
  __uom_domain_from character varying;
  __unit_conversion_factors common.unit_conversion_type[];
  __m common.unit_conversion_type;
  __exponentiation integer DEFAULT 1;

BEGIN

  /*
  case
    when __array @> ARRAY[30] then
      raise notice 'msg %', 0;
    when __array @> ARRAY[20] then
      raise notice 'msg %', 1;
    when __array @> ARRAY[10] then
      raise notice 'msg %', 0;
  end case;

  raise NOTICE 'array dump %', __unit_conversion_factors;
  raise NOTICE 'array unnest %', unnest(array[__unit_conversion_factors[1]]);


  case when __unit_conversion_factors @> ARRAY[(_uom_code_from,_uom_code_to,null)::mdm.unit_conversion_type] THEN
  RAISE NOTICE 'ok %', __unit_conversion_factors;
  else RAISE NOTICE 'not ok %', __unit_conversion_factors;
  end case
  
  */

  -- визначити домен одиниці виміру, до якої приводимо
  __uom_domain_to := uom.get_domain(_uom_code := _uom_code_to);
  -- визначити домен одиниці виміру, з якої приводимо
  __uom_domain_from := uom.get_domain(_uom_code := _uom_code_from);

  --RAISE NOTICE 'conversion from % to %', __uom_domain_to, __uom_domain_from;

  -- якщо той самий домен, то використовуємо коефіцієнт Сі
  IF (__uom_domain_from = __uom_domain_to) THEN
    --RAISE NOTICE 'formula = % * %', _quantity, mdm.get_factor(_uom_code_from, _uom_code_to);
    RETURN _quantity * uom.get_factor(_uom_code_from, _uom_code_to);
  END IF;

    __unit_conversion_factors := inventory.get_uom_conversion_factors(
      _part_code := _part_code,
      _version_num := _version_num,
      _uom_domain_from := __uom_domain_from,
      _uom_domain_to := __uom_domain_to);

    -- логіка перетворення з основного домену в додатковий
    IF (array_ndims(__unit_conversion_factors) >= 1) THEN

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF (__m.uom_code_from = _uom_code_from AND __m.uom_code_to = _uom_code_to) THEN
          RAISE NOTICE 'full forward match % to % = %',_uom_code_from, _uom_code_to, __m.factor;
          RETURN _quantity * (__m.factor ^ __exponentiation);
        END IF;
      END LOOP;

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF ( __m.uom_code_from = _uom_code_from) THEN
          RAISE NOTICE 'partial forward _from_ match % to % = %',_uom_code_from, __m.uom_code_to, __m.factor;
          RETURN _quantity *  
            (__m.factor ^ __exponentiation) *
            uom.get_factor(_uom_code_to, __m.uom_code_to);
        END IF;
      END LOOP;

      FOREACH __m IN
        ARRAY __unit_conversion_factors
      LOOP 
        IF ( __m.uom_code_to = _uom_code_to) THEN
          RAISE NOTICE 'partial forward _to_ match % to % = %',__m.uom_code_from, _uom_code_to, __m.factor;
          RETURN _quantity * 
            (__m.factor ^ __exponentiation) * 
            uom.get_factor(_uom_code_from, __m.uom_code_from);
        END IF;
      END LOOP;

      RAISE NOTICE 'finally forward match % to % = %', 
        __unit_conversion_factors[1].uom_code_from, 
        __unit_conversion_factors[1].uom_code_to, 
        __unit_conversion_factors[1].factor;
      RETURN _quantity * 
        uom.get_factor(_uom_code_from, __unit_conversion_factors[1].uom_code_from) * 
        (__unit_conversion_factors[1].factor ^ __exponentiation) *
        uom.get_factor(__unit_conversion_factors[1].uom_code_to, _uom_code_to);

    -- логіка перетворення з додаткового в основний домен
    ELSE
      __unit_conversion_factors := inventory.get_uom_conversion_factors(
        _part_code := _part_code,
        _version_num := _version_num,
        _uom_domain_from := __uom_domain_to,
        _uom_domain_to := __uom_domain_from);

      IF (array_ndims(__unit_conversion_factors) >= 1) THEN
        __exponentiation := -1;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF (__m.uom_code_from = _uom_code_to AND __m.uom_code_to = _uom_code_from) THEN
            RAISE NOTICE 'full reverse match % to % = %',_uom_code_from, _uom_code_to, __m.factor;
            RETURN _quantity * (__m.factor ^ __exponentiation);
          END IF;
        END LOOP;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF ( __m.uom_code_from = _uom_code_to) THEN
            RAISE NOTICE 'partial reverse _from_ match % to % = %',_uom_code_from, __m.uom_code_to, __m.factor;
            RETURN _quantity *  
              (__m.factor ^ __exponentiation) *
              uom.get_factor(_uom_code_from ,  __m.uom_code_to);
          END IF;
        END LOOP;

        FOREACH __m IN
          ARRAY __unit_conversion_factors
        LOOP 
          IF ( __m.uom_code_to = _uom_code_from) THEN
            RAISE NOTICE 'partial reverse _to_ match % to % = %',__m.uom_code_to, _uom_code_from, __m.factor;
            RETURN _quantity * 
              (__m.factor ^ __exponentiation) * 
              uom.get_factor(_uom_code_to, __m.uom_code_from);
          END IF;
        END LOOP;

        RAISE NOTICE 'finally reverse match % to % = %',
          __unit_conversion_factors[1].uom_code_from,
          __unit_conversion_factors[1].uom_code_to,
          __unit_conversion_factors[1].factor;
        RETURN _quantity * 
          uom.get_factor(_uom_code_from ,  __unit_conversion_factors[1].uom_code_to) *
          (__unit_conversion_factors[1].factor ^ __exponentiation) *
          uom.get_factor(__unit_conversion_factors[1].uom_code_from, _uom_code_to);

      ELSE
        --RETURN 987654321;
        RAISE EXCEPTION 'no conversion factor found for measure domains % and % for % version %',
          __uom_domain_from,
          __uom_domain_to, 
          _part_code,
          _version_num;
          
      END IF;

    END IF;

END;

$$;",mdm.sql
"CREATE FUNCTION correct_time(param_time character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    full_time character varying;
	mil character varying;
	BEGIN
		full_time = split_part($1,'.',1);
		mil = split_part($1,'.',2);
if(char_length(mil)=1)
then
	mil = '00'||mil;
else if(char_length(mil)=2)
then
mil = '0'||mil;
end if;
end if;
return full_time||'.'||mil;
	END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION cost(id_type integer, total_weight real, total_cost money) RETURNS money
    LANGUAGE plpgsql STABLE SECURITY DEFINER LEAKPROOF
    AS $$
DECLARE
cost money;
weight real;
type_row ""Тип_отправления""%ROWTYPE;
BEGIN
SELECT * INTO type_row 
FROM public.""Тип_отправления"" 
WHERE ""ИД_Тип"" = id_type;
weight = total_weight - type_row.""СтандартВес"";
cost = type_row.""СтандартТариф"";
IF (weight > 0) THEN
	weight = ceiling(weight / type_row.""ДопВес"");
	cost = cost + (type_row.""ДопТариф"" * weight);
END IF;
IF (type_row.""Ценность"" = true) THEN
	cost = cost + (type_row.""ЦенТариф""  * ceiling(total_cost / type_row.""ДопЦен""));
END IF;
RETURN COALESCE(cost,0::money);
END
$$;",post_office.backup
"CREATE FUNCTION count_acccat1(pbusqueda character, pcodrol character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from acccat1 a, bvtcat1 b
where a.b_codcat1 = b.codcat1
and  a.b_codcat1||b.descat1  like '%'||pbusqueda||'%'
AND  a.b_codrol like pcodrol||'%'
and cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_acccat2(pbusqueda character, pcodrol character, pcodcat1 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from acccat2 a, bvtcat1 b, bvtcat2 c
WHERE a.b_codcat1=b.codcat1
and  a.b_codcat1=c.b_codcat1
and  a.b_codcat2=c.codcat2
and  a.b_codcat1||b.descat1||a.b_codcat2||c.descat2 like '%'||pbusqueda||'%'
and  a.b_codcat1 like pcodcat1||'%'
AND  a.b_codrol like pcodrol||'%'
and cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_acccat3(pbusqueda character, pcodrol character, pcodcat1 character, pcodcat2 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from   acccat3 a, bvtcat1 b, bvtcat2 c, bvtcat3 d
where a.b_codcat1=b.codcat1
and   a.b_codcat1=c.b_codcat1
and   a.b_codcat2=c.codcat2
and   a.b_codcat1=d.b_codcat1
and   a.b_codcat2=d.b_codcat2
and   a.b_codcat3=d.codcat3
and   a.b_codcat1||b.descat1||a.b_codcat2||c.descat2||a.b_codcat3||d.descat3 like '%'||pbusqueda||'%'
and  a.b_codcat1 like pcodcat1||'%'
and  a.b_codcat1 like pcodcat2||'%'
AND  a.b_codrol like pcodrol||'%'
and cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_acccat4(pbusqueda character, pcodrol character, pcodcat1 character, pcodcat2 character, pcodcat3 character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from acccat4 a, bvtcat1 b, bvtcat2 c, bvtcat3 d, bvtcat4 e
where a.b_codcat1=b.codcat1
and   a.b_codcat1=c.b_codcat1
and   a.b_codcat2=c.codcat2
and   a.b_codcat1=d.b_codcat1
and   a.b_codcat2=d.b_codcat2
and   a.b_codcat3=d.codcat3
and   a.b_codcat1=e.b_codcat1
and   a.b_codcat2=e.b_codcat2
and   a.b_codcat3=e.b_codcat3
and   a.b_codcat4=e.codcat4
and   a.b_codcat1||b.descat1||a.b_codcat2||c.descat2||a.b_codcat3||d.descat3||a.b_codcat4||e.descat4 like  '%'||pbusqueda||'%'
and   a.b_codcat1 like pcodcat1||'%'
and   a.b_codcat2 like pcodcat2||'%'
and   a.b_codcat3 like pcodcat3||'%'
AND   a.b_codrol like pcodrol||'%';
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_acccat4(pbusqueda character, pcodrol character, pcodcat1 character, pcodcat2 character, pcodcat3 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from acccat4 a, bvtcat1 b, bvtcat2 c, bvtcat3 d, bvtcat4 e
where a.b_codcat1=b.codcat1
and   a.b_codcat1=c.b_codcat1
and   a.b_codcat2=c.codcat2
and   a.b_codcat1=d.b_codcat1
and   a.b_codcat2=d.b_codcat2
and   a.b_codcat3=d.codcat3
and   a.b_codcat1=e.b_codcat1
and   a.b_codcat2=e.b_codcat2
and   a.b_codcat3=e.b_codcat3
and   a.b_codcat4=e.codcat4
and   a.b_codcat1||b.descat1||a.b_codcat2||c.descat2||a.b_codcat3||d.descat3||a.b_codcat4||e.descat4 like  '%'||pbusqueda||'%'
and   a.b_codcat1 like pcodcat1||'%'
and   a.b_codcat2 like pcodcat2||'%'
and   a.b_codcat3 like pcodcat3||'%'
AND   a.b_codrol like pcodrol||'%'
and   cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_admins() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'ADMINISTRADOR';
	RETURN result;
END;	
$$;",backup%2007-12.sql
"CREATE FUNCTION count_admins() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'ADMINISTRADOR';
	RETURN result;
END;	
$$;",backup%2008-12.sql
"CREATE FUNCTION count_admins() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'ADMINISTRADOR';
	RETURN result;
END;	
$$;",backup%2009-12(2).sql
"CREATE FUNCTION count_admins() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'ADMINISTRADOR';
	RETURN result;
END;	
$$;",backup%2009-12.sql
"CREATE FUNCTION count_biaudit(pbusqueda character, pfecha date, pvalor character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
if pvalor = '0' then
select count(*) into vcount 
from biaudit
where  fechadia||substr(fecacc,12,22)||detfaz||negocio like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
else 
select count(*) into vcount 
from biaudit
where  fechadia||substr(fecacc,12,22)||detfaz||negocio like '%'||pbusqueda||'%'
and fechadia = pfecha
and cast(instancia as text) = pinstancia;
end if;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt001(pbusqueda character, pcodrol character, pgrupo character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
if pgrupo is null then
select count(*) into vcount 
from bvt001
where codrep||desrep  like '%'||pbusqueda||'%'
AND  CODREP  IN (SELECT B_CODREP FROM BVT007 WHERE B_CODROL = pcodrol);
else
select count(*) into vcount 
from bvt001
where codrep||desrep  like '%'||pbusqueda||'%'
AND  CODREP  IN (SELECT B_CODREP FROM BVT007 WHERE B_CODROL = pcodrol)
and  codgrup like pgrupo||'%'
and cast(instancia as text) = pinstancia;
end if;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt001a(pbusqueda character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvt001a
where codgrup||desgrup  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt002(pbusqueda character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvt002
where coduser||desuser  like '%'||pbusqueda||'%';
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt003(pbusqueda character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvt003
where codrol||desrol  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt003a(pbusqueda character, pusuario character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvt003a a, bvt003 b
where a.codrol = b.codrol
and a.coduser||b.desrol  like '%'||pbusqueda||'%'
and a.coduser like pusuario||'%'
and cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt005(pbusqueda character, prol character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
FROM Bvt005
WHERE b_codrol||codopc||desopc like  '%'||pbusqueda||'%'
and b_codrol like prol||'%';
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt005(pbusqueda character, prol character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
FROM Bvt005
WHERE b_codrol||codopc||desopc like  '%'||pbusqueda||'%'
and b_codrol like prol||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt006(pbusqueda character, pcoduser character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvt006
where b_codrep||b_desrep  like '%'||pbusqueda||'%'
and b_coduser like pcoduser||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvt007(pbusqueda character, prol character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
FROM Bvt007 a, bvt003 b, bvt001 c
WHERE a.b_codrol=b.codrol
and   a.b_codrep=c.codrep
and a.b_codrol||b.desrol||a.b_codrep||c.desrep like  '%'||pbusqueda||'%'
and a.b_codrol like prol||'%'
and cast(a.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvtcat1(pbusqueda character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvtcat1
where codcat1||descat1  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvtcat2(pbusqueda character, pbcodcat1 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvtcat2
where b_codcat1 like pbcodcat1||'%' 
and codcat2||descat2  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvtcat3(pbusqueda character, pbcodcat1 character, pbcodcat2 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvtcat3
where b_codcat1 like pbcodcat1||'%'
and b_codcat2 like pbcodcat2||'%' 
and codcat3||descat3  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvtcat4(pbusqueda character, pbcodcat1 character, pbcodcat2 character, pbcodcat3 character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvtcat4
where b_codcat1 like pbcodcat1||'%'
and b_codcat2 like pbcodcat2||'%' 
and b_codcat3 like pbcodcat3||'%' 
and codcat4||descat4  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_bvtmenu(pbusqueda character, pcodrol character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from bvtmenu
where b_codrol||codopc||desopc  like '%'||pbusqueda||'%'
AND  b_codrol  like pcodrol||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_estimate(query text) RETURNS INTEGER AS    
$func$    
DECLARE    
    rec   record;    
    ROWS  INTEGER;    
BEGIN    
    FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP    
        ROWS := SUBSTRING(rec.""QUERY PLAN"" FROM ' rows=([[:digit:]]+)');    
        EXIT WHEN ROWS IS NOT NULL;    
    END LOOP;    
    RETURN ROWS;    
END    
$func$ LANGUAGE plpgsql;",20170522_01.md
"CREATE FUNCTION count_estimate(query text) RETURNS INTEGER AS    
$func$    
DECLARE    
    rec   record;    
    ROWS  INTEGER;    
BEGIN    
    FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP    
        ROWS := SUBSTRING(rec.&quot;QUERY PLAN&quot; FROM ' rows=([[:digit:]]+)');    
        EXIT WHEN ROWS IS NOT NULL;    
    END LOOP;    
    RETURN ROWS;    
END    
$func$ LANGUAGE plpgsql;",index.html
CREATE FUNCTION count_estimate(query text) RETURNS INTEGER AS $func$ DECLARE rec record; ROWS INTEGER; BEGIN FOR rec IN EXECUTE 'EXPLAIN ' || query LOOP ROWS := SUBSTRING(rec.&quot;QUERY PLAN&quot; FROM ' rows=([[:digit:]]+)'); EXIT WHEN ROWS IS NOT NULL; END LOOP; RETURN ROWS; END $func$ LANGUAGE plpgsql;,index.html
"CREATE FUNCTION count_instancias(pbusqueda character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from instancias
where cast(instancia as text)||descripcion  like '%'||pbusqueda||'%';
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_instanciasusr(pbusqueda character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from instancias_usr a, instancias b
where a.instancia=b.instancia
and  a.coduser||cast(a.instancia as text)||b.descripcion  like '%'||pbusqueda||'%'
AND  cast(a.instancia as text) like pinstancia||'%';
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_mailgrupo(pbusqueda character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
from mailgrupos
where cast(idgrupo as text)||desgrupo  like '%'||pbusqueda||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_maillista(pbusqueda character, pidgrupo character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
FROM  MAILGRUPOS A, MAILLISTA B
WHERE A.IDGRUPO=B.IDGRUPO
and cast(a.idgrupo as text)||cast(b.idmail as text)||b.mail like  '%'||pbusqueda||'%'
and  cast(a.idgrupo as text) like pidgrupo||'%'
and cast(b.instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_programacion(pbusqueda character, popctareas character, pinstancia character) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
vcount bigint;
begin
select count(*) into vcount 
FROM  t_programacion
WHERE job||disparador||codrep like  '%'||pbusqueda||'%'
and opctareas like popctareas||'%'
and cast(instancia as text) = pinstancia;
return vcount;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION count_users() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'USUARIO';
	RETURN result;
END;	
$$;",backup%2007-12.sql
"CREATE FUNCTION count_users() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'USUARIO';
	RETURN result;
END;	
$$;",backup%2008-12.sql
"CREATE FUNCTION count_users() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'USUARIO';
	RETURN result;
END;	
$$;",backup%2009-12(2).sql
"CREATE FUNCTION count_users() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	result integer;
BEGIN
	SELECT COUNT(*) INTO result FROM usuario u 
		INNER JOIN rol r ON r.id = u.id_rol AND r.descripcion = 'USUARIO';
	RETURN result;
END;	
$$;",backup%2009-12.sql
"CREATE FUNCTION count_vote_rating_received_user(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE publicationvotecount INTEGER;
BEGIN
  SELECT SUM(votes.values) FROM votes INNER JOIN publications ON votes.publicationid = publications.publicationid
    INNER JOIN users ON publications.userid = users.userid WHERE publications.userid = puser_id
  INTO publicationvotecount;

  IF publicationvotecount is null THEN
    publicationvotecount := 0;
  END IF;

  return publicationvotecount;
END
$$;",dbm
"CREATE FUNCTION count_vote_rating_received_user(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE publicationvotecount INTEGER;
BEGIN
  SELECT SUM(votes.values) FROM votes INNER JOIN publications ON votes.publicationid = publications.publicationid
    INNER JOIN users ON publications.userid = users.userid WHERE publications.userid = puser_id
  INTO publicationvotecount;

  IF publicationvotecount is null THEN
    publicationvotecount := 0;
  END IF;

  return publicationvotecount;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION countapplications(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE Applications INTEGER;
	
BEGIN
       SELECT COUNT(la.*) INTO Applications 
       FROM     locum_db.locum_applications AS la  
       WHERE    ((application_Status = 'app')
	OR(application_Status = 'vie' 
	AND EXISTS  ( SELECT  '1' 
			FROM     locum_db.Users AS usr 
			WHERE    usr.user_id  = la.user_id 
			AND      COALESCE(usr.expiry_Date, current_date) >= current_date)));
	return Applications;
END;
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countappliedvacancies(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE AppliedVacancy INTEGER;
BEGIN
       SELECT COUNT(lSchdEvt.*)    INTO AppliedVacancy 
		FROM (SELECT lEvt.branch_id       AS branch_id 
		     ,lEvt.status_flag     AS status_flag 
		     ,COUNT(lEvt.id)       AS nRecs 
		     ,MIN(lEvt.event_date) AS eventDate 
		FROM      locum_db.locum_schedule_events AS lEvt 
		WHERE     lEvt.event_date   >= current_date
		GROUP BY lEvt.branch_id ,lEvt.status_flag 
		  ) AS lSchdEvt 
		  ,locum_db.branch_details AS brn 
		WHERE     current_date BETWEEN COALESCE(brn.start_date, current_date)
							AND COALESCE(brn.end_date, current_date)  
		AND       lSchdEvt.branch_id   = brn.branch_id 
		AND       lSchdEvt.status_flag = 'app' 
		AND       lSchdEvt.nRecs       > 0 
		AND EXISTS (SELECT  '1' 
			FROM    locum_db.vw_coord_group_branches as vcgb
			WHERE   vcgb.branch_id  = brn.branch_id 
			AND     vcgb.user_id    = $1);
		return AppliedVacancy;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countblockbookingapplications(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE BlockBooking INTEGER;
	BEGIN
	       SELECT CAST(COUNT(tab.*) AS INTEGER) INTO BlockBooking
		FROM  (SELECT 	b.branch_id
				, a.emp_name
				, a.hol_type
				, min(a.start_date) AS start_date
				, max(a.end_date) AS end_date
			FROM locum_db.emp_holidays a
			JOIN locum_db.vacancy_details b ON b.emp_id = a.emp_id AND b.treat_as_bulk = true
			WHERE a.status_flag = 'con' 
			AND (EXISTS (SELECT '1'
				     FROM locum_db.locum_schedule_events c
				     WHERE c.vacancy_id = b.id AND c.status_flag = 'app'))
			AND  EXISTS (SELECT  '1'
				     FROM    locum_db.vw_coord_group_branches as vcgb
				     WHERE   vcgb.branch_Id  = a.branch_Id
				     AND     vcgb.user_Id    = $1
				    )	     
			GROUP BY b.branch_id
				, a.emp_name
				, a.hol_type
		HAVING min(a.start_date) >= current_timestamp
		AND    min(a.start_date) <= (current_timestamp + '1 year')) tab;
		return BlockBooking;
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countclaimsmadebylocums(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE LocumClaim INTEGER;
BEGIN
       SELECT CAST(count(*) AS INTEGER) AS count INTO LocumClaim
       FROM locum_db.locum_claims a
       WHERE EXISTS (SELECT '1'
		     FROM locum_db.locum_claim_details b
		     WHERE b.claim_id = a.id 
		     AND  (b.schedule_id IN (SELECT c.id
				             FROM locum_db.locum_schedule_events c
				             WHERE c.id = b.schedule_id 
				             AND (c.status_flag IN ('acc', 'con'))
				             AND EXISTS (SELECT  '1'
						         FROM    locum_db.vw_coord_group_branches as vcgb
						         WHERE   vcgb.branch_Id  = c.branch_Id
						         AND     vcgb.user_Id    = $1))));
	return LocumClaim;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countdomaingroupstoexpand(_footprint_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	return (
	select 
		count(*)
	from
	       domain_groups dg
	       join domains d on d.id = dg.domain_id and d.footprint_id = dg.footprint_id
	       join domain_credentials dc on d.domain_name = dc.domain
	       join domain_credentials_map m on m.domain_credentials_id = dc.id
	       join host_data hd on m.host_data_id = hd.id
	where
	       d.footprint_id = dc.footprint_id and
	       d.footprint_id = hd.footprint_id and
	       d.footprint_id = m.footprint_id and
	       m.valid = true and    
	       dg.users_gathered = false and 
	       m.psexec_failed = false and 
	       m.dgu_failed = false and
	       dg.id not in (select item_identifier from task_list where task_descriptions_id = 26 and footprint_id = _footprint_id and in_progress = true) and
	       hd.footprint_id = _footprint_id );
end;
$$;",createdbstructure.sql
"CREATE FUNCTION countfulltimeapplications(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE FullTimeApplication INTEGER;
BEGIN
       SELECT CAST(COUNT(tab.*) AS INTEGER) INTO FullTimeApplication
	FROM (SELECT a.id
		    , a.branch_id
		    , a.user_id
		    , b.branch_name
		    , TRIM(BOTH ' ' FROM COALESCE(c.title, '') || ' ' || c.fore_name || ' ' || COALESCE(c.last_name, '')) AS locum_name
		    , to_char(a.applied_date, 'dd Mon, yyyy') AS applied_date
		    , (SELECT d.description
			FROM locum_db.codes d
			WHERE d.code = a.status_flag AND d.code_type = 'STATUS') AS status_flag
		    , c.email
		    , adet.telephone_mobile
		    , a.contact_method
		FROM locum_db.full_time_vacancy_applications a
			JOIN locum_db.branch_details b ON b.branch_id = a.branch_id AND current_date BETWEEN COALESCE(b.start_date, current_date)
															AND COALESCE(b.end_date, current_date) 
			JOIN locum_db.users c ON c.user_id = a.user_id
			JOIN locum_db.address_details adet ON adet.address_id = c.address_id
		WHERE a.status_flag = 'app'
		AND  EXISTS (SELECT  '1'
				FROM    locum_db.vw_coord_group_branches as vcgb
				WHERE   vcgb.branch_Id  = b.branch_Id
				AND     vcgb.user_Id    = $1
			)) tab;
			return FullTimeApplication;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countuserratings(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE UserRatings INTEGER;
BEGIN
       SELECT CAST(COUNT(lr.*) AS INTEGER) INTO  UserRatings
			FROM locum_db.locum_rating lr
			INNER JOIN locum_db.locum_schedule_events ls ON ls.id = lr.event_id
			WHERE ls.status_flag IN ('con', 'pay')
			AND   ls.event_date < current_timestamp
                        AND   lr.rating_assighned = false
			AND   EXISTS (SELECT  '1'
				      	  FROM    locum_db.vw_coord_group_branches as vcgb
				      	  WHERE   vcgb.branch_Id  = ls.branch_Id
				      	  AND     vcgb.user_Id    = $1
				          )
                        AND   EXISTS (SELECT  '1'
			              FROM    locum_db.users u
			              WHERE   u.user_id = ls.user_id
			              AND     u.user_type  = 'loc'
			              AND     COALESCE(u.expiry_date, current_timestamp) >= current_timestamp
			             ); 

		return UserRatings;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION countuserratings(text, text, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
	DECLARE UserRatings INTEGER;
	BEGIN
	       SELECT CAST((CASE $1
				WHEN 'cor' THEN
					(SELECT CAST(COUNT(lr.*) AS INTEGER)
					 FROM locum_db.locum_rating lr
					 INNER JOIN locum_db.locum_schedule_events ls ON ls.id = lr.event_id
					 WHERE ls.status_flag IN ('con', 'pay')
					 AND   ls.event_date < current_timestamp
					 AND   lr.rating_assighned = false
					 And   lr.cor_rating_assighned = false
					 AND   EXISTS (SELECT  '1'
						       FROM    locum_db.vw_coord_group_branches as vcgb
						       WHERE   vcgb.branch_Id  = ls.branch_Id
						       AND     vcgb.user_Id    = $2)
					 AND   EXISTS (SELECT  '1'
						       FROM    locum_db.users u
						       WHERE   u.user_id = ls.user_id
						       AND     u.user_type  = 'loc'
						       AND     COALESCE(u.expiry_date, current_timestamp) >= current_timestamp))
				ELSE
					(SELECT     CAST(COUNT(lr.*)AS INTEGER)
					 FROM locum_db.locum_rating lr
					 INNER JOIN locum_db.locum_schedule_events ls ON ls.id = lr.event_id
					 WHERE ls.status_flag IN ('con', 'pay')
					 AND   ls.event_date < current_timestamp
					 AND   lr.rating_assighned = false
					 And   lr.brc_rating_assighned = false
					 AND   EXISTS (SELECT  '1'
						       FROM    locum_db.vw_brc_user_branches as vcgb
						       WHERE   vcgb.branch_Id  = ls.branch_Id
						       AND     vcgb.user_Id    = $2
						       AND     vcgb.branch_Id  = $3)
					 AND   EXISTS (SELECT  '1'
						       FROM    locum_db.users u
						       WHERE   u.user_id = ls.user_id
						       AND     u.user_type  = 'loc'
						       AND     COALESCE(u.expiry_date, current_timestamp) >= current_timestamp))	
			END) AS INTEGER) INTO  UserRatings;
			return UserRatings;
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION crc32(word text) RETURNS bigint
    LANGUAGE plpgsql IMMUTABLE
    AS $$
          DECLARE tmp bigint;
          DECLARE i int;
          DECLARE j int;
          DECLARE word_array bytea;
          BEGIN
            IF COALESCE(word, '') = '' THEN
              return 0;
            END IF;
          
            i = 0;
            tmp = 4294967295;
            word_array = decode(replace(word, E'\\', E'\\\\'), 'escape');
            LOOP
              tmp = (tmp # get_byte(word_array, i))::bigint;
              i = i + 1;
              j = 0;
              LOOP
                tmp = ((tmp >> 1) # (3988292384 * (tmp & 1)))::bigint;
                j = j + 1;
                IF j >= 8 THEN
                  EXIT;
                END IF;
              END LOOP;
              IF i >= char_length(word) THEN
                EXIT;
              END IF;
            END LOOP;
            return (tmp # 4294967295);
          END
        $$;",o-w-production-backup29-06-2011
"CREATE FUNCTION crearschema(nombreschema character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
  DECLARE
     BEGIN
     SELECT DISTINCT SCHEMANAME FROM PG_TABLES;
     
     IF nombreSchema <> '' THEN
        EXECUTE 'CREATE SCHEMA ' || nombreSchema;        
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.ALMACEN AS SELECT * FROM PUBLIC.ALMACEN LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.ALMACENPRODUCTO AS SELECT * FROM PUBLIC.ALMACENPRODUCTO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.AREA AS SELECT * FROM PUBLIC.AREA LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.CIUDAD AS SELECT * FROM PUBLIC.CIUDAD LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.DETALLEMOVIMIENTO AS SELECT * FROM PUBLIC.DETALLEMOVIMIENTO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.FUNCIONALIDAD AS SELECT * FROM PUBLIC.FUNCIONALIDAD LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.MODULO AS SELECT * FROM PUBLIC.MODULO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.MOVIMIENTO AS SELECT * FROM PUBLIC.MOVIMIENTO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.PERFILES AS SELECT * FROM PUBLIC.PERFILES LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.PERFILFUNCIONALIDAD AS SELECT * FROM PUBLIC.PERFILFUNCIONALIDAD LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.PERSONA AS SELECT * FROM PUBLIC.PERSONA LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.PRODUCTO AS SELECT * FROM PUBLIC.PRODUCTO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.TENANT AS SELECT * FROM PUBLIC.TENANT LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.TIPOIDENTIFICACION AS SELECT * FROM PUBLIC.TIPOIDENTIFICACION LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.TIPOMEDIDA AS SELECT * FROM PUBLIC.TIPOMEDIDA LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.TIPOMOVIMIENTO AS SELECT * FROM PUBLIC.TIPOMOVIMIENTO LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.TIPOPERSONAS AS SELECT * FROM PUBLIC.TIPOPERSONAS LIMIT 0';
	EXECUTE 'CREATE TABLE ' || nombreSchema || '.USUARIO AS SELECT * FROM PUBLIC.USUARIO LIMIT 0';
     END IF;
     RETURN;
  END;
$$;",BaseDeDatos.sql
"CREATE FUNCTION create_acl_view(name) RETURNS name
    LANGUAGE plpgsql
    AS $_$
BEGIN
       

	EXECUTE ('
                DROP VIEW IF EXISTS ' || $1 || '_view;
		CREATE VIEW ' || $1 || '_view AS 
		SELECT ' || $1 || '.* FROM ' || $1 || ' 
		INNER JOIN ' || $1 || '_acl 
			ON (' || $1 || '_acl.object_id IN (0,' || $1 || '.id) AND ' || $1 || '_acl.username IN (CURRENT_USER,''*'') AND _select) OR (SELECT usesuper FROM pg_user WHERE usename=CURRENT_USER) ;
		GRANT ALL ON ' || $1 || '_view TO public;

	');

	RETURN $1;
END;
$_$;",yala.sql
"CREATE FUNCTION create_if_not_exists(table_name text, schema_name text, create_stmt text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN

IF EXISTS (
    SELECT *
    FROM   pg_catalog.pg_tables 
    WHERE    tablename  = table_name
    AND schemaname = schema_name
    ) THEN
   RETURN 'TABLE ' || '''' || table_name || '''' || ' ALREADY EXISTS';
ELSE
   EXECUTE create_stmt;
   RETURN 'CREATED';
END IF;

END;
$$;",backup.sql
"CREATE FUNCTION credit(integer, character varying) RETURNS numeric
    AS $_$
DECLARE
	course_detail RECORD;
	mp_detail RECORD;
	values RECORD;
	
BEGIN
select * into course_detail from course_periods where course_period_id = $1;
select * into mp_detail from marking_periods where marking_period_id = $2;

IF course_detail.marking_period_id = mp_detail.marking_period_id THEN
	return course_detail.credits;
ELSIF course_detail.mp = 'FY' AND mp_detail.mp_type = 'semester' THEN
	select into values count(*) as mp_count from marking_periods where parent_id = course_detail.marking_period_id group by parent_id;
ELSIF course_detail.mp = 'FY' and mp_detail.mp_type = 'quarter' THEN
	select into values count(*) as mp_count from marking_periods where grandparent_id = course_detail.marking_period_id group by grandparent_id;
ELSIF course_detail.mp = 'SEM' and mp_detail.mp_type = 'quarter' THEN
	select into values count(*) as mp_count from marking_periods where parent_id = course_detail.marking_period_id group by parent_id;
ELSE
	return 0;
END IF;

IF values.mp_count > 0 THEN
	return course_detail.credits/values.mp_count;
ELSE
	return 0;
END IF;

END$_$
    LANGUAGE plpgsql;",centre.sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;





RETURN round(x,4);



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;





RETURN round(x,4);



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;





RETURN round(x,4);



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'cs%' AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

sid INTEGER;

tid INTEGER;

BEGIN





-- old query

-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x

-- FROM viewclasses

-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;



-- new query: arg1 = studenttermid

SELECT studentid into sid FROM studentterms where studenttermid = $1;

SELECT termid into tid FROM studentterms where studenttermid = $1;





SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x

FROM viewclasses

WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;

-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;

RETURN round(x,4);



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;

-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;

RETURN round(x,4);



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;

-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;

RETURN round(x,4);



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;

-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;

RETURN round(x,4);



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION csgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits), 0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'CS%' AND gradeid <= 11;

-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'CS%' AND gradeid <= 11 AND termid <= tid;

RETURN round(x,4);



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION current_sess_id() RETURNS character varying
    AS $$
DECLARE
    v_sess_id varchar;
BEGIN
    SELECT into v_sess_id sess_id from session_id;
    IF NOT FOUND THEN
        RAISE EXCEPTION 'SESSION PROBLEM';
    END IF;

    RETURN v_sess_id;
END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION cwaproto3(p_studentid integer) RETURNS numeric
    AS $_$DECLARE 

ah INTEGER;

mst INTEGER;

ssp INTEGER;

ahcredits numeric DEFAULT 0;

mstcredits numeric DEFAULT 0;

sspcredits numeric DEFAULT 0;

majcredits numeric DEFAULT 0;

elecredits numeric DEFAULT 0;

ahd numeric DEFAULT 0;

mstd numeric DEFAULT 0;

sspd numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

cwa numeric DEFAULT 0;



BEGIN

	

	SELECT SUM(x * y) into ahcredits

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'AH' 

	ORDER BY v.termid ASC

	LIMIT 5 ) as z;	



	SELECT SUM(y) into ahd

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'AH' 

	ORDER BY v.termid ASC

	LIMIT 5 ) as z;	



	-- start: checks for the 2/3 rules of natsci 1 and 2

-- 	IF (SELECT COUNT(*)

-- 		FROM viewclasses v 

-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 1' AND v.coursename IN ('nat sci 1, chem 1, physics 10')

-- 			) > 3

-- 	THEN RETURN 7;

-- 	END IF;

-- 

-- 	IF (SELECT COUNT(*)

-- 		FROM viewclasses v 

-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 1' AND v.coursename IN ('nat sci 2, bio 1, geol 1')

-- 			) > 3

-- 	THEN RETURN 7;

-- 	END IF;

	-- end: checks for the 2/3 rules of natsci 1 and 2

	

	SELECT SUM(x * y) into mstcredits

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 1'

	ORDER BY v.termid ASC

	LIMIT 4 ) as z;		



	SELECT SUM(y) into mstd

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 1'

	ORDER BY v.termid ASC

	LIMIT 4 ) as z;	



	SELECT SUM(x * y) into sspcredits

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'SSP' 

	ORDER BY v.termid ASC

	LIMIT 5 ) as z;	



	SELECT SUM(y) into sspd

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'SSP' 

	ORDER BY v.termid ASC

	LIMIT 5 ) as z;	





	SELECT SUM(x * y) into majcredits

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'MAJ') as z;

	

	SELECT SUM(y) into majd

	FROM (

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND v.domain = 'MAJ') as z;



-- 	SELECT SUM(x * y) into elecredits

-- 	FROM (

-- 	SELECT v.gradevalue as x, v.credits as y

-- 	FROM viewclasses v 

-- 	WHERE v.studentid = $1 AND v.domain = 'ELE') as z;

-- 	

-- 	SELECT SUM(y) into eled

-- 	FROM (

-- 	SELECT v.gradevalue as x, v.credits as y

-- 	FROM viewclasses v 

-- 	WHERE v.studentid = $1 AND v.domain = 'ELE') as z;





	--start: correcting measures if a domain does not have a subject yet

	IF (SELECT COUNT(*) FROM (SELECT * from viewclasses v WHERE v.studentid = $1 AND v.domain = 'AH') as z) = 0

	THEN ahd = 0; ahcredits = 0;

	END IF;

	IF (SELECT COUNT(*) FROM (SELECT * from viewclasses v WHERE v.studentid = $1 AND v.domain = 'MST') as z) = 0

	THEN mstd = 0; mstcredits = 0;

	END IF;

	IF (SELECT COUNT(*) FROM (SELECT * from viewclasses v WHERE v.studentid = $1 AND v.domain = 'SSP') as z) = 0

	THEN sspd = 0; sspcredits = 0;

	END IF;

	IF (SELECT COUNT(*) FROM (SELECT * from viewclasses v WHERE v.studentid = $1 AND v.domain = 'MAJ') as z) = 0

	THEN majd = 0; majcredits = 0;

	END IF;

	--end: correcting measures if a domain does not have a subject yet

	

	cwa = (ahcredits + mstcredits + sspcredits + majcredits + elecredits) / (ahd + mstd + sspd + majd + eled);

	RETURN cwa;



END;$_$
    LANGUAGE plpgsql;",2013-01-21%20Dump%20(Dan).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE ahFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE mstFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE sspFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;



	CREATE TEMPORARY TABLE eleFails AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);

		



	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN

		SELECT SUM(x * y) into ahf FROM ahFails;

		SELECT SUM(y) into ahdf FROM ahFails;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN

		SELECT SUM(x * y) into mstf FROM mstFails;

		SELECT SUM(y) into mstdf FROM mstFails;

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;

	

	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN

		SELECT SUM(x * y) into sspf FROM sspFails;

		SELECT SUM(y) into sspdf FROM sspFails;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN

			SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN

		SELECT SUM(x * y) into elef FROM eleFails;

		SELECT SUM(y) into eledf FROM eleFails;

	END IF;


	DROP TABLE first5ahPass;

	DROP TABLE ahFails;

	DROP TABLE first4mstPass;

	DROP TABLE mstFails;

	DROP TABLE first5sspPass;

	DROP TABLE sspFails;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	DROP TABLE eleFails;


	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	



END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 
ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
cwa numeric DEFAULT 0;

BEGIN



	CREATE TEMPORARY TABLE first5ahPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE ahFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first4mstPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 4;

	CREATE TEMPORARY TABLE mstFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first5sspPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE sspFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE majors ON COMMIT DROP AS 
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;


	IF (SELECT COUNT(*) FROM first5ahPass) != 0 THEN
		SELECT SUM(x * y) into ah FROM first5ahPass;
		SELECT SUM(y) into ahd FROM first5ahPass;
	END IF;

	IF (SELECT COUNT(*) FROM ahFails) != 0 THEN
		SELECT SUM(x * y) into ahf FROM ahFails;
		SELECT SUM(y) into ahdf FROM ahFails;
	END IF;

	IF (SELECT COUNT(*) FROM first4mstPass) != 0 THEN
		SELECT SUM(x * y) into mst FROM first4mstPass;
		SELECT SUM(y) into mstd FROM first4mstPass;

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 
			SELECT ns1correction($1) into mst; 
			SELECT ns1_dcorrection($1) into mstd;
		END IF;
		
		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 
			SELECT ns2correction($1) into mst; 
			SELECT ns2_dcorrection($1) into mstd;
		END IF;
		
	END IF;

	IF (SELECT COUNT(*) FROM mstFails) != 0 THEN
		SELECT SUM(x * y) into mstf FROM mstFails;
		SELECT SUM(y) into mstdf FROM mstFails;
	END IF;

	IF (SELECT COUNT(*) FROM first5sspPass) != 0 THEN
		SELECT SUM(x * y) into ssp FROM first5sspPass;
		SELECT SUM(y) into sspd FROM first5sspPass;
	END IF;
	
	IF (SELECT COUNT(*) FROM sspFails) != 0 THEN
		SELECT SUM(x * y) into sspf FROM sspFails;
		SELECT SUM(y) into sspdf FROM sspFails;
	END IF;

	IF (SELECT COUNT(*) FROM majors) != 0 THEN
		SELECT SUM(x * y) into maj FROM majors;
		SELECT SUM(y) into majd FROM majors;
	END IF;

	cwa = (ah + ahf + mst + mstf + ssp + sspf + maj + ele) / (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	RETURN round(cwa,4);	

END;$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 
ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
cwa numeric DEFAULT 0;

BEGIN



	CREATE TEMPORARY TABLE first5ahPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE ahFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first4mstPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 4;

	CREATE TEMPORARY TABLE mstFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first5sspPass ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE sspFails ON COMMIT DROP AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE majors ON COMMIT DROP AS 
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;


	IF (SELECT COUNT(*) FROM first5ahPass) != 0 THEN
		SELECT SUM(x * y) into ah FROM first5ahPass;
		SELECT SUM(y) into ahd FROM first5ahPass;
	END IF;

	IF (SELECT COUNT(*) FROM ahFails) != 0 THEN
		SELECT SUM(x * y) into ahf FROM ahFails;
		SELECT SUM(y) into ahdf FROM ahFails;
	END IF;

	IF (SELECT COUNT(*) FROM first4mstPass) != 0 THEN
		SELECT SUM(x * y) into mst FROM first4mstPass;
		SELECT SUM(y) into mstd FROM first4mstPass;

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 
			SELECT ns1correction($1) into mst; 
			SELECT ns1_dcorrection($1) into mstd;
		END IF;
		
		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 
			SELECT ns2correction($1) into mst; 
			SELECT ns2_dcorrection($1) into mstd;
		END IF;
		
	END IF;

	IF (SELECT COUNT(*) FROM mstFails) != 0 THEN
		SELECT SUM(x * y) into mstf FROM mstFails;
		SELECT SUM(y) into mstdf FROM mstFails;
	END IF;

	IF (SELECT COUNT(*) FROM first5sspPass) != 0 THEN
		SELECT SUM(x * y) into ssp FROM first5sspPass;
		SELECT SUM(y) into sspd FROM first5sspPass;
	END IF;
	
	IF (SELECT COUNT(*) FROM sspFails) != 0 THEN
		SELECT SUM(x * y) into sspf FROM sspFails;
		SELECT SUM(y) into sspdf FROM sspFails;
	END IF;

	IF (SELECT COUNT(*) FROM majors) != 0 THEN
		SELECT SUM(x * y) into maj FROM majors;
		SELECT SUM(y) into majd FROM majors;
	END IF;

	cwa = (ah + ahf + mst + mstf + ssp + sspf + maj + ele) / (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	RETURN round(cwa,4);	

END;$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION cwaproto4(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 
ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;

BEGIN



	CREATE TEMPORARY TABLE first5ahPass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE ahFails AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first4mstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 4;

	CREATE TEMPORARY TABLE mstFails AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE first5sspPass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE sspFails AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10);

	CREATE TEMPORARY TABLE majors AS 
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11;

	CREATE TEMPORARY TABLE first3elePass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 3;

	CREATE TEMPORARY TABLE eleFails AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10);
		

	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN
		SELECT SUM(x * y) into ah FROM first5ahPass;
		SELECT SUM(y) into ahd FROM first5ahPass;
	END IF;

	IF (SELECT COUNT(*) FROM ahFails) <> 0 THEN
		SELECT SUM(x * y) into ahf FROM ahFails;
		SELECT SUM(y) into ahdf FROM ahFails;
	END IF;

	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN
		SELECT SUM(x * y) into mst FROM first4mstPass;
		SELECT SUM(y) into mstd FROM first4mstPass;

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 
			SELECT ns1_correction($1) into mst; 
			SELECT ns1_dcorrection($1) into mstd;
		END IF;
		
		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 
			SELECT ns2_correction($1) into mst; 
			SELECT ns2_dcorrection($1) into mstd;
		END IF;
		
	END IF;

	IF (SELECT COUNT(*) FROM mstFails) <> 0 THEN
		SELECT SUM(x * y) into mstf FROM mstFails;
		SELECT SUM(y) into mstdf FROM mstFails;
	END IF;

	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN
		SELECT SUM(x * y) into ssp FROM first5sspPass;
		SELECT SUM(y) into sspd FROM first5sspPass;
	END IF;
	
	IF (SELECT COUNT(*) FROM sspFails) <> 0 THEN
		SELECT SUM(x * y) into sspf FROM sspFails;
		SELECT SUM(y) into sspdf FROM sspFails;
	END IF;

	IF (SELECT COUNT(*) FROM majors) <> 0 THEN
		SELECT SUM(x * y) into maj FROM majors;
		SELECT SUM(y) into majd FROM majors;
	END IF;

	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN
		SELECT SUM(x * y) into ele FROM first3elePass;
		SELECT SUM(y) into eled FROM first3elePass;

		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'C197') > 2 THEN
			SELECT overcs197_correction($1) INTO ele;
			SELECT overcs197_dcorrection($1) INTO eled;
		END IF;

		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN
			SELECT overMSEE_correction($1) INTO ele;
			SELECT overMSEE_dcorrection($1) INTO eled;
		END if;

		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN
			SELECT overFE_correction($1) INTO ele;
			SELECT overFE_dcorrection($1) INTO eled; 
		END IF;
	END IF;

	IF (SELECT COUNT(*) FROM eleFails) <> 0 THEN
		SELECT SUM(x * y) into elef FROM eleFails;
		SELECT SUM(y) into eledf FROM eleFails;
	END IF;

	cwa = (ah + ahf + mst + mstf + ssp + sspf + maj + ele) / (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);

	DROP TABLE first5ahPass;
	DROP TABLE ahFails;
	DROP TABLE first4mstPass;
	DROP TABLE mstFails;
	DROP TABLE first5sspPass;
	DROP TABLE sspFails;
	DROP TABLE majors;
	DROP TABLE first3elePass;
	DROP TABLE eleFails;
	
	RETURN round(cwa,4);	

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION dangnhap(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(select * from ""DangNhap"" where ""TenDangNhap""= $1 and ""MatKhau"" = $2);
	end
	$_$;",database.backup
"CREATE FUNCTION data_atual() RETURNS date
    LANGUAGE plpgsql
    AS $$
  declare 
     data date not null DEFAULT '2011-10-30'::date ;
  begin
      select current_date into data;
      --select null into data;
     return data;
  end;  
$$;",aula.sql
"CREATE FUNCTION data_atual2(OUT data date) RETURNS date
    LANGUAGE plpgsql
    AS $$
     begin
       select current_date into data;
     end;
  $$;",aula.sql
"CREATE FUNCTION databasesize() RETURNS character varying
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
  RETURN pg_size_pretty(pg_database_size(current_database())) AS ""Размер базы данных"";
END;
$$;",Dump.sql
"CREATE FUNCTION date() RETURNS date
    LANGUAGE plpgsql
    AS $$
begin
         return  current_date;
end; 
$$;",sql_schema_20170101.sql
"CREATE FUNCTION date(integer, integer, integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$

declare 

	tnYear alias for $1;

	tnMonth alias for $2;

	tnDay alias for $3;
	lcYear varchar(4);

	lcMonth varchar(2);

	lcDay varchar(2);

begin
	if tnYear = 0 or tnMonth = 0 or tnDay = 0 then
		return null;
	end if;


	lcYear := str(tnYear,4);

	if tnMonth < 10 then

		lcMonth := '0'+str(tnMonth,1);

	else

		lcMonth:= str(tnMonth,2);

	end if;

	if tnDay < 10 then

		lcDay := '0'+str(tnDay,1);

	else

		lcDay:= str(tnday,2);

	end if;

         return  to_date(lcYear+lcMonth+lcDay,'YYYYMMDD');
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION date(integer, integer, integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$

declare 

	tnYear alias for $1;

	tnMonth alias for $2;

	tnDay alias for $3;
	lcYear varchar(4);

	lcMonth varchar(2);

	lcDay varchar(2);

begin

	lcYear := str(tnYear,4);

	if tnMonth < 10 then

		lcMonth := '0'+str(tnMonth,1);

	else

		lcMonth:= str(tnMonth,2);

	end if;

	if tnDay < 10 then

		lcDay := '0'+str(tnDay,1);

	else

		lcDay:= str(tnday,2);

	end if;

         return  to_date(lcYear+lcMonth+lcDay,'YYYYMMDD');
end; 
$_$;",dumpl.sql
"CREATE FUNCTION date2slot(refdate timestamp with time zone) RETURNS bigint
    LANGUAGE plpgsql
    AS $$declare
  slot bigint;
begin
  slot = date_part('year',refdate) * 100000000;
  slot = slot + date_part('month',refdate) * 1000000;
  slot = slot + date_part('day',refdate) * 10000;
  slot = slot + date_part('hour',refdate) * 100;
  IF date_part('minute',refdate) < 30 THEN
    slot = slot + 0;
  ELSE
    slot = slot + 30;
  END IF;

  return slot;
end;
$$;",TBDB.bck
"CREATE FUNCTION date_add(date, interval) RETURNS date
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add(date, interval) RETURNS date
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add(timestamp with time zone, interval) RETURNS timestamp with time zone     AS $_$ BEGIN  RETURN $1 + $2; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION date_add(timestamp with time zone, interval) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::timestamp with time zone;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add(timestamp with time zone, interval) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::timestamp with time zone;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add(timestamp without time zone, interval) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add(timestamp without time zone, interval) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate     ALIAS FOR $1;
  pInterval ALIAS FOR $2;
BEGIN
  RETURN (pDate + pInterval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_days(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN date_add_days(pDate::timestamp with time zone, pDays)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_days(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN date_add_days(pDate::timestamp with time zone, pDays)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_days(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pDays || ' days')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_days(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pDays || ' days')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_days(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN date_add_days(pDate::timestamp with time zone, pDays)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_days(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  pDays ALIAS FOR $2;
BEGIN
  RETURN date_add_days(pDate::timestamp with time zone, pDays)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_months(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN date_add_months(pDate::timestamp with time zone, pMonths)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_months(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN date_add_months(pDate::timestamp with time zone, pMonths)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_months(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pMonths || ' months')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_months(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pMonths || ' months')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_months(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN date_add_months(pDate::timestamp with time zone, pMonths);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_months(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate   ALIAS FOR $1;
  pMonths ALIAS FOR $2;
BEGIN
  RETURN date_add_months(pDate::timestamp with time zone, pMonths);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_years(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN date_add_years(pDate::timestamp with time zone, pYears)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_years(date, integer) RETURNS date
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN date_add_years(pDate::timestamp with time zone, pYears)::date;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_years(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pYears || ' years')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_years(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN (pDate + (pYears || ' years')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_add_years(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN date_add_years(pDate::timestamp with time zone, pYears);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_add_years(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pDate  ALIAS FOR $1;
  pYears ALIAS FOR $2;
BEGIN
  RETURN date_add_years(pDate::timestamp with time zone, pYears);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_arg_format(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	mes double precision;
	mes_salida character varying(20);
BEGIN
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN date_part('day',fecha) || ' de ' || mes_salida || ' de ' || date_part('year',fecha);
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION date_arg_format(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	mes double precision;
	mes_salida character varying(20);
BEGIN
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN date_part('day',fecha) || ' de ' || mes_salida || ' de ' || date_part('year',fecha);
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION date_arg_format(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	mes double precision;
	mes_salida character varying(20);
BEGIN
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN date_part('day',fecha) || ' de ' || mes_salida || ' de ' || date_part('year',fecha);
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION date_arg_format(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	mes double precision;
	mes_salida character varying(20);
BEGIN
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN date_part('day',fecha) || ' de ' || mes_salida || ' de ' || date_part('year',fecha);
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION date_arg_format(fecha date) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	mes double precision;
	mes_salida character varying(20);
BEGIN
	IF (fecha IS NOT NULL) THEN
		mes = date_part('month',fecha);
		CASE mes
			WHEN 1 THEN mes_salida = 'Enero';
			WHEN 2 THEN mes_salida = 'Febrero';
			WHEN 3 THEN mes_salida = 'Marzo';
			WHEN 4 THEN mes_salida = 'Abril';
			WHEN 5 THEN mes_salida = 'Mayo';
			WHEN 6 THEN mes_salida = 'Junio';
			WHEN 7 THEN mes_salida = 'Julio';
			WHEN 8 THEN mes_salida = 'Agosto';
			WHEN 9 THEN mes_salida = 'Septiembre';
			WHEN 10 THEN mes_salida = 'Octubre';
			WHEN 11 THEN mes_salida = 'Noviembre';
			WHEN 12 THEN mes_salida = 'Diciembre';
		END CASE;
	ELSE
		RAISE EXCEPTION 'La fecha es nula, no se puede castear';
	END IF;
	RETURN date_part('day',fecha) || ' de ' || mes_salida || ' de ' || date_part('year',fecha);
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION date_diff_days(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN  to_days(pEndDate) - to_days(pStartDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_days(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN  to_days(pEndDate) - to_days(pStartDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_days(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
  vInterval  interval;
BEGIN
  vInterval := DATE_TRUNC('day', pEndDate) - DATE_TRUNC('day', pStartDate);
  RETURN EXTRACT('day' FROM vInterval);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_days(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
  vInterval  interval;
BEGIN
  vInterval := DATE_TRUNC('day', pEndDate) - DATE_TRUNC('day', pStartDate);
  RETURN EXTRACT('day' FROM vInterval);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_days(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN  to_days(pEndDate) - to_days(pStartDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_days(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN  to_days(pEndDate) - to_days(pStartDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_months(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_months(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_months(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_months(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_months(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
  vInterval  interval;
BEGIN
  vInterval := AGE(pEndDate, pStartDate);
  RETURN EXTRACT('month' FROM vInterval) + (12 * EXTRACT('year' FROM vInterval));
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_months(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
  vInterval  interval;
BEGIN
  vInterval := AGE(pEndDate, pStartDate);
  RETURN EXTRACT('month' FROM vInterval) + (12 * EXTRACT('year' FROM vInterval));
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_months(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_months(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_months(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_months(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_years(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_years(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_years(date, date) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_years(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_years(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN EXTRACT('year' FROM AGE(DATE_TRUNC('month', pEndDate), DATE_TRUNC('month', pStartDate)));
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_years(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN EXTRACT('year' FROM AGE(DATE_TRUNC('month', pEndDate), DATE_TRUNC('month', pStartDate)));
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_diff_years(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_years(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION date_diff_years(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate   ALIAS FOR $2;
BEGIN
  RETURN date_diff_years(pStartDate::timestamp with time zone, pEndDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION date_format(timestamp with time zone, text) RETURNS text     AS $_$ DECLARE  f text;  r text[][] = ARRAY[['%Y','YYYY'],['%m','MM'],['%d','DD'],['%H','HH24'],['%i','MI'],['%S','SS'],['%k','FMHH24']];  i int4; BEGIN  f := $2;  FOR i IN 1..array_upper(r, 1) LOOP    f := replace(f, r[i][1], r[i][2]);  END LOOP;  RETURN to_char($1, f); END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION date_sub(date, integer, text) RETURNS date
    LANGUAGE plpgsql
    AS $_$
DECLARE
        var1 date;
        var2 text;
BEGIN
        var2 = $2 || ' ' || $3;
        SELECT INTO var1
                to_date($1 - var2::interval, 'YYYY-MM-DD');
RETURN var1;
END;$_$;",backupDBforTesting.backup
"CREATE FUNCTION date_sub(date, integer, text) RETURNS date
    LANGUAGE plpgsql
    AS $_$
DECLARE
        var1 date;
        var2 text;
BEGIN
        var2 = $2 || ' ' || $3;
        SELECT INTO var1
                to_date($1 - var2::interval, 'YYYY-MM-DD');
RETURN var1;
END;$_$;",salida
"CREATE FUNCTION date_sub(timestamp with time zone, interval) RETURNS timestamp with time zone     AS $_$ BEGIN  RETURN $1 - $2; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION day(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
         return  datepart(""day"",$1)
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION dayofmonth(date) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION dayofmonth(date) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION dayofmonth(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION dayofmonth(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION dayofmonth(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION dayofmonth(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN EXTRACT('day' FROM pDate);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION dayofweek(timestamp with time zone) RETURNS integer     AS $_$ DECLARE  i int4; BEGIN  i = date_part('dow', $1);  RETURN i + 1; END; $_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION dba.""getConfig""(config_ character varying, scope_ character, scopeid_ character varying, defsetting_ character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare Setting_ varchar(255);
begin
  select setting
    into Setting_ from dba.pxconfig
    where Config = Config_ and Scope = Scope_ and ScopeID = ScopeID_;
  if Setting_ is null or Setting_ = '' then
    set Setting_ = DefSetting_;
  end if;
  return trim(Setting_);
end
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION dba.pxgetean13(tmpcd character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare ProdCD char(13);
  declare CDigit char(1);
  declare i integer;
  declare step1 integer;
  declare step2 integer;
  declare sum integer;
  declare factor_ integer;
  BEGIN
    ProdCD = '';
    if length(tmpCD) <> 12 then
      ProdCD = tmpCD;
    else
      i = 12; --(len(tmpCD)
      sum = 0;
      factor_ = 3;
      while i >= 1 loop
        sum = sum+(cast(SUBSTRING(tmpCD,i,1) as integer)*factor_);
        i = i-1;
        factor_ = 4-factor_;
      end loop;
      --CDigit = remainder((1000-sum),10);
      CDigit = (1000-sum) % 10;
      ProdCD = tmpCD || cast(CDigit as char(1));
    end if;
    --return length(tmpCD);  
    return ProdCD;
  END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION dba.setpreserveddefault(userid_ character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  Select dba.setpreserved('EOP',userid_,'Glo:CurrentPeriod','1','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:CurrentSiteID','99999','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:SiteID1','0','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:SiteID2','Z','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:CurrentEntityID','04','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:Entity1','0','Preserved');
  --PERFORM dba.setpreserved('EOP',userid_,'Glo:Entity2','Z','Preserved');
END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION deactivatesummsubass(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('deactivatesummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, null, true));

	

	PERFORM (SELECT deactivatepart(	pItemNumber,

					pRevision,

					pSerialNumber));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT deactivatepart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber));

		END IF;

	END LOOP;

		  

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION deallocpart(text, text, text, text DEFAULT NULL::text, text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 		ALIAS FOR $1;

	pRevision 		ALIAS FOR $2;

	pSerialNumber 		ALIAS FOR $3;	

	pLine			ALIAS FOR $4;

	pStation		ALIAS FOR $5;

	_parentviewpart 	RECORD;

	_viewpart 		RECORD;

	_allocCheck 		RECORD;

	_locationId 		INTEGER;

	_partStateId 		INTEGER;

	_usrId 			INTEGER;

	_message 		TEXT;

	_partAllocHistId 	INTEGER;

	_stationId		INTEGER;

	_lineId			INTEGER;

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('deallocpart'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, 'Child', true));

	

	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_rev,

		part_serialnumber, 

		part_sequencenumber,

		part_allocpos,

		parent_part_id,

		parent_item_number,

		parent_part_rev,

		parent_part_serialnumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;



	IF _viewpart.parent_part_id IS NOT NULL THEN

		RETURN deallocpart(_viewpart.parent_item_number, _viewpart.parent_part_rev, _viewpart.parent_part_serialnumber, pItemNumber, pRevision, pSerialNumber, 'AMDD001', pLine, pStation);

	ELSE

		RAISE EXCEPTION 'Parent does not exists for Child Item Number % Revision % Serial Number % and cannot be deallocated.', 

			pItemNumber, 

			pRevision, 

			pSerialNumber;

	END IF;

END;$_$;",ames_dev.backup
"CREATE FUNCTION defaul_index_trial_f() RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
dist double precision;
id integer;
BEGIN
dist = MIN(cube_distance(cube(ARRAY[col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, 
            col11, col12, col13, col14, col15]), cube(ARRAY[65,814,447,596,61,667,149,763,38,39,514,399,635,443,761]))) FROM default_index_trial;
id = p_key FROM default_index_trial WHERE cube_distance(cube(ARRAY[col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, 
            col11, col12, col13, col14, col15]), cube(ARRAY[65,814,447,596,61,667,149,763,38,39,514,399,635,443,761])) = dist;
return id;
END;$$;",database
"CREATE FUNCTION default_timestamp() RETURNS timestamp with time zone
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
  return transaction_timestamp();
END;
$$;",baseline-schema.sql
"CREATE FUNCTION descendientes_out(varconceptid numeric, OUT conceptid numeric, OUT term character varying, OUT depth integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
    reg RECORD;
BEGIN
    FOR REG IN  select d.conceptId, d.term, t.depth
		from snomed.descriptions d 
		Inner join snomed.languages l on d.id = l.referencedcomponentid
		inner join snomed.transitiveclosure t on t.subtypeid = d.conceptId
		where 
		d.active = TRUE
		and l.active = TRUE
		and l.refsetId =  450828004 --conjunto de referencias de lenguaje castellano para América Latina (metadato fundacional) 
		and t.supertypeId = varconceptid --valor para buscar
		--and d.typeId = 900000000000003001 --FSN
		order by t.depth, char_length(d.term) LOOP
	conceptid := reg.conceptid;
	term := reg.term;
	depth := reg.depth;
       RETURN NEXT;
    END LOOP;
    RETURN;
END
$$;",simulador.txt
"CREATE FUNCTION describe(_table text) RETURNS SETOF attr_stats AS $$
DECLARE
  _query text;
  _result attr_stats;
BEGIN
  SELECT INTO _query &#39;SELECT (b.a).* FROM (SELECT UNNEST(ARRAY[&#39; || array_to_string(array_agg(format(&#39;
      (&#39;&#39;%s&#39;&#39;,
      COUNT(%s),
      AVG(%s::double precision),
      STDDEV_SAMP(%s::double precision),
      MIN(%s::double precision),
      (PERCENTILE_DISC(0.25) WITHIN GROUP (ORDER BY %s))::double precision,
      (PERCENTILE_DISC(0.50) WITHIN GROUP (ORDER BY %s))::double precision,
      (PERCENTILE_DISC(0.75) WITHIN GROUP (ORDER BY %s))::double precision,
      MAX(%s::double precision))::attr_stats&#39;,
    a.attname, a.attname, a.attname, a.attname, a.attname, a.attname, a.attname, a.attname, a.attname)), &#39;, &#39;) || &#39;]) a FROM &#39; || _table || &#39;) b&#39;
  FROM pg_attribute a
  JOIN pg_type t ON t.oid = a.atttypid
  WHERE a.attrelid = _table::regclass AND t.typcategory = &#39;N&#39; AND t.typname != &#39;oid&#39;;

  RAISE NOTICE &#39;Executing following query: %&#39;, _query;

  FOR _result IN EXECUTE _query LOOP
    RETURN NEXT _result;
  END LOOP;

  RETURN;
END;
$$ LANGUAGE PLPGSQL STRICT;",Pandas%20and%20SQL.slides.html
"CREATE FUNCTION determina_resultat(idprovatecnica bigint, idpacient bigint, resultat character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql1 varchar := '';
  sql2 varchar := '';
  ret varchar :='';
  rec record;
  trobat boolean := False;
  edat int;
  sexe int;
  min_pat float;
  max_pat float;
  min_pan float;
  max_pan float;
  res_numeric float;
BEGIN
  sql1 := 'SELECT * FROM pacients WHERE idpacient = ' || idpacient || ';';
  FOR rec IN EXECUTE(sql1) LOOP
    trobat:= True;
    IF rec.data_naix is NULL OR rec.sexe is NULL THEN
      return '2';
    ELSE
      sql2 := 'select to_char(age(timestamp '''||rec.data_naix||'''), '''||'YY'||''');';
      EXECUTE (sql2) INTO edat;
      IF rec.sexe = 'M' THEN
        sexe = 1;
      ELSE
        sexe = 2;
      END IF;
    END IF;
  END LOOP;
  
  IF NOT trobat THEN
    return '2';
  END IF;
  
  trobat:= False;
  sql1 := 'select * from provestecnica where idprovatecnica='||idprovatecnica||' and sexe ='||sexe||';';
  FOR rec IN EXECUTE(sql1) LOOP
    trobat :=True;
  END LOOP;
  
  IF NOT trobat THEN
    sexe=0;
  END IF;
  
  sql1 := 'select * from provestecnica where idprovatecnica='||idprovatecnica||' and sexe='||sexe||' and '||edat||' between edat_inicial and edat_final and edat_final >'||edat||' ;';
  FOR rec IN EXECUTE(sql1) LOOP
    trobat := true;
    IF rec.resultat_numeric then
      IF es_Numeric(resultat) THEN
        min_pat     := rec.minpat;
        max_pat     := rec.maxpat;
        min_pan     := rec.minpan;
        max_pan     := rec.maxpan;
        res_numeric := cast(resultat as float);
        
        IF res_numeric > min_pat AND res_numeric < max_pat THEN
            ret := '1';
        ELSE
          IF (res_numeric >= max_pat AND res_numeric < max_pan) 
          OR (res_numeric <= min_pat AND res_numeric > min_pan) THEN
            ret := '2';
          ELSE
            IF res_numeric >= max_pan OR res_numeric <= min_pan THEN
              ret := '3';
            END IF;
          END IF;
        END IF;
      ELSE
        ret:='3';
      END IF;
    ELSE
      IF resultat != rec.alfpat   THEN
        ret := '2';
      ELSE
        ret := '1';
      END IF;
    END IF;  
  END LOOP;

  if not trobat then
    return '-5';
  end if;
  
RETURN ret;
EXCEPTION 
  WHEN unique_violation THEN return '-1'; 
  WHEN foreign_key_violation THEN return '-2'; 
  WHEN not_null_violation THEN return '-3';
  WHEN others THEN return '-4'; 
END;
$$;",lab_clinic.sql
"CREATE FUNCTION device_memory_amount(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE
sum double precision;
 BEGIN
	sum = SUM(amount_of_memory) FROM memorymodule JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON memorymodule.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN sum;
END$$;",database
"CREATE FUNCTION device_setting_retrieve(devname character varying) RETURNS devicesetting
    AS $$
declare
	r devicesetting%rowtype;
BEGIN
	SELECT * into r FROM devicesetting where deviceid IN ( select id from devices where strname=devname );
	return r;
END;

  $$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION device_setting_retrieve1(devname character varying) RETURNS SETOF refcursor
    AS $$

DECLARE 
	ref1 refcursor;
BEGIN
	OPEN ref1 FOR 
	 SELECT * FROM devicesetting;
	RETURN NEXT ref1;
	return; 
END;

  $$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION dias_prorroga_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_f) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo and (fecha_entrega-fecha_f)>=0;
RETURN total;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION dias_prorroga_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_f) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo and (fecha_entrega-fecha_f)>=0;
RETURN total;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION dias_prorroga_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_f) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo and (fecha_entrega-fecha_f)>=0;
RETURN total;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION dias_prorroga_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_f) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo and (fecha_entrega-fecha_f)>=0;
RETURN total;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION dias_prorroga_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_f) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo and (fecha_entrega-fecha_f)>=0;
RETURN total;
END
$$;",backup1.sql
"CREATE FUNCTION divide(a integer, b integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
  begin
    return a/b;
  exception
    when division_by_zero then
       return -1;     
  end;
$$;",aula.sql
"CREATE FUNCTION dni_correct(dni character varying) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE

 	ret varchar := '1';
 	partnum varchar;
 	lletras varchar := 'TRWAGMYFPDXBNJZSQVHLCKE';
 	modul int;
 	lletraresultat varchar(1);
 	lletradni varchar(1);
BEGIN
 	IF char_length(dni) != 9 THEN
		 ret := '-1';
	ELSE
 		partnum = substr (dni, 1, 8);
 		modul := cast (partnum as int) % 23;
 		
 		lletraresultat := substring(lletras from modul + 1  for 1);
		lletradni := right(dni,1);

		IF lletraresultat <>  lletradni THEN
			ret := '2';
		END IF;
		
	END IF;
RETURN ret;
EXCEPTION WHEN others THEN
	RETURN '3';
END;
$$;",lab_clinic.sql
"CREATE FUNCTION doc_get_id(path text) RETURNS bigint
    LANGUAGE plpgsql
    AS $_$
declare
  iParentId bigint;
  iId bigint;
  i integer;
  sPart text;
  arrParts text[];
begin
  iParentId = 0;
  arrParts = regexp_split_to_array($1,
    _get_config_var('doc_path_delimeters'));
  i = array_lower(arrParts, 1);
  while i<=array_upper(arrParts, 1) loop
    sPart = arrParts[i];
    if(sPart <> '') then
      select id from docs where node = sPart and parent_id = iParentId into iId;
      if(iId is null) then
        return null;
      else
        iParentId = iId;
      end if;
    end if;
    i = i+1;
  end loop;
  return iId;
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION doc_get_path(id bigint) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare 
  sDelim text;
begin
  sDelim = _get_config_var('doc_path_delim');
  return (with recursive a(ord, id, path) as (
        select 1, parent_id, node from docs where docs.id = $1
      union
        select a.ord+1, parent_id, node||sDelim||a.path
        from a, docs
        where docs.id = a.id
    )
    select path from a order by ord desc limit 1);
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION doc_get_random() RETURNS bigint
    LANGUAGE plpgsql
    AS $$begin
  return (select id from docs
    where weight>0 order by id offset floor(random() * (select count(1) from docs where weight>0)) limit 1);
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION doc_get_vector(doc_id bigint) RETURNS _vector[]
    LANGUAGE plpgsql
    AS $_$begin
  return array(
    select (tf.term_id, tf.term_count)::_vector
      from tf where tf.doc_id = $1 order by term_id
  )::_vector[];
  /*return array(
    select (p2.term_id, 1.0*p2.term_count/(select weight from docs where id = $1) *
      log((select count(1) from docs)/p2.count))::_vector
    from (
      select tf1.term_id, tf1.term_count, count(1) as count from (
        select * from tf where tf.doc_id = $1 order by term_id offset $2 limit $3) tf1
      join tf tf2 on tf1.term_id = tf2.term_id
      group by tf1.term_id, tf1.term_count
    ) p2 order by p2.term_id
  )::_vector[];*/
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION donor_quarterly_rank_query(v_quarter integer, v_team integer, v_year integer) RETURNS SETOF type_donor_quarterly_rank
    LANGUAGE plpgsql STABLE STRICT
    AS $$
declare
line type_donor_quarterly_rank;
a_month smallint[];
cur_month smallint;
cur_year smallint;
cur_month_in boolean;

begin
a_month[1] := v_quarter * 3 - 2;
a_month[2] := v_quarter * 3 - 1;
a_month[3] := v_quarter * 3;
cur_month := extract(month from (select last_date from last_date));
cur_year := extract(year from (select last_date from last_date));
cur_month_in := (cur_month = any (a_month) and cur_year = v_year);
if cur_month_in then
   if cur_month < a_month[3] then a_month[3] := -1; end if;
   if cur_month < a_month[2] then a_month[2] := -1; end if;
else cur_month := -1;
end if;
for line in
select
   ui.usuario_serial, ui.usuario_nome,
   case when a_month[1] = cur_month then dp.pontos_month    else points[a_month[1]]       end as p1,
   case when a_month[2] = cur_month then dp.pontos_month    else points[a_month[2]]       end as p2,
   case when a_month[3] = cur_month then dp.pontos_month    else points[a_month[3]]       end as p3,
   case when a_month[1] = cur_month then dp.rank_month_time else team_rank[a_month[1]]    end as tr1,
   case when a_month[2] = cur_month then dp.rank_month_time else team_rank[a_month[2]]    end as tr2,
   case when a_month[3] = cur_month then dp.rank_month_time else team_rank[a_month[3]]    end as tr3,
   case when a_month[1] = cur_month then dp.rank_month      else project_rank[a_month[1]] end as pr1,
   case when a_month[2] = cur_month then dp.rank_month      else project_rank[a_month[2]] end as pr2,
   case when a_month[3] = cur_month then dp.rank_month      else project_rank[a_month[3]] end as pr3,
   coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) as qt
from usuarios_indice as ui
left join donor_yearly as dy
   on ui.usuario_serial = dy.donor and ""year"" = v_year
left join donors_production as dp
   on ui.usuario_serial = dp.usuario and cur_month_in
where ui.n_time = v_team
   and coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) > 0

loop
return next line;
end loop;

return;
end;
$$;",fahstats.schema
"CREATE FUNCTION donor_quarterly_rank_query(v_quarter integer, v_team integer, v_year integer) RETURNS SETOF type_donor_quarterly_rank
    LANGUAGE plpgsql STABLE STRICT
    AS $$
declare
line type_donor_quarterly_rank;
a_month smallint[];
cur_month smallint;
cur_year smallint;
cur_month_in boolean;

begin
a_month[1] := v_quarter * 3 - 2;
a_month[2] := v_quarter * 3 - 1;
a_month[3] := v_quarter * 3;
cur_month := extract(month from (select last_date from last_date));
cur_year := extract(year from (select last_date from last_date));
cur_month_in := (cur_month = any (a_month) and cur_year = v_year);
if cur_month_in then
   if cur_month < a_month[3] then a_month[3] := -1; end if;
   if cur_month < a_month[2] then a_month[2] := -1; end if;
else cur_month := -1;
end if;
for line in
select
   ui.usuario_serial, ui.usuario_nome,
   case when a_month[1] = cur_month then dp.pontos_month    else points[a_month[1]]       end as p1,
   case when a_month[2] = cur_month then dp.pontos_month    else points[a_month[2]]       end as p2,
   case when a_month[3] = cur_month then dp.pontos_month    else points[a_month[3]]       end as p3,
   case when a_month[1] = cur_month then dp.rank_month_time else team_rank[a_month[1]]    end as tr1,
   case when a_month[2] = cur_month then dp.rank_month_time else team_rank[a_month[2]]    end as tr2,
   case when a_month[3] = cur_month then dp.rank_month_time else team_rank[a_month[3]]    end as tr3,
   case when a_month[1] = cur_month then dp.rank_month      else project_rank[a_month[1]] end as pr1,
   case when a_month[2] = cur_month then dp.rank_month      else project_rank[a_month[2]] end as pr2,
   case when a_month[3] = cur_month then dp.rank_month      else project_rank[a_month[3]] end as pr3,
   coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) as qt
from usuarios_indice as ui
left join donor_yearly as dy
   on ui.usuario_serial = dy.donor and ""year"" = v_year
left join donors_production as dp
   on ui.usuario_serial = dp.usuario and cur_month_in
where ui.n_time = v_team
   and coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) > 0

loop
return next line;
end loop;

return;
end;
$$;",ks2.schema
"CREATE FUNCTION donor_quarterly_rank_query_count(v_quarter integer, v_team integer, v_year integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
declare
a_month smallint[];
cur_month smallint;
cur_year smallint;
cur_month_in boolean;

begin
a_month[1] := v_quarter * 3 - 2;
a_month[2] := v_quarter * 3 - 1;
a_month[3] := v_quarter * 3;
cur_month := extract(month from (select last_date from last_date));
cur_year := extract(year from (select last_date from last_date));
cur_month_in := (cur_month = any (a_month) and cur_year = v_year);
if cur_month_in then
   if cur_month < a_month[3] then a_month[3] := -1; end if;
   if cur_month < a_month[2] then a_month[2] := -1; end if;
else cur_month := -1;
end if;

return (
select count(ui.usuario_serial)
from usuarios_indice as ui
left join donor_yearly as dy
   on ui.usuario_serial = dy.donor and ""year"" = v_year
left join donors_production as dp
   on ui.usuario_serial = dp.usuario and cur_month_in
where ui.n_time = v_team
   and coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) > 0
);

end;
$$;",fahstats.schema
"CREATE FUNCTION donor_quarterly_rank_query_count(v_quarter integer, v_team integer, v_year integer) RETURNS integer
    LANGUAGE plpgsql STABLE STRICT
    AS $$
declare
a_month smallint[];
cur_month smallint;
cur_year smallint;
cur_month_in boolean;

begin
a_month[1] := v_quarter * 3 - 2;
a_month[2] := v_quarter * 3 - 1;
a_month[3] := v_quarter * 3;
cur_month := extract(month from (select last_date from last_date));
cur_year := extract(year from (select last_date from last_date));
cur_month_in := (cur_month = any (a_month) and cur_year = v_year);
if cur_month_in then
   if cur_month < a_month[3] then a_month[3] := -1; end if;
   if cur_month < a_month[2] then a_month[2] := -1; end if;
else cur_month := -1;
end if;

return (
select count(ui.usuario_serial)
from usuarios_indice as ui
left join donor_yearly as dy
   on ui.usuario_serial = dy.donor and ""year"" = v_year
left join donors_production as dp
   on ui.usuario_serial = dp.usuario and cur_month_in
where ui.n_time = v_team
   and coalesce(points[a_month[1]], 0) + coalesce(points[a_month[2]], 0) + coalesce(points[a_month[3]], 0) + coalesce(dp.pontos_month, 0) > 0
);

end;
$$;",ks2.schema
"CREATE FUNCTION dow(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
         return  date_part ('DOW', $1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION drop_acl_view(name) RETURNS name
    LANGUAGE plpgsql
    AS $_$
BEGIN
	EXECUTE ('
		DROP VIEW IF EXISTS ' || $1 || '_view;
	');

	RETURN $1;
END;
$_$;",yala.sql
"CREATE FUNCTION dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$;",hr_database.pgsql
"CREATE FUNCTION dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$;",pgex_backup.sql
"CREATE FUNCTION dropgeometrycolumn(catalog_name character varying, schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	myrec RECORD;
	okay boolean;
	real_schema name;

BEGIN


	-- Find, check or fix schema_name
	IF ( schema_name != '' ) THEN
		okay = false;

		FOR myrec IN SELECT nspname FROM pg_namespace WHERE text(nspname) = schema_name LOOP
			okay := true;
		END LOOP;

		IF ( okay <>  true ) THEN
			RAISE NOTICE 'Invalid schema name - using current_schema()';
			SELECT current_schema() into real_schema;
		ELSE
			real_schema = schema_name;
		END IF;
	ELSE
		SELECT current_schema() into real_schema;
	END IF;

	-- Find out if the column is in the geometry_columns table
	okay = false;
	FOR myrec IN SELECT * from geometry_columns where f_table_schema = text(real_schema) and f_table_name = table_name and f_geometry_column = column_name LOOP
		okay := true;
	END LOOP;
	IF (okay <> true) THEN
		RAISE EXCEPTION 'column not found in geometry_columns table';
		RETURN false;
	END IF;

	-- Remove table column
	EXECUTE 'ALTER TABLE ' || quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' DROP COLUMN ' ||
		quote_ident(column_name);

	RETURN real_schema || '.' || table_name || '.' || column_name ||' effectively removed.';

END;
$$;",sqlex_backup.pgsql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",dbsetup.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",xenia_all.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",database.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",nlp.dump
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",schema.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",dbsetup.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$
    LANGUAGE plpgsql STRICT;",xenia_all.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",database.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",nlp.dump
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",schema.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION dropgeometrycolumn(character varying, character varying, character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION dropgeometrycolumn(schema_name character varying, table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('',$1,$2,$3) into ret;
	RETURN ret;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION dropgeometrycolumn(table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION dropgeometrycolumn(table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION dropgeometrycolumn(table_name character varying, column_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
	ret text;
BEGIN
	SELECT DropGeometryColumn('','',$1,$2) into ret;
	RETURN ret;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$$;",hr_database.pgsql
"CREATE FUNCTION dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$$;",pgex_backup.sql
"CREATE FUNCTION dropgeometrytable(catalog_name character varying, schema_name character varying, table_name character varying) RETURNS text
    LANGUAGE plpgsql STRICT
    AS $$
DECLARE
	real_schema name;

BEGIN

	IF ( schema_name = '' ) THEN
		SELECT current_schema() into real_schema;
	ELSE
		real_schema = schema_name;
	END IF;

	-- TODO: Should we warn if table doesn't exist probably instead just saying dropped
	-- Remove table
	EXECUTE 'DROP TABLE IF EXISTS '
		|| quote_ident(real_schema) || '.' ||
		quote_ident(table_name) || ' RESTRICT';

	RETURN
		real_schema || '.' ||
		table_name ||' dropped.';

END;
$$;",sqlex_backup.pgsql
"CREATE FUNCTION dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		schema name;
		sql text;
		rtn boolean;
	BEGIN
		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		rtn := _drop_overview_constraint(schema, $2, $3);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to drop the overview constraint .  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		schema name;
		sql text;
		rtn boolean;
	BEGIN
		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		rtn := _drop_overview_constraint(schema, $2, $3);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to drop the overview constraint .  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION dropoverviewconstraints(ovschema name, ovtable name, ovcolumn name) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		schema name;
		sql text;
		rtn boolean;
	BEGIN
		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		rtn := _drop_overview_constraint(schema, $2, $3);
		IF rtn IS FALSE THEN
			RAISE EXCEPTION 'Unable to drop the overview constraint .  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		x int;
		schema name;
		sql text;
		kw text;
		rtn boolean;
		cnt int;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be dropped.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Dropping SRID constraint';
						rtn := _drop_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Dropping alignment constraint';
						rtn := _drop_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Dropping regular blocking constraint';
						rtn := _drop_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Dropping number of bands constraint';
						rtn := _drop_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Dropping pixel type constraint';
						rtn := _drop_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Dropping nodata value constraint';
						rtn := _drop_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Dropping out-of-database constraint';
						rtn := _drop_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Dropping maximum extent constraint';
						rtn := _drop_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to drop constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be dropped.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		x int;
		schema name;
		sql text;
		kw text;
		rtn boolean;
		cnt int;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be dropped.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Dropping SRID constraint';
						rtn := _drop_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Dropping alignment constraint';
						rtn := _drop_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Dropping regular blocking constraint';
						rtn := _drop_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Dropping number of bands constraint';
						rtn := _drop_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Dropping pixel type constraint';
						rtn := _drop_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Dropping nodata value constraint';
						rtn := _drop_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Dropping out-of-database constraint';
						rtn := _drop_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Dropping maximum extent constraint';
						rtn := _drop_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to drop constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be dropped.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, VARIADIC constraints text[]) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		max int;
		x int;
		schema name;
		sql text;
		kw text;
		rtn boolean;
		cnt int;
	BEGIN
		cnt := 0;
		max := array_length(constraints, 1);
		IF max < 1 THEN
			RAISE NOTICE 'No constraints indicated to be dropped.  Doing nothing';
			RETURN TRUE;
		END IF;

		-- validate schema
		schema := NULL;
		IF length($1) > 0 THEN
			sql := 'SELECT nspname FROM pg_namespace '
				|| 'WHERE nspname = ' || quote_literal($1)
				|| 'LIMIT 1';
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The value provided for schema is invalid';
				RETURN FALSE;
			END IF;
		END IF;

		IF schema IS NULL THEN
			sql := 'SELECT n.nspname AS schemaname '
				|| 'FROM pg_catalog.pg_class c '
				|| 'JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace '
				|| 'WHERE c.relkind = ' || quote_literal('r')
				|| ' AND n.nspname NOT IN (' || quote_literal('pg_catalog')
				|| ', ' || quote_literal('pg_toast')
				|| ') AND pg_catalog.pg_table_is_visible(c.oid)'
				|| ' AND c.relname = ' || quote_literal($2);
			EXECUTE sql INTO schema;

			IF schema IS NULL THEN
				RAISE EXCEPTION 'The table % does not occur in the search_path', quote_literal($2);
				RETURN FALSE;
			END IF;
		END IF;

		<<kwloop>>
		FOR x in 1..max LOOP
			kw := trim(both from lower(constraints[x]));

			BEGIN
				CASE
					WHEN kw = 'srid' THEN
						RAISE NOTICE 'Dropping SRID constraint';
						rtn := _drop_raster_constraint_srid(schema, $2, $3);
					WHEN kw IN ('scale_x', 'scalex') THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
					WHEN kw IN ('scale_y', 'scaley') THEN
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw = 'scale' THEN
						RAISE NOTICE 'Dropping scale-X constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'x');
						RAISE NOTICE 'Dropping scale-Y constraint';
						rtn := _drop_raster_constraint_scale(schema, $2, $3, 'y');
					WHEN kw IN ('blocksize_x', 'blocksizex', 'width') THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
					WHEN kw IN ('blocksize_y', 'blocksizey', 'height') THEN
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw = 'blocksize' THEN
						RAISE NOTICE 'Dropping blocksize-X constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'width');
						RAISE NOTICE 'Dropping blocksize-Y constraint';
						rtn := _drop_raster_constraint_blocksize(schema, $2, $3, 'height');
					WHEN kw IN ('same_alignment', 'samealignment', 'alignment') THEN
						RAISE NOTICE 'Dropping alignment constraint';
						rtn := _drop_raster_constraint_alignment(schema, $2, $3);
					WHEN kw IN ('regular_blocking', 'regularblocking') THEN
						RAISE NOTICE 'Dropping regular blocking constraint';
						rtn := _drop_raster_constraint_regular_blocking(schema, $2, $3);
					WHEN kw IN ('num_bands', 'numbands') THEN
						RAISE NOTICE 'Dropping number of bands constraint';
						rtn := _drop_raster_constraint_num_bands(schema, $2, $3);
					WHEN kw IN ('pixel_types', 'pixeltypes') THEN
						RAISE NOTICE 'Dropping pixel type constraint';
						rtn := _drop_raster_constraint_pixel_types(schema, $2, $3);
					WHEN kw IN ('nodata_values', 'nodatavalues', 'nodata') THEN
						RAISE NOTICE 'Dropping nodata value constraint';
						rtn := _drop_raster_constraint_nodata_values(schema, $2, $3);
					WHEN kw IN ('out_db', 'outdb') THEN
						RAISE NOTICE 'Dropping out-of-database constraint';
						rtn := _drop_raster_constraint_out_db(schema, $2, $3);
					WHEN kw = 'extent' THEN
						RAISE NOTICE 'Dropping maximum extent constraint';
						rtn := _drop_raster_constraint_extent(schema, $2, $3);
					ELSE
						RAISE NOTICE 'Unknown constraint: %.  Skipping', quote_literal(constraints[x]);
						CONTINUE kwloop;
				END CASE;
			END;

			IF rtn IS FALSE THEN
				cnt := cnt + 1;
				RAISE WARNING 'Unable to drop constraint: %.  Skipping', quote_literal(constraints[x]);
			END IF;

		END LOOP kwloop;

		IF cnt = max THEN
			RAISE EXCEPTION 'None of the constraints specified could be dropped.  Is the schema name, table name or column name incorrect?';
			RETURN FALSE;
		END IF;

		RETURN TRUE;
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN DropRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",hr_database.pgsql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN DropRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",pgex_backup.sql
"CREATE FUNCTION droprasterconstraints(rastschema name, rasttable name, rastcolumn name, srid boolean DEFAULT true, scale_x boolean DEFAULT true, scale_y boolean DEFAULT true, blocksize_x boolean DEFAULT true, blocksize_y boolean DEFAULT true, same_alignment boolean DEFAULT true, regular_blocking boolean DEFAULT true, num_bands boolean DEFAULT true, pixel_types boolean DEFAULT true, nodata_values boolean DEFAULT true, out_db boolean DEFAULT true, extent boolean DEFAULT true) RETURNS boolean
    LANGUAGE plpgsql STRICT
    AS $_$
	DECLARE
		constraints text[];
	BEGIN
		IF srid IS TRUE THEN
			constraints := constraints || 'srid'::text;
		END IF;

		IF scale_x IS TRUE THEN
			constraints := constraints || 'scale_x'::text;
		END IF;

		IF scale_y IS TRUE THEN
			constraints := constraints || 'scale_y'::text;
		END IF;

		IF blocksize_x IS TRUE THEN
			constraints := constraints || 'blocksize_x'::text;
		END IF;

		IF blocksize_y IS TRUE THEN
			constraints := constraints || 'blocksize_y'::text;
		END IF;

		IF same_alignment IS TRUE THEN
			constraints := constraints || 'same_alignment'::text;
		END IF;

		IF regular_blocking IS TRUE THEN
			constraints := constraints || 'regular_blocking'::text;
		END IF;

		IF num_bands IS TRUE THEN
			constraints := constraints || 'num_bands'::text;
		END IF;

		IF pixel_types IS TRUE THEN
			constraints := constraints || 'pixel_types'::text;
		END IF;

		IF nodata_values IS TRUE THEN
			constraints := constraints || 'nodata_values'::text;
		END IF;

		IF out_db IS TRUE THEN
			constraints := constraints || 'out_db'::text;
		END IF;

		IF extent IS TRUE THEN
			constraints := constraints || 'extent'::text;
		END IF;

		RETURN DropRasterConstraints($1, $2, $3, VARIADIC constraints);
	END;
	$_$;",sqlex_backup.pgsql
"CREATE FUNCTION dtoc(date) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
       lcString varchar;
begin
     return to_char($1,'DD.MM.YYYY')::varchar;
end;
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION dumbloom_contains (
  b    dumbloom,
  item text
) RETURNS boolean AS 
$$
DECLARE
  i   integer;
  idx integer;
BEGIN
  IF b IS NULL THEN
    RETURN FALSE;
  END IF;

  FOREACH i IN ARRAY dumbloom_fingerprint(b, item) LOOP
    idx := i / 32 + 1;
    IF NOT (b.bits[idx] &amp; (1 &lt;&lt; (i % 32)))::boolean THEN
      RETURN FALSE;
    END IF;
  END LOOP;

  RETURN TRUE;
END;
$$
LANGUAGE 'plpgsql' IMMUTABLE;",Making%20Postgres%20Bloom.html
"CREATE FUNCTION dumbloom_contains (  
  b    dumbloom,  
  item text  
) RETURNS boolean AS   
$$  
DECLARE  
  i   integer;  
  idx integer;  
BEGIN  
  IF b IS NULL THEN  
    RETURN FALSE;  
  END IF;  
  
  FOREACH i IN ARRAY dumbloom_fingerprint(b, item) LOOP  -- 计算k个哈希产生的值，判断是否有非1的bit, 有则返回false，如果全部为1则返回true.   
    idx := i / 32 + 1;  
    IF NOT (b.bits[idx] & (1 << (i % 32)))::boolean THEN  
      RETURN FALSE;  
    END IF;  
  END LOOP;  
  
  RETURN TRUE;  
END;  
$$  
LANGUAGE 'plpgsql' IMMUTABLE;",20160523_01.md
"CREATE FUNCTION dumbloom_empty (  
  -- 2% false probability  
  p float8 DEFAULT 0.02,  
  -- 100k expected uniques  
  n integer DEFAULT 100000  
) RETURNS dumbloom AS  
$$  
DECLARE  
  m    integer;  
  k    integer;  
  i    integer;  
  bits integer[];     
BEGIN  
  -- Getting m and k from n and p is some math sorcery  
  -- See: https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions  
  m := abs(ceil(n * ln(p) / (ln(2) ^ 2)))::integer;  
  k := round(ln(2) * m / n)::integer;  
  bits := NULL;  
  
  -- Initialize all bits to 0  
  FOR i in 1 .. ceil(m / 32.0) LOOP  
    bits := array_append(bits, 0);  
  END LOOP;  
  
  RETURN (m, k, bits)::dumbloom;  
END;  
$$  
LANGUAGE 'plpgsql' IMMUTABLE;",20160523_01.md
"CREATE FUNCTION dumbloom_fingerprint (  
  b    dumbloom,  
  item text  
) RETURNS integer[] AS   
$$  
DECLARE  
  h1     bigint;  
  h2     bigint;  
  i      integer;  
  fingerprint integer[];  
BEGIN  
  h1 := abs(hashtext(upper(item)));  
  -- If lower(item) and upper(item) are the same, h1 and h2 will be identical too,  
  -- let's add some random salt  
  h2 := abs(hashtext(lower(item) || 'yo dawg!'));  
  finger := NULL;   
  
  FOR i IN 1 .. b.k LOOP  
    -- This combinatorial approach works just as well as using k independent  
    -- hash functions, but is obviously much faster  
    -- See: https://www.eecs.harvard.edu/~michaelm/postscripts/tr-02-05.pdf  
    fingerprint := array_append(fingerprint, ((h1 + i * h2) % b.m)::integer);  
  END LOOP;  
  
  RETURN fingerprint;  
END;  
$$  
LANGUAGE 'plpgsql' IMMUTABLE;",20160523_01.md
"CREATE FUNCTION dump_hash(text DEFAULT ''::text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		license text;
	BEGIN
		create temp table temp1 as
			select $1;
		copy (select * from temp1) to '/tmp/tosign'; -- to '/tmp/prep_ver\';
		drop table temp1;
	END;$_$;",baza.sql
"CREATE FUNCTION dump_key(text DEFAULT ''::text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	declare
		license text;
	BEGIN
		create temp table temp1 as
			select $1;
		copy (select * from temp1) to '/tmp/key'; -- to '/tmp/prep_ver\';
		drop table temp1;
	END;
$_$;",baza.sql
"CREATE FUNCTION dump_sig(bytea) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	declare
		license text;
	BEGIN
		create temp table temp1 as
			(select $1 as lol);
		copy (select encode(lol, 'base64') from temp1) to '/tmp/sigprep'; -- to '/tmp/prep_ver\';
		--perform system('bash /bejs.sh');
		drop table temp1;
	END;
$_$;",baza.sql
"CREATE FUNCTION dump_sig(text DEFAULT ''::text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	declare
		license text;
	BEGIN
		create temp table temp1 as
			select $1;
		copy (select * from temp1) to '/tmp/sig'; -- to '/tmp/prep_ver\';
		drop table temp1;
	END;
$_$;",baza.sql
"CREATE FUNCTION dungeon_access(p1 character varying, p2 character varying, p3 character varying, d character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
    DECLARE
enter VARCHAR;
 temp1 INT;
 temp2 INT;
 temp3 INT;
 min INT;
 BEGIN
SELECT PlayerLevel INTO temp1 FROM PLAYER WHERE PlayerName=p1;
SELECT PlayerLevel INTO temp2 FROM PLAYER WHERE PlayerName=p2;
SELECT PlayerLevel INTO temp3 FROM PLAYER WHERE PlayerName=p3;
SELECT MinimumLevel INTO min FROM DUNGEON WHERE DungeonName=d;
 
 IF(temp1>=min AND temp2>=min AND temp3>=min) THEN enter='Ketiga pemain dapat memasuki '||d;END IF;
 IF(temp1>=min AND temp2>=min AND temp3<min) THEN enter='Semua pemain dapat memasuki '||d||' kecuali '||p3;END IF;
 IF(temp1>=min AND temp2<min AND temp3>=min) THEN enter='Semua pemain dapat memasuki '||d||' kecuali '||p2;END IF;
 IF(temp1<min AND temp2>=min AND temp3>=min) THEN enter='Semua pemain dapat memasuki '||d||' kecuali '||p1;END IF;
 IF(temp1<min AND temp2<min AND temp3>=min) THEN enter='Hanya '||p3||' yang dapat memasuki '||d;END IF;
 IF(temp1>=min AND temp2<min AND temp3<min) THEN enter='Hanya '||p1||' yang dapat memasuki '||d;END IF;
 IF(temp1<min AND temp2>=min AND temp3<min) THEN enter='Hanya '||p2||' yang dapat memasuki '||d;END IF;
 IF(temp1<min AND temp2<min AND temp3<min) THEN enter='semua pemain tidak dapat memasuki '||d;END IF;
 RETURN enter;
 END
$$;",siasisten-only.sql
"CREATE FUNCTION dystans(l_wylotu integer, l_przylotu integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
	AX INTEGER;
	AY INTEGER;
	ZX INTEGER;
	ZY INTEGER;
	DIST_X INTEGER;
	DIST_Y INTEGER;
	RESULT REAL;
BEGIN

SELECT WSP_X, WSP_Y
INTO AX, AY
FROM LOTNISKA
WHERE ID_LOTNISKA=L_WYLOTU;

SELECT WSP_X, WSP_Y
INTO ZX, ZY
FROM LOTNISKA
WHERE ID_LOTNISKA=L_PRZYLOTU;

DIST_X:=AX-ZX;
DIST_Y:=AY-ZY;

DIST_X:=DIST_X*DIST_X;
DIST_Y:=DIST_Y*DIST_Y;

RESULT:=|/(DIST_X+DIST_Y);
RETURN CAST(RESULT AS INT);

END$$;",db_schema.sql
"CREATE FUNCTION ejemplo() RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
 RETURN 104;
END;
$$;",local
"CREATE FUNCTION ejemplo(numero integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE 
cont integer;
BEGIN
cont:=1;
FOR cont IN cont..numero LOOP
	
	raise notice '%',cont;
	
	END LOOP;
	
END;

$$;",competencia_15032014_1.sql
"CREATE FUNCTION ejemplo2(numero integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
 RETURN numero;
END;
$$;",local
"CREATE FUNCTION eleven(study_uid text) RETURNS text
    LANGUAGE plpgsql
    AS $$declare
------------------------------------------
-- Purpose: GE PACS header processor
-- 	After successful run clears entry from
--	""exams-to-process"" table
-- Caller: Dispatcher
-----------------------------------------
	func text :='ddw:eleven';
	status text :='failed';

begin
	status :='ok';
	-- right now this is just a stub to clear the ""exams-to-process"" table
	-- and avoid errors in the Log table
	return status ;
end;$$;",purged-ddw.sql
"CREATE FUNCTION employeeschema.donationpercentages(amount numeric, percentage numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
BEGIN
IF percentage > 1
THEN
	RETURN amount * percentage / 100;
ELSE
	RETURN amount * percentage;
END IF;
END;
$$;",all.sql
"CREATE FUNCTION empty(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null or len(ltrim(rtrim($1))) < 1 then
		return true;
	else
		return false;
	end if;
end;
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION empty(date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null or $1 <  year (now()::date)-100 then
		return true;
	else
		return false;
	end if;
end;
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION empty(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null or $1 = 0 then
		return true;
	else
		return false;
	end if;
end;
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION empty(numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null or $1 = 0 then
		return true;
	else
		return false;
	end if;
end;
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION empty_blob() RETURNS bytea
    LANGUAGE plpgsql
    AS $$
    BEGIN  
        return empty_lob();
    END;
$$;",create.sql
"CREATE FUNCTION encode(val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN encode(digest(val, 'sha1'), 'hex')::character varying;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION encode(val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN encode(digest(val, 'sha1'), 'hex')::character varying;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION encode(val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN encode(digest(val, 'sha1'), 'hex')::character varying;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION encode(val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN encode(digest(val, 'sha1'), 'hex')::character varying;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION encode(val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN encode(digest(val, 'sha1'), 'hex')::character varying;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION enum2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res xml;
     enu xml;
  BEGIN
     enu := getEnumerationXML(item.syntax);

     res := xmlelement(name ""simpleType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                        xmlattributes('en' as ""xml:lang""), 
                        'Implemantation of ' ||item.item || '. Defined as: ' || item.definition)),
          
             xmlelement(name restriction, 
                        xmlattributes('normalizedString' as base), enu)



              );

     return res;
  END;
$$;",test.sql
"CREATE FUNCTION env2gcdmltypes(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$

  DECLARE
     res xml;
  BEGIN
     
     IF item.value_type IN ('measurement', 'named measurement') THEN
       res := measurement2gcdmlType(item);
     ELSIF item.value_type = 'text' THEN
       res := text2gcdmlType(item);
     ELSIF item.value_type = 'enumeration' THEN
       res := enum2gcdmlType(item);
     ELSIF item.value_type = 'reference' THEN
       res := reference2gcdmlType(item);
     ELSIF item.value_type IN ('regime', 'named regime') THEN
       res := regime2gcdmlType(item);
     ELSIF item.value_type = 'treatment' THEN
       res := treatment2gcdmlType(item);
     ELSIF item.value_type IN ('integer') THEN
       res := integer2gcdmlType(item);
     ELSIF item.value_type = 'boolean' THEN
       res := boolean2gcdmlType(item);
     ELSIF item.value_type = 'timestamp' THEN
       res := timestamp2gcdmlType(item);
     ELSE
       --res := xmlelement(name ""not_implemented"",
         --                xmlattributes(item.item as name)
           --              );
     END IF;

     return res;
  END;
$$;",test.sql
"CREATE FUNCTION env_raise_exception(p_errcode text, res_code text, param01 text DEFAULT NULL::text, param02 text DEFAULT NULL::text, param03 text DEFAULT NULL::text, param04 text DEFAULT NULL::text, param05 text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql STABLE COST 5
    AS $$
begin
  -- возбуждает исключение, заданное кодом p_errcode с текстом, заданным по коду сообщения res_code
  raise exception using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
end;
$$;",metadict.sql
"CREATE FUNCTION env_raise_exception(p_level integer, p_errcode text, res_code text, param01 text DEFAULT NULL::text, param02 text DEFAULT NULL::text, param03 text DEFAULT NULL::text, param04 text DEFAULT NULL::text, param05 text DEFAULT NULL::text) RETURNS void
    LANGUAGE plpgsql STABLE COST 5
    AS $$
declare
  r record;
begin
  -- возбуждает исключение или создает сообщение другого указанного уровня важности с текстом, заданным по коду сообщения
  -- DEBUG, LOG, INFO, NOTICE, WARNING, EXCEPTION
  select ""DEBUG"", ""LOG"", ""INFO"", ""NOTICE"", ""WARNING"", ""EXCEPTION"" into r from env_severity_level();
  case p_level
    when r.""EXCEPTION"" then 
      raise exception using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    when r.""WARNING"" then 
      raise warning using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    when r.""NOTICE"" then 
      raise notice using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    when r.""INFO"" then 
      raise info using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    when r.""LOG"" then 
      raise log using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    when r.""DEBUG"" then 
      raise debug using message = env_resource_text_format(res_code, param01, param02, param03, param04, param05), ERRCODE = p_errcode;
    else
      -- 'ENV00001', 'unknown severity level %s'
      raise exception using message = env_resource_text_format('ENV00001', p_level::text), ERRCODE = p_errcode;
  end case;
end;
$$;",metadict.sql
"CREATE FUNCTION env_resource_text_find_by_code(res_code text) RETURNS integer
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  res  integer;
begin
  select id
    into strict res
   from env_resource_text
  where code = res_code;
  return res;
exception
  when NO_DATA_FOUND then
    raise exception 'resource code=% not found (in env_resource_text)', res_code;
  when TOO_MANY_ROWS then
    raise exception 'resource code=% not unique', res_code;
end;

  
$$;",metadict.sql
"CREATE FUNCTION env_resource_text_format(res_code text, param01 text DEFAULT NULL::text, param02 text DEFAULT NULL::text, param03 text DEFAULT NULL::text, param04 text DEFAULT NULL::text, param05 text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  res_txt env_resource_text;
begin
  select *
    into strict res_txt
   from env_resource_text
  where code = res_code;
  return format(res_txt.content, param01, param02, param03, param04, param05);
exception
  when NO_DATA_FOUND then
    raise exception 'resource code=% not found (in env_resource_text). can not format resource text', res_code;
  when TOO_MANY_ROWS then
    raise exception 'resource code=% not unique', res_code;
end;

  
$$;",metadict.sql
"CREATE FUNCTION env_resource_text_format(res_id integer, param01 text DEFAULT NULL::text, param02 text DEFAULT NULL::text, param03 text DEFAULT NULL::text, param04 text DEFAULT NULL::text, param05 text DEFAULT NULL::text) RETURNS text
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  res_txt env_resource_text;
begin
  select *
    into strict res_txt
   from env_resource_text
  where id = res_id;
  return format(res_txt.content, param01, param02, param03, param04, param05);
exception
  when NO_DATA_FOUND then
    raise exception 'resource id=% not found (in env_resource_text). can not format resource text', res_id;
  when TOO_MANY_ROWS then
    raise exception 'resource id=% not unique', res_id;
end;

  
$$;",metadict.sql
"CREATE FUNCTION env_severity_level(OUT ""DEBUG"" smallint, OUT ""LOG"" smallint, OUT ""INFO"" smallint, OUT ""NOTICE"" smallint, OUT ""WARNING"" smallint, OUT ""EXCEPTION"" smallint) RETURNS record
    LANGUAGE plpgsql IMMUTABLE COST 1
    AS $$
begin
  -- возвращает константные значения уровней важности сообщений
  -- DEBUG, LOG, INFO, NOTICE, WARNING, EXCEPTION
  ""EXCEPTION"" := 0;
  ""WARNING"" := 1;
  ""NOTICE"" := 2;
  ""INFO"" := 3;
  ""LOG"" := 4;
  ""DEBUG"" := 5;
  return;
end;
$$;",metadict.sql
"CREATE FUNCTION env_text_similar(word1 text, word2 text, min_sim_len integer DEFAULT 5) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE COST 2
    AS $_$declare
  -- сравнивает две строки (word1, word2) на сходство (без учета регистра символов). возвращает true, если две строки схожи и false - в противном случае.
  -- строки считаются схожими, если у них есть общие части текста (последовательность символов не менее min_len символов)
begin
  if (word1 is not null) and (word2 is not null) then
    -- сравниваем без учета регистра символов
    word1 := lower(word1);
    word2 := lower(word2);
    -- ищем вхождение фрагментов строки word1 в строке word2
    for i in 1 .. char_length(word1)-min_sim_len loop
      -- если вхождение найдено
      if position(substring(word1 from i for min_sim_len) in word2) > 0 then
        -- 'RES00003', 'text ""%1$s"" is similar to ""%2$s""'
        return env_resource_text_find_by_code('RES00003');
      end if;
    end loop;
    -- ищем вхождение фрагментов строки word2 в строке word1
    for i in 1 .. char_length(word2)-min_sim_len loop
      -- если вхождение найдено
      if position(substring(word2 from i for min_sim_len) in word1) > 0 then
        -- 'RES00003', 'text ""%1$s"" is similar to ""%2$s""'
        return env_resource_text_find_by_code('RES00003');
      end if;
    end loop;
  end if;
  -- 'RES00004', 'text ""%1$s"" is not similar to ""%2$s""'
  return env_resource_text_find_by_code('RES00004');
end;
$_$;",metadict.sql
"CREATE FUNCTION es_hoja(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  reg		record;
  salida	text;
  idnod		integer;
  x		integer;
  hoja		boolean;
  

BEGIN
idnod:=$1;
hoja:=true;

	FOR reg IN 
	        select * from nodo
 	     LOOP
 	     if reg.depende_de=idnod then
 	         return false;
 	     end if;
 		
 	END LOOP;

return hoja;
END; 
$_$;",nodos.sql
"CREATE FUNCTION es_numeric(num_str character varying) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	i numeric;
BEGIN
	i := cast (num_str as numeric);
	return true;
EXCEPTION 
	WHEN others then return false;
END	
$$;",lab_clinic.sql
"CREATE FUNCTION esiste_sessione(auth character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE m_session RECORD;
BEGIN
	SELECT * INTO m_session
	FROM user_session
	WHERE authcode = auth;
	IF NOT found THEN RETURN FALSE;
	ELSE RETURN TRUE;
	END IF;
END;
$$;",script.sql
"CREATE FUNCTION esta_alquilado(id_a integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
ff date;
BEGIN
SELECT max(contratos.fecha_f) INTO ff FROM contratos JOIN autos 
ON autos.id_auto=contratos.cont_id_auto JOIN situaciones ON autos.id_situacion_auto=situaciones.id_sit
WHERE situaciones.tipo_situacion='ocupado' AND autos.id_auto=id_a
GROUP BY contratos.fecha_f
ORDER BY contratos.fecha_f ASC;

if(ff ISNULL)THEN
aux='NO';
ELSE
aux=(ff)::VARCHAR;
END IF;
RETURN aux;
END
 $$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION esta_alquilado(id_a integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
ff date;
BEGIN
SELECT max(contratos.fecha_f) INTO ff FROM contratos JOIN autos 
ON autos.id_auto=contratos.cont_id_auto JOIN situaciones ON autos.id_situacion_auto=situaciones.id_sit
WHERE situaciones.tipo_situacion='ocupado' AND autos.id_auto=id_a
GROUP BY contratos.fecha_f
ORDER BY contratos.fecha_f ASC;

if(ff ISNULL)THEN
aux='NO';
ELSE
aux=(ff)::VARCHAR;
END IF;
RETURN aux;
END
 $$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION esta_alquilado(id_a integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
ff date;
BEGIN
SELECT max(contratos.fecha_f) INTO ff FROM contratos JOIN autos 
ON autos.id_auto=contratos.cont_id_auto JOIN situaciones ON autos.id_situacion_auto=situaciones.id_sit
WHERE situaciones.tipo_situacion='ocupado' AND autos.id_auto=id_a
GROUP BY contratos.fecha_f
ORDER BY contratos.fecha_f ASC;

if(ff ISNULL)THEN
aux='NO';
ELSE
aux=(ff)::VARCHAR;
END IF;
RETURN aux;
END
 $$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION esta_alquilado(id_a integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
ff date;
BEGIN
SELECT max(contratos.fecha_f) INTO ff FROM contratos JOIN autos 
ON autos.id_auto=contratos.cont_id_auto JOIN situaciones ON autos.id_situacion_auto=situaciones.id_sit
WHERE situaciones.tipo_situacion='ocupado' AND autos.id_auto=id_a
GROUP BY contratos.fecha_f
ORDER BY contratos.fecha_f ASC;

if(ff ISNULL)THEN
aux='NO';
ELSE
aux=(ff)::VARCHAR;
END IF;
RETURN aux;
END
 $$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION esta_alquilado(id_a integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
ff date;
BEGIN
SELECT max(contratos.fecha_f) INTO ff FROM contratos JOIN autos 
ON autos.id_auto=contratos.cont_id_auto JOIN situaciones ON autos.id_situacion_auto=situaciones.id_sit
WHERE situaciones.tipo_situacion='ocupado' AND autos.id_auto=id_a
GROUP BY contratos.fecha_f
ORDER BY contratos.fecha_f ASC;

if(ff ISNULL)THEN
aux='NO';
ELSE
aux=(ff)::VARCHAR;
END IF;
RETURN aux;
END
 $$;",backup1.sql
"CREATE FUNCTION estoqueatual(p_produtoid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_total double precision;

BEGIN

SELECT 
       ((SELECT CASE 
                    WHEN
                        SUM(EME.quantidade) IS NULL THEN 0
                    ELSE
                        SUM(EME.quantidade)
                END
           FROM estoquemovimento EME
          WHERE EME.operacao = 1
            AND EME.produtoid = P.produtoid) -
        (SELECT CASE 
                    WHEN
                        SUM(EMS.quantidade) IS NULL THEN 0
                    ELSE
                        SUM(EMS.quantidade) 
                END
           FROM estoquemovimento EMS
          WHERE EMS.operacao = 2
            AND EMS.produtoid = P.produtoid)) INTO v_total
  FROM produto P
 WHERE P.produtoid = p_produtoid;

RETURN v_total;

END;
$$;",almoxarifado.sql
"CREATE FUNCTION eval(sid integer) RETURNS integer
    AS $$
DECLARE
pots integer DEFAULT 0;
ans record;
rst boolean;
cqid integer DEFAULT 0;
ctyp integer DEFAULT 0;
crst boolean;
cpot integer DEFAULT 0;
BEGIN
FOR ans IN SELECT b.qst_id, b.typ, a.opt_id,b.odr,b.keys,b.points FROM (select * FROM choices WHERE ssn_id = sid ) a RIGHT OUTER JOIN (SELECT qst_id, typ, odr,keys, points FROM options WHERE qst_id IN (SELECT qst_id FROM choices WHERE ssn_id = sid)) b ON a.qst_id=b.qst_id AND a.opt_id = b.odr ORDER BY qst_id, odr LOOP
	IF cqid <> ans.qst_id THEN
		IF ctyp = 3 THEN
			IF rst THEN
				pots := pots + cpot;
			END IF;
		END IF;
		IF ans.typ = 1 OR ans.typ = 2 THEN
			rst := false;
			IF ans.opt_id = ans.odr and ans.keys  THEN
				rst := true;
				pots := pots + ans.points;
			END IF;
			cqid := ans.qst_id;
			ctyp := ans.typ;
		ELSIF ans.typ = 3 THEN
			rst := true;
			IF ans.opt_id = ans.odr THEN
				IF ans.keys THEN
					crst := true;
				ELSE
					crst := false;
				END IF;
			ELSE
				IF ans.keys THEN
					crst := false;
				ELSE
					crst := true;
				END IF;
			END IF;
			rst := rst AND crst;
			cqid := ans.qst_id;
			ctyp := ans.typ;
			cpot := ans.points;
		ELSIF ans.typ = 4 THEN
			IF ans.opt_id = ans.odr THEN
				pots := pots + ans.points;
			END IF;
			cqid := ans.qst_id;
			ctyp := ans.typ;
		END IF;
	ELSIF cqid = ans.qst_id THEN
		IF ctyp = 1 OR ctyp = 2 THEN
			IF NOT rst and ans.opt_id = ans.odr and ans.keys  THEN
				rst := true;
				pots := pots + ans.points;
			END IF;
			cqid := ans.qst_id;
			ctyp := ans.typ;
		ELSIF ctyp = 3 THEN
			IF ans.opt_id = ans.odr THEN
				IF ans.keys THEN
					crst := true;
				ELSE
					crst := false;
				END IF;
			ELSE
				IF ans.keys THEN
					crst := false;
				ELSE
					crst := true;
				END IF;
			END IF;
			rst := rst AND crst;
			cqid := ans.qst_id;
			ctyp := ans.typ;
			cpot := ans.points;
		ELSIF ctyp = 4 THEN
			IF ans.opt_id = ans.odr THEN
				pots := pots + ans.points;
			END IF;
			cqid := ans.qst_id;
			ctyp := ans.typ;
		END IF;
	END IF;
END LOOP;
IF ctyp = 3 THEN
	IF rst THEN
		pots := pots + cpot;
	END IF;
END IF;
RETURN pots;
END
$$
    LANGUAGE plpgsql;",init_db.sql
"CREATE FUNCTION examina_resultats(id_pacient bigint, id_analitica bigint DEFAULT NULL::bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	sql1 text;
	sql2 text;
	sql3 text;
	rec record;
	rec2 record;
	trobat boolean := False;
	nom varchar;
	cognom varchar;
	analitica bigint;
	id_resultat bigint;
	ret varchar :='';
	data_res date;
	resultat varchar :='';
	valoracio varchar;
	prova int;
	n_prova varchar;
BEGIN
	sql1 := 'SELECT * FROM pacients WHERE idpacient = ' || id_pacient || ';';
	
	FOR rec IN EXECUTE(sql1) LOOP
		trobat := True;
		nom    := rec.nom;
		cognom := rec.cognoms;
		
	END LOOP;
	
	IF NOT trobat THEN
		return '-5';
	END IF;
	
	trobat := False;
	
	IF id_analitica is not NULL THEN
		sql1 := 'SELECT idanalitica FROM analitiques WHERE idanalitica = ' || id_analitica || ' and idpacient = ' || id_pacient || ';';
		
		FOR rec IN EXECUTE(sql1) LOOP
			trobat    := True;
			analitica := rec.idanalitica;	
		END LOOP;
		
		IF NOT trobat THEN
			return '-6';
		END IF;
	ELSE
		sql1 := 'SELECT idanalitica FROM analitiques WHERE idpacient = ' || id_pacient || ' order by dataanalitica desc limit 1;';
		FOR rec IN EXECUTE(sql1) LOOP
			trobat    := True;
			analitica := rec.idanalitica;	
		END LOOP;
		
		IF NOT trobat THEN
			return '-7';
		END IF;
	END IF;
	
/* #####################################################################
   # HASTA AQUI, TANTO COMO EL PACIENTE COMO LA ANALITICA EXISTEN
   #####################################################################	
*/
	trobat := False;
	sql1 := 'SELECT * FROM  resultats WHERE idanalitica = ' || analitica || ';';
	
	FOR rec IN EXECUTE(sql1) LOOP
		
		trobat    := True;
		resultat  := rec.resultats;
		data_res  := to_char(rec.dataresultat,'YYYY-MM-DD');
		valoracio := valorar_idresultat(rec.idresultat);
		
		
		
		sql2 := 'SELECT * FROM  provestecnica WHERE idprovatecnica = ' || rec.idprovatecnica || ';';
		
		FOR rec2 IN EXECUTE(sql2) LOOP
			prova := rec2.idprova;
		END LOOP;
		
		sql3 := 'SELECT * FROM  catalegproves WHERE idprova = ' || prova|| ';';
		
		FOR rec2 IN EXECUTE(sql3) LOOP
			n_prova :=rec2.nom_prova ;
		END LOOP;
		
		ret := ret || '' || nom || '#' || cognom || '#' || data_res || '#' || prova || '#' || n_prova || '#' || resultat || '#' || valoracio || e' \n';
		
	
	END LOOP;
	
	IF NOT trobat THEN
		return '-8';
	END IF;
	
RETURN ret;
EXCEPTION 
	WHEN unique_violation THEN return '-1'; 
	WHEN foreign_key_violation THEN return '-2'; 
	WHEN not_null_violation THEN return '-3';
	--WHEN others THEN return '-4'; 
END;
$$;",lab_clinic.sql
"CREATE FUNCTION example_cursor() RETURNS void
    LANGUAGE plpgsql
    AS $$

declare
cur1 cursor for select * from company;
tst company%ROWTYPE;
begin
open cur1;
fetch cur1 into tst;
loop


RAISE NOTICE 'id %,name %,age %,address %,salary %',
tst.id,tst.name,tst.age,tst.address,tst.salary;
FETCH  cur1 into tst;
EXIT WHEN NOT FOUND;
end loop;
end;
$$;",file(21Aprl).pgsql
"CREATE FUNCTION execution_queue_to_json() RETURNS json
    LANGUAGE plpgsql
    AS $$

  BEGIN

    RETURN execution_queue_to_json(false);

  END

$$;",dump20171228.sql
"CREATE FUNCTION execution_queue_to_json() RETURNS json
    LANGUAGE plpgsql
    AS $$

  BEGIN

    RETURN execution_queue_to_json(false);

  END

$$;",dump_23-09-2017_10_26_25.sql
"CREATE FUNCTION execution_queue_to_json(humanized boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$

  DECLARE

    execution_queue_json JSON;

    notifications_json JSON;



  BEGIN

    -- Funcoes row_to_json usada para converter uma tupla inteira para JSON,

    -- array_agg para fazer agregacao de varias tuplas numa soh e

    -- array_to_json que converte o resultado de tudo isso para JSON

    -- sao as que fazem o milagre

    SELECT INTO execution_queue_json array_to_json(array_agg(row_to_json(eqj, humanized))) AS execution_queue

      FROM ( SELECT eq.id, eq.task_check_id, eq.next_execution,

                    tc.name AS task_check_name, tc.description AS task_check_description, pl.name AS place_name, us.name, us.email, us.mobile_message,

                    ( SELECT array_to_json(array_agg(row_to_json(nj, humanized))) AS notifications

                        FROM ( SELECT ns.notification_type_id, pm.key_name AS notifications_type_name

                               FROM notifications ns

                                 INNER JOIN parameters pm ON ns.notification_type_id = pm.id

                                 INNER JOIN task_checks tc ON ns.task_check_id = tc.id

                               WHERE tc.id = eq.task_check_id

                             ) nj

                    ) AS notifications 



             FROM execution_queue eq

               INNER JOIN task_checks tc ON eq.task_check_id = tc.id

               INNER JOIN places pl ON tc.place_id = pl.id

               INNER JOIN users us ON tc.user_checker_id = us.id

           ) eqj;



    RETURN execution_queue_json;

  END

$$;",dump20171228.sql
"CREATE FUNCTION execution_queue_to_json(humanized boolean) RETURNS json
    LANGUAGE plpgsql
    AS $$

  DECLARE

    execution_queue_json JSON;

    notifications_json JSON;



  BEGIN

    -- Funcoes row_to_json usada para converter uma tupla inteira para JSON,

    -- array_agg para fazer agregacao de varias tuplas numa soh e

    -- array_to_json que converte o resultado de tudo isso para JSON

    -- sao as que fazem o milagre

    SELECT INTO execution_queue_json array_to_json(array_agg(row_to_json(eqj, humanized))) AS execution_queue

      FROM ( SELECT eq.id, eq.task_check_id, eq.next_execution,

                    tc.name AS task_check_name, tc.description AS task_check_description, pl.name AS place_name, us.name, us.email, us.mobile_message,

                    ( SELECT array_to_json(array_agg(row_to_json(nj, humanized))) AS notifications

                        FROM ( SELECT ns.notification_type_id, pm.key_name AS notifications_type_name

                               FROM notifications ns

                                 INNER JOIN parameters pm ON ns.notification_type_id = pm.id

                                 INNER JOIN task_checks tc ON ns.task_check_id = tc.id

                               WHERE tc.id = eq.task_check_id

                             ) nj

                    ) AS notifications 



             FROM execution_queue eq

               INNER JOIN task_checks tc ON eq.task_check_id = tc.id

               INNER JOIN places pl ON tc.place_id = pl.id

               INNER JOIN users us ON tc.user_checker_id = us.id

           ) eqj;



    RETURN execution_queue_json;

  END

$$;",dump_23-09-2017_10_26_25.sql
"CREATE FUNCTION execution_queue_to_json(humanized boolean, text_json boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$

  BEGIN

    RETURN execution_queue_to_json(humanized)::TEXT;

  END

$$;",dump20171228.sql
"CREATE FUNCTION execution_queue_to_json(humanized boolean, text_json boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$

  BEGIN

    RETURN execution_queue_to_json(humanized)::TEXT;

  END

$$;",dump_23-09-2017_10_26_25.sql
"CREATE FUNCTION exemple(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
 numero1 ALIAS FOR $1;
 numero2 ALIAS FOR $2;

 constante CONSTANT integer := 100;
 resultado integer;

BEGIN
 resultado := (numero1 * numero2) + constante;
 RETURN resultado;
END;
$_$;",lab_clinic.sql
"CREATE FUNCTION exemple_txt(integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
 numero1 ALIAS FOR $1;
 numero2 ALIAS FOR $2;

 constante CONSTANT integer := 100;
 resultado INTEGER;

 resultado_txt TEXT DEFAULT 'El resultat es 104'; 

BEGIN
 resultado := (numero1 * numero2) + constante;

 IF resultado <> 104 THEN
    resultado_txt :=  'El resultado NO es 104';
 END IF;

 RETURN resultado_txt;
END;
$_$;",lab_clinic.sql
"CREATE FUNCTION export_database(table_name text, file_path text)
	RETURNS INTEGER
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || '
				) TO 
					' || quote_literal(file_path) || '
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
			RETURN 1;
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database(table_name text, file_path text)
	RETURNS VOID
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || '
				) TO 
					' || quote_literal(file_path) || '
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database(table_name text, path text, file_name text)
	RETURNS VOID
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || '
				) TO 
					' || quote_literal(path || file_name) || '
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database_join(table_name text, join_table_name text, column_name text, join_column_name text, file_path text)
	RETURNS INTEGER
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || ' 
				INNER JOIN 
					' || quote_ident(join_table_name) || ' 
				ON 
					' || column_name || ' 
				= 
					' || join_column_name || ' 
				) TO 
					' || quote_literal(file_path) || ' 
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
			RETURN 1;
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database_join(table_name text, join_table_name text, column_name text, join_column_name text, file_path text)
	RETURNS VOID
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT
					' || quote_ident(table_name) || '
				.* FROM 
					' || quote_ident(table_name) || ' 
				INNER JOIN 
					' || quote_ident(join_table_name) || ' 
				ON 
					' || column_name || ' 
				= 
					' || join_column_name || ' 
				) TO 
					' || quote_literal(file_path) || ' 
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database_join(table_name text, join_table_name text, column_name text, join_column_name text, file_path text)
	RETURNS VOID
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || ' 
				INNER JOIN 
					' || quote_ident(join_table_name) || ' 
				ON 
					' || column_name || ' 
				= 
					' || join_column_name || ' 
				) TO 
					' || quote_literal(file_path) || ' 
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION export_database_join(table_name text, join_table_name text, column_name text, join_column_name text, path text, file_name text)
	RETURNS VOID
	LANGUAGE plpgsql
	SECURITY DEFINER
	AS $BODY$
		BEGIN
			EXECUTE '
				COPY (SELECT * FROM 
					' || quote_ident(table_name) || ' 
				INNER JOIN 
					' || quote_ident(join_table_name) || ' 
				ON 
					' || column_name || ' 
				= 
					' || join_column_name || ' 
				) TO 
					' || quote_literal(path || file_name) || ' 
				WITH (
					FORMAT CSV, DELIMITER '';'', HEADER
				);
			';
		END;
	$BODY$
;",sormas_schema.sql
"CREATE FUNCTION extractdomain(url text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE

v_domain text;
p2 text;

BEGIN
p2:=url;
select array_to_string into v_domain (regexp_matches(url ,E'http[s]{0,1}://([^\/]+)'),'');


RETURN v_domain;
END;
$$;",02.sql
"CREATE FUNCTION extractdomain(url text, domain_level integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
v_domain_full text;
v_domain text;
v_matches text[];
v_level INTEGER := 1;
v_url_levels INTEGER := 0;
rec record;
BEGIN
SELECT regexp_matches(lower(url), E'https?://(www\\.)?([-\\wа-яА-Я0-9.]*\\.[а-яa-z]{2,6})', 'gi') INTO v_matches LIMIT 1;

IF v_matches IS NULL OR v_matches[2] IS NULL THEN
RETURN NULL;
END IF;

v_domain_full := v_matches[2];

v_matches := regexp_split_to_array(v_domain_full, E'\\.'); 
SELECT count(*) INTO v_url_levels FROM regexp_split_to_table(v_domain_full, E'\\.');

IF v_url_levels = domain_level THEN
RETURN v_domain_full;
END IF;

IF v_url_levels < domain_level THEN
RETURN NULL;
END IF;

v_domain := v_matches[v_url_levels];

IF (domain_level > 1) THEN
FOR i IN 1..domain_level-1 LOOP
v_domain := v_matches[v_url_levels - i] || '.' || v_domain;
END LOOP;
END IF;

RETURN v_domain;
END;
$$;",02.sql
"CREATE FUNCTION f_() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_assume_you_must_use_files() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $_$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Assume You
Must Use Files""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t
USING (table_schema, table_name) WHERE c.data_type IN ('character varying', 'text')
AND t.table_type='BASE TABLE' AND 
c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL) ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''^.*/.*\.[A-Za-z]{3}$''';
/*The source of the regular expression:
http://stackoverflow.com/questions/6416065/c-sharp-regex-for-file-paths-e-g-c-testtest-exe*/
RAISE NOTICE '%', sql_stmt;
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$_$;",backup-19-12-2016.backup
"CREATE FUNCTION f_assume_you_must_use_files() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $_$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Assume You
Must Use Files""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t
USING (table_schema, table_name) WHERE c.data_type IN ('character varying', 'text')
AND t.table_type='BASE TABLE' AND 
c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL) ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''^.*/.*\.[A-Za-z]{3}$''';
/*The source of the regular expression:
http://stackoverflow.com/questions/6416065/c-sharp-regex-for-file-paths-e-g-c-testtest-exe*/
RAISE NOTICE '%', sql_stmt;
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$_$;",final-backup.backup
"CREATE FUNCTION f_assume_you_must_use_files() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $_$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Assume You
Must Use Files""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t
USING (table_schema, table_name) WHERE c.data_type IN ('character varying', 'text')
AND t.table_type='BASE TABLE' AND 
c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL) ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''^.*/.*\.[A-Za-z]{3}$''';
/*The source of the regular expression:
http://stackoverflow.com/questions/6416065/c-sharp-regex-for-file-paths-e-g-c-testtest-exe*/
RAISE NOTICE '%', sql_stmt;
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$_$;",pre_esitamine_backup_revised.backup
"CREATE FUNCTION f_avert_abonnement() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_check_format_comma_separated_list() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Format
Comma-Separated Lists""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
lower(c.column_name) NOT LIKE '%aadress%' AND
lower(c.column_name) NOT LIKE '%address%' AND
lower(c.column_name) NOT LIKE '%elukoht%' AND
lower(c.column_name) NOT LIKE '%kirjeldus%' AND
lower(c.column_name) NOT LIKE '%tekst%' AND
lower(c.column_name) NOT LIKE '%description%' AND
lower(c.column_name) NOT LIKE '%kommentaar%' AND
lower(c.column_name) NOT LIKE '%comment%' AND
lower(c.column_name) NOT LIKE '%diagnoos%' AND
lower(c.column_name) NOT LIKE '%diagnosis%' AND
lower(c.column_name) NOT LIKE '%ringkon%' AND
lower(c.column_name) NOT LIKE '%constituency%'
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''(.+)([,;]{1}.+)+''';
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",backup-19-12-2016.backup
"CREATE FUNCTION f_check_format_comma_separated_list() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Format
Comma-Separated Lists""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
lower(c.column_name) NOT LIKE '%aadress%' AND
lower(c.column_name) NOT LIKE '%address%' AND
lower(c.column_name) NOT LIKE '%elukoht%' AND
lower(c.column_name) NOT LIKE '%kirjeldus%' AND
lower(c.column_name) NOT LIKE '%tekst%' AND
lower(c.column_name) NOT LIKE '%description%' AND
lower(c.column_name) NOT LIKE '%kommentaar%' AND
lower(c.column_name) NOT LIKE '%comment%' AND
lower(c.column_name) NOT LIKE '%diagnoos%' AND
lower(c.column_name) NOT LIKE '%diagnosis%' AND
lower(c.column_name) NOT LIKE '%ringkon%' AND
lower(c.column_name) NOT LIKE '%constituency%'
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''(.+)([,;]{1}.+)+''';
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",final-backup.backup
"CREATE FUNCTION f_check_format_comma_separated_list() RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
varchar_columns RECORD;
BEGIN
RAISE NOTICE 'Detecting possible occurrences of the antipattern ""Format
Comma-Separated Lists""';
FOR varchar_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
lower(c.column_name) NOT LIKE '%aadress%' AND
lower(c.column_name) NOT LIKE '%address%' AND
lower(c.column_name) NOT LIKE '%elukoht%' AND
lower(c.column_name) NOT LIKE '%kirjeldus%' AND
lower(c.column_name) NOT LIKE '%tekst%' AND
lower(c.column_name) NOT LIKE '%description%' AND
lower(c.column_name) NOT LIKE '%kommentaar%' AND
lower(c.column_name) NOT LIKE '%comment%' AND
lower(c.column_name) NOT LIKE '%diagnoos%' AND
lower(c.column_name) NOT LIKE '%diagnosis%' AND
lower(c.column_name) NOT LIKE '%ringkon%' AND
lower(c.column_name) NOT LIKE '%constituency%'
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= varchar_columns.table_schema;
table_name:= varchar_columns.table_name;
column_name:= varchar_columns.column_name;
sql_stmt:='SELECT Count(' || quote_ident(column_name) || ') AS c FROM
' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' WHERE '||
quote_ident(column_name) || '~''(.+)([,;]{1}.+)+''';
EXECUTE sql_stmt INTO cnt;
IF cnt>0 THEN
RETURN NEXT;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",pre_esitamine_backup_revised.backup
"CREATE FUNCTION f_check_password() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
val TEXT ;
passwd_columns RECORD;
table_schema TEXT;
table_name TEXT;
column_name TEXT;
sample_value TEXT;
return_str TEXT:='';
BEGIN
RAISE NOTICE 'Checking whether password is open text';
FOR passwd_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character', 'character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
(lower(c.column_name) LIKE '%parool%' OR
lower(c.column_name) LIKE '%passwd%' OR
lower(c.column_name) LIKE '%password%' OR
lower(c.column_name) LIKE '%salasona%')
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= passwd_columns.table_schema;
table_name:= passwd_columns.table_name;
column_name:= passwd_columns.column_name;
sql_stmt:='SELECT ' || quote_ident(column_name) || ' AS c FROM ' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' LIMIT 1';
EXECUTE sql_stmt INTO sample_value;
return_str:=return_str || ' ' || quote_ident(table_schema) || '.' ||  quote_ident(table_name) || '.' || quote_ident(column_name) || '=' || sample_value;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN return_str;
END;
$$;",backup-19-12-2016.backup
"CREATE FUNCTION f_check_password() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
val TEXT ;
passwd_columns RECORD;
table_schema TEXT;
table_name TEXT;
column_name TEXT;
sample_value TEXT;
return_str TEXT:='';
BEGIN
RAISE NOTICE 'Checking whether password is open text';
FOR passwd_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character', 'character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
(lower(c.column_name) LIKE '%parool%' OR
lower(c.column_name) LIKE '%passwd%' OR
lower(c.column_name) LIKE '%password%' OR
lower(c.column_name) LIKE '%salasona%')
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= passwd_columns.table_schema;
table_name:= passwd_columns.table_name;
column_name:= passwd_columns.column_name;
sql_stmt:='SELECT ' || quote_ident(column_name) || ' AS c FROM ' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' LIMIT 1';
EXECUTE sql_stmt INTO sample_value;
return_str:=return_str || ' ' || quote_ident(table_schema) || '.' ||  quote_ident(table_name) || '.' || quote_ident(column_name) || '=' || sample_value;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN return_str;
END;
$$;",final-backup.backup
"CREATE FUNCTION f_check_password() RETURNS text
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
val TEXT ;
passwd_columns RECORD;
table_schema TEXT;
table_name TEXT;
column_name TEXT;
sample_value TEXT;
return_str TEXT:='';
BEGIN
RAISE NOTICE 'Checking whether password is open text';
FOR passwd_columns IN SELECT c.table_schema, c.table_name, c.column_name
FROM INFORMATION_SCHEMA.columns AS c INNER JOIN INFORMATION_SCHEMA.tables AS t USING
(table_schema, table_name) WHERE c.data_type IN ('character', 'character varying', 'text') AND
t.table_type='BASE TABLE' AND c.table_schema NOT IN (SELECT schema_name
FROM INFORMATION_SCHEMA.schemata
WHERE schema_name<>'public' AND
schema_owner='postgres' AND schema_name IS NOT NULL)  AND
(lower(c.column_name) LIKE '%parool%' OR
lower(c.column_name) LIKE '%passwd%' OR
lower(c.column_name) LIKE '%password%' OR
lower(c.column_name) LIKE '%salasona%')
ORDER BY c.table_schema, c.table_name LOOP
table_schema:= passwd_columns.table_schema;
table_name:= passwd_columns.table_name;
column_name:= passwd_columns.column_name;
sql_stmt:='SELECT ' || quote_ident(column_name) || ' AS c FROM ' || quote_ident(table_schema) ||'.' || quote_ident(table_name) || ' LIMIT 1';
EXECUTE sql_stmt INTO sample_value;
return_str:=return_str || ' ' || quote_ident(table_schema) || '.' ||  quote_ident(table_name) || '.' || quote_ident(column_name) || '=' || sample_value;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN return_str;
END;
$$;",pre_esitamine_backup_revised.backup
"CREATE FUNCTION f_check_recurso(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
    DECLARE
		count integer;
	BEGIN
		count:=-1;
		
		PERFORM *
		FROM recursos
		WHERE recursoid = $1;
		
		GET DIAGNOSTICS count = ROW_COUNT;
		return count;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
		
	END
$_$;",DBTests.sql
"CREATE FUNCTION f_check_user_email(v_email character varying, pass text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		i_email VARCHAR;
	BEGIN
		IF (hashed == 1) THEN
			SELECT USERNAME INTO i_email
			FROM USUARIOS
			WHERE USERNAME = v_email AND PASSWORD = pass;
		ELSE
			SELECT USERNAME INTO i_email
			FROM USUARIOS
			WHERE USERNAME = v_email AND PASSWORD = crypt(pass, PASSWORD);
		END IF;
		IF (i_user == NULL) THEN
			RETURN 1;
		ELSE
			RETURN 0;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_check_user_username(v_user character varying, pass text, hashed integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		i_user VARCHAR;
	BEGIN
		IF (hashed == 1) THEN
			SELECT USERNAME INTO i_user
			FROM USUARIOS
			WHERE USERNAME = v_user AND PASSWORD = pass;
		ELSE
			SELECT USERNAME INTO i_user
			FROM USUARIOS
			WHERE USERNAME = v_user AND PASSWORD = crypt(pass, PASSWORD);
		END IF;
		IF (i_user == NULL) THEN
			RETURN 1;
		ELSE
			RETURN 0;
		END IF;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_connexion_user(v_email text, v_password text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$


begin


RETURN EXISTS (SELECT 1 FROM ""Utilisateur"" WHERE email = v_email AND password = v_password);


end


$$;",baseExterne.sql
"CREATE FUNCTION f_default_value_with_no_match() RETURNS TABLE(foreign_ns text, foreign_table text, foreign_colname text, target_ns text, target_table text, target_colname text, target_default text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
rslt TEXT:='';
fks RECORD;
BEGIN
RAISE NOTICE 'Detecting foreign key columns that have a default value that does not have a matching value in the
key of the primary table.';
FOR fks IN (WITH d AS (SELECT A.table_schema::text, A.table_name::text, A.column_name::text, A.column_default::text
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
WHERE column_default IS NOT NULL 
AND T.table_type='BASE TABLE' AND domain_name IS NULL
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')
UNION SELECT A.table_schema, A.table_name , A.column_name, D.domain_default
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
INNER JOIN information_schema.domains D
ON A.domain_schema = D.domain_schema
AND A.domain_name = D.domain_name
WHERE T.table_type='BASE TABLE'
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')),
fk AS (select (select nspname from pg_namespace where oid=f.relnamespace)::text as foreign_ns,
f.relname::text as foreign_table,
(select a.attname from pg_attribute a where a.attrelid = f.oid and a.attnum = o.confkey[1] and a.attisdropped = false)::text as foreign_colname,
(select nspname from pg_namespace where oid=m.relnamespace)::text as target_ns,
m.relname::text as target_table,
(select a.attname from pg_attribute a where a.attrelid = m.oid and a.attnum = o.conkey[1] and a.attisdropped = false)::text as target_colname 
from pg_constraint o left join    pg_class c on c.oid = o.conrelid
left join pg_class f on f.oid = o.confrelid left join pg_class m on m.oid = o.conrelid
where o.contype = 'f' and o.conrelid in (select oid from pg_class c where c.relkind = 'r'))
SELECT fk.*, d.column_default AS target_default
FROM fk, d
WHERE fk.target_ns=d.table_schema AND
fk.target_table=d.table_name AND
fk.target_colname=d.column_name) LOOP
sql_stmt:='SELECT Count(' || quote_ident(fks.foreign_colname) || ') AS c FROM
' || quote_ident(fks.foreign_ns) ||'.' || quote_ident(fks.foreign_table) || ' WHERE '||
quote_ident(fks.foreign_colname) || '::text='||fks.target_default || '::text';
IF sql_stmt IS NOT NULL THEN
EXECUTE sql_stmt INTO cnt;
IF cnt=0 THEN
foreign_ns:=fks.foreign_ns;
foreign_table:=fks.foreign_table;
foreign_colname:=fks.foreign_colname;
target_ns:=fks.target_ns;
target_table:=fks.target_table;
target_colname:=fks.target_colname;
target_default:=fks.target_default;
RETURN NEXT;
END IF;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",backup-19-12-2016.backup
"CREATE FUNCTION f_default_value_with_no_match() RETURNS TABLE(foreign_ns text, foreign_table text, foreign_colname text, target_ns text, target_table text, target_colname text, target_default text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
rslt TEXT:='';
fks RECORD;
BEGIN
RAISE NOTICE 'Detecting foreign key columns that have a default value that does not have a matching value in the
key of the primary table.';
FOR fks IN (WITH d AS (SELECT A.table_schema::text, A.table_name::text, A.column_name::text, A.column_default::text
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
WHERE column_default IS NOT NULL 
AND T.table_type='BASE TABLE' AND domain_name IS NULL
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')
UNION SELECT A.table_schema, A.table_name , A.column_name, D.domain_default
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
INNER JOIN information_schema.domains D
ON A.domain_schema = D.domain_schema
AND A.domain_name = D.domain_name
WHERE T.table_type='BASE TABLE'
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')),
fk AS (select (select nspname from pg_namespace where oid=f.relnamespace)::text as foreign_ns,
f.relname::text as foreign_table,
(select a.attname from pg_attribute a where a.attrelid = f.oid and a.attnum = o.confkey[1] and a.attisdropped = false)::text as foreign_colname,
(select nspname from pg_namespace where oid=m.relnamespace)::text as target_ns,
m.relname::text as target_table,
(select a.attname from pg_attribute a where a.attrelid = m.oid and a.attnum = o.conkey[1] and a.attisdropped = false)::text as target_colname 
from pg_constraint o left join    pg_class c on c.oid = o.conrelid
left join pg_class f on f.oid = o.confrelid left join pg_class m on m.oid = o.conrelid
where o.contype = 'f' and o.conrelid in (select oid from pg_class c where c.relkind = 'r'))
SELECT fk.*, d.column_default AS target_default
FROM fk, d
WHERE fk.target_ns=d.table_schema AND
fk.target_table=d.table_name AND
fk.target_colname=d.column_name) LOOP
sql_stmt:='SELECT Count(' || quote_ident(fks.foreign_colname) || ') AS c FROM
' || quote_ident(fks.foreign_ns) ||'.' || quote_ident(fks.foreign_table) || ' WHERE '||
quote_ident(fks.foreign_colname) || '::text='||fks.target_default || '::text';
IF sql_stmt IS NOT NULL THEN
EXECUTE sql_stmt INTO cnt;
IF cnt=0 THEN
foreign_ns:=fks.foreign_ns;
foreign_table:=fks.foreign_table;
foreign_colname:=fks.foreign_colname;
target_ns:=fks.target_ns;
target_table:=fks.target_table;
target_colname:=fks.target_colname;
target_default:=fks.target_default;
RETURN NEXT;
END IF;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",final-backup.backup
"CREATE FUNCTION f_default_value_with_no_match() RETURNS TABLE(foreign_ns text, foreign_table text, foreign_colname text, target_ns text, target_table text, target_colname text, target_default text)
    LANGUAGE plpgsql SECURITY DEFINER
    SET search_path TO information_schema, pg_temp
    AS $$
DECLARE
sql_stmt TEXT;
cnt BIGINT;
rslt TEXT:='';
fks RECORD;
BEGIN
RAISE NOTICE 'Detecting foreign key columns that have a default value that does not have a matching value in the
key of the primary table.';
FOR fks IN (WITH d AS (SELECT A.table_schema::text, A.table_name::text, A.column_name::text, A.column_default::text
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
WHERE column_default IS NOT NULL 
AND T.table_type='BASE TABLE' AND domain_name IS NULL
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')
UNION SELECT A.table_schema, A.table_name , A.column_name, D.domain_default
FROM information_schema.columns A
INNER JOIN information_schema.tables T
ON A.table_schema = T.table_schema
AND A.table_name = T.table_name
INNER JOIN information_schema.schemata S
ON A.table_schema=S.schema_name
INNER JOIN information_schema.domains D
ON A.domain_schema = D.domain_schema
AND A.domain_name = D.domain_name
WHERE T.table_type='BASE TABLE'
AND (A.table_schema = 'public'
OR S.schema_owner<>'postgres')),
fk AS (select (select nspname from pg_namespace where oid=f.relnamespace)::text as foreign_ns,
f.relname::text as foreign_table,
(select a.attname from pg_attribute a where a.attrelid = f.oid and a.attnum = o.confkey[1] and a.attisdropped = false)::text as foreign_colname,
(select nspname from pg_namespace where oid=m.relnamespace)::text as target_ns,
m.relname::text as target_table,
(select a.attname from pg_attribute a where a.attrelid = m.oid and a.attnum = o.conkey[1] and a.attisdropped = false)::text as target_colname 
from pg_constraint o left join    pg_class c on c.oid = o.conrelid
left join pg_class f on f.oid = o.confrelid left join pg_class m on m.oid = o.conrelid
where o.contype = 'f' and o.conrelid in (select oid from pg_class c where c.relkind = 'r'))
SELECT fk.*, d.column_default AS target_default
FROM fk, d
WHERE fk.target_ns=d.table_schema AND
fk.target_table=d.table_name AND
fk.target_colname=d.column_name) LOOP
sql_stmt:='SELECT Count(' || quote_ident(fks.foreign_colname) || ') AS c FROM
' || quote_ident(fks.foreign_ns) ||'.' || quote_ident(fks.foreign_table) || ' WHERE '||
quote_ident(fks.foreign_colname) || '::text='||fks.target_default || '::text';
IF sql_stmt IS NOT NULL THEN
EXECUTE sql_stmt INTO cnt;
IF cnt=0 THEN
foreign_ns:=fks.foreign_ns;
foreign_table:=fks.foreign_table;
foreign_colname:=fks.foreign_colname;
target_ns:=fks.target_ns;
target_table:=fks.target_table;
target_colname:=fks.target_colname;
target_default:=fks.target_default;
RETURN NEXT;
END IF;
END IF;
END LOOP;
RAISE NOTICE 'Detection completed';
RETURN;
END;
$$;",pre_esitamine_backup_revised.backup
"CREATE FUNCTION f_get_counter_value(_cnt_id integer, _cdate date) RETURNS real
    LANGUAGE plpgsql STABLE
    AS $_$
begin
	if (SELECT isnew FROM gks.counter_values where cnt_id = $1 AND checkdate=$2) = false then
		return (SELECT reading FROM gks.counter_values where cnt_id = $1 AND checkdate=$2)-
		(SELECT reading FROM gks.counter_values where cnt_id = $1 AND checkdate < $2 ORDER BY id desc LIMIT 1);
	end if;

	return 0;
end;
$_$;",db.backup
"CREATE FUNCTION f_get_location_station(id integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
	DECLARE
		x RECORD;
	BEGIN
		SELECT E.UBICACIONLAT AS LAT, E.UBICACIONLNG AS LNG INTO x
		FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN x;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN NULL;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_get_name_station(id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	DECLARE
		name VARCHAR := 'N/A';
	BEGIN
		SELECT E.NOMBREESTACION AS name
		FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN name;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN NULL;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_get_nearest_resource(lat numeric, lng numeric, type integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE

	BEGIN

	END
$$;",DBTests.sql
"CREATE FUNCTION f_get_severity_incident(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		severity INTEGER := -1;
	BEGIN
		SELECT 
		60*(EXTRACT(HOUR FROM (NOW()::TIMESTAMP - I.FECHANOTIFICACION))) + (EXTRACT(MINUTE FROM (NOW()::TIMESTAMP - I.FECHANOTIFICACION))) + I.GRAVEDAD
		INTO severity
		FROM HIST_INCIDENCIAS I
		WHERE I.incidenciaid = $1;
		RETURN severity;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$_$;",DBTests.sql
"CREATE FUNCTION f_get_type_resource(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		type_id INTEGER := -1;
	BEGIN
		SELECT E.TIPORECURSOID INTO type_id FROM ESTACIONES E
		JOIN RECURSOS R ON R.ESTACIONID = E.ESTACIONID
		WHERE R.RECURSOID = id;
		RETURN type_id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_get_type_station(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		type_id INTEGER := -1;
	BEGIN
		SELECT E.TIPORECURSOID INTO type_id FROM ESTACIONES E
		WHERE E.ESTACIONID = id;
		RETURN type_id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_get_user_id(dni character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	DECLARE
		id INTEGER := -1;
	BEGIN
		SELECT U.USUARIOID INTO id
		FROM USUARIOS U
		WHERE U.DNI = dni;
		RETURN id;
	EXCEPTION
		WHEN OTHERS THEN
			RETURN -2;
	END
$$;",DBTests.sql
"CREATE FUNCTION f_inscr_ami_seance() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_inscr_seance_client(v_email text, idseance integer) RETURNS void
    LANGUAGE plpgsql
    AS $$


declare


    iduser int;


begin


    -- On récupère l'id de l'utilisateur


    SELECT ""idUtilisateur"" from ""Utilisateur"" where ""email""=v_email into iduser;


    -- On inscrit le client à la séance


    select f_inscr_seance(iduser, idseance, FALSE);


end


$$;",baseExterne.sql
"CREATE FUNCTION f_is_exist_email(p_email character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
declare
  cnt INTEGER:=0;
begin
  SELECT COUNT(1) INTO cnt FROM USERS u WHERE u.email=p_email;
  IF cnt>0 THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;
end;
$$;",scriptDB.sql
"CREATE FUNCTION f_on_juhataja(p_e_meil text, p_parool text) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$DECLARE rslt boolean;
BEGIN
SELECT INTO rslt (parool = public.crypt(p_parool, parool)) 
FROM
(SELECT Isik.e_meil, Isik.parool, Tootaja.amet_kood, Tootaja.tootaja_seisundi_liik_kood
FROM Isik INNER JOIN Tootaja ON Isik.isik_id = Tootaja.isik_id) AS andmed
WHERE Upper(e_meil)=Upper(p_e_meil) AND amet_kood = 1 AND tootaja_seisundi_liik_kood IN (1,6,7);
RETURN coalesce(rslt, FALSE);
END;$$;",final-backup.backup
"CREATE FUNCTION f_on_juhataja(p_e_meil text, p_parool text) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$DECLARE rslt boolean;
BEGIN
SELECT INTO rslt (parool = public.crypt(p_parool, parool)) 
FROM
(SELECT Isik.e_meil, Isik.parool, Tootaja.amet_kood, Tootaja.tootaja_seisundi_liik_kood
FROM Isik INNER JOIN Tootaja ON Isik.isik_id = Tootaja.isik_id) AS andmed
WHERE Upper(e_meil)=Upper(p_e_meil) AND amet_kood = 1 AND tootaja_seisundi_liik_kood IN (1,6,7);
RETURN coalesce(rslt, FALSE);
END;$$;",pre_esitamine_backup_revised.backup
"CREATE FUNCTION f_on_juhataja(p_e_meil text, p_parool text) RETURNS boolean
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    SET search_path TO public, pg_temp
    AS $$
DECLARE rslt boolean;
BEGIN
SELECT INTO rslt (parool = public.crypt(p_parool, parool)) 
FROM isik, tootaja WHERE Upper(e_meil)=Upper(p_e_meil) AND amet_kood
BETWEEN 1 AND 8 AND tootaja_seisundi_liik_kood IN (1,6,7);
RETURN coalesce(rslt, FALSE);
END;
$$;",backup-19-12-2016.backup
"CREATE FUNCTION f_prendre_coach() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_prop_seances_complet() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_prop_seances_salle() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_set_internaute() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


set role u_internaute;


end


$$;",baseExterne.sql
"CREATE FUNCTION f_set_role(v_email text) RETURNS void
    LANGUAGE plpgsql
    AS $$


declare userrole text;


begin


userrole:=(select role from ""Utilisateur"" where ""Utilisateur"".email=v_email);


IF userrole = 'client' THEN


    set role u_client;


ELSIF userrole = 'admin' THEN


    set role u_admin;


ELSIF userrole = 'coach' THEN


    set role u_coach;


ELSIF userrole = 'employe' THEN


    set role u_employe;


ELSE


    set role u_internaute;


END IF;


end


$$;",baseExterne.sql
"CREATE FUNCTION f_voir_hist_seance() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_voir_plan_client() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_voir_plan_coach() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION f_voir_plan_seance() RETURNS void
    LANGUAGE plpgsql
    AS $$


begin


end


$$;",baseExterne.sql
"CREATE FUNCTION fact_sum_interval(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
x interval;
result integer := 0;
begin

if (SELECT EXTRACT(EPOCH FROM (select * from fact_timetable($1,$2) limit 1)) is null) then
	return -1;
end if;
for x in select * from fact_timetable($1, $2)
loop
	result := result + (SELECT EXTRACT(EPOCH FROM x))/3600;
end loop;

return result;
end
$_$;",MovieStore_script.sql
"CREATE FUNCTION fail(_message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  RAISE EXCEPTION E'#fail\n%', _message;
END;
$$;",mdm.sql
"CREATE FUNCTION fail(_message character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  RAISE EXCEPTION E'#fail\n%', _message;
END;
$$;",mes-idea.sql
"CREATE FUNCTION fbalance() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE 
	_cnt 		int;
BEGIN
	WITH accounting_order AS (SELECT np,sum(qtt) AS qtt FROM torder GROUP BY np),
	     accounting_mvt   AS (SELECT nat as np,sum(qtt) AS qtt FROM tmvt GROUP BY nat)
	SELECT count(*) INTO _cnt FROM tquality,accounting_order,accounting_mvt
	WHERE tquality.id=accounting_order.np AND tquality.id=accounting_mvt.np
		AND tquality.qtt != accounting_order.qtt + accounting_mvt.qtt;
	RETURN _cnt;
END;		
$$;",simu_ref.sql
"CREATE FUNCTION fexplodequality(_quality_name text) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
DECLARE
	_e int;
	_q text[];
	_CHECK_QUALITY_OWNERSHIP int := fgetconst('CHECK_QUALITY_OWNERSHIP');
BEGIN
	IF(char_length(_quality_name) <1) THEN
		RAISE NOTICE 'Quality name ""%"" incorrect: do not len(name)<1',_quality_name;
		RAISE EXCEPTION USING ERRCODE='YU001';
	END IF;
	IF(_CHECK_QUALITY_OWNERSHIP = 0) THEN
		_q[1] := NULL;
		_q[2] := _quality_name;
		RETURN _q;
	END IF;
	
	_e =position('/' in _quality_name);
	IF(_e < 2) THEN 
		RAISE NOTICE 'Quality name ""%"" incorrect: <depository>/<quality> expected',_quality_name;
		RAISE EXCEPTION USING ERRCODE='YU001';
	END IF;
	
	_q[1] = substring(_quality_name for _e-1);
	_q[2] = substring(_quality_name from _e+1);
	if(char_length(_q[2])<1) THEN
		RAISE NOTICE 'Quality name ""%"" incorrect: <depository>/<quality> expected',_quality_name;
		RAISE EXCEPTION USING ERRCODE='YU001';
	END IF;
	RETURN _q;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fget_treltried(_np integer, _nr integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE 
	_cnt int8;
	_MAXTRY 	int := fgetconst('MAXTRY');
BEGIN
	IF(_MAXTRY=0) THEN
		RETURN 0;
	END IF;
	SELECT cnt into _cnt FROM treltried WHERE np=_np AND nr=_nr;
	IF NOT FOUND THEN
		_cnt := 0;
	END IF;

	RETURN _cnt;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fgetagr(_grp text) RETURNS TABLE(_own text, _natp text, _qtt_prov bigint, _qtt_requ bigint, _natr text)
    LANGUAGE plpgsql
    AS $$
DECLARE 
	_fnat	 text;
	_fqtt	 int8;
	_fown	 text;
	_m	 vmvtverif%rowtype;
BEGIN
		_qtt_requ := NULL;
		FOR _m IN SELECT * FROM vmvtverif WHERE grp=_grp ORDER BY id ASC LOOP
			IF(_qtt_requ IS NULL) THEN
				_qtt_requ := _m.qtt;
				SELECT name INTO _natr FROM tquality WHERE _m.nat=id;
				SELECT name INTO _fown FROM towner WHERE _m.own_src=id;
				_fqtt := _m.qtt;
				_fnat := _natr;
			ELSE
				SELECT name INTO _natp FROM tquality WHERE _m.nat=id;
				SELECT name INTO _own FROM towner WHERE _m.own_src=id;
				_qtt_prov := _m.qtt;
				
				RETURN NEXT;
				_qtt_requ := _qtt_prov;
				_natr := _natp;
			END IF;
		END LOOP;
		IF(_qtt_requ IS NOT NULL) THEN
			_own := _fown;
			_natp := _fnat;
			_qtt_prov := _fqtt;
			--_qtt_requ := _qtt_requ;
			--_natr :=  _natr;
			RETURN NEXT;
		END IF;
	RETURN;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fgetconst(_name text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE
	_ret int;
BEGIN
	SELECT value INTO _ret FROM tconst WHERE name=_name;
	IF(NOT FOUND) THEN
		RAISE WARNING 'the const % is not found',_name USING ERRCODE= 'YA002';
		RAISE EXCEPTION USING ERRCODE='YA002';
	END IF;
	IF(_name = 'MAXCYCLE' AND _ret >8) THEN
		RAISE EXCEPTION 'obCMAXVALUE must be <=8' USING ERRCODE='YA002';
	END IF;
	RETURN _ret;
END; 
$$;",simu_ref.sql
"CREATE FUNCTION fgeterrs(_details boolean) RETURNS TABLE(_name text, cnt bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE 
	_i 		int;
	_cnt 		int;
BEGIN		
	_name := 'balance';
	cnt := fbalance();	
	RETURN NEXT;
	
	IF(_details) THEN
	
		_name := 'errors on quantities in mvts';
		cnt := fverifmvt();
		RETURN NEXT;
	
		_name := 'errors on agreements in mvts';
		cnt := fverifmvt2();
		RETURN NEXT;
	END IF;
	RETURN;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fgetstats(_details boolean) RETURNS TABLE(_name text, cnt bigint)
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
DECLARE 
	_i 		int;
	_cnt 		int;
BEGIN

	_name := 'number of qualities';
	select count(*) INTO cnt FROM tquality;
	RETURN NEXT;
	
	_name := 'number of owners';
	select count(*) INTO cnt FROM towner;
	RETURN NEXT;
	
	_name := 'number of quotes';
	select count(*) INTO cnt FROM tquote;
	RETURN NEXT;
			
	_name := 'number of orders';
	select count(*) INTO cnt FROM vorderverif;
	RETURN NEXT;
	
	_name := 'number of movements';
	select count(*) INTO cnt FROM vmvtverif;
	RETURN NEXT;
	
	_name := 'number of quotes removed';
	select count(*) INTO cnt FROM tquoteremoved;
	RETURN NEXT;

	_name := 'number of orders removed';
	select count(*) INTO cnt FROM torderremoved;
	RETURN NEXT;
	
	_name := 'number of movements removed';
	select count(*) INTO cnt FROM tmvtremoved;	
	RETURN NEXT;
	
	_name := 'number of agreements';
	select count(distinct grp) INTO cnt FROM vmvtverif where nb!=1;	
	RETURN NEXT;	
	
	_name := 'number of orders rejected';
	select count(distinct grp) INTO cnt FROM vmvtverif where nb=1;	
	RETURN NEXT;	
	
	FOR _i,cnt IN select nb,count(distinct grp) FROM vmvtverif where nb!=1 GROUP BY nb LOOP
		_name := 'agreements with ' || _i || ' partners';
		RETURN NEXT;
	END LOOP;

	RETURN;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fgetuuid(_id integer) RETURNS text
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	_market_session	int;
BEGIN
	SELECT market_session INTO _market_session FROM vmarket;
	-- RETURN lpad(_market_session::text,19,'0') || '-' || lpad(_id::text,19,'0');
	RETURN _market_session::text || '-' || _id::text;
END;
$$;",simu_ref.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",database.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",schema.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",villages.sql
"CREATE FUNCTION find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||schemaname||'"".""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||schemaname||'"".""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",database.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",schema.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",villages.sql
"CREATE FUNCTION find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    AS $_$DECLARE
   schem text;
   tabl text;
   sr int4;
BEGIN
   IF $1 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - schema is NULL!';
   END IF;
   IF $2 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - table name is NULL!';
   END IF;
   IF $3 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - column name is NULL!';
   END IF;
   schem = $1;
   tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
   IF ( schem = '' and tabl LIKE '%.%' ) THEN
     schem = substr(tabl,1,strpos(tabl,'.')-1);
     tabl = substr(tabl,length(schem)+2);
   ELSE
     schem = schem || '%';
   END IF;

   select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
   IF NOT FOUND THEN
       RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
   END IF;
  return sr;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    AS $_$DECLARE
   schem text;
   tabl text;
   sr int4;
BEGIN
   IF $1 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - schema is NULL!';
   END IF;
   IF $2 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - table name is NULL!';
   END IF;
   IF $3 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - column name is NULL!';
   END IF;
   schem = $1;
   tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
   IF ( schem = '' and tabl LIKE '%.%' ) THEN
     schem = substr(tabl,1,strpos(tabl,'.')-1);
     tabl = substr(tabl,length(schem)+2);
   ELSE
     schem = schem || '%';
   END IF;

   select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
   IF NOT FOUND THEN
       RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
   END IF;
  return sr;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",database.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",nlp.dump
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",schema.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schem text;
	tabl text;
	sr int4;
BEGIN
	IF $1 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - schema is NULL!';
	END IF;
	IF $2 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - table name is NULL!';
	END IF;
	IF $3 IS NULL THEN
	  RAISE EXCEPTION 'find_srid() - column name is NULL!';
	END IF;
	schem = $1;
	tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
	IF ( schem = '' and tabl LIKE '%.%' ) THEN
	 schem = substr(tabl,1,strpos(tabl,'.')-1);
	 tabl = substr(tabl,length(schem)+2);
	ELSE
	 schem = schem || '%';
	END IF;

	select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
	IF NOT FOUND THEN
	   RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
	END IF;
	return sr;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$DECLARE
   schem text;
   tabl text;
   sr int4;
BEGIN
   IF $1 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - schema is NULL!';
   END IF;
   IF $2 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - table name is NULL!';
   END IF;
   IF $3 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - column name is NULL!';
   END IF;
   schem = $1;
   tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
   IF ( schem = '' and tabl LIKE '%.%' ) THEN
     schem = substr(tabl,1,strpos(tabl,'.')-1);
     tabl = substr(tabl,length(schem)+2);
   ELSE
     schem = schem || '%';
   END IF;

   select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
   IF NOT FOUND THEN
       RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
   END IF;
  return sr;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION find_srid(character varying, character varying, character varying) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$DECLARE
   schem text;
   tabl text;
   sr int4;
BEGIN
   IF $1 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - schema is NULL!';
   END IF;
   IF $2 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - table name is NULL!';
   END IF;
   IF $3 IS NULL THEN
      RAISE EXCEPTION 'find_srid() - column name is NULL!';
   END IF;
   schem = $1;
   tabl = $2;
-- if the table contains a . and the schema is empty
-- split the table into a schema and a table
-- otherwise drop through to default behavior
   IF ( schem = '' and tabl LIKE '%.%' ) THEN
     schem = substr(tabl,1,strpos(tabl,'.')-1);
     tabl = substr(tabl,length(schem)+2);
   ELSE
     schem = schem || '%';
   END IF;

   select SRID into sr from geometry_columns where f_table_schema like schem and f_table_name = tabl and f_geometry_column = $3;
   IF NOT FOUND THEN
       RAISE EXCEPTION 'find_srid() - couldnt find the corresponding SRID - is the geometry registered in the GEOMETRY_COLUMNS table?  Is there an uppercase/lowercase missmatch?';
   END IF;
  return sr;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION findprice(character, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
makerIn ALIAS FOR $1;
modelIn ALIAS FOR $2;
typeFind CHARACTER(20);
BEGIN
typeFind = (SELECT type
FROM Product
WHERE maker = makerIn
AND model = modelIn
LIMIT 1);
IF (typeFind = 'pc') THEN
RETURN (SELECT price FROM PC WHERE model = modelIn);
ELSIF (typeFind = 'laptop') THEN
RETURN (SELECT price FROM Laptop WHERE model = modelIn);
ELSE
RETURN (SELECT price FROM Printer WHERE model = modelIn);
END IF;
END;
$_$;",dump_postgres_15_11.sql
"CREATE FUNCTION first_password() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	rnd integer;
	passchange varchar(12);
BEGIN
	passchange := trunc(random()*1000);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);
	passchange := passchange || trunc(random()*1000);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);

	return passchange;
END;
$$;",employee.sql
"CREATE FUNCTION five(study_uid text) RETURNS text
    LANGUAGE plpgsql
    AS $$declare
------------------------------------------
-- Purpose: Philips CR header processor
-- 	After successful run clears entry from
--	""exams-to-process"" table
-- Caller: Dispatcher
-----------------------------------------
	func text :='ddw:five';
	status text :='failed';

begin
	status :='ok';
	-- right now this is just a stub to clear the ""exams-to-process"" table
	-- and avoid errors in the Log table
	return status ;
end;$$;",purged-ddw.sql
"CREATE FUNCTION fn_calcularcuota(p_montototal numeric, p_nrocuotas numeric, p_tea numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $$

declare valorcuota decimal = 0;
declare numerador decimal = 0;
declare denominador decimal = 0;
declare tasamensual decimal = 0;

Begin

tasamensual = negocio.fn_calculartem(p_tea);

numerador = ((1+tasamensual)^p_nrocuotas) * tasamensual;
denominador = ((1+tasamensual)^p_nrocuotas) - 1;

valorcuota = p_montototal * (numerador / denominador);


return valorcuota;


End;
$$;",nova.backup
"CREATE FUNCTION fn_calculartem(p_tea numeric) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

declare tasamensual decimal = 0;


begin

tasamensual = ( (1+p_tea)^(1.0/12.0) )-1;

return tasamensual;

end;
$$;",nova.backup
"CREATE FUNCTION fn_clientes_sel(smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF clientes
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idcliente alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	 consulta TEXT = 'select idcliente, tipodocumento, numerodocumento, direccion, telefono, correoelectronico, responsable, consejo from clientes';
begin
	inicio = limite * pagina - limite;
	if _tipo = 0 then -- Consulta todos los registros
		consulta = consulta;
	elsif _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where idcliente = ' || _idcliente;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir || ' limit ' || limite || ' offset ' || inicio;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_clientes_sel(smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF clientes
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idcliente alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	 consulta TEXT = 'select idcliente, tipodocumento, numerodocumento, direccion, telefono, correoelectronico, responsable, consejo from clientes';
begin
	inicio = limite * pagina - limite;
	if _tipo = 0 then -- Consulta todos los registros
		consulta = consulta;
	elsif _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where idcliente = ' || _idcliente;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir || ' limit ' || limite || ' offset ' || inicio;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_comboproveedorestipo(p_idtipo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT per.id, per.nombres, per.apellidopaterno, per.apellidomaterno
  FROM negocio.""Persona"" per,
       negocio.""ProveedorPersona"" pper
 WHERE per.id                = pper.idproveedor
   AND per.idestadoregistro  = 1
   AND pper.idestadoregistro = 1
   AND pper.idtipoproveedor  = p_idtipo;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_20130224.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_configuracion_sel(smallint DEFAULT (-1), character varying DEFAULT 'NINGUNO'::character varying, boolean DEFAULT true) RETURNS SETOF configuracion
    LANGUAGE plpgsql
    AS $_$
declare
	tipo alias for $1;
	para alias for $2;
	acti alias for $3;
begin
	if tipo = 0 then -- Consulta todos los parametros
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion;
	elsif tipo = 1 then -- Consulta de un parametro especifico
		return query select idconfiguracion, parametro, valorparametro, activo from configuracion where parametro = upper(para);
	end if;
end;
$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_consultarclientescumple() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select id, idtipopersona, nombres, apellidopaterno, apellidomaterno, 
       idgenero, idestadocivil, idtipodocumento, numerodocumento, usuariocreacion, 
       fechacreacion, ipcreacion, usuariomodificacion, fechamodificacion, 
       ipmodificacion, idestadoregistro, fecnacimiento, nropasaporte, 
       fecvctopasaporte
  from negocio.""Persona"" p
 where p.idestadoregistro              = 1
   and p.idtipopersona                 = 1
   and to_char(p.fecnacimiento,'ddMM') = to_char(current_date,'ddMM');

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarclientesnovios(p_genero character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT pro.id AS idpersona, tdoc.id AS idtipodocumento, 
       tdoc.nombre AS nombretipodocumento, pro.numerodocumento, pro.nombres, 
       pro.apellidopaterno, pro.apellidomaterno
   FROM negocio.""Persona"" pro, 
        soporte.""Tablamaestra"" tdoc
  WHERE pro.idestadoregistro  = 1 
    AND pro.idtipopersona     = 1
    AND tdoc.idmaestro        = 1 
    AND pro.idtipodocumento   = tdoc.id
    AND pro.idgenero          = p_genero;


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarclientesnovios(p_genero character varying, p_idtipodocumento integer, p_numerodocumento character varying, p_nombres character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT pro.id AS idpersona, tdoc.id AS idtipodocumento, 
       tdoc.nombre AS nombretipodocumento, pro.numerodocumento, pro.nombres, 
       pro.apellidopaterno, pro.apellidomaterno
   FROM negocio.""Persona"" pro, 
        soporte.""Tablamaestra"" tdoc
  WHERE pro.idestadoregistro  = 1 
    AND pro.idtipopersona     = 1
    AND tdoc.idmaestro        = 1 
    AND pro.idtipodocumento   = tdoc.id
    AND pro.idgenero          = p_genero
    AND tdoc.id               = COALESCE(p_idtipodocumento,tdoc.id)
    AND pro.numerodocumento   = COALESCE(p_numerodocumento,pro.numerodocumento)
    AND CONCAT(replace(pro.nombres,' ',''),trim(pro.apellidopaterno),trim(pro.apellidomaterno)) like '%'||COALESCE(p_nombres,CONCAT(replace(pro.nombres,' ',''),trim(pro.apellidopaterno),trim(pro.apellidomaterno)))||'%';


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarconfiguracionservicio(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT idtiposervicio, muestraaerolinea, muestraempresatransporte, muestrahotel, 
       muestraproveedor, muestradescservicio, muestrafechaservicio, 
       muestrafecharegreso, muestracantidad, muestraprecio, muestradestino, 
       muestracomision, muestraoperador, muestratarifanegociada
  FROM soporte.""ConfiguracionTipoServicio""
 WHERE idestadoregistro = 1
   AND idtiposervicio   = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarconsolidador(p_idconsolidador integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, usuariocreacion, fechacreacion, ipcreacion, usuariomodificacion, 
       fechamodificacion, ipmodificacion
  FROM negocio.""Consolidador""
 WHERE idestadoregistro = 1
   AND id               = p_idconsolidador;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarcontactoxpersona(p_idpersona integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select per.id, per.idtipopersona, per.nombres, per.apellidopaterno, per.apellidomaterno, 
       per.idgenero, per.idestadocivil, per.idtipodocumento, per.numerodocumento
  from negocio.""PersonaContactoProveedor"" pcon,
       negocio.""Persona"" per
 where pcon.idestadoregistro = 1
   and per.idestadoregistro  = 1
   and per.idtipopersona     = 3
   and pcon.idcontacto       = per.id
   and pcon.idproveedor      = p_idpersona;


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarcronogramapago(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT nrocuota, idservicio, fechavencimiento, capital, interes, totalcuota, 
       idestadocuota, usuariocreacion, fechacreacion, ipcreacion, usuariomodificacion, 
       fechamodificacion, ipmodificacion, idestadoregistro
  FROM negocio.""CronogramaPago""
 where idservicio = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarcronogramaservicio(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
SELECT nrocuota, idservicio, fechavencimiento, capital, interes, totalcuota, 
       idestadocuota, usuariocreacion, fechacreacion, ipcreacion, usuariomodificacion, 
       fechamodificacion, ipmodificacion, idestadoregistro
  FROM negocio.""CronogramaPago""
 WHERE idservicio = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultardestino(p_iddestino integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT d.id, d.idcontinente, d.idpais, p.descripcion as descpais, d.codigoiata, d.idtipodestino, d.descripcion as descdestino, 
       d.usuariocreacion, d.fechacreacion, d.ipcreacion, d.usuariomodificacion, 
       d.fechamodificacion, d.ipmodificacion, p.abreviado
  FROM soporte.destino d,
       soporte.pais p
 WHERE d.idestadoregistro = 1
   AND d.id               = p_iddestino
   AND d.idpais           = p.id
   AND p.idestadoregistro = 1;


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarinvitadosnovios(p_idnovios integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT id, nombres, apellidopaterno, apellidomaterno, telefono, correoelectronico, 
       fecnacimiento
  FROM negocio.""Personapotencial""
 WHERE idnovios = p_idnovios;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarnovios(p_id integer, p_codnovios character varying, p_idnovia integer, p_idnovio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT snov.id, snov.codigonovios, novia.idtipodocumento as tipodocnovia, novia.numerodocumento as numdocnovia, 
       snov.idnovia, novia.nombres as nomnovia, novia.apellidopaterno as apepatnovia, novia.apellidomaterno as apematnovia,
       novio.idtipodocumento as tipodocnovio, novio.numerodocumento as numdocnovio, 
       snov.idnovio, novio.nombres as nomnovio, novio.apellidopaterno as apepatnovio, novio.apellidomaterno as apematnovio,
       snov.iddestino, dest.descripcion as descdestino, dest.codigoiata, pai.descripcion as descpais,
       snov.fechaboda, snov.fechaviaje, 
       snov.idmoneda, snov.cuotainicial, snov.dias, snov.noches, snov.fechashower, snov.observaciones, 
       snov.usuariocreacion, snov.fechacreacion, snov.ipcreacion, snov.usuariomodificacion, 
       snov.fechamodificacion, snov.ipmodificacion,
       (select count(1) from negocio.""Personapotencial"" where idnovios = snov.id) as cantidadInvitados, snov.idservicio,
       sercab.idvendedor, usu.nombres as nomvendedor, usu.apepaterno as apepatvendedor, usu.apematerno as apematvendedor,
       sercab.montocomisiontotal, sercab.montototal, sercab.montototalfee
  FROM negocio.""ProgramaNovios"" snov,
       negocio.""Persona"" novia,
       negocio.""Persona"" novio,
       soporte.destino dest,
       soporte.pais pai,
       negocio.""ServicioCabecera"" sercab,
       seguridad.usuario usu
 WHERE snov.idestadoregistro  = 1
   AND snov.id                = COALESCE(p_id,snov.id)
   AND novia.idestadoregistro = 1
   AND novia.idtipopersona    = 1
   AND novia.id               = snov.idnovia
   AND snov.idnovia           = COALESCE(p_idnovia,snov.idnovia)
   AND novio.idestadoregistro = 1
   AND novio.idtipopersona    = 1
   AND novio.id               = snov.idnovio
   AND snov.idnovio           = COALESCE(p_idnovio,snov.idnovio)
   AND dest.idestadoregistro  = 1
   AND dest.id                = snov.iddestino
   AND pai.idestadoregistro   = 1
   AND dest.idpais            = pai.id
   AND snov.idservicio        = sercab.id
   AND sercab.idvendedor      = usu.id;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarpersona(p_id integer, p_idtipopersona integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT pro.id, pro.nombres, pro.apellidopaterno, pro.apellidomaterno, 
    pro.idgenero, pro.idestadocivil, pro.idtipodocumento, pro.numerodocumento, 
    pro.usuariocreacion, pro.fechacreacion, pro.ipcreacion, ppro.idrubro, pro.fecnacimiento,
    pro.nropasaporte, pro.fecvctopasaporte
   FROM negocio.""Persona"" pro
   left join negocio.""PersonaAdicional"" ppro on ppro.idpersona = pro.id AND ppro.idestadoregistro = 1
  WHERE pro.idestadoregistro = 1 
    AND pro.idtipopersona = p_idtipopersona
    AND pro.id = p_id;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarpersonas(p_idtipopersona integer, p_idtipodocumento integer, p_numerodocumento character varying, p_nombres character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT pro.id AS idproveedor, tdoc.id AS idtipodocumento, 
       tdoc.nombre AS nombretipodocumento, pro.numerodocumento, pro.nombres, 
       pro.apellidopaterno, pro.apellidomaterno, 
       dir.idvia, tvia.nombre AS nombretipovia, 
       dir.nombrevia, dir.numero, dir.interior, dir.manzana, dir.lote, 
	    ( SELECT tel.numero
		FROM negocio.""TelefonoDireccion"" tedir, 
		     negocio.""Telefono"" tel
	       WHERE tedir.idestadoregistro = 1 
		 AND tel.idestadoregistro   = 1 
		 AND tedir.iddireccion      = dir.id 
		 AND tedir.idtelefono       = tel.id LIMIT 1) AS teledireccion
   FROM negocio.""Persona"" pro, 
        soporte.""Tablamaestra"" tdoc,
        negocio.""PersonaDireccion"" pdir
   LEFT JOIN negocio.""Direccion"" dir     ON pdir.iddireccion = dir.id AND dir.principal = 'S'
   LEFT JOIN soporte.""Tablamaestra"" tvia ON tvia.idmaestro  = 2       AND dir.idvia     = tvia.id
  WHERE pro.idestadoregistro  = 1 
    AND pro.idtipopersona     = 1
    AND tdoc.idmaestro        = 1 
    AND pro.idtipodocumento   = tdoc.id
    AND dir.idestadoregistro  = 1 
    AND pdir.idestadoregistro = 1 
    AND pro.id                = pdir.idpersona
    AND tdoc.id               = COALESCE(p_idtipodocumento,tdoc.id)
    AND pro.numerodocumento   = COALESCE(p_numerodocumento,pro.numerodocumento)
    AND CONCAT(replace(pro.nombres,' ',''),trim(pro.apellidopaterno),trim(pro.apellidomaterno)) like '%'||COALESCE(p_nombres,CONCAT(replace(pro.nombres,' ',''),trim(pro.apellidopaterno),trim(pro.apellidomaterno)))||'%';

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarpersonas2(p_idtipopersona integer, p_idtipodocumento integer, p_numerodocumento character varying, p_nombres character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT per.id, tdoc.id AS idtipodocumento, 
       tdoc.nombre AS nombretipodocumento, per.numerodocumento, per.nombres, 
       per.apellidopaterno, per.apellidomaterno, per.idgenero, 
       (case when per.idgenero='M' then 'MASCULINO'
        else 'FEMENINO' end) as genero, per.idestadocivil, estciv.nombre
   FROM soporte.""Tablamaestra"" tdoc,
        negocio.""Persona"" per
   LEFT JOIN soporte.""Tablamaestra"" estciv ON estciv.idmaestro = 9 AND estciv.id = per.idestadocivil
  WHERE per.idestadoregistro  = 1 
    AND per.idtipopersona     = 1
    AND tdoc.idmaestro        = 1 
    AND per.idtipodocumento   = tdoc.id
    AND tdoc.id               = COALESCE(p_idtipodocumento,tdoc.id)
    AND per.numerodocumento   = COALESCE(p_numerodocumento,per.numerodocumento)
    AND CONCAT(replace(per.nombres,' ',''),trim(per.apellidopaterno),trim(per.apellidomaterno)) like '%'||COALESCE(p_nombres,CONCAT(replace(per.nombres,' ',''),trim(per.apellidopaterno),trim(per.apellidomaterno)))||'%';


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarproveedorservicio(p_idproveedor integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT idproveedor, idtiposervicio, idproveedorservicio, porcencomnacional, porcencominternacional
  FROM negocio.""ProveedorTipoServicio""
 WHERE idproveedor = p_idproveedor;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarsaldosservicio(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT idsaldoservicio, idservicio, idpago, fechaservicio, montototalservicio, 
       montosaldoservicio
  FROM negocio.""SaldosServicio""
 WHERE idsaldoservicio = (SELECT max(idsaldoservicio)
                            FROM negocio.""SaldosServicio"" 
                           WHERE idservicio = p_idservicio);


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarservicio(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, idmaeserfee, pagaimpto, idmaeserimpto, cargacomision, esimpuesto, esfee, idparametroasociado, visible
  FROM negocio.""MaestroServicios""
 WHERE id = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarserviciodependientes(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT idservicio, idserviciodepende, ms.nombre, ms.visible
  FROM negocio.""ServicioMaestroServicio"" sms,
       negocio.""MaestroServicios"" ms
 WHERE sms.idestadoregistro  = 1
   AND sms.idservicio        = p_idservicio
   AND sms.idserviciodepende = ms.id
   AND ms.visible            = true;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarserviciodetallehijos(p_idservicio integer, p_idserviciopadre integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
SELECT serdet.id as idSerdetalle, serdet.idtiposervicio, 
       tipser.id, tipser.nombre as nomtipservicio, tipser.desccorta as descservicio, tipser.requierefee, 
       tipser.pagaimpto, tipser.cargacomision, tipser.esimpuesto, tipser.esfee,
       serdet.descripcionservicio, serdet.fechaida, serdet.fecharegreso, serdet.cantidad, 
       serdet.preciobase, serdet.porcencomision, serdet.montocomision, serdet.montototal, serdet.idproveedor, pro.nombres, pro.apellidopaterno, 
       pro.apellidomaterno
  FROM negocio.""ServicioDetalle"" serdet
 INNER JOIN negocio.""MaestroServicios"" tipser ON tipser.idestadoregistro = 1 AND tipser.id = serdet.idtiposervicio
  LEFT JOIN negocio.vw_proveedoresnova pro ON pro.id = serdet.idproveedor
 WHERE serdet.idestadoregistro = 1
   AND serdet.idservicio       = p_idservicio
   AND serdet.idservdetdepende = p_idserviciopadre;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarserviciosinvisibles(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for

select * 
  from negocio.""ServicioMaestroServicio"" sms
  inner join negocio.""MaestroServicios"" ms on sms.idserviciodepende = ms.id
   left join soporte.""Parametro"" par       on par.id                = ms.idparametroasociado
   and ms.visible            = false
 where sms.idservicio        = p_idservicio;

 return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarservicioventa(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select sercab.id, sercab.idcliente1, cli1.nombres as nombres1, cli1.apellidopaterno as apellidopaterno1, cli1.apellidomaterno as apellidomaterno1, 
       sercab.idcliente2, cli2.nombres as nombres2, cli2.apellidopaterno as apellidopaterno2, cli2.apellidomaterno as apellidomaterno2, 
       sercab.fechacompra, sercab.montototal, sercab.montocomisiontotal, sercab.montototaligv, sercab.montototalfee,
       sercab.idformapago, maemp.nombre as nommediopago, maemp.descripcion as descmediopago,
       sercab.idestadopago, maeep.nombre as nomestpago, maeep.descripcion as descestpago,
       sercab.nrocuotas, sercab.tea, sercab.valorcuota, sercab.fechaprimercuota, sercab.fechaultcuota, sercab.montocomisiontotal,
       usu.nombres as nombresvendedor, usu.apepaterno, usu.apematerno,
       sercab.usuariocreacion, sercab.fechacreacion, sercab.ipcreacion, 
       sercab.usuariomodificacion, sercab.fechamodificacion, sercab.ipmodificacion
  from negocio.""ServicioCabecera"" sercab 
 inner join negocio.vw_clientesnova cli1 on sercab.idcliente1 = cli1.id
 inner join soporte.""Tablamaestra"" maemp on maemp.estado = 'A' and maemp.idmaestro = 13 and maemp.id = sercab.idformapago
 inner join soporte.""Tablamaestra"" maeep on maeep.estado = 'A' and maeep.idmaestro = 14 and maeep.id = sercab.idestadopago
 inner join seguridad.usuario usu on usu.id = sercab.idvendedor
  left join negocio.vw_clientesnova cli2 on sercab.idcliente2 = cli2.id
 where sercab.idestadoregistro = 1
   and (select count(1) from negocio.""ServicioDetalle"" det where det.idservicio = sercab.id) > 0
   and sercab.id               = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarservicioventa(p_tipodocumento integer, p_numerodocumento character varying, p_nombres character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select sercab.id, sercab.idcliente1, cli1.nombres as nombres1, cli1.apellidopaterno as apellidopaterno1, cli1.apellidomaterno as apellidomaterno1, 
       sercab.idcliente2, cli2.nombres as nombres2, cli2.apellidopaterno as apellidopaterno2, cli2.apellidomaterno as apellidomaterno2, 
       sercab.fechacompra, sercab.montototal, 
       sercab.idformapago, maemp.nombre as nommediopago, maemp.descripcion as descmediopago,
       sercab.idestadopago, maeep.nombre as nomestpago, maeep.descripcion as descestpago, sercab.idestadoservicio, maest.nombre as nomestservicio,
       sercab.nrocuotas, sercab.tea, sercab.valorcuota, sercab.fechaprimercuota, sercab.fechaultcuota,
       sercab.usuariocreacion, sercab.fechacreacion, sercab.ipcreacion, 
       sercab.usuariomodificacion, sercab.fechamodificacion, sercab.ipmodificacion,
       (select count(1) from negocio.""ProgramaNovios"" where idservicio = sercab.id) as cantidadNovios
  from negocio.""ServicioCabecera"" sercab 
 inner join negocio.vw_clientesnova cli1 on sercab.idcliente1 = cli1.id
 inner join soporte.""Tablamaestra"" maemp on maemp.estado = 'A' and maemp.idmaestro = 13 and maemp.id = sercab.idformapago
 inner join soporte.""Tablamaestra"" maeep on maeep.estado = 'A' and maeep.idmaestro = 14 and maeep.id = sercab.idestadopago
 inner join soporte.""Tablamaestra"" maest on maest.estado = 'A' and maest.idmaestro = 15 and maest.id = sercab.idestadoservicio
  left join negocio.vw_clientesnova cli2 on sercab.idcliente2 = cli2.id
 where sercab.idestadoregistro = 1
 and (select count(1) from negocio.""ServicioDetalle"" det where det.idservicio = sercab.id) > 0
   and cli1.idtipodocumento    = COALESCE(p_tipodocumento,cli1.idtipodocumento)
   and cli1.numerodocumento    = COALESCE(p_numerodocumento,cli1.numerodocumento)
   and UPPER(CONCAT(replace(cli1.nombres,' ',''),trim(cli1.apellidopaterno),trim(cli1.apellidomaterno))) like UPPER('%'||COALESCE(p_nombres,CONCAT(trim(replace(cli1.nombres,' ','')),trim(cli1.apellidopaterno),trim(cli1.apellidomaterno)))||'%');
	
return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarservicioventadetalle(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
SELECT serdet.id as idSerdetalle, idtiposervicio, tipser.nombre as nomtipservicio, descripcionservicio, iddestino, 
       descripciondestino, dias, noches, fechaida, fecharegreso, cantidad, 
       preciobase, porcencomision, montocomision, montototal
  FROM negocio.""ServicioDetalle"" serdet,
       soporte.""Tablamaestra"" tipser
 WHERE serdet.idestadoregistro = 1
   AND tipser.idmaestro        = 12
   AND tipser.estado           = 'A'
   AND tipser.id               = serdet.idtiposervicio
   AND serdet.idservicio       = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_consultarservicioventadetalle(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
SELECT serdet.id as idSerdetalle, serdet.idtiposervicio, 
       tipser.id, tipser.nombre as nomtipservicio, tipser.desccorta as descservicio, tipser.requierefee, 
       tipser.pagaimpto, tipser.cargacomision, tipser.esimpuesto, tipser.esfee,
       serdet.descripcionservicio, serdet.fechaida, serdet.fecharegreso, serdet.cantidad, 
       serdet.preciobase, serdet.porcencomision, serdet.montocomision, serdet.montototal, serdet.idproveedor, pro.nombres, pro.apellidopaterno, 
       pro.apellidomaterno, tipser.visible
  FROM negocio.""ServicioDetalle"" serdet
 INNER JOIN negocio.""MaestroServicios"" tipser ON tipser.idestadoregistro = 1 AND tipser.id = serdet.idtiposervicio
  LEFT JOIN negocio.vw_proveedoresnova pro ON pro.id = serdet.idproveedor
 WHERE serdet.idestadoregistro = 1
   AND serdet.idservicio       = p_idservicio
   AND serdet.idservdetdepende is null;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_contar_registros(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	tabla alias for $1;
	consulta TEXT = 'select count(*) from ' || tabla;
	resultado integer;
begin
	execute consulta into resultado;
	return resultado;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_contar_registros(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
	tabla alias for $1;
	consulta TEXT = 'select count(*) from ' || tabla;
	resultado integer;
begin
	execute consulta into resultado;
	return resultado;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_correosxpersona(p_idpersona integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT id, correo, idpersona, usuariocreacion, fechacreacion, ipcreacion, 
       usuariomodificacion, fechamodificacion, ipmodificacion, idestadoregistro
  FROM negocio.""CorreoElectronico""
 WHERE idestadoregistro = 1
   AND idpersona        = p_idpersona;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_20130224.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_credenciales_sel(smallint, integer) RETURNS SETOF credenciales
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idc alias for $2;
begin
  if tip=0 then -- Consulta por id de credencial
    return query select * from credenciales where cre_id=idc;
  elsif tip=1 then -- Consulta de todas las credenciales
    return query select * from credenciales;
  end if;
end;
$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_20130224.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_credenciales_val(integer, integer) RETURNS smallint
    LANGUAGE plpgsql
    AS $_$
declare
  idc alias for $1;
  idu alias for $2;
  can int;
begin
  select count(*) into can from credenciales 
      where cre_id=idc and cre_idusuario=idu 
      and (select extract(epoch from (now()-cre_ultimaaccion))/60)<=(select valorparametro::integer from configuracion where parametro = 'TIEMPOCREDENCIAL' limit 1);
  return can;
end;
$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_departamentos_sel(smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF departamentos
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_iddepartamento alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	 consulta TEXT = 'select iddepartamento, codigo, nombre from departamentos';
begin
	inicio = limite * pagina - limite;
	if _tipo = 0 then -- Consulta todos los registros
		consulta = consulta;
	elsif _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where iddepartamento = ' || _iddepartamento;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir;
	if limite > 0 then
		consulta = consulta || ' limit ' || limite || ' offset ' || inicio;
	end if;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_desgrup(pcodgrup character) RETURNS character
    LANGUAGE plpgsql
    AS $$declare
vdesgrup character(50);
begin
select desgrup into vdesgrup 
from bvt001a
where codgrup = pcodgrup;
return vdesgrup;
end;$$;",tb%26fn_openbizviewpg.sql
"CREATE FUNCTION fn_direccionesxpersona(p_idpersona integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT dir.id, dir.idvia, dir.nombrevia, dir.numero, dir.interior, dir.manzana, 
       dir.lote, dir.principal, dir.idubigeo, dir.usuariocreacion, 
       dir.fechacreacion, dir.ipcreacion, dep.iddepartamento, 
       dep.descripcion AS departamento, pro.idprovincia, 
       pro.descripcion AS provincia, dis.iddistrito, dis.descripcion AS distrito, 
       pdir.idpersona, dir.observacion, dir.referencia
  FROM negocio.""Direccion"" dir, 
       negocio.""PersonaDireccion"" pdir, 
       soporte.ubigeo dep, 
       soporte.ubigeo pro, 
       soporte.ubigeo dis
 WHERE dir.idestadoregistro                  =  1 
   AND pdir.idestadoregistro                 =  1 
   AND dir.id                                =  pdir.iddireccion 
   AND substring(dir.idubigeo, 1, 2)||'0000' =  dep.id
   AND dep.iddepartamento                    <> '00'
   AND dep.idprovincia                       =  '00'
   AND dep.iddistrito                        =  '00'
   AND substring(dir.idubigeo, 1, 4)||'00'   =  pro.id
   AND pro.iddepartamento                    <> '00'
   AND pro.idprovincia                       <> '00'
   AND pro.iddistrito                        =  '00'
   AND dis.id::bpchar                        = dir.idubigeo
   AND pdir.idpersona                        = p_idpersona;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_estadocivil_sel(smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF estadocivil
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idestadocivil alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	 consulta TEXT = 'select idestadocivil, abreviatura, nombre from estadocivil';
begin
	inicio = limite * pagina - limite;
	if _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where idestadocivil = ' || _idestadocivil;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir;
	if limite > 0 then
		consulta = consulta || ' limit ' || limite || ' offset ' || inicio;
	end if;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_formatn(n integer, l integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare 
	res varchar(10);
begin
res := N::varchar(10);
while char_length(res) < L loop
  res := '0' || res;
end loop;  
return res;  
end;
$$;",pomanager.sql
"CREATE FUNCTION fn_generarcodigonovio(p_codigosnovios integer, p_usuario character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare cod_novio character varying(20);
declare fechaserie character varying(4);

Begin


select to_char(fecnacimiento,'ddMM')
  into fechaserie
  from seguridad.usuario
 where usuario = p_usuario;

cod_novio = fechaserie || p_codigosnovios;

return cod_novio;

end;
$$;",nova.backup
"CREATE FUNCTION fn_genero_sel(smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF genero
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idgenero alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	 consulta TEXT = 'select idgenero, sigla, genero from genero';
begin
	inicio = limite * pagina - limite;
	if _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where idgenero = ' || _idgenero;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir;
	if limite < 0 then
		consulta = consulta || ' limit ' || limite || ' offset ' || inicio;
	end if;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_get_id() RETURNS character varying
    LANGUAGE plpgsql COST 10
    AS $$       
	DECLARE
		id integer default nextval('utiles.seq_ids'::regclass);
		sigla character varying;
		
	BEGIN

		sigla = (select siglas from utiles.configuracion limit 1)||'-ACC-'||id;

		return sigla;
	


		
	END;
  $$;",salario.sql
"CREATE FUNCTION fn_get_miles_betwn_branch_locum_postcodes(branch_id integer, user_id text) RETURNS TABLE(miles text, upostcode character varying, bpostcode character varying, distance numeric)
    LANGUAGE plpgsql
    AS $_$
DECLARE
    pBranchId     ALIAS FOR $1 ;
    pUserId       ALIAS FOR $2 ;
BEGIN
    RETURN QUERY
				SELECT  TRIM(BOTH ' ' FROM 
							TO_CHAR(CASE
										WHEN brnPostCode.milesExempt <= 0 THEN 0
										ELSE CASE
												WHEN ((pstDst.distance * 2) > (brnPostCode.milesExempt * 2)) THEN
														 ((pstDst.distance * 2) - (brnPostCode.milesExempt * 2))
												ELSE 0
											 END
									 END, 'FM990.00')) AS miles
					   ,pstDst.from_postcode AS uPostCode
					   ,pstDst.to_postcode   AS bPostCode
					   ,pstDst.distance      AS distance
				FROM    locum_db.postcode_distance AS pstDst
					   ,(
						SELECT  addrDets.postcode AS post_code
						       ,usrDets.user_id   AS user_id
						FROM    locum_db.users AS usrDets
								INNER JOIN locum_db.address_details AS addrDets
								ON (addrDets.address_id = usrDets.address_id)
						) AS usrPostCode
					  , (
						SELECT  addrDets.postcode AS post_code
						       ,brnDets.branch_id AS branch_id
						       ,brnDets.miles_exempt_deduction AS milesExempt
						FROM    locum_db.branch_details as brnDets
								INNER JOIN locum_db.address_details AS addrDets
								ON (addrDets.address_id = brnDets.address_id)
						) AS brnPostCode
				WHERE   (
							(
							pstDst.from_postcode = usrPostCode.post_code
							AND
							pstDst.to_postcode = brnPostCode.post_code
							)
						OR
							(
							pstDst.to_postcode = usrPostCode.post_code
							AND
							pstDst.from_postcode = brnPostCode.post_code
							)
						)
				AND     usrPostCode.user_id   = pUserId
				AND     brnPostCode.branch_id = pBranchId
				;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION fn_get_outstanding_claims_for_locum(startdate date, enddate date, usertype character varying) RETURNS TABLE(event_date date, branchname text, rate numeric, hoursworked numeric, locumcost numeric, travelcost numeric, othertravel numeric, mur numeric, extraexp numeric, user_id character varying, locumname text, email character varying)
    LANGUAGE plpgsql
    AS $_$DECLARE
    dStartDate		ALIAS FOR $1 ;
    dEndDate		ALIAS FOR $2 ;
	szUserType		ALIAS FOR $3 ;
BEGIN
    RETURN QUERY	
	SELECT   CAST(ls.event_date AS DATE)               AS eventDate
		   , BranchDetails.branch_Name || ' (' || 
				ls.branch_id || ')'        AS branchName
		   , CAST(ls.rate AS NUMERIC)              AS rate
		   , CAST((
		           ROUND(TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
							  (ls.lch_end_time - ls.lch_start_time)
							 , 'HH24')
							 ,'99') +
				   (TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
							  (ls.lch_end_time - ls.lch_start_time)
							 , 'MI')
							 ,'99') / 0.59999999999999998)/100
				 ,2)
				 ) AS NUMERIC)    AS hoursWorked
		   , CAST((
                            ROUND(TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
								(ls.lch_end_time - ls.lch_start_time)
							   , 'HH24')
								   ,'99') +
					  (TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
								  (ls.lch_end_time - ls.lch_start_time)
							 , 'MI')
						  ,'99') / 0.59999999999999998)/100
										, 2) * ls.rate
			   )
                           AS NUMERIC)             AS locumCost
		   , CAST(ls.travel_cost AS NUMERIC)                AS travelCost
		   , CAST(ls.parking_expense AS NUMERIC)            AS otherTravel
		   , CAST(ls.mur_expense AS NUMERIC)                AS mur
		   , CAST(ls.extra_expense AS NUMERIC)              AS extraExp
	           , Users.user_id                 AS user_id
		   , locum_db.getusername('foreName',Users.user_id) AS  locumName
		   , Users.email                   AS email
	FROM     locum_db.locum_schedule_events      AS  ls
			 INNER JOIN locum_db.users           AS  Users
				ON (Users.user_id               = ls.user_id)
			 INNER JOIN locum_db.branch_details  AS BranchDetails
				ON (BranchDetails.branch_id     = ls.branch_id)
	WHERE    ls.event_date			BETWEEN dStartDate AND dEndDate
	AND      ls.status_flag			IN ('acc', 'con')
	AND      ls.rate				> 0
	AND      NOT EXISTS
			 (
						SELECT '1'
						FROM   locum_db.payment_details payDets
						WHERE  payDets.schedule_id = ls.id
			 )
	AND  'loc' = szUserType
	UNION
	SELECT   CAST(ls.event_date AS DATE)               AS eventDate
		   , BranchDetails.branch_Name || ' (' || 
				ls.branch_id || ')'        AS branchName
		   , CAST(ls.rate AS NUMERIC)              AS rate
		   , CAST((
		           ROUND(TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
							  (ls.lch_end_time - ls.lch_start_time)
							 , 'HH24')
							 ,'99') +
				   (TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
							  (ls.lch_end_time - ls.lch_start_time)
							 , 'MI')
							 ,'99') / 0.59999999999999998)/100
				 ,2)
				 ) AS NUMERIC)    AS hoursWorked
		   , CAST((
                            ROUND(TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
								(ls.lch_end_time - ls.lch_start_time)
							   , 'HH24')
								   ,'99') +
					  (TO_NUMBER(TO_CHAR((ls.cl_time - ls.op_time) -
								  (ls.lch_end_time - ls.lch_start_time)
							 , 'MI')
						  ,'99') / 0.59999999999999998)/100
										, 2) * ls.rate
			   )
                           AS NUMERIC)             AS locumCost
		   , CAST(ls.travel_cost AS NUMERIC)                AS travelCost
		   , CAST(ls.parking_expense AS NUMERIC)            AS otherTravel
		   , CAST(ls.mur_expense AS NUMERIC)                AS mur
		   , CAST(ls.extra_expense AS NUMERIC)              AS extraExp
	           , Users.user_id                 AS user_id
		   , locum_db.getusername('foreName',Users.user_id) AS  locumName
		   , Users.email                   AS email
	FROM     locum_db.dispenser_schedule_events      AS  ls
			 INNER JOIN locum_db.users           AS  Users
				ON (Users.user_id               = ls.user_id)
			 INNER JOIN locum_db.branch_details  AS BranchDetails
				ON (BranchDetails.branch_id     = ls.branch_id)
	WHERE    ls.event_date			BETWEEN dStartDate AND dEndDate
	AND      ls.status_flag         IN ('acc', 'con')
	AND      ls.rate                > 0
	AND      NOT EXISTS
			 (
					SELECT '1'
					FROM   locum_db.payment_details payDets
					WHERE  payDets.dispenser_id = ls.id
			 )
	AND  'dsp' = szUserType
	ORDER BY 11,1
	;			
	
END;$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION fn_get_vacancies_for_locum(startdate date, enddate date) RETURNS TABLE(user_id character varying, locumname text, email text, vacancydate text, branchname text, event_date date, comments character varying, op_time timestamp without time zone, cl_time timestamp without time zone, userpostcode character varying, brnpostcode character varying, distance numeric)
    LANGUAGE plpgsql
    AS $_$
DECLARE
    dStartDate     ALIAS FOR $1 ;
    dEndDate       ALIAS FOR $2 ;
BEGIN
    RETURN QUERY
    SELECT    locums.user_id
            , locums.locumname
            , locums.email
            , vacs.vacancyDate
            , vacs.branchName
            , CAST(vacs.event_date AS DATE) event_date
            , vacs.comments
            , vacs.op_time
            , vacs.cl_time
            , userPostCode
            , brnPostCode
            , CAST(locum_db.getmilesforpostcodes(userPostCode, brnPostCode) AS NUMERIC) AS distance 
    FROM
            (
                SELECT 	  to_char(vacDets.event_date, 'Dy fmdd Mon, yyyy')          AS vacancyDate
                                , branchDetail.branch_Name || ' (' || 
                                    branchDetail.branch_id || ')'                   AS branchName
                                , vacDets.num_of_vacancies - COALESCE(c.vacCnt, 0)  AS nvacancy
                                , vacDets.event_date                                AS event_date 
                                , vacDets.description                               AS comments
                                , vacDets.op_time                                   AS op_time
                                , vacDets.cl_time                                   AS cl_time
                                , CASE locEvt.day_type
                                        WHEN 'AM' THEN 'PM'
                                        WHEN 'PM' THEN 'AM'
                                        ELSE vacDets.day_type
                                    END                                             AS evt_dayType
                                , addrDets.postcode                                 AS brn_Post_Code
                FROM    locum_db.vacancy_details                                    AS vacDets
                        JOIN locum_db.branch_details                                AS  branchDetail
                        ON (branchDetail.branch_id = vacDets.branch_id)
                        INNER JOIN  locum_db.Address_Details                        AS addrDets 
                        ON ( addrDets.address_id = branchDetail.address_id ) 
                        LEFT OUTER JOIN (SELECT   x.vacancy_id
                                        , SUM(CASE upper(x.day_type)
                                                        WHEN 'FULL' THEN 1
                                                        WHEN 'AM' THEN 0.5
                                                        WHEN 'PM' THEN 0.5
                                                        ELSE 1
                                                        END ) AS vacCnt
                                    FROM    locum_db.locum_schedule_events AS x
                                    WHERE   x.status_flag IN ('acc','con','app','pay','par')
                                    GROUP BY x.vacancy_id ) AS c
                        ON (c.vacancy_id   = vacDets.id )
                        LEFT OUTER JOIN locum_db.locum_schedule_events  AS locEvt
                        ON (locEvt.vacancy_id = vacDets.id AND locEvt.status_flag != 'rej')
                WHERE   current_date BETWEEN COALESCE(branchDetail.start_date,current_date) AND COALESCE(branchDetail.end_date,current_date)
                AND     (CASE vacDets.day_type
                                    WHEN 'Full' THEN vacDets.num_of_vacancies
                                    ELSE vacDets.num_of_vacancies - 0.5
                                    END
                                ) > COALESCE(c.vacCnt, 0)
            ) AS vacs
        ,(
                SELECT  DISTINCT 
                        b.user_id
                       ,TRIM(BOTH ' ' FROM COALESCE(b.title, '') || ' ' || b.fore_name || ' ' || 
                                COALESCE(b.last_name, '')) AS locumName
                       ,LOWER(b.email) as email
                       ,addrDets.postcode AS user_Post_Code 
                FROM    locum_db.locum_schedule_events a
                        INNER JOIN locum_db.users b 
                        ON (b.user_id = a.user_id
                            AND  b.user_type = 'loc'
                            AND  COALESCE(b.expiry_Date, current_date) >= current_date
                           )
                        INNER JOIN locum_db.address_details AS addrDets
                        ON (addrDets.address_id = b.address_id)                                        
                WHERE   a.status_flag     IN ('app', 'acc', 'rej', 'con', 'pay', 'can')
                AND     a.event_date BETWEEN current_date - interval '12 month' AND current_date
                AND     b.user_type        = 'loc'
                AND     EXISTS (SELECT '1'
                                FROM   locum_db.branch_details c
                                WHERE  c.branch_id = a.branch_id
                               )
                AND     LOWER(b.email) NOT LIKE LOWER('abc@%') 
                AND     LOWER(b.email) NOT LIKE LOWER('info@%') 
                AND     LOWER(b.email) NOT LIKE LOWER('%@%xx%') 
                AND     LOWER(b.email) NOT LIKE LOWER('%@manichem.co%') 
            ) AS locums
    WHERE   vacs.event_date BETWEEN dStartDate AND dEndDate	
    AND     NOT EXISTS
                    (
                        SELECT  '1'
                        FROM    locum_db.locum_schedule_events  AS locEvt
                        WHERE   locEvt.event_date   = vacs.event_date
                        AND     locEvt.user_id      = locums.user_id
                        AND     locEvt.status_flag IN ('acc', 'con', 'rej')
                    )
    ORDER BY 2, event_date, 5
    ;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION fn_getpropertvalue(property character varying, mode character varying, faclid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$


declare


  --  a text[]; 


    --i int;


    prop_val varchar(128);


begin


if mode = 'settemp' then


	BEGIN


--	RETURN QUERY


	Select  Case 	when	property = '1' then a3a 


			when	property = '2' then a3b


			--when	property = '3' then a3


			when	property = '4' then a3c


			when	property = '5' then a3d


			when	property in ('0','7')then a3


		END 


	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;


	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;


	END;


END IF;


if mode = 'fanspeed' then


	BEGIN


	Select  Case 	when	property = '1' then a6a 


			when	property = '2' then a6b


			when	property = '3' then a6e


			when	property = '4' then a6c


			when	property = '5' then a6d


			when	property in ('0','7')then a6


		END 


	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;


	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;


	END;


END if;


if mode = 'winddirection' then


	BEGIN


	Select  Case 	when	property = '1' then a7a 


			when	property = '2' then a7b


			when	property = '3' then a7e


			when	property = '4' then a7c


			when	property = '5' then a7d


			when	property in ('0','7')then a7


		END 


	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;


	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;


	END;


END if;


      return prop_val  as propval;       


end


$$;",b2bac_final_12.11.15-preST-AWS.sql
"CREATE FUNCTION fn_getpropertvalue(property character varying, mode character varying, faclid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare

  --  a text[]; 

    --i int;

    prop_val varchar(128);

begin

if mode = 'settemp' then

	BEGIN

--	RETURN QUERY

	Select  Case 	when	property = '1' then a3a 

			when	property = '2' then a3b

			--when	property = '3' then a3

			when	property = '4' then a3c

			when	property = '5' then a3d

			when	property in ('0','7')then a3

		END 

	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;

	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;

	END;

END IF;

if mode = 'fanspeed' then

	BEGIN

	Select  Case 	when	property = '1' then a6a 

			when	property = '2' then a6b

			when	property = '3' then a6e

			when	property = '4' then a6c

			when	property = '5' then a6d

			when	property in ('0','7')then a6

		END 

	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;

	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;

	END;

END if;

if mode = 'winddirection' then

	BEGIN

	Select  Case 	when	property = '1' then a7a 

			when	property = '2' then a7b

			when	property = '3' then a7e

			when	property = '4' then a7c

			when	property = '5' then a7d

			when	property in ('0','7')then a7

		END 

	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;

	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;

	END;

END if;

      return prop_val  as propval;       

end$$;",b2bac_schema_only.sql
"CREATE FUNCTION fn_getpropertvalue(property character varying, mode character varying, faclid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare
  --  a text[]; 
    --i int;
    prop_val varchar(128);
begin
if mode = 'settemp' then
	BEGIN
--	RETURN QUERY
	Select  Case 	when	property = '1' then a3a 
			when	property = '2' then a3b
			--when	property = '3' then a3
			when	property = '4' then a3c
			when	property = '5' then a3d
			when	property in ('0','7')then a3
			
		END 
	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;
	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;
	END;
END IF;
if mode = 'fanspeed' then
	BEGIN
	Select  Case 	when	property = '1' then a6a 
			when	property = '2' then a6b
			when	property = '3' then a6e
			when	property = '4' then a6c
			when	property = '5' then a6d
			when	property in ('0','7')then a6
					
		END 
	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;
	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;
	END;
END if;

if mode = 'winddirection' then
	BEGIN
	Select  Case 	when	property = '1' then a7a 
			when	property = '2' then a7b
			when	property = '3' then a7e
			when	property = '4' then a7c
			when	property = '5' then a7d
			when	property in ('0','7')then a7
					
		END 
	from ct_statusinfo where a2 = property and facl_id = faclid into prop_val;
	--RAISE NOTICE 'Calling csww_create_job(%)', prop_val;
	END;
END if;

      return prop_val  as propval;       
end$$;",b2bac_schema.sql
"CREATE FUNCTION fn_hojadevida_sel(smallint, integer, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF t_hojadevida
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idhojadevida alias for $2; -- Id de la tabla
	pagina alias for $3;
	limite alias for $4;
	colind alias for $5;
	coldir alias for $6;
	inicio integer;
	consulta TEXT = 'select h.idhojadevida, h.idtipodedocumento, t.tipodedocumento, h.numerodocumento, h.primerapellido, h.segundoapellido, h.nombres,
				h.idgenero, g.genero, h.libretamilitar, h.distritolm, h.lugarnacimiento as idlugarnacimiento, m.nombre as lugardenacimiento,
				h.lugarexpediciond, me.nombre as lugardeexpedicion, h.lugarresidencia as idlugarresidencia, mr.nombre as lugarderesidencia, h.fechanacimiento,
				h.fechaexpediciond, h.idestadocivil, e.nombre as estadocivil, h.disponibilidadviaje, h.direccion, h.telefono, h.correo, h.foto
			from hojadevida as h inner join tiposdedocumento as t on h.idtipodedocumento = t.idtipodedocumento inner join
				genero as g on h.idgenero = g.idgenero inner join municipios as m on
				h.lugarnacimiento = m.idmunicipio inner join municipios as me on h.lugarexpediciond = me.idmunicipio inner join municipios as mr on
				h.lugarresidencia = mr.idmunicipio inner join estadocivil as e on h.idestadocivil = e.idestadocivil';
begin
	inicio = limite * pagina - limite;
	if _tipo = 1 then -- Consulta por el id de la tabla
		consulta = consulta || ' where idhojadevida = ' || _idhojadevida;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir;
	if limite > 0 then
		consulta = consulta || ' limit ' || limite || ' offset ' || inicio;
	end if;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_iniciosesion(p_usuario character varying, p_credencial character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

declare cantidad integer;

begin

cantidad = 0;

select count(1)
  into cantidad
  from seguridad.usuario usr
 where upper(usr.usuario) = p_usuario
   and usr.credencial     = p_credencial;

if cantidad = 1 then
   return true;
else
   return false;
end if;

exception
when others then
  return false;

end;
$$;",nova.backup
"CREATE FUNCTION fn_iniciosesion(p_usuario character varying, p_credencial character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

declare cantidad integer;

begin

cantidad = 0;

select count(1)
  into cantidad
  from seguridad.usuario usr
 where usr.usuario    = p_usuario
   and usr.credencial = p_credencial;

if cantidad = 1 then
   return true;
else
   return false;
end if;

exception
when others then
  return false;

end;

$$;",bd.backup
"CREATE FUNCTION fn_is_client_available(p_no_client_id character varying) RETURNS sistema.tp_resultado
    LANGUAGE plpgsql
    AS $$
DECLARE
   v_va_return sistema.tp_resultado%rowtype;
   v_il_client_available INTEGER := 0;
   v_msg_client_available CHARACTER VARYING := 'El recurso no est� disponible.';
BEGIN
   SELECT 
      count( * )
   FROM 
      oauth.tb_client_details cd
   INTO
      v_il_client_available
   WHERE
      cd.no_client_id = p_no_client_id;

   IF v_il_client_available = 1 THEN
      v_msg_client_available := 'El recurso est� disponible.';
   END IF;

   v_va_return.id_resulta := v_il_client_available;
   v_va_return.no_mensaje := v_msg_client_available;

   RETURN v_va_return;         
END
$$;",BD_GENERAL.sql
"CREATE FUNCTION fn_listarclientescorreo() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select cli.id as idcliente, cli.nombres as nomcliente, cli.apellidopaterno as apepatcliente, cli.apellidomaterno as apematcliente, 
       con.id as idcontacto, con.nombres as nomcontacto, con.apellidopaterno as apepatcontacto, con.apellidomaterno as apematcontacto,
       cor.correo, cor.recibirpromociones
  from negocio.vw_clientesnova cli,
       negocio.""PersonaContactoProveedor"" pccli,
       negocio.vw_consultacontacto con,
       negocio.""CorreoElectronico"" cor
 where cli.id                 = pccli.idproveedor
   and pccli.idestadoregistro = 1
   and pccli.idcontacto       = con.id
   and cor.idpersona          = con.id
   and cor.correo             is not null
   and cor.correo             <> '';

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarclientescumples() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
select * 
  from negocio.vw_clientesnova
 where to_char(fecnacimiento,'ddMM') = to_char(current_date,'ddMM');

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarconsolidadores() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, usuariocreacion, fechacreacion, ipcreacion, usuariomodificacion, 
       fechamodificacion, ipmodificacion
  FROM negocio.""Consolidador""
 WHERE idestadoregistro = 1;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listardestinos() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT des.id, des.idcontinente, cont.nombre as nombrecontinente, idpais, pai.descripcion as nombrepais, codigoiata, idtipodestino, tipdes.nombre as nombretipdestino, des.descripcion, 
       des.usuariocreacion, des.fechacreacion, des.ipcreacion, des.usuariomodificacion, 
       des.fechamodificacion, des.ipmodificacion, des.idestadoregistro, pai.abreviado
  FROM soporte.destino des,
       soporte.""Tablamaestra"" cont,
       soporte.""Tablamaestra"" tipdes,
       soporte.pais pai       
 WHERE des.idestadoregistro = 1
   AND cont.idmaestro       = 10
   AND cont.estado          = 'A'
   AND cont.id              = des.idcontinente
   AND pai.idestadoregistro = 1
   AND pai.id               = des.idpais
   AND tipdes.idmaestro     = 11
   AND tipdes.estado        = 'A'
   AND tipdes.id            = des.idtipodestino;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarmaestroservicios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, pagaimpto, cargacomision
  FROM negocio.""MaestroServicios""
 WHERE visible          = true
   AND idestadoregistro = 1;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarmaestroserviciosadm() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, pagaimpto, cargacomision
  FROM negocio.""MaestroServicios""
 WHERE idestadoregistro = 1;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarmaestroserviciosfee() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, pagaimpto, cargacomision
  FROM negocio.""MaestroServicios""
 WHERE idestadoregistro = 1
   AND esfee            = TRUE;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarmaestroserviciosigv() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, pagaimpto, cargacomision
  FROM negocio.""MaestroServicios""
 WHERE idestadoregistro = 1
   AND esimpuesto       = TRUE;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarmaestroserviciosimpto() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT id, nombre, desccorta, desclarga, requierefee, pagaimpto, cargacomision
  FROM negocio.""MaestroServicios""
 WHERE idestadoregistro = 1
   AND esimpuesto       = TRUE;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarpagos(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

declare micursor refcursor;

begin

open micursor for
SELECT idpago, idservicio, fechapago, montopagado, sustentopago, usuariocreacion, 
       fechacreacion, ipcreacion, usuariomodificacion, fechamodificacion, 
       ipmodificacion
  FROM negocio.""PagosServicio""
 WHERE idestadoregistro = 1
   AND idservicio       = p_idservicio
 ORDER BY idpago DESC;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarpaises(p_idcontinente integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT id, descripcion, idcontinente, usuariocreacion, fechacreacion, 
       ipcreacion, usuariomodificacion, fechamodificacion, ipmodificacion, 
       idestadoregistro
  FROM soporte.pais
 WHERE idcontinente = p_idcontinente;


return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_listarusuarios() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
select * from seguridad.usuario;

return micursor;

end;$$;",nova.backup
"CREATE FUNCTION fn_listarusuarios() RETURNS void
    LANGUAGE plpgsql
    AS $$

begin

select * from seguridad.usuario;

end;$$;",bd.backup
"CREATE FUNCTION fn_listarvendedores() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin
open micursor for
select * 
  from seguridad.usuario u
 where u.vendedor = true;

return micursor;

end;$$;",nova.backup
"CREATE FUNCTION fn_municipios_sel(smallint, smallint, smallint, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF t_municipio
    LANGUAGE plpgsql
    AS $_$
declare
	_tipo alias for $1; -- Tipo de busqueda
	_idmunicipio alias for $2; -- Id de la tabla
	_iddepartamento alias for $3; -- Id del departamento
	pagina alias for $4;
	limite alias for $5;
	colind alias for $6;
	coldir alias for $7;
	inicio integer;
	consulta TEXT = 'select m.iddepartamento, d.codigo as codigodepto, d.nombre as departamento, m.idmunicipio, m.codigo, m.nombre as municipio from municipios as m inner join departamentos as d on m.iddepartamento = d.iddepartamento';
begin
	inicio = limite * pagina - limite;
	if _tipo = 1 then -- Consulta por el id del municipio
		consulta = consulta || ' where m.idmunicipio = ' || _idmunicipio;
	elsif _tipo = 2 then -- Consulta por el id del departamento
		consulta = consulta || ' where m.iddepartamento = ' || _iddepartamento;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir;
	if limite > 0 then -- Si se limitan los registros
		consulta = consulta || ' limit ' || limite || ' offset ' || inicio;
	end if;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_20130224.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_objetos_sel(smallint, character varying, character varying, boolean) RETURNS SETOF objetos
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	cod alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Consulta por codigo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_codigo=cod;
	elsif tip=1 then -- Conslta por nombre
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_nombre like nom;
	elsif tip=2 then -- Consulta por activo
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos where obj_activo=act;
	elsif tip=3 then -- Consulta de todos los registros
		return query select obj_codigo, obj_nombre, obj_descripcion, obj_activo from objetos;
	end if;
end;
$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_20130224.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_perfiles_sel(smallint, smallint, character varying, boolean) RETURNS SETOF perfiles
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idp alias for $2;
	nom alias for $3;
	act alias for $4;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idperfil, nombre, activo from perfiles;
	elsif tip=1 then -- Si el tipo de consulta es por idperfil
		return query select idperfil, nombre, activo from perfiles where idperfil=idp;
	elsif tip=2 then -- Si el tipo de consulta es por nombre del perfil
		return query select idperfil, nombre, activo from perfiles where nombre like nom;
	elsif tip=3 then -- Si el tipo de consulta es por si esta activo o no
		return query select idperfil, nombre, activo from perfiles where activo = act;
	end if;
end;$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_proveedorxservicio(p_idservicio integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT per.id, per.nombres, proser.porcencomnacional, proser.porcencominternacional
  FROM negocio.""Persona"" per,
       negocio.""ProveedorTipoServicio"" proser
 WHERE per.idestadoregistro    = 1 
   AND proser.idestadoregistro = 1 
   AND per.idtipopersona       = 2
   AND per.id                  = proser.idproveedor
   AND proser.idtiposervicio   = p_idservicio;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_split(parstring text, sep character varying, OUT nn integer, OUT id text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
   str text[];  
   n int;
BEGIN
   str := regexp_split_to_array(ParString, Sep);
   n := array_length(str, 1);
   FOR i IN 1..n LOOP
      NN := i;
      ID := str[i];
      RETURN NEXT;
   END LOOP;
END;
$$;",pomanager.sql
"CREATE FUNCTION fn_telefonosxdireccion(p_iddireccion integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT tel.id, tel.numero, tel.idempresaproveedor, tel.usuariocreacion, tel.fechacreacion, 
       tel.ipcreacion, tel.usuariomodificacion, tel.fechamodificacion, tel.ipmodificacion
  FROM negocio.""TelefonoDireccion"" tdir,
       negocio.""Telefono"" tel
 WHERE tdir.idestadoregistro = 1
   AND tel.idestadoregistro  = 1
   AND tdir.idtelefono       = tel.id
   AND tdir.iddireccion      = p_iddireccion;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_telefonosxpersona(p_idpersona integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare micursor refcursor;

begin

open micursor for
SELECT tel.id, tel.numero, tel.idempresaproveedor, tel.usuariocreacion, tel.fechacreacion, 
       tel.ipcreacion, tel.usuariomodificacion, tel.fechamodificacion, tel.ipmodificacion
  FROM negocio.""TelefonoPersona"" tper,
       negocio.""Telefono"" tel
 WHERE tper.idestadoregistro = 1
   AND tel.idestadoregistro  = 1
   AND tper.idtelefono       = tel.id
   AND tper.idpersona        = p_idpersona;

return micursor;

end;
$$;",nova.backup
"CREATE FUNCTION fn_tiposdedocumento_sel(smallint, smallint, character varying, character varying, boolean) RETURNS SETOF tiposdedocumento
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idt alias for $2;
	abr alias for $3;
	nom alias for $4;
	act alias for $5;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento;
	elsif tip=1 then -- Si el tipo de consulta es por idtipodedocumento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where idtipodedocumento=idt;
	elsif tip=2 then -- Si el tipo de consulta es por abreviatura del tipodedocumento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where abreviatura like abr;
	elsif tip=3 then -- Si el tipo de consulta es por el nombre del tipo de documento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where tipodedocumento like nom;
	elsif tip=4 then -- Si el tipo de consulta es por activo
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where activo = act;
	end if;
end;$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_tiposdedocumento_sel(smallint, smallint, character varying, character varying, boolean) RETURNS SETOF tiposdedocumento
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idt alias for $2;
	abr alias for $3;
	nom alias for $4;
	act alias for $5;
begin
	if tip=0 then -- Si el tipo de consulta es todos
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento;
	elsif tip=1 then -- Si el tipo de consulta es por idtipodedocumento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where idtipodedocumento=idt;
	elsif tip=2 then -- Si el tipo de consulta es por abreviatura del tipodedocumento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where abreviatura like abr;
	elsif tip=3 then -- Si el tipo de consulta es por el nombre del tipo de documento
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where tipodedocumento like nom;
	elsif tip=4 then -- Si el tipo de consulta es por activo
		return query select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento where activo = act;
	end if;
end;$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_tiposdedocumento_sel(smallint, smallint, character varying, character varying, boolean, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF tiposdedocumento
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idt alias for $2;
	abr alias for $3;
	nom alias for $4;
	act alias for $5;
	pagina alias for $6;
	limite alias for $7;
	colind alias for $8;
	coldir alias for $9;
	inicio integer;
	consulta TEXT = 'select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento';
begin
	inicio = limite * pagina - limite;
	if tip=0 then -- Si el tipo de consulta es todos
		consulta = consulta;
	elsif tip=1 then -- Si el tipo de consulta es por idtipodedocumento
		consulta = consulta || ' where idtipodedocumento = ' || idt;
	elsif tip=2 then -- Si el tipo de consulta es por abreviatura del tipodedocumento
		consulta = consulta || ' where abreviatura like ' || quote_literal(abr);
	elsif tip=3 then -- Si el tipo de consulta es por el nombre del tipo de documento
		consulta = consulta || ' where tipodedocumento like ' || quote_literal(nom);
	elsif tip=4 then -- Si el tipo de consulta es por activo
		consulta = consulta || ' where activo = ' || act;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir || ' limit ' || limite || ' offset ' || inicio;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_tiposdedocumento_sel(smallint, smallint, character varying, character varying, boolean, integer DEFAULT 1, integer DEFAULT 5, integer DEFAULT 1, character varying DEFAULT 'asc'::character varying) RETURNS SETOF tiposdedocumento
    LANGUAGE plpgsql
    AS $_$
declare
	tip alias for $1;
	idt alias for $2;
	abr alias for $3;
	nom alias for $4;
	act alias for $5;
	pagina alias for $6;
	limite alias for $7;
	colind alias for $8;
	coldir alias for $9;
	inicio integer;
	consulta TEXT = 'select idtipodedocumento, abreviatura, tipodedocumento, activo from tiposdedocumento';
begin
	inicio = limite * pagina - limite;
	if tip=0 then -- Si el tipo de consulta es todos
		consulta = consulta;
	elsif tip=1 then -- Si el tipo de consulta es por idtipodedocumento
		consulta = consulta || ' where idtipodedocumento = ' || idt;
	elsif tip=2 then -- Si el tipo de consulta es por abreviatura del tipodedocumento
		consulta = consulta || ' where abreviatura like ' || quote_literal(abr);
	elsif tip=3 then -- Si el tipo de consulta es por el nombre del tipo de documento
		consulta = consulta || ' where tipodedocumento like ' || quote_literal(nom);
	elsif tip=4 then -- Si el tipo de consulta es por activo
		consulta = consulta || ' where activo = ' || act;
	end if;
	consulta = consulta || ' order by ' || colind || ' ' || coldir || ' limit ' || limite || ' offset ' || inicio;
	return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || cod;
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || nom;
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || ape;
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || cor;
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || ide;
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || fcr;
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || fcr;
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || fcr;
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || ing;
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || ing;
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || ing;
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || fbl;
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || fbl;
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || fbl;
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || fdb;
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || fdb;
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || fdb;
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || cod || ' and usu_clave = ' || cla;
  end if;
  return query execute consulta;
end;
$_$;",Backup_20130407.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod);
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || quote_literal(nom);
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || quote_literal(ape);
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || quote_literal(cor);
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || quote_literal(ide);
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || quote_literal(fcr);
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || quote_literal(fcr);
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || quote_literal(fcr);
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || quote_literal(ing);
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || quote_literal(ing);
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || quote_literal(ing);
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || quote_literal(fbl);
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || quote_literal(fbl);
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || quote_literal(fbl);
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || quote_literal(fdb);
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || quote_literal(fdb);
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || quote_literal(fdb);
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod) || ' and usu_clave = ' || quote_literal(cla);
  end if;
  return query execute consulta;
end;
$_$;",Backup_20130413.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod);
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || quote_literal(nom);
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || quote_literal(ape);
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || quote_literal(cor);
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || quote_literal(ide);
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || quote_literal(fcr);
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || quote_literal(fcr);
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || quote_literal(fcr);
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || quote_literal(ing);
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || quote_literal(ing);
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || quote_literal(ing);
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || quote_literal(fbl);
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || quote_literal(fbl);
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || quote_literal(fbl);
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || quote_literal(fdb);
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || quote_literal(fdb);
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || quote_literal(fdb);
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod) || ' and usu_clave = ' || quote_literal(cla);
  end if;
  return query execute consulta;
end;
$_$;",Backup_20131209.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod);
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || quote_literal(nom);
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || quote_literal(ape);
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || quote_literal(cor);
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || quote_literal(ide);
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || quote_literal(fcr);
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || quote_literal(fcr);
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || quote_literal(fcr);
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || quote_literal(ing);
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || quote_literal(ing);
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || quote_literal(ing);
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || quote_literal(fbl);
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || quote_literal(fbl);
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || quote_literal(fbl);
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || quote_literal(fdb);
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || quote_literal(fdb);
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || quote_literal(fdb);
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod) || ' and usu_clave = ' || quote_literal(cla);
  end if;
  return query execute consulta;
end;
$_$;",Backup_GRH_20140414.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod);
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || quote_literal(nom);
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || quote_literal(ape);
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || quote_literal(cor);
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || quote_literal(ide);
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || quote_literal(fcr);
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || quote_literal(fcr);
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || quote_literal(fcr);
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || quote_literal(ing);
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || quote_literal(ing);
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || quote_literal(ing);
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || quote_literal(fbl);
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || quote_literal(fbl);
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || quote_literal(fbl);
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || quote_literal(fdb);
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || quote_literal(fdb);
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || quote_literal(fdb);
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod) || ' and usu_clave = ' || quote_literal(cla);
  end if;
  return query execute consulta;
end;
$_$;",Backup_GRH_20140418.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, date DEFAULT NULL::date, date DEFAULT NULL::date, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1; -- Tipo de busqueda
  idu alias for $2; -- Id del usuario
  cod alias for $3; -- Codigo
  nom alias for $4; -- Nombres
  ape alias for $5; -- Apellidos
  cor alias for $6; -- Correo
  ide alias for $7; -- Identificacion
  per alias for $8; -- Codigo Perfil
  ccl alias for $9; -- Cambio de clave
  fcr alias for $10; -- Fecha de creacion
  ing alias for $11; -- Fecha de ultimo ingreso
  blo alias for $12; -- Bloqueado
  fbl alias for $13; -- Fecha de bloqueado
  fdb alias for $14; -- Fecha de desbloqueo
  cla alias for $15; -- Clave
  consulta TEXT = 'select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_correo, usu_identificacion, usu_perfil, perfiles.nombre, perfiles.activo, usu_cambiarclave, usu_fechacreacion, usu_ultimoingreso, usu_bloqueado, usu_fechabloqueado, usu_fechadesbloqueado from usuarios inner join perfiles on usu_perfil=idperfil';
begin
  if tip=0 then -- Consulta de todos los registros
    consulta = consulta;
  elsif tip=1 then -- Consulta por id de usuario
    consulta = consulta || ' where usu_id = ' || idu;
  elsif tip=2 then -- Consulta por codigo de usuario
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod);
  elsif tip=3 then -- Consulta por nombre de usuario
    consulta = consulta || ' where usu_nombres like ' || quote_literal(nom);
  elsif tip=4 then -- Consulta por apellido de usuario
    consulta = consulta || ' where usu_apellidos like ' || quote_literal(ape);
  elsif tip=5 then -- Consulta por correo
    consulta = consulta || ' where usu_correo like ' || quote_literal(cor);
  elsif tip=6 then -- Consulta por identificacion
    consulta = consulta || ' where usu_identificacion = ' || quote_literal(ide);
  elsif tip=7 then -- Consulta por perfil de usuario
    consulta = consulta || ' where usu_perfil = ' || per;
  elsif tip=8 then -- Consulta por perfil activo o no
    consulta = consulta || ' where perfiles.activo = ' || blo;
  elsif tip=9 then -- Consulta por cambio de clave
    consulta = consulta || ' where usu_cambiarclave = ' || ccl;
  elsif tip=10 then -- Consulta por fecha de creacion exacta
    consulta = consulta || ' where date(usu_fechacreacion) = ' || quote_literal(fcr);
  elsif tip=11 then -- Consulta por fecha de creacion menor o igual a
    consulta = consulta || ' where date(usu_fechacreacion) <= ' || quote_literal(fcr);
  elsif tip=12 then -- Consulta por fecha de creacion mayor o igual
    consulta = consulta || ' where date(usu_fechacreacion) >= ' || quote_literal(fcr);
  elsif tip=13 then -- Consulta por fecha de ingreso exacta
    consulta = consulta || ' where date(usu_ultimoingreso) = ' || quote_literal(ing);
  elsif tip=14 then -- Consulta por fecha de ingreso menor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) <= ' || quote_literal(ing);
  elsif tip=15 then -- Consulta por fecha de ingreso mayor o igual a
    consulta = consulta || ' where date(usu_ultimoingreso) >= ' || quote_literal(ing);
  elsif tip=16 then -- Consulta por bloqueado
    consulta = consulta || ' where usu_bloqueado = ' || blo;
  elsif tip=17 then -- Consulta de fecha de bloqueo exacta
    consulta = consulta || ' where date(usu_fechabloqueado) = ' || quote_literal(fbl);
  elsif tip=18 then -- Consulta de fecha de bloqueo menor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) <= ' || quote_literal(fbl);
  elsif tip=19 then -- Consulta de fecha de bloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechabloqueado) >= ' || quote_literal(fbl);
  elsif tip=20 then -- Consulta de fecha de desbloqueo exacta
    consulta = consulta || ' where date(usu_fechadesbloqueado) = ' || quote_literal(fdb);
  elsif tip=21 then -- Consulta de fecha de desbloqueo menor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) <= ' || quote_literal(fdb);
  elsif tip=22 then -- Consulta de fecha de desbloqueo mayor o igual
    consulta = consulta || ' where date(usu_fechadesbloqueado) >= ' || quote_literal(fdb);
  elsif tip=23 then -- Consulta de autenticacion
    consulta = consulta || ' where usu_codigo = ' || quote_literal(cod) || ' and usu_clave = ' || quote_literal(cla);
  end if;
  return query execute consulta;
end;
$_$;",Backup_Tampa.backup
"CREATE FUNCTION fn_usuarios_sel(smallint DEFAULT (-1), integer DEFAULT (-1), character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying, smallint DEFAULT (-1), date DEFAULT NULL::date, boolean DEFAULT NULL::boolean, character varying DEFAULT ''::character varying, character varying DEFAULT ''::character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idu alias for $2;
  cod alias for $3;
  nom alias for $4;
  ape alias for $5;
  per alias for $6;
  ing alias for $7;
  blo alias for $8;
  cor alias for $9;
  cla alias for $10;
begin
  if tip=0 then -- Consulta de todos los registros
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil;
  elsif tip=1 then -- Consulta por codigo de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_codigo=cod;
  elsif tip=2 then -- Consulta por nombre de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_nombres like nom;
  elsif tip=3 then -- Consulta por apellido de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_apellidos like ape;
  elsif tip=4 then -- Consulta por perfil de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_perfil = per;
  elsif tip=5 then -- Consulta por fecha de ingreso exacta
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) = ing;
  elsif tip=6 then -- Consulta por fecha de ingreso menor o igual a
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) <= ing;
  elsif tip=7 then -- Consulta por fecha de ingreso mayor o igual a
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) >= ing;
  elsif tip=8 then -- Consulta por bloqueado
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_bloqueado = blo;
  elsif tip=9 then -- Consulta por correo
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_correo like cor;
  elsif tip=10 then -- Consulta de autenticacion
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_codigo=cod and usu_clave=cla;
  elsif tip=11 then -- Consulta por id de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_id=idu;
  elsif tip=12 then -- Consulta por si el perfil esta activo o no
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, perfiles.activo, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where perfiles.activo = blo;
  end if;
end;
$_$;",Backup_20130306.backup
"CREATE FUNCTION fn_usuarios_sel(smallint, integer, character varying, character varying, character varying, smallint, date, boolean, character varying, character varying) RETURNS SETOF t_usuarios
    LANGUAGE plpgsql
    AS $_$
declare
  tip alias for $1;
  idu alias for $2;
  cod alias for $3;
  nom alias for $4;
  ape alias for $5;
  per alias for $6;
  ing alias for $7;
  blo alias for $8;
  cor alias for $9;
  cla alias for $10;
begin
  if tip=0 then -- Consulta de todos los registros
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil;
  elsif tip=1 then -- Consulta por codigo de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_codigo=cod;
  elsif tip=2 then -- Consulta por nombre de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_nombres like nom;
  elsif tip=3 then -- Consulta por apellido de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_apellidos like ape;
  elsif tip=4 then -- Consulta por perfil de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_perfil = per;
  elsif tip=5 then -- Consulta por fecha de ingreso exacta
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) = ing;
  elsif tip=6 then -- Consulta por fecha de ingreso menor o igual a
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) <= ing;
  elsif tip=7 then -- Consulta por fecha de ingreso mayor o igual a
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where date(usu_ultimoingreso) >= ing;
  elsif tip=8 then -- Consulta por bloqueado
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_bloqueado = blo;
  elsif tip=9 then -- Consulta por correo
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_correo like cor;
  elsif tip=10 then -- Consulta de autenticacion
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_codigo=cod and usu_clave=cla;
  elsif tip=11 then -- Consulta por id de usuario
    return query select usu_id, usu_codigo, usu_nombres, usu_apellidos, usu_perfil, perfiles.nombre, usu_ultimoingreso, usu_bloqueado, usu_correo
    from usuarios inner join perfiles on usu_perfil=idperfil
    where usu_id=idu;
  end if;
end;
$_$;",Backup_20130224.backup
"CREATE FUNCTION fnc_base_idade() RETURNS SETOF tp_base_idade
    LANGUAGE plpgsql
    AS $$
declare
   retorno record;
begin

   for retorno in (select id, nome, cpf, idade, ''::varchar as base_idade from pessoas) loop

      
      if retorno.idade < 18 then
         retorno.base_idade := 'menor';
      elsif retorno.idade <= 25 then
         retorno.base_idade := 'adulto 1';
      elsif retorno.idade <= 45 then
         retorno.base_idade := 'adulto 2';
      elsif retorno.idade <= 65 then
         retorno.base_idade := 'adulto 3';
      elsif retorno.idade > 65 then
         retorno.base_idade := '3 idade';
      else 
         retorno.base_idade := 'Idade nao definida';
      end if;
      return next retorno;
   end loop;

   return ;
end;
$$;",aula.sql
"CREATE FUNCTION fnc_base_idade(pcpf character varying) RETURNS tp_base_idade
    LANGUAGE plpgsql
    AS $$
declare
   retorno tp_base_idade;
begin

   select * into retorno from pessoas where cpf = pcpf;
   if not FOUND then
      raise 
         exception 'Pessoa nao encontrada !!!';
   end if;

   if retorno.idade < 18 then
      retorno.base_idade := 'menor';
   elsif retorno.idade <= 25 then
      retorno.base_idade := 'adulto 1';
   elsif retorno.idade <= 45 then
      retorno.base_idade := 'adulto 2';
   elsif retorno.idade <= 65 then
      retorno.base_idade := 'adulto 3';
   elsif retorno.idade > 65 then
      retorno.base_idade := '3 idade';
   else 
      retorno.base_idade := 'Idade nao definida';
   end if;

   return retorno;
end;
$$;",aula.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",AuroraOld.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-07-31.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-08-01.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-09-25.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-10-07.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-10-14.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-14-11-24-versao-1.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-15-03-03.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-15-03-10.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-15-04-28.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-15-04-30-oficial.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-16-11-09-2.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-16-11-09.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-16-11-25.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump-16-11-28.sql
"CREATE FUNCTION fnc_get_parametro(nome character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_nome_parametro ALIAS FOR $1;
		r record;
	BEGIN
		select into r p.* from parametros as p where p.nome = v_nome_parametro;
		
		RETURN r.valor;
	END
$_$;",liverpool_dump_14-09-20.sql
"CREATE FUNCTION fnc_pessoa(pcpf character varying) RETURNS tp_pessoa
    LANGUAGE plpgsql
    AS $$
     declare
        resultado tp_pessoa;
     begin
        select nome, idade into resultado
        from pessoas
        where cpf = pcpf;
        return resultado;
     end;
   $$;",aula.sql
"CREATE FUNCTION fnc_pessoa2(pcpf character varying, OUT pnome character varying, OUT pidade integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
     begin
        select nome, idade into pnome, pidade
        from pessoas
        where cpf = pcpf;
        
     end;
   $$;",aula.sql
"CREATE FUNCTION fnc_pessoa3(pcpf character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 declare 
   result varchar;
 begin
   select nome into result
   from pessoas
   where cpf = pcpf;
   return result; 
   
 end;
$$;",aula.sql
"CREATE FUNCTION fnc_pessoa3(pcpf character varying, pcampo character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
 declare 
   result varchar;
   sql    text;
 begin
   sql := 'select '|| pcampo || ' from pessoas where cpf = $1';
   execute sql into result using pcpf;
   return result; 
   
 end;
$_$;",aula.sql
"CREATE FUNCTION fnc_pessoa4(pcpf anyelement, pcampo character varying) RETURNS anyelement
    LANGUAGE plpgsql
    AS $_$
 declare 
   result varchar;
   sql    text;
 begin
   sql := 'select '|| pcampo || ' from pessoas where cpf = $1';
   execute sql into result using pcpf;
   return result; 
   
 end;
$_$;",aula.sql
"CREATE FUNCTION footgun(_schema text, _parttionbase text) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    row     record;
BEGIN
    FOR row IN 
        SELECT
            table_schema,
            table_name
        FROM
            information_schema.tables
        WHERE
            table_type = 'BASE TABLE'
        AND
            table_schema = _schema
        AND
            table_name ILIKE (_parttionbase || '%')
    LOOP
       BEGIN
        EXECUTE 'DROP TABLE ' || quote_ident(row.table_schema) || '.' || quote_ident(row.table_name);
        RAISE INFO 'Dropped table: %', quote_ident(row.table_schema) || '.' || quote_ident(row.table_name);
       EXCEPTION when division_by_zero  then
        --RAISE INFO 'Cannot Dropped table: %', quote_ident(row.table_schema) || '.' || quote_ident(row.table_name);
       
       END;
    END LOOP;
END;
$$;",db_bphtb.sql
"CREATE FUNCTION format_date(v_day_id numeric, v_month_id numeric, v_year numeric) RETURNS character varying
LANGUAGE plpgsql
AS $$
begin
    return v_day_id || ' ' || (select month_name_parental_case from cm_month where month_id = v_month_id) || ' ' || v_year || ' года';
end
$$;",functions.sql
"CREATE FUNCTION format_month(v_month_id numeric, v_year numeric) RETURNS character varying
LANGUAGE plpgsql
AS $$
begin
    return (select month_name from cm_month where month_id = v_month_id) || ' ' || v_year || ' года';
end
$$;",functions.sql
"CREATE FUNCTION format_tgl(tgl date, pendek boolean, tanpatgl boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare 
    tgl_out varchar;
    nbln_out varchar;
    ntgl integer;
    nbln integer;
    nthn integer;
begin

select extract(day from tgl) into ntgl;
select extract(month from tgl)::int into nbln;
select extract(year from tgl) into nthn;

/*
1 januari 2014 
1 jan 2014
januari 2014
jan 2014
*/

if pendek then
  if nbln=1 then 
    nbln_out:='Jan ';
  elseif nbln=2 then 
    nbln_out:='Peb ';
  elseif nbln=3 then 
    nbln_out:='Mar ';
  elseif nbln=4 then 
    nbln_out:='Apr ';
  elseif nbln=5 then 
    nbln_out:='Mei ';
  elseif nbln=6 then 
    nbln_out:='Jun ';
  elseif nbln=7 then 
    nbln_out:='Jul ';
  elseif nbln=8 then 
    nbln_out:='Agt ';
  elseif nbln=9 then 
    nbln_out:='Sep ';
  elseif nbln=10 then 
    nbln_out:='Okt ';
  elseif nbln=11 then 
    nbln_out:='Nop ';
  elseif nbln=12 then 
    nbln_out:='Des ';
  end if;
else
  if nbln=1 then 
    nbln_out:='Januari ';
  elseif nbln=2 then 
    nbln_out:='Pebruari ';
  elseif nbln=3 then 
    nbln_out:='Maret ';
  elseif nbln=4 then 
    nbln_out:='April ';
  elseif nbln=5 then 
    nbln_out:='Mei ' ;
  elseif nbln=6 then 
    nbln_out:='Juni ';
  elseif nbln=7 then 
    nbln_out:='Juli ';
  elseif nbln=8 then 
    nbln_out:='Agustus ';
  elseif nbln=9 then 
    nbln_out:='September ';
  elseif nbln=10 then 
    nbln_out:='Oktober ';
  elseif nbln=11 then 
    nbln_out:='Nopember ';
  elseif nbln=12 then 
    nbln_out:='Desember ';
  end if;
end if;

if tanpatgl then
    select nbln_out||nthn into tgl_out;
else
    select ntgl||' '||nbln_out||nthn into tgl_out;
end if;

return tgl_out;   
end
$$;",db_padl.sql
"CREATE FUNCTION format_tgl(tgl timestamp without time zone, pendek boolean, tanpatgl boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

declare 
    tgl_out varchar;
    nbln_out varchar;
    ntgl integer;
    nbln integer;
    nthn integer;
begin

select extract(day from tgl) into ntgl;
select extract(month from tgl)::int into nbln;
select extract(year from tgl) into nthn;


if pendek then
  if nbln=1 then 
    nbln_out:='Jan ';
  elseif nbln=2 then 
    nbln_out:='Peb ';
  elseif nbln=3 then 
    nbln_out:='Mar ';
  elseif nbln=4 then 
    nbln_out:='Apr ';
  elseif nbln=5 then 
    nbln_out:='Mei ';
  elseif nbln=6 then 
    nbln_out:='Jun ';
  elseif nbln=7 then 
    nbln_out:='Jul ';
  elseif nbln=8 then 
    nbln_out:='Agt ';
  elseif nbln=9 then 
    nbln_out:='Sep ';
  elseif nbln=10 then 
    nbln_out:='Okt ';
  elseif nbln=11 then 
    nbln_out:='Nop ';
  elseif nbln=12 then 
    nbln_out:='Des ';
  end if;
else
  if nbln=1 then 
    nbln_out:='Januari ';
  elseif nbln=2 then 
    nbln_out:='Pebruari ';
  elseif nbln=3 then 
    nbln_out:='Maret ';
  elseif nbln=4 then 
    nbln_out:='April ';
  elseif nbln=5 then 
    nbln_out:='Mei ' ;
  elseif nbln=6 then 
    nbln_out:='Juni ';
  elseif nbln=7 then 
    nbln_out:='Juli ';
  elseif nbln=8 then 
    nbln_out:='Agustus ';
  elseif nbln=9 then 
    nbln_out:='September ';
  elseif nbln=10 then 
    nbln_out:='Oktober ';
  elseif nbln=11 then 
    nbln_out:='Nopember ';
  elseif nbln=12 then 
    nbln_out:='Desember ';
  end if;
end if;

if tanpatgl then
    select nbln_out||nthn into tgl_out;
else
    select ntgl||' '||nbln_out||nthn into tgl_out;
end if;

return tgl_out;   
end
$$;",db_padl.sql
"CREATE FUNCTION four(study_uid text) RETURNS text
    LANGUAGE plpgsql
    AS $$declare
------------------------------------------
-- Purpose: GE DR header processor
-- 	After successful run clears entry from
--	""exams-to-process"" table
-- Caller: Dispatcher
-----------------------------------------
	func text :='ddw:four';
	status text :='failed';

begin
	status :='ok';
	-- right now this is just a stub to clear the ""exams-to-process"" table
	-- and avoid errors in the Log table
	return status ;
end;$$;",purged-ddw.sql
"CREATE FUNCTION fu_lista_categoria_producto(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo_cat, nombre, descripcion from categoria_producto  where estado = pestado;   
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_categoria_producto(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo_cat, nombre, descripcion from categoria_producto  where estado = pestado;   
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_categoria_producto(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo_cat, nombre, descripcion from categoria_producto  where estado = pestado;   
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_compras(pcodigo integer, pserie character varying, pnumero character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 

	SELECT tc.nombre, pro.nombre, co.fecha_compra FROM compra co 
	inner join tipo_venta tc on (co.tipo_compra=tc.codigo)
	inner join proveedor pro on (pro.codigo=co.proveedor)
	where co.estado = true and co.serie = pserie and co.numero_factura = pnumero and co.codigo = pcodigo; 
	return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_compras(pcodigo integer, pserie character varying, pnumero character varying, pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 

	SELECT tc.nombre, pro.nombre, co.fecha_compra, co.sub_total, co.igv, co.total 
	FROM compra co 
	inner join tipo_venta tc on (co.tipo_compra=tc.codigo)
	inner join proveedor pro on (pro.codigo=co.proveedor)
	where co.estado = pestado and co.serie = pserie and co.numero_factura = pnumero and co.codigo = pcodigo; 
	return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_compras_detalle(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT pr.nombre, dc.cantidad, dc.cantidad_presentacion, pre.nombre 
	from detalle_compra  dc 
	inner join producto pr on (dc.codigo_producto = pr.codigo)
	inner join presentacion pre on (pre.codigo = DC.codigo_presentacion)
	WHERE dc.codigo_compra=pcodigo; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_compras_serie_numero(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT co.codigo, co.serie, co.numero_factura, tc.nombre  from compra  co
	inner join tipo_venta tc on (co.tipo_compra = tc.codigo)
	where co.estado = pestado
	order by co.serie, co.numero_factura; 
	return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_presentacion(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, u.nombre, cantidad, p.descripcion  
	from presentacion  p inner join unidad_medida u on (u.codigo=p.unidad_medida)
	where p.estado = pestado;  
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_presentacion(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, u.nombre, cantidad, p.descripcion, u.codigo  
	from presentacion  p inner join unidad_medida u on (u.codigo=p.unidad_medida)
	where p.estado = pestado;  
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_presentacion(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, u.nombre, cantidad, p.descripcion, u.codigo  
	from presentacion  p inner join unidad_medida u on (u.codigo=p.unidad_medida)
	where p.estado = pestado;  
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_presentacion_producto(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_presentacion_producto(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_presentacion_producto(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_presentacion_producto_codigo(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
		SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre, pre.descripcion  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_presentacion_producto_codigo(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
		SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre, pre.descripcion  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_presentacion_producto_codigo(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
		SELECT pre.codigo, pre.nombre, pre.cantidad, uni.nombre, pre.descripcion  from producto p 
	inner join detalle_presentaciones d on (p.codigo = d.codigoproducto)
	inner join presentacion pre on (pre.codigo=d.codigopresentacion) 
	inner join unidad_medida  uni on (uni.codigo=pre.unidad_medida)
	where p.codigo = pcodigo; 
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_productos(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, p.categoria, c.nombre, p.color, p.descripcion from producto  p 
	inner join categoria_producto  c on (p.categoria = c.codigo_cat)
	WHERE p.estado = pestado; 
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_productos(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, p.categoria, c.nombre, p.color, p.descripcion, u.codigo as codigoUnidadMedida, u.nombre as unidadMedida
	from producto  p 
	inner join categoria_producto  c on (p.categoria = c.codigo_cat)
	inner join unidad_medida  u on ( u.codigo = p.unida_medida )
	WHERE p.estado = pestado; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_productos(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, p.categoria, c.nombre, p.color, p.descripcion, u.codigo as codigoUnidadMedida, u.nombre as unidadMedida
	from producto  p 
	inner join categoria_producto  c on (p.categoria = c.codigo_cat)
	inner join unidad_medida  u on ( u.codigo = p.unida_medida )
	WHERE p.estado = pestado; 
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_productos_busqueda(pestado boolean, pnombre character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, p.categoria, c.nombre, p.color, p.descripcion, u.codigo as codigoUnidadMedida, u.nombre as unidadMedida
	from producto  p 
	inner join categoria_producto  c on (p.categoria = c.codigo_cat)
	inner join unidad_medida  u on ( u.codigo = p.unida_medida )
	WHERE p.estado = pestado and p.nombre like '%'||pnombre||'%'; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_productos_busqueda(pestado boolean, pnombre character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT p.codigo, p.nombre, p.categoria, c.nombre, p.color, p.descripcion, u.codigo as codigoUnidadMedida, u.nombre as unidadMedida
	from producto  p 
	inner join categoria_producto  c on (p.categoria = c.codigo_cat)
	inner join unidad_medida  u on ( u.codigo = p.unida_medida )
	WHERE p.estado = pestado and p.nombre like '%'||pnombre||'%'; 
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_proveedores(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, ruc, direccion from proveedor  where estado = pestado; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_proveedores(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, ruc, direccion from proveedor  where estado = pestado; 
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_proveedores(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, ruc, direccion from proveedor  where estado = pestado; 
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_tipo_venta(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, descripcion from tipo_venta 
	where estado = pestado; 
	return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_tipo_venta(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, descripcion from tipo_venta 
	where estado = pestado; 
	return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_tipo_venta(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo, nombre, descripcion from tipo_venta 
	where estado = pestado; 
	return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lista_unidad_medida(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo,nombre, descripcion  from unidad_medida  where estado = true;  
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lista_unidad_medida(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo,nombre, descripcion  from unidad_medida  where estado = true;  
return lista; 
end 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_lista_unidad_medida(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor;  
begin 
	OPEN lista FOR 
	SELECT codigo,nombre, descripcion  from unidad_medida  where estado = true;  
return lista; 
end 
$$;",bakup-febrero.backup
"CREATE FUNCTION fu_lstar_detalle_compra(pcodigo integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor; 
begin
	open lista FOR
	SELECT pr.nombre, pre.nombre, dc.cantidad_presentacion, dc.precio_unitario, dc.precio_total, pr.color, dc.cantidad, dc.codigo_producto
	from detalle_compra  dc 
	inner join producto pr on (dc.codigo_producto = pr.codigo)
	inner join presentacion pre on (pre.codigo = DC.codigo_presentacion)
	where dc.codigo_compra=pcodigo; 
	return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lstar_venta(pcodigo integer, pserie character varying, pnumero character varying, pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor; 
begin
open lista FOR
	SELECT tv.nombre, v.cliente, v.fecha_venta, v.sub_total, v.igv, v.total 
	from venta v  
	inner join tipo_venta tv on (tv.codigo=v.tipo_venta)
	where v.estado = pestado and v.codigo = pcodigo and v.serie = pserie and v.numero = pnumero
	order by v.serie, v.numero; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lstar_venta_detalle(pcodigo_venta integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor; 
begin
open lista FOR

	SELECT p.codigo, p.nombre, pr.nombre,dv.cantidad_presentacion, dv.precio, dv.precio_total, dv.cantidad, p.color 
	from detalle_venta dv 
	inner join producto p  on  (dv.codigo_producto = p.codigo) 
	inner join presentacion pr on ( pr.codigo = dv.codigo_presentacion)
	where dv.codigo_venta = pcodigo_venta; 	
	
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_lstar_ventas_serie_numero(pestado boolean) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare 
lista refcursor; 
begin
open lista FOR
	SELECT v.codigo, v.serie, v.numero, tv.nombre from venta v  
	inner join tipo_venta tv on (tv.codigo=v.tipo_venta)
	where v.estado = pestado
	order by v.serie, v.numero; 
return lista; 
end 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_verificarusuario(pnombreusuario character varying, ppassword character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE lista refcursor;
begin 	
		open lista for 
		select idusuario, nombre_usuario, estado from usuario
		where estado = true and nombre_usuario=pnombreusuario and contrasena = MD5(ppassword);  
		return lista; 
end; 
$$;",bakup-28febrero.backup
"CREATE FUNCTION fu_verificarusuario(pnombreusuario character varying, ppassword character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE lista refcursor;
begin 	
		open lista for 
		select idusuario, nombre_usuario, estado from usuario
		where estado = true and nombre_usuario=pnombreusuario and contrasena = MD5(ppassword);  
		return lista; 
end; 
$$;",bakup-5-dic.backup
"CREATE FUNCTION fu_verificarusuario(pnombreusuario character varying, ppassword character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE lista refcursor;
begin 	
		open lista for 
		select idusuario, nombre_usuario, estado from usuario
		where estado = true and nombre_usuario=pnombreusuario and contrasena = MD5(ppassword);  
		return lista; 
end; 
$$;",bakup-febrero.backup
"CREATE FUNCTION fun_account_contacts_byid(inidaccount integer, inidcontact integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResultado FOR SELECT idaccount, idcontact, enable, encode(firstname::bytea, 'base64') as firstname, encode(lastname::bytea, 'base64') as lastname, prioritycontact, enable_as_contact, encode(appointment::bytea, 'base64') as appointment, encode(note::bytea, 'base64') as note, ts  FROM usaga.view_account_contacts WHERE idaccount = inidaccount AND idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;

ELSE

OPEN CursorResultado FOR SELECT * FROM usaga.view_account_contacts WHERE idaccount = inidaccount AND idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;

END IF;

RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_account_contacts_table_xml(inidaccount integer, inidcontact integer, inpriority integer, inenable boolean, inappointment text, innote text, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_account_contacts_table(inidaccount, inidcontact, inpriority, inenable, inappointment, innote, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_account_getdata_string(inidaccount integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
AccountROWDATA   usaga.account%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO AccountROWDATA FROM usaga.account WHERE idaccount = inidaccount;
  
    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
    
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(AccountROWDATA.idaccount::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(AccountROWDATA.partition::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(AccountROWDATA.enable::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(AccountROWDATA.account::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(AccountROWDATA.name::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(AccountROWDATA.type::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(AccountROWDATA.dateload::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(AccountROWDATA.idgroup::text,''));

	WHEN i_string[1] = '09' THEN
--Retorno := replace(Retorno, '&P09', COALESCE(AccountROWDATA.idaddress::text,''));
Retorno := replace(Retorno, '09', COALESCE(AccountROWDATA.idaddress::text,''));

	WHEN i_string[1] = '10' THEN
Retorno := replace(Retorno, prefix||'10', COALESCE(AccountROWDATA.note::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;


--raise notice 'Retornox = %',Retorno;                                                

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_account_notifications_applyselected_xml(inidaccount integer, idphones integer[], incall boolean, insms boolean, inmsg text, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_account_notifications_applyselected(inidaccount, idphones, incall, insms, inmsg, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_account_notifications_table_xml(inidnotifaccount integer, inidaccount integer, inidphone integer, prioinrity integer, incall boolean, insms boolean, insmstext text, innote text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_account_notifications_table(inidnotifaccount, inidaccount, inidphone, prioinrity, incall, insms, insmstext, innote, ints, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_account_notify_applied_to_selected_contacts(inidaccount integer, idcontacts integer[], incall boolean, insms boolean, inmsg text, fieldtextasbase64 boolean, OUT outreturn integer, OUT outpgmsg text) RETURNS record
    LANGUAGE plpgsql
    AS $$DECLARE

InternalIdPhone INTEGER DEFAULT 0;
CursorPhones refcursor;
numcontacts INTEGER DEFAULT 0;
numphonesx INTEGER DEFAULT 0;
numphonesy INTEGER DEFAULT 0;

BEGIN

-- Recorremos cada idcontcat

FOR i IN array_lower(idcontacts,1) .. array_upper(idcontacts,1) LOOP

-- Verificamos que efectivamente cada idcontact pertenesca a la cuenta
IF EXISTS(SELECT * FROM usaga.view_account_contacts WHERE idaccount = inidaccount AND idcontact = idcontacts[i]) THEN
numcontacts := numcontacts+1;
-- Recorremos todos los telefonos que tiene ese contacto
OPEN CursorPhones FOR SELECT idphone FROM phones WHERE idcontact = idcontacts[i];

    loop 

        FETCH CursorPhones INTO InternalIdPhone;
        EXIT WHEN NOT FOUND;


SELECT xyz.outreturn INTO numphonesy FROM usaga.fun_account_notifications_applyselected(inidaccount, ARRAY[InternalIdPhone], incall, insms, inmsg, false) as xyz;
numphonesx = numphonesx+numphonesy;


    end loop;
    CLOSE CursorPhones;


END IF;


END LOOP;

outreturn :=0;

outpgmsg:= 'Se aplicó los cambios a '||numphonesx::text||' teléfonos de '||numcontacts::text||' de '||array_length(idcontacts, 1)::text||' contactos solicitados.';

IF fieldtextasbase64 THEN
outpgmsg := encode(outpgmsg::bytea, 'base64');
END IF;

RETURN;
END;$$;",usms.sql
"CREATE FUNCTION fun_account_notify_applied_to_selected_contacts_xml(inidaccount integer, idcontacts integer[], incall boolean, insms boolean, inmsg text, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_account_notify_applied_to_selected_contacts(inidaccount, idcontacts, incall, insms, inmsg, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_account_search_name(innameaccount text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT -1;

BEGIN

SELECT idaccount INTO Retorno FROM usaga.account WHERE name = innameaccount;

IF Retorno<1 OR Retorno IS NULL THEN
Retorno := 0;
END IF;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_account_search_number(innumberaccount text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT -1;

BEGIN

SELECT idaccount INTO Retorno FROM usaga.account WHERE account = innumberaccount;

IF Retorno<1 OR Retorno IS NULL THEN
Retorno := 0;
END IF;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_address_edit_xml(inidaddress integer, inidlocation integer, ingeox double precision, ingeoy double precision, f1 text, f2 text, f3 text, f4 text, f5 text, f6 text, f7 text, f8 text, f9 text, f10 text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE
outreturn integer default 0;
outpgmsg TEXT DEFAULT 'Ninguna acción realizada';
BEGIN
SELECT fun_address_edit.outreturn, fun_address_edit.outpgmsg INTO outreturn, outpgmsg FROM fun_address_edit(inidaddress, inidlocation, ingeox, ingeoy, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, ints, fieldtextasbase64);
RETURN '<table><row><outreturn>'||outreturn::text||'</outreturn><outpgmsg>'||outpgmsg::text||'</outpgmsg></row></table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_address_getdata_string(inidaddress integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
AddressROWDATA   address%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO AddressROWDATA FROM address WHERE idaddress = inidaddress;

--Retorno := fun_location_getdata_string(AddressROWDATA.idlocation, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
                            --    raise notice 'row = %',i_string[1];                      
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(AddressROWDATA.idaddress::text,''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(AddressROWDATA.idlocation::text,''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(AddressROWDATA.geox::text,''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(AddressROWDATA.geoy::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(AddressROWDATA.field1::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(AddressROWDATA.field2::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(AddressROWDATA.field3::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(AddressROWDATA.field4::text,''));

	WHEN i_string[1] = '09' THEN
Retorno := replace(Retorno, prefix||'09', COALESCE(AddressROWDATA.field5::text,''));

	WHEN i_string[1] = '10' THEN
Retorno := replace(Retorno, prefix||'10', COALESCE(AddressROWDATA.field6::text,''));

	WHEN i_string[1] = '11' THEN
Retorno := replace(Retorno, prefix||'11', COALESCE(AddressROWDATA.field7::text,''));

	WHEN i_string[1] = '12' THEN
Retorno := replace(Retorno, prefix||'12', COALESCE(AddressROWDATA.field8::text,''));

	WHEN i_string[1] = '13' THEN
Retorno := replace(Retorno, prefix||'13', COALESCE(AddressROWDATA.field8::text,''));

	WHEN i_string[1] = '14' THEN
Retorno := replace(Retorno, prefix||'14', COALESCE(AddressROWDATA.field10::text,''));

	WHEN i_string[1] = '15' THEN
Retorno := replace(Retorno, prefix||'15', COALESCE(AddressROWDATA.geourl::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;


RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_auto_process_events() RETURNS boolean
    LANGUAGE plpgsql
    AS $$BEGIN
PERFORM usaga.fun_account_event_notifications_sms();

RETURN TRUE;
END;$$;",usms.sql
"CREATE FUNCTION fun_contact_getdata_string(inidcontact integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
ContactROWDATA   contacts%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO ContactROWDATA FROM contacts WHERE idcontact = inidcontact;
  
--Retorno := fun_address_getdata_string(ContactROWDATA.idaddress, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';

--raise notice 'i_query = %',i_query;                                                

    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
    --raise notice 'Retornocxx = %',Retorno;                                                
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(ContactROWDATA.idcontact::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(ContactROWDATA.enable::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(ContactROWDATA.title::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(ContactROWDATA.firstname::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(ContactROWDATA.lastname::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(ContactROWDATA.gender::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(ContactROWDATA.birthday::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(ContactROWDATA.typeofid::text,''));

	WHEN i_string[1] = '09' THEN
Retorno := replace(Retorno, prefix||'09', COALESCE(ContactROWDATA.identification::text,''));

	WHEN i_string[1] = '10' THEN
Retorno := replace(Retorno, prefix||'10', COALESCE(ContactROWDATA.web::text,''));

	WHEN i_string[1] = '11' THEN
Retorno := replace(Retorno, prefix||'11', COALESCE(ContactROWDATA.email1::text,''));

	WHEN i_string[1] = '12' THEN
Retorno := replace(Retorno, prefix||'12', COALESCE(ContactROWDATA.email2::text,''));

	WHEN i_string[1] = '13' THEN
Retorno := replace(Retorno, prefix||'13', COALESCE(ContactROWDATA.idaddress::text,''));

	WHEN i_string[1] = '14' THEN
Retorno := replace(Retorno, prefix||'14', COALESCE(ContactROWDATA.note::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;

--raise notice 'Retornoxxx = %',Retorno;                                                


RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_contact_search_by_name(infirstname text, inlastname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT -1;

BEGIN

SELECT idcontact INTO Retorno FROM contacts WHERE upper(trim(firstname)) = upper(trim(infirstname)) AND upper(trim(lastname)) = upper(trim(inlastname)) LIMIT 1;

IF Retorno<1 OR Retorno IS NULL THEN
Retorno := 0;
END IF;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_contacts_edit_xml(inidcontact integer, inenable boolean, intitle text, infirstname text, inlastname text, ingender integer, inbirthday date, intypeofid integer, inidentification text, inweb text, inemail1 text, inemail2 text, inidaddress integer, innote text, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor;
Retorno TEXT DEFAULT '';

BEGIN
--fun_contacts_table_xml(IN inidcontact integer, IN inenable boolean, IN intitle text, IN infirstname text, IN inlastname text, IN ingender integer, IN inbirthday date, IN intypeofid integer, IN inidentification text, IN inweb text, IN inemail1 text, IN inemail2 text, IN inidaddress text, IN note text)

OPEN CursorResultado FOR SELECT * FROM fun_contacts_edit(inidcontact, inenable, intitle, infirstname, inlastname, ingender, inbirthday, intypeofid, inidentification, inweb, inemail1, inemail2, inidaddress, innote, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_correntportproviders_get_idprovider(inidport integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT 0;

BEGIN

SELECT idprovider INTO Retorno FROM currentportsproviders WHERE idport = inidport;

IF Retorno < 1 OR Retorno IS NULL THEN
Retorno := 0;
END IF;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_events_getdata_string(inidevent integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
EventsROWDATA   usaga.events%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO EventsROWDATA FROM usaga.events WHERE idevent = inidevent;
  
--Retorno := fun_address_getdata_string(PhonesROWDATA.idaddress, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
--    raise notice 'row4 = %',Retorno;                                                
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(EventsROWDATA.idevent::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(EventsROWDATA.dateload::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(EventsROWDATA.idaccount::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(EventsROWDATA.code::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(EventsROWDATA.zu::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(EventsROWDATA.priority::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(EventsROWDATA.description::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(EventsROWDATA.ideventtype::text,''));

	WHEN i_string[1] = '09' THEN
Retorno := replace(Retorno, prefix||'09', COALESCE(EventsROWDATA.datetimeevent::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;




RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_events_lastid_xml() RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT idevent FROM usaga.events ORDER BY idevent DESC LIMIT 1;
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_eventtypes_edit_xml(inideventtype integer, inpriority integer, inlabel text, inadefault boolean, ingdefault boolean, innote text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_eventtypes_edit(inideventtype, inpriority, inlabel, inadefault, ingdefault, innote, ints, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_eventtypes_getdata_string(inideventtype integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
EventTypesROWDATA   usaga.eventtypes%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO EventTypesROWDATA FROM usaga.eventtypes WHERE ideventtype = inideventtype;
  
--Retorno := fun_address_getdata_string(PhonesROWDATA.idaddress, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
--    raise notice 'row4 = %',Retorno;                                                
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(EventTypesROWDATA.ideventtype::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(EventTypesROWDATA.name::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(EventTypesROWDATA.priority::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(EventTypesROWDATA.accountdefault::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(EventTypesROWDATA.groupdefault::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(EventTypesROWDATA.label::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(EventTypesROWDATA.note::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;




RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_generate_test_report(OUT outeventsgenerated integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$BEGIN


RETURN;
END;$$;",usms.sql
"CREATE FUNCTION fun_get_priority_from_ideventtype(inideventtype integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT 0;

BEGIN
SELECT priority INTO Retorno FROM usaga.eventtypes WHERE ideventtype = inideventtype;
IF Retorno IS NULL OR Retorno < 0 THEN
Retorno := 10;
END IF;
RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_group_getdata_string(inidgroup integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
GroupROWDATA   usaga.groups%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO GroupROWDATA FROM usaga.groups WHERE idgroup = inidgroup;
  
--Retorno := fun_address_getdata_string(PhonesROWDATA.idaddress, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
--    raise notice 'row4 = %',Retorno;                                                
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(GroupROWDATA.idgroup::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(GroupROWDATA.enable::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(GroupROWDATA.name::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(GroupROWDATA.note::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;




RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_groups_edit_xml(inidgroup integer, inenable boolean, inname text, innote text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_groups_edit(inidgroup, inenable, inname, innote, ints, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_groups_remove_selected_xml(idgroups integer[], fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_groups_remove_selected(idgroups, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_idphone_from_phone(inphone text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno INTEGER DEFAULT 0;

BEGIN

IF char_length(inphone) > 0 THEN
-- Obtenemos el phone 
SELECT idphone INTO Retorno FROM phones WHERE phone = inphone;
IF Retorno IS NULL THEN
Retorno := 0;
END IF;
END IF;


RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_location_getdata_string(inidlocation integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
VLIdLROWDATA   view_location_idlocation%ROWTYPE;
VLFROWDATA   view_locations_full%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO VLIdLROWDATA FROM view_location_idlocation WHERE idlocation = inidlocation LIMIT 1;
-- raise notice 'row = %',VLIdLROWDATA;                                                     
SELECT * INTO VLFROWDATA FROM view_locations_full WHERE (idl1 = VLIdLROWDATA.idl1 OR idl1 IS NULL) AND (idl2 = VLIdLROWDATA.idl2 OR idl2 IS NULL) AND (idl3 = VLIdLROWDATA.idl3 OR idl3 IS NULL) AND (idl4 = VLIdLROWDATA.idl4 OR idl4 IS NULL) AND (idl5 = VLIdLROWDATA.idl5 OR idl5 IS NULL) AND (idl6 = VLIdLROWDATA.idl6 OR idl6 IS NULL) limit 1;

-- raise notice 'row = %',VLFROWDATA;                                                     

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
                               -- raise notice 'row = %',i_query;  
  --raise notice 'row = %',i_string[1];                                                     
CASE   
	WHEN i_string[1] = '01' THEN
	    --raise notice 'row = %',VLFROWDATA.l1name;  
Retorno := replace(Retorno, prefix||'01', COALESCE(VLFROWDATA.idl1::text,''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(VLFROWDATA.l1name::text,''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(VLFROWDATA.l1code::text,''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(VLFROWDATA.idl2::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(VLFROWDATA.l2name::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(VLFROWDATA.l2code::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(VLFROWDATA.idl3::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(VLFROWDATA.l3name::text,''));

	WHEN i_string[1] = '09' THEN
Retorno := replace(Retorno, prefix||'09', COALESCE(VLFROWDATA.l3code::text,''));

	WHEN i_string[1] = '10' THEN
Retorno := replace(Retorno, prefix||'10', COALESCE(VLFROWDATA.idl4::text,''));

	WHEN i_string[1] = '11' THEN
Retorno := replace(Retorno, prefix||'11', COALESCE(VLFROWDATA.l4name::text,''));

	WHEN i_string[1] = '12' THEN
Retorno := replace(Retorno, prefix||'12', COALESCE(VLFROWDATA.l4code::text,''));

	WHEN i_string[1] = '13' THEN
Retorno := replace(Retorno, prefix||'13', COALESCE(VLFROWDATA.idl5::text,''));

	WHEN i_string[1] = '14' THEN
Retorno := replace(Retorno, prefix||'14', COALESCE(VLFROWDATA.l5name::text,''));

	WHEN i_string[1] = '15' THEN
Retorno := replace(Retorno, prefix||'15', COALESCE(VLFROWDATA.l5code::text,''));

	WHEN i_string[1] = '16' THEN
Retorno := replace(Retorno, prefix||'16', COALESCE(VLFROWDATA.idl6::text,''));

	WHEN i_string[1] = '17' THEN
Retorno := replace(Retorno, prefix||'17', COALESCE(VLFROWDATA.l6name::text,''));

	WHEN i_string[1] = '18' THEN
Retorno := replace(Retorno, prefix||'18', COALESCE(VLFROWDATA.l6code::text,''));

	WHEN i_string[1] = '19' THEN
Retorno := replace(Retorno, prefix||'19', COALESCE(inidlocation::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;



RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_location_level_edit_xml(l integer, idpk integer, idfk integer, inname text, incode text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';

BEGIN

CASE

	WHEN l = 1 THEN
Retorno:= fun_location_level1_edit_xml(idpk, inname, incode, ints, fieldtextasbase64);
	WHEN l = 2 THEN
Retorno:= fun_location_level2_edit_xml(idpk, idfk, inname, incode, ints, fieldtextasbase64);
	WHEN l = 3 THEN
Retorno:= fun_location_level3_edit_xml(idpk, idfk, inname, incode, ints, fieldtextasbase64);
	WHEN l = 4 THEN
Retorno:= fun_location_level4_edit_xml(idpk, idfk, inname, incode, ints, fieldtextasbase64);
	WHEN l = 5 THEN
Retorno:= fun_location_level5_edit_xml(idpk, idfk, inname, incode, ints, fieldtextasbase64);
	WHEN l = 6 THEN
Retorno:= fun_location_level6_edit_xml(idpk, idfk, inname, incode, ints, fieldtextasbase64);
	ELSE
Retorno := '<table></table>';
END CASE;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_notification_gen_message(inidevent integer, insmstext text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';

IIdAddressAccount INTEGER DEFAULT 0;
IIdLocationAccount INTEGER DEFAULT 0;

Internalidphone INTEGER DEFAULT 0;

IIdAddressContact INTEGER DEFAULT 0;
IIdLocationContact INTEGER DEFAULT 0;

IIdAddressPhone INTEGER DEFAULT 0;
IIdLocationPhone INTEGER DEFAULT 0;

EventROWDATA   usaga.events%ROWTYPE;

idnt INTEGER DEFAULT 0; -- Notification template

BEGIN

Retorno := trim(insmstext);

-- Verificamos si el mensaje tiene el formato &NTXX que representa el idnotiftempl, si existe utilizamos ese mensaje.
idnt :=  to_number((regexp_matches(Retorno, '&NT(\d\d\d)'))[1], '999');
    --raise notice 'idnt = %',idnt; 
IF  EXISTS(SELECT * FROM usaga.notification_templates WHERE idnotiftempl = idnt) THEN
SELECT message INTO Retorno FROM usaga.notification_templates WHERE idnotiftempl = idnt;
END IF;


SELECT * INTO EventROWDATA FROM usaga.events WHERE idevent = inidevent LIMIT 1;

-- DATOS RELACIONADOS CON LA CUENTA DE ABONADO
Retorno := usaga.fun_account_getdata_string(COALESCE(EventROWDATA.idaccount, 0), 'A', Retorno);
SELECT idaddress INTO IIdAddressAccount FROM usaga.account WHERE idaccount = EventROWDATA.idaccount;
Retorno := fun_address_getdata_string(COALESCE(IIdAddressAccount, 0), 'AA', Retorno);
SELECT idlocation INTO IIdLocationAccount FROM address WHERE idaddress = IIdAddressAccount;
Retorno := fun_location_getdata_string(COALESCE(IIdLocationAccount, 0), 'AL', Retorno);

-- DATOS RELACIONADOS CON EL USUARIO QUE GENERA LA ALARMA
Retorno := fun_contact_getdata_string(COALESCE(EventROWDATA.idcontact, 0), 'AU', Retorno);
SELECT idaddress INTO IIdAddressContact FROM contacts WHERE idcontact = EventROWDATA.idcontact;
Retorno := fun_address_getdata_string(COALESCE(IIdAddressContact, 0), 'AUA', Retorno);
SELECT idlocation INTO IIdLocationContact FROM address WHERE idaddress = IIdAddressContact;
Retorno := fun_location_getdata_string(COALESCE(IIdLocationContact, 0), 'AUL', Retorno);


IF EventROWDATA.ideventtype = 72 THEN
-- Obtenemos el idphone que generó la alarma
SELECT idphone INTO Internalidphone FROM incomingcalls WHERE idincall = (SELECT idincall FROM usaga.events_generated_by_calls WHERE idevent = EventROWDATA.idevent);
END IF;

-- DATOS RELACIONADOS CON EL TELEFONO QUE GENERA LA ALARMA (En caso de ser una alarma tipo 72)
Retorno := fun_phone_getdata_string(Internalidphone, 'APU', Retorno);
SELECT idaddress INTO IIdAddressPhone FROM phones WHERE idphone = Internalidphone;
Retorno := fun_address_getdata_string(COALESCE(IIdAddressPhone, 0), 'APUA', Retorno);
SELECT idlocation INTO IIdLocationPhone FROM address WHERE idaddress = IIdAddressPhone;
Retorno := fun_location_getdata_string(COALESCE(IIdLocationContact, 0), 'APUL', Retorno);

-- DATOS RELACIONADOS CON EL EVENTO
Retorno := usaga.fun_events_getdata_string(inidevent, 'AE', Retorno);


RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_notification_templates_edit_xml(inidnotiftempl integer, indescription text, inmessage text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_notification_templates_edit(inidnotiftempl , indescription , inmessage , ints, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;
$$;",usms.sql
"CREATE FUNCTION fun_outgoing_new_now(inidprovider integer, inidsim integer, inidsmstype integer, inidphone integer, inphone text, inmsg text, inpriority integer, inreport boolean, inenablemsgclass boolean, inmsgclass integer, inidowner integer, innote text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE

BEGIN

RETURN fun_outgoing_new(inidprovider, inidsim, inidsmstype, inidphone, inphone, inmsg, 'now()', inpriority, inreport, inenablemsgclass, inmsgclass, inidowner, innote);
END;$$;",usms.sql
"CREATE FUNCTION fun_phone_from_idphone(inidphone integer) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';

BEGIN

IF inidphone>0 THEN
-- Obtenemos el phone 
SELECT phone INTO Retorno FROM phones WHERE idphone = inidphone;
IF Retorno IS NULL THEN
Retorno := '';
END IF;
END IF;


RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_phone_getdata_string(inidphone integer, prefix text, stringfields text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

i_strings              refcursor := null;
i_string                text[];
i_query                text;

Retorno TEXT DEFAULT '';
PhonesROWDATA   phones%ROWTYPE;

BEGIN

Retorno := trim(stringfields);
prefix := '&'||prefix::text;

SELECT * INTO PhonesROWDATA FROM phones WHERE idphone = inidphone;
  
--Retorno := fun_address_getdata_string(PhonesROWDATA.idaddress, Retorno);

    i_query := 'select regexp_matches('''||Retorno||''', '''||prefix||'(\d\d)'',''g'')';
    open i_strings for execute i_query; 
    if i_strings is not null then
        loop    fetch i_strings into i_string;
        exit when not found;
--    raise notice 'row4 = %',Retorno;                                                
CASE   
	WHEN i_string[1] = '01' THEN
Retorno := replace(Retorno, prefix||'01', COALESCE(PhonesROWDATA.idphone::text, ''));

	WHEN i_string[1] = '02' THEN
Retorno := replace(Retorno, prefix||'02', COALESCE(PhonesROWDATA.idcontact::text, ''));

	WHEN i_string[1] = '03' THEN
Retorno := replace(Retorno, prefix||'03', COALESCE(PhonesROWDATA.enable::text, ''));

	WHEN i_string[1] = '04' THEN
Retorno := replace(Retorno, prefix||'04', COALESCE(PhonesROWDATA.idprovider::text,''));

	WHEN i_string[1] = '05' THEN
Retorno := replace(Retorno, prefix||'05', COALESCE(PhonesROWDATA.phone::text,''));

	WHEN i_string[1] = '06' THEN
Retorno := replace(Retorno, prefix||'06', COALESCE(PhonesROWDATA.phone_ext::text,''));

	WHEN i_string[1] = '07' THEN
Retorno := replace(Retorno, prefix||'07', COALESCE(PhonesROWDATA.typephone::text,''));

	WHEN i_string[1] = '08' THEN
Retorno := replace(Retorno, prefix||'08', COALESCE(PhonesROWDATA.ubiphone::text,''));

	WHEN i_string[1] = '09' THEN
Retorno := replace(Retorno, prefix||'09', COALESCE(PhonesROWDATA.idaddress::text,''));

	WHEN i_string[1] = '10' THEN
Retorno := replace(Retorno, prefix||'10', COALESCE(PhonesROWDATA.note::text,''));

ELSE
-- No concide con ninguno
--Retorno := Retorno;
END CASE;
                                
        end loop;
        close i_strings;
    end if;




RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_phone_idphone_check(inidphone integer, inphone text, OUT outidphone integer, OUT outphone text) RETURNS record
    LANGUAGE plpgsql
    AS $$DECLARE
retorno INTEGER DEFAULT -1; 

BEGIN

-- Verificamos que los datos sea validos 
IF char_length(inphone) > 0 OR  inidphone > 0 THEN

IF inidphone>0 THEN
-- Si se pasa el idphone como parametro se obtiene el phone desde la tabla phones segun ese id
outidphone := inidphone;
outphone := fun_phone_from_idphone(outidphone);

ELSE
-- Si inidphone <= 0 tratamos de obtenerlo usando el inphone
outphone := inphone;
outidphone := fun_idphone_from_phone(outphone);
END IF;

ELSE
-- Valores vacios
outphone := 0;
outidphone := '';

END IF;

RETURN;
END;$$;",usms.sql
"CREATE FUNCTION fun_phone_search_by_number(inphone text) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
Retorno INTEGER DEFAULT -1;

BEGIN

SELECT idphone INTO Retorno FROM phones WHERE upper(trim(phone)) = upper(trim(inphone)) LIMIT 1;

IF Retorno<1 OR Retorno IS NULL THEN
Retorno := 0;
END IF;

RETURN Retorno;
END;$$;",usms.sql
"CREATE FUNCTION fun_phones_table_xml(inidphone integer, inidcontact integer, inenable boolean, inphone text, intypephone integer, inidprovider integer, inphone_ext text, inidaddress integer, inubiphone integer, innote text, ts timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor;
Retorno TEXT DEFAULT '';

BEGIN

OPEN CursorResultado FOR SELECT * FROM fun_phones_table(inidphone, inidcontact, inenable, inphone, intypephone, inidprovider, inphone_ext, inidaddress, inubiphone, innote, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_provider_edit_xml(inidprovider integer, inenable boolean, incimi text, inname text, innote text, ints timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor;
Retorno TEXT DEFAULT '';

BEGIN

OPEN CursorResultado FOR SELECT * FROM fun_provider_edit(inidprovider, inenable , incimi, inname , innote,  ints, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_providers_idname_xml(fieldtextasbase64 boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN
IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idprovider, enable, encode(name::bytea, 'base64') AS name FROM provider;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idcontact, enable, name FROM provider;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_receiver_from_incomingsmss(OUT outsmss integer, OUT outeventsgenerated integer) RETURNS record
    LANGUAGE plpgsql
    AS $$DECLARE


BEGIN


RETURN;
END;$$;",usms.sql
"CREATE FUNCTION fun_sim_table_edit_xml(inidsim integer, inidprovider integer, inenable boolean, inphone text, insmsout_request_reports boolean, insmsout_retryonfail integer, insmsout_max_length integer, insmsout_max_lifetime integer, insmsout_enabled_other_providers boolean, inidmodem integer, inon_incommingcall integer, innote text, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor;
Retorno TEXT DEFAULT '';

BEGIN

OPEN CursorResultado FOR SELECT * FROM fun_sim_table_edit(inidsim, inidprovider, inenable, inphone, insmsout_request_reports, insmsout_retryonfail, insmsout_max_length, insmsout_max_lifetime, insmsout_enabled_other_providers, inidmodem, inon_incommingcall, innote, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 10, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_contact_notif_eventtypes(inidaccount integer, inidphone integer, fieldtextasbase64 boolean, OUT idnotifaccount integer, OUT ideventtype integer, OUT enable boolean, OUT label text, OUT ts timestamp without time zone) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$DECLARE

CursorEventtypes refcursor; 

ROWDATAEventType   usaga.eventtypes%ROWTYPE;
ROWDATANET   usaga.account_notifications_eventtype%ROWTYPE;

InternalIdNotifAccount INTEGER DEFAULT 0;


BEGIN

SELECT usaga.account_notifications.idnotifaccount INTO InternalIdNotifAccount FROM usaga.account_notifications WHERE idphone = inidphone AND idaccount = inidaccount LIMIT 1;

IF InternalIdNotifAccount > 0 THEN

OPEN CursorEventtypes FOR SELECT * FROM usaga.eventtypes ORDER BY label;
    loop    

        FETCH CursorEventtypes INTO ROWDATAEventType;
        EXIT WHEN NOT FOUND;

IF EXISTS(SELECT usaga.account_notifications_eventtype.idnotifphoneeventtype FROM usaga.account_notifications_eventtype WHERE usaga.account_notifications_eventtype.idnotifaccount = InternalIdNotifAccount AND usaga.account_notifications_eventtype.ideventtype = ROWDATAEventType.ideventtype LIMIT 1) THEN
SELECT * INTO ROWDATANET FROM usaga.account_notifications_eventtype WHERE usaga.account_notifications_eventtype.idnotifaccount = InternalIdNotifAccount AND usaga.account_notifications_eventtype.ideventtype = ROWDATAEventType.ideventtype LIMIT 1;
IF fieldtextasbase64 THEN
RETURN QUERY SELECT InternalIdNotifAccount::integer, ROWDATAEventType.ideventtype::integer, 'true'::boolean, encode(ROWDATAEventType.label::bytea, 'base64'), ROWDATANET.ts::timestamp without time zone;
ELSE
RETURN QUERY SELECT InternalIdNotifAccount::integer, ROWDATAEventType.ideventtype::integer, 'true'::boolean, ROWDATAEventType.label::text, ROWDATANET.ts::timestamp without time zone;
END IF;

ELSE

IF fieldtextasbase64 THEN
RETURN QUERY SELECT InternalIdNotifAccount::integer, ROWDATAEventType.ideventtype::integer, 'false'::boolean, encode(ROWDATAEventType.label::bytea, 'base64'), '1900-01-01 00:00'::timestamp without time zone;
ELSE
RETURN QUERY SELECT InternalIdNotifAccount::integer, ROWDATAEventType.ideventtype::integer, 'false'::boolean, ROWDATAEventType.label::text, '1900-01-01 00:00'::timestamp without time zone;
END IF;



END IF;

    end loop;
    CLOSE CursorEventtypes;

END IF;

END
$$;",usms.sql
"CREATE FUNCTION fun_view_account_contact_notif_eventtypes_xml(inidaccount integer, inidphone integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_view_account_contact_notif_eventtypes(inidaccount, inidphone, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_contacts_xml(inidaccount integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idaccount, idcontact, enable, encode(firstname::bytea, 'base64') AS firstname, encode(lastname::bytea, 'base64') AS lastname, prioritycontact, enable_as_contact, encode(appointment::bytea, 'base64') as appointment, ts FROM usaga.view_account_contacts WHERE idaccount = inidaccount;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM usaga.view_account_contacts WHERE idaccount = inidaccount;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_events_xml(inidaccount integer, datestart timestamp without time zone, dateend timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idevent, dateload, CASE WHEN idaccount IS NULL THEN '0' ELSE idaccount END AS idaccount, CASE WHEN partition IS NULL THEN '0' ELSE partition END AS partition, CASE WHEN enable IS NULL THEN 'false' ELSE enable END AS enable, CASE WHEN account IS NULL THEN encode('System'::bytea, 'base64') ELSE encode(account::bytea, 'base64') END AS account, CASE WHEN name IS NULL THEN encode('uSAGA'::bytea, 'base64') ELSE encode(name::bytea, 'base64') END AS name, CASE WHEN type IS NULL THEN '0' ELSE type END AS type, encode(code::bytea, 'base64') as code, zu, priority, encode(description::bytea, 'base64') as description, ideventtype, datetimeevent, encode(eventtype::bytea, 'base64') AS eventtype, process1, process2, process3, process4, process5, dateprocess1, dateprocess2, dateprocess3, dateprocess4, dateprocess5 FROM usaga.view_events WHERE idaccount = inidaccount AND dateload BETWEEN datestart AND dateend ORDER BY idevent DESC;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idevent, dateload, CASE WHEN idaccount IS NULL THEN '0' ELSE idaccount END AS idaccount, CASE WHEN partition IS NULL THEN '0' ELSE partition END AS partition, CASE WHEN enable IS NULL THEN 'false' ELSE enable END AS enable, CASE WHEN account IS NULL THEN 'System' ELSE account END AS account, CASE WHEN name IS NULL THEN 'uSAGA' ELSE name END AS name, CASE WHEN type IS NULL THEN '0' ELSE type END AS type, code, zu, priority, description, ideventtype, eventtype, datetimeevent, process1, process2, process3, process4, process5, dateprocess1, dateprocess2, dateprocess3, dateprocess4, dateprocess5 FROM usaga.view_events WHERE idaccount = inidaccount AND dateload BETWEEN datestart AND dateend ORDER BY idevent DESC;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_location_byid_xml(inidaccount integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idaddress, geox, geoy  FROM address WHERE idaddress = (SELECT idaddress FROM usaga.account WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 20, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idaddress, geox, geoy  FROM address WHERE idaddress = (SELECT idaddress FROM usaga.account WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 20, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_notif_phones(inidaccount integer, inidcontact integer, fieldtextasbase64 boolean, OUT idnotifcontact integer, OUT idaccount integer, OUT idcontact integer, OUT idphone integer, OUT phone_enable boolean, OUT type integer, OUT idprovider integer, OUT phone text, OUT priority integer, OUT call boolean, OUT sms boolean, OUT smstext text, OUT note text, OUT ts timestamp without time zone) RETURNS SETOF record
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE

--CursorViewContactsPhonesAddress CURSOR FOR SELECT * FROM view_contacts_phones WHERE view_contacts_phones.idcontact = inidcontact;
CursorViewContactsPhonesAddress refcursor; 

ROWDATAViewContact   public.view_contacts_phones%ROWTYPE;
ROWDATAAccNotif   usaga.account_notifications%ROWTYPE;

BEGIN

IF EXISTS(SELECT phones.idphone FROM phones WHERE phones.idcontact = inidcontact) THEN

OPEN CursorViewContactsPhonesAddress FOR SELECT * FROM view_contacts_phones WHERE view_contacts_phones.idcontact = inidcontact;
    loop    

        FETCH CursorViewContactsPhonesAddress INTO ROWDATAViewContact;
        EXIT WHEN NOT FOUND;
--fieldtextasbase64
IF EXISTS(SELECT usaga.account_notifications.idnotifaccount FROM usaga.account_notifications WHERE usaga.account_notifications.idaccount = inidaccount AND usaga.account_notifications.idphone = ROWDATAViewContact.idphone LIMIT 1) THEN
SELECT * INTO ROWDATAAccNotif FROM usaga.account_notifications WHERE usaga.account_notifications.idaccount = inidaccount AND usaga.account_notifications.idphone = ROWDATAViewContact.idphone LIMIT 1;

IF fieldtextasbase64 THEN
RETURN QUERY SELECT ROWDATAAccNotif.idnotifaccount::integer, inidaccount::integer, ROWDATAViewContact.idcontact::integer, ROWDATAViewContact.idphone::integer, ROWDATAViewContact.phone_enable::boolean, ROWDATAViewContact.type::integer, ROWDATAViewContact.idprovider::integer, encode(ROWDATAViewContact.phone::bytea, 'base64'), ROWDATAAccNotif.priority::integer, ROWDATAAccNotif.call::boolean, ROWDATAAccNotif.sms::boolean, encode(ROWDATAAccNotif.smstext::bytea, 'base64'), encode(ROWDATAAccNotif.note::bytea, 'base64'), ROWDATAAccNotif.ts::timestamp without time zone;
ELSE
RETURN QUERY SELECT ROWDATAAccNotif.idnotifaccount::integer, inidaccount::integer, ROWDATAViewContact.idcontact::integer, ROWDATAViewContact.idphone::integer, ROWDATAViewContact.phone_enable::boolean, ROWDATAViewContact.type::integer, ROWDATAViewContact.idprovider::integer, ROWDATAViewContact.phone::text, ROWDATAAccNotif.priority::integer, ROWDATAAccNotif.call::boolean, ROWDATAAccNotif.sms::boolean, ROWDATAAccNotif.smstext::text, ROWDATAAccNotif.note::text, ROWDATAAccNotif.ts::timestamp without time zone;
END IF;

ELSE

IF fieldtextasbase64 THEN
RETURN QUERY SELECT '0'::integer, inidaccount::integer, ROWDATAViewContact.idcontact::integer, ROWDATAViewContact.idphone::integer, ROWDATAViewContact.phone_enable::boolean, ROWDATAViewContact.type::integer, ROWDATAViewContact.idprovider::integer, encode(ROWDATAViewContact.phone::bytea, 'base64'), '0'::integer, 'false'::boolean, 'false'::boolean, ''::text, ''::text, '1990-01-01 00:00'::timestamp without time zone;
ELSE
RETURN QUERY SELECT '0'::integer, inidaccount::integer, ROWDATAViewContact.idcontact::integer, ROWDATAViewContact.idphone::integer, ROWDATAViewContact.phone_enable::boolean, ROWDATAViewContact.type::integer, ROWDATAViewContact.idprovider::integer, ROWDATAViewContact.phone::text, '0'::integer, 'false'::boolean, 'false'::boolean, ''::text, ''::text, '1990-01-01 00:00'::timestamp without time zone;
END IF;



END IF;

    end loop;
    CLOSE CursorViewContactsPhonesAddress;

END IF;

END
$$;",usms.sql
"CREATE FUNCTION fun_view_account_notif_phones_xml(inidaccount integer, inidcontact integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    AS $$DECLARE

CursorResultado refcursor; 
Retorno TEXT DEFAULT '';

BEGIN
OPEN CursorResultado FOR SELECT * FROM usaga.fun_view_account_notif_phones(inidaccount, inidcontact, fieldtextasbase64);
SELECT * FROM cursor_to_xml(CursorResultado, 1000, false, false, '') INTO Retorno;
CLOSE CursorResultado;
RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_unregistered_contacts_xml(inidaccount integer, fieldtextasbase64 boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idcontact, enable, encode((lastname ||' '||firstname)::bytea, 'base64') AS name FROM contacts WHERE idcontact NOT IN (SELECT idcontact FROM usaga.account_contacts WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idcontact, enable, (lastname ||' '||firstname) AS name FROM contacts WHERE idcontact NOT IN (SELECT idcontact FROM usaga.account_contacts WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_unregistered_users_xml(inidaccount integer, fieldtextasbase64 boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idcontact, enable, encode((lastname ||' '||firstname)::bytea, 'base64') AS name FROM contacts WHERE idcontact NOT IN (SELECT idcontact FROM usaga.account_users WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idcontact, enable, (lastname ||' '||firstname) AS name FROM contacts WHERE idcontact NOT IN (SELECT idcontact FROM usaga.account_users WHERE idaccount = inidaccount);
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_user_byidaccountidcontact_xml(inidaccount integer, inidcontact integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT  idaccount, idcontact, encode(firstname::bytea, 'base64') AS firstname, encode(lastname::bytea, 'base64') AS lastname, prioritycontact, enable, encode(appointment::bytea, 'base64') AS appointment, enable_as_user, encode(keyword::bytea, 'base64') AS keyword, encode(pwd::bytea, 'base64') AS pwd, numuser, encode(note_user::bytea, 'base64') AS note_user, ts FROM usaga.view_account_users WHERE idaccount = inidaccount AND idcontact = inidcontact LIMIT 1;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM  usaga.view_account_users WHERE idaccount = inidaccount AND idcontact = inidcontact LIMIT 1;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_account_users_xml(inidaccount integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT  idaccount, idcontact, prioritycontact, enable, encode(firstname::bytea, 'base64') AS firstname, encode(lastname::bytea, 'base64') AS lastname, encode(appointment::bytea, 'base64') AS appointment, enable_as_user, numuser FROM usaga.view_account_users WHERE idaccount = inidaccount;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM  usaga.view_account_users WHERE idaccount = inidaccount;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_address_byid_xml(inidaddress integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idaddress, idlocation, geox, geoy, encode(field1::bytea, 'base64') AS field1, 
encode(field2::bytea, 'base64') AS field2, 
encode(field3::bytea, 'base64') AS field3, 
encode(field4::bytea, 'base64') AS field4, 
encode(field5::bytea, 'base64') AS field5, 
encode(field6::bytea, 'base64') AS field6, 
encode(field7::bytea, 'base64') AS field7, 
encode(field8::bytea, 'base64') AS field8, 
encode(field9::bytea, 'base64') AS field9, 
encode(field10::bytea, 'base64') AS field10,
encode(geourl::bytea, 'base64') AS geourl,
ts 
 FROM address WHERE idaddress = inidaddress;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM address WHERE idaddress = inidaddress;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_view_contacts_byidcontact_xml(inidcontact integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idcontact, enable, encode(title::bytea, 'base64') AS title, encode(firstname::bytea, 'base64') AS firstname, encode(lastname::bytea, 'base64') AS lastname, gender, birthday, typeofid, encode(identification::bytea, 'base64') AS identification, encode(web::bytea, 'base64') as web, encode(email1::bytea, 'base64') as email1, encode(email2::bytea, 'base64') as email2, encode(note::bytea, 'base64') AS note, idaddress, ts   FROM contacts WHERE idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM contacts  WHERE idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_contacts_to_list_xml(fieldtextasbase64 boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idcontact, enable, encode((lastname ||' '||firstname)::bytea, 'base64') AS name FROM contacts;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idcontact, enable, (lastname ||' '||firstname) AS name FROM contacts;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_eventtypes_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT  ideventtype, encode(name::bytea, 'base64') AS name, priority, accountdefault, groupdefault, encode(label::bytea, 'base64') AS label, encode(note::bytea, 'base64') AS note, ts FROM usaga.eventtypes ORDER BY ideventtype;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM usaga.eventtypes ORDER BY label, name;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_groups_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT  idgroup, enable, encode(name::bytea, 'base64') AS name, encode(note::bytea, 'base64') AS note, ts FROM usaga.groups ORDER BY idgroup;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM usaga.groups ORDER BY idgroup;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_idaccounts_names_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idaccount, encode(name::bytea, 'base64') AS name FROM usaga.account ORDER BY name;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idaccount, name FROM usaga.account ORDER BY name;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_idgroup_name_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT  idgroup, encode(name::bytea, 'base64') AS name FROM usaga.groups ORDER BY idgroup;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idgroup, name FROM usaga.groups ORDER BY idgroup;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_incomingcalls_xml(datestart timestamp without time zone, dateend timestamp without time zone, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idincall, datecall, idport, idphone, callaction, encode(phone::bytea, 'base64') AS phone, flag1, flag2, flag3, flag4, flag5, idmodem, encode(note::bytea, 'base64') AS note, ts FROM incomingcalls WHERE datecall BETWEEN datestart AND dateend ORDER BY datecall DESC;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM incomingcalls WHERE datecall BETWEEN datestart AND dateend ORDER BY datecall DESC;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_last_events_xml(rows integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idevent, dateload, CASE WHEN idaccount IS NULL THEN '0' ELSE idaccount END AS idaccount, CASE WHEN partition IS NULL THEN '0' ELSE partition END AS partition, CASE WHEN enable IS NULL THEN 'false' ELSE enable END AS enable, CASE WHEN account IS NULL THEN encode('System'::bytea, 'base64') ELSE encode(account::bytea, 'base64') END AS account, CASE WHEN name IS NULL THEN encode('uSAGA'::bytea, 'base64') ELSE encode(name::bytea, 'base64') END AS name, CASE WHEN type IS NULL THEN '0' ELSE type END AS type, encode(code::bytea, 'base64') as code, zu, priority, encode(description::bytea, 'base64') as description, ideventtype, datetimeevent, encode(eventtype::bytea, 'base64') AS eventtype, process1, process2, process3, process4, process5, dateprocess1, dateprocess2, dateprocess3, dateprocess4, dateprocess5 FROM usaga.view_events ORDER BY idevent DESC LIMIT rows;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idevent, dateload, CASE WHEN idaccount IS NULL THEN '0' ELSE idaccount END AS idaccount, CASE WHEN partition IS NULL THEN '0' ELSE partition END AS partition, CASE WHEN enable IS NULL THEN 'false' ELSE enable END AS enable, CASE WHEN account IS NULL THEN 'System' ELSE account END AS account, CASE WHEN name IS NULL THEN 'uSAGA' ELSE name END AS name, CASE WHEN type IS NULL THEN '0' ELSE type END AS type, code, zu, priority, description, ideventtype, eventtype, datetimeevent, process1, process2, process3, process4, process5, dateprocess1, dateprocess2, dateprocess3, dateprocess4, dateprocess5 FROM usaga.view_events ORDER BY idevent DESC LIMIT rows;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_location_level_xml(l integer, idfk integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;
query TEXT DEFAULT '';

BEGIN

CASE  
	WHEN l = 1 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl1, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level1';
ELSE
query:= 'SELECT * FROM location_level1;';
END IF;

	WHEN l = 2 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl2, idl1, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level2 WHERE idl1 = '||idfk::text;
ELSE
query:= 'SELECT * FROM location_level2 WHERE idl1 = '||idfk::text;
END IF;

	WHEN l = 3 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl3, idl2, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level3 WHERE idl2 = '||idfk::text;
ELSE
query:= 'SELECT * FROM location_level3 WHERE idl2 = '||idfk::text;
END IF;


	WHEN l = 4 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl4, idl3, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level4 WHERE idl3 = '||idfk::text;
ELSE
query:= 'SELECT * FROM location_level4 WHERE idl3 = '||idfk::text;
END IF;

	WHEN l = 5 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl5, idl4, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level5 WHERE idl4 = '||idfk::text;
ELSE
query:= 'SELECT * FROM location_level5 WHERE idl4 = '||idfk::text;
END IF;

	WHEN l = 6 THEN
IF fieldtextasbase64 THEN
query := 'SELECT idl6, idl5, encode(name::bytea, ''base64'') as name, encode(code::bytea, ''base64'') as code, ts FROM location_level6 WHERE idl5 = '||idfk::text;
ELSE
query:= 'SELECT * FROM location_level6 WHERE idl5 = '||idfk::text;
END IF;


ELSE
Retorno :='';
END CASE;

IF length(query) > 0 THEN
OPEN CursorResult FOR EXECUTE query;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;
END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_locations_ids_from_idlocation_xml(inidlocation numeric) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

OPEN CursorResult FOR SELECT * FROM view_location_idlocation WHERE idlocation = inidlocation;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_notification_templates_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idnotiftempl, encode(description::bytea, 'base64') AS description, encode(message::bytea, 'base64') AS message, ts FROM usaga.notification_templates;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM usaga.notification_templates;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_outgoing_view_filter_xml(datestart timestamp without time zone, dateend timestamp without time zone, maxrows integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idsmsout, idowner, dateload, idsim, idsmstype, idcontact, idphone, enable, typephone, encode(phone::bytea, 'base64') AS phone, idprovider, encode(message::bytea, 'base64') AS message, datetosend, priority, report, enablemessageclass, messageclass, status, encode(note::bytea, 'base64') AS note, ts FROM view_outgoing_idphone WHERE datetosend BETWEEN datestart AND dateend ORDER BY datetosend DESC LIMIT maxrows;
SELECT * FROM cursor_to_xml(CursorResult, maxrows+1, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM view_outgoing_idphone WHERE datetosend BETWEEN datestart AND dateend ORDER BY datetosend DESC LIMIT maxrows;
SELECT * FROM cursor_to_xml(CursorResult, maxrows+1, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_phones_byid_xml(inidphone integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idphone, idcontact, enable, encode(phone::bytea, 'base64') as phone, typephone, idprovider, encode(note::bytea, 'base64') as note, idaddress, encode(phone_ext::bytea, 'base64') as phone_ext, ubiphone, ts FROM phones WHERE idphone = inidphone;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM phones WHERE idphone = inidphone;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_phones_byidcontact_simplified_xml(inidcontact integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idphone, idcontact, enable, encode(phone::bytea, 'base64') as phone, idprovider FROM phones WHERE idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT idphone, idcontact, enable, phone, idprovider FROM phones WHERE idcontact = inidcontact;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_provider_table_xml(fieldtextasbase64 boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idprovider, enable, encode(cimi::bytea, 'base64') AS cimi, encode(name::bytea, 'base64') AS name, encode(note::bytea, 'base64') AS note, ts FROM provider;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM provider;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';
END;$$;",usms.sql
"CREATE FUNCTION fun_view_sim_xml(fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idsim, idprovider, enable, encode(phone::bytea, 'base64') AS phone, smsout_request_reports, smsout_retryonfail, smsout_max_length, smsout_max_lifetime, smsout_enabled_other_providers, idmodem,  on_incommingcall, ts, encode(note::bytea, 'base64') AS note  FROM sim;

SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM sim;
SELECT * FROM cursor_to_xml(CursorResult, 1000, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION fun_view_smsin_table_filter_xml(datestart timestamp without time zone, dateend timestamp without time zone, maxrows integer, fieldtextasbase64 boolean) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE

Retorno TEXT DEFAULT '';
CursorResult refcursor;

BEGIN

IF fieldtextasbase64 THEN

OPEN CursorResult FOR SELECT idsmsin, dateload, idprovider, idphone, encode(phone::bytea, 'base64') AS phone, datesms, encode(message::bytea, 'base64') AS message, idport, status, flag1, flag2, flag3, flag4, flag5, encode(note::bytea, 'base64') AS note, ts FROM smsin WHERE dateload BETWEEN datestart AND dateend ORDER BY dateload DESC LIMIT maxrows;
SELECT * FROM cursor_to_xml(CursorResult, maxrows+1, false, false, '') INTO Retorno;
CLOSE CursorResult;

ELSE

OPEN CursorResult FOR SELECT * FROM smsin WHERE dateload BETWEEN datestart AND dateend ORDER BY dateload DESC LIMIT maxrows;
SELECT * FROM cursor_to_xml(CursorResult, maxrows+1, false, false, '') INTO Retorno;
CLOSE CursorResult;

END IF;

RETURN '<table>'||Retorno||'</table>';

END;$$;",usms.sql
"CREATE FUNCTION func(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE 
priceIn ALIAS FOR $1;
BEGIN
RETURN (SELECT Product.model 
       FROM Product, PC
       WHERE Product.model = PC.model
       ORDER BY abs(PC.price - priceIn)
       LIMIT 1);
END;
$_$;",dump_postgres_15_11.sql
"CREATE FUNCTION fverifmvt() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	_qtt_prov	 int8;
	_qtt		 int8;
	_uuid		 text;
	_qtta		 int8;
	_npa		 int;
	_npb		 int;
	_np		 int;
	_cnterr		 int := 0;
	_iserr		 bool;
BEGIN
	
	FOR _qtt_prov,_qtt,_uuid,_np IN SELECT qtt_prov,qtt,uuid,np FROM vorderverif LOOP
	
		_iserr := false;
	
		SELECT sum(qtt),max(nat),min(nat) INTO _qtta,_npa,_npb 
			FROM vmvtverif WHERE oruuid=_uuid GROUP BY oruuid;
			
		IF(	FOUND ) THEN 
			IF(	(_qtt_prov != _qtta+_qtt) 
				-- NOT vorderverif.qtt_prov == vorderverif.qtt + sum(mvt.qtt)
				OR (_np != _npa)	
				-- NOT mvt.nat == vorderverif.nat 
				OR (_npa != _npb)
				-- NOT all mvt.nat are the same 
			)	THEN 
				_iserr := true;
				
			END IF;	
		END IF;
		
		IF(_iserr) THEN
			_cnterr := _cnterr +1;
			RAISE NOTICE 'error on uuid:%',_uuid;
		END IF;
	END LOOP;

	RETURN _cnterr;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fverifmvt2() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	_cnterr		 int := 0;
	_cnterrtot	 int := 0;
	_mvt		 tmvt%rowtype;
	_mvtprec	 tmvt%rowtype;
	_mvtfirst	 tmvt%rowtype;
	_uuiderr	 text;
	_cnt		 int;		-- count mvt in agreement
BEGIN
		
	_mvtprec.grp := NULL;_mvtfirst.grp := NULL;
	_uuiderr := NULL;
	FOR _mvt IN SELECT id,uuid,nb,oruuid,grp,own_src,own_dst,qtt,nat FROM vmvtverif ORDER BY grp,uuid ASC  LOOP
		IF(_mvt.grp != _mvtprec.grp) THEN -- first mvt of agreement
			--> finish last agreement
			IF NOT (_mvtprec.grp IS NULL OR _mvtfirst.grp IS NULL) THEN
				_cnterr := _cnterr + fverifmvt2_int(_mvtprec,_mvtfirst);
				_cnt := _cnt +1;
				
				if(_cnt != _mvtprec.nb) THEN
					_cnterr := _cnterr +1;
					RAISE NOTICE 'wrong number of movements for agreement %',_mvtprec.oruuid;
				END IF;
				-- errors found
				if(_cnterr != 0) THEN
					_cnterrtot := _cnterr + _cnterrtot;
					IF(_uuiderr IS NULL) THEN
						_uuiderr := _mvtprec.oruuid;
					END IF;
				END IF;
			END IF;
			--< A
			_mvtfirst := _mvt;
			_cnt := 0;
			_cnterr := 0;
		ELSE
			_cnterr := _cnterr + fverifmvt2_int(_mvtprec,_mvt);
			_cnt := _cnt +1;
		END IF;
		_mvtprec := _mvt;
	END LOOP;
	--> finish last agreement
	IF NOT (_mvtprec.grp IS NULL OR _mvtfirst.grp IS NULL) THEN
		_cnterr := _cnterr + fverifmvt2_int(_mvtprec,_mvtfirst);
		_cnt := _cnt +1;
		
		if(_cnt != _mvtprec.nb) THEN
			_cnterr := _cnterr +1;
			RAISE NOTICE 'wrong number of movements for agreement %',_mvtprec.oruuid;
		END IF;
		-- errors found
		if(_cnterr != 0) THEN
			_cnterrtot := _cnterr + _cnterrtot;
			IF(_uuiderr IS NULL) THEN
				_uuiderr := _mvtprec.oruuid;
			END IF;
		END IF;
	END IF;
	--< A
	IF(_cnterrtot != 0) THEN
		RAISE NOTICE 'mvt.oruuid= % is the first agreement where an error is found',_uuiderr;
		RETURN _cnterrtot;
	ELSE
		RETURN 0;
	END IF;
END;
$$;",simu_ref.sql
"CREATE FUNCTION fverifmvt2_int(_mvtprec tmvt, _mvt tmvt) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	_o		vorderverif%rowtype;
BEGIN
	SELECT uuid,np,nr,qtt_prov,qtt_requ INTO _o.uuid,_o.np,_o.nr,_o.qtt_prov,_o.qtt_requ FROM vorderverif WHERE uuid = _mvt.oruuid;
	IF (NOT FOUND) THEN
		RAISE NOTICE 'order not found for vorderverif %',_mvt.oruuid;
		RETURN 1;
	END IF;

	IF(_o.np != _mvt.nat OR _o.nr != _mvtprec.nat) THEN
		RAISE NOTICE 'mvt.nat != np or mvtprec.nat!=nr';
		RETURN 1;
	END IF;
	
	-- NOT(_o.qtt_prov/_o.qtt_requ >= _mvt.qtt/_mvtprec.qtt)
	IF(((_o.qtt_prov::float8) / (_o.qtt_requ::float8)) < ((_mvt.qtt::float8)/(_mvtprec.qtt::float8))) THEN
		RAISE NOTICE 'order %->%, with  mvt %->%',_o.qtt_requ,_o.qtt_prov,_mvtprec.qtt,_mvt.qtt;
		RAISE NOTICE '% < 1; should be >=1',(((_o.qtt_prov::float8) / (_o.qtt_requ::float8)) / ((_mvt.qtt::float8)/(_mvtprec.qtt::float8)));
		RAISE NOTICE 'order.uuid %, with  mvtid %->%',_o.uuid,_mvtprec.id,_mvt.id;
		RETURN 1;
	END IF;


	RETURN 0;
END;
$$;",simu_ref.sql
"CREATE FUNCTION garage_actions_account(bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE 
	gid bigint;
BEGIN
	select id into gid from garage where account_id = $1 limit 1;
	return garage_actions(gid);
END$_$;",streetking-database.sql
"CREATE FUNCTION gen_part_instance_3d_model(bigint, text, bigint, text, text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE COST 10
    AS $_$DECLARE 

	ptid alias for $1;
	ptname alias for $2;
	d3dmid alias for $3;
	d3dname alias for $4;
	cmname alias for $5;
	mfname alias for $6;
	

BEGIN
	if ptid = 11 then -- body kit
		return replace(lower(d3dname || '/'::text || btrim(mfname) || ' '::text || btrim(cmname) || '/body_kit_'::text || d3dmid || '.unity3d'::text), ' '::text, '_'::text);
	elseif ptid = 20 then -- car
		return replace(lower(d3dname || '/'::text || btrim(mfname) || ' '::text || btrim(cmname) || '/car.unity3d'::text), ' '::text, '_'::text);
	else
		return replace(lower(d3dname || '/'::text || btrim(ptname) || '_'::text || d3dmid || '.unity3d'::text), ' '::text, '_'::text);
	end if;
	
END$_$;",streetking-database.sql
"CREATE FUNCTION generate_random_string() RETURNS TEXT AS $$
DECLARE
  items TEXT[] =
    ARRAY[
      'AAAA','BBBB','CCCC','DDDD','EEEE','FFFF','GGGG',
      'HHHH','IIII','JJJJ','KKKK','LLLL','MMMM','NNNN',
      'OOOO','PPPP','QQQQ','RRRR','SSSS','TTTT','UUUU',
      'VVVV','WWWW','XXXX','YYYY','ZZZZ',
      '&amp;', '&#34;', '&#39;', '&#38;','&#60;','&#62;',
      '&#162;','&#163;','&#164;','&#165;','&#166;','&#167;',
      '&#168;','&#169;','&#170;','&#171;','&#172;','&#173;',
      '&#174;','&#175;','&#176;','&#177;','&#178;','&#179;',
      '&#180;','&#181;','&#182;','&#183;','&#184;','&#185;',
      '&#186;','&#187;','&#188;','&#189;','&#190;'
    ];
  length INTEGER := random(500, 1500);
  result TEXT := '';
  items_length INTEGER := array_length(items, 1);
BEGIN
  FOR x IN 1..length LOOP
    result := result || items[ random(1, items_length) ];
  END LOOP;

  RETURN result;
END;
$$ LANGUAGE PLPGSQL;",the-real-cost-of-data-roundtrip.html.md
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160222%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160227%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160307%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160308%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160310%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160312%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160315%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160325%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160510%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160513%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160524%20karental.sql
"CREATE FUNCTION generate_rent_code() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  random text := '';
  result text := '';
begin
  select random_string(5) into random;

  result = random;
  result = '123';
  
  return result;
end;
$$;",20160531%20karental.sql
"CREATE FUNCTION generateparts(text, text, text, text, text, text, integer, text DEFAULT NULL::text, text DEFAULT NULL::text) RETURNS TABLE(_partnumber text, _revision text, _serialnumber text, _sequencenumber integer, _itemfreqcode text)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pDocNumber ALIAS FOR $3;

	pDocType ALIAS FOR $4;

	pLocation ALIAS FOR $5;

	pPartState ALIAS FOR $6;

	pQty ALIAS FOR $7;

	pLine ALIAS FOR $8;

	pStation ALIAS FOR $9;

	i INTEGER;

  

BEGIN

	PERFORM (SELECT checkpriv('generateparts'));

	

	FOR i IN 1..pQty LOOP

		RETURN QUERY (SELECT * FROM generatepart(pItemNumber, pRevision, pDocNumber, pDocType, pLocation, pPartState, pLine, pStation));

	END LOOP;

	

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION generateserial(text, integer, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$DECLARE

	pPrefix ALIAS FOR $1;

	pSequenceNumber ALIAS FOR $2;

	pSerialPattern ALIAS FOR $3;

	_serialNumber TEXT;

	_serialPatternArray TEXT[];

	_sequenceLength INTEGER;

	_sequenceNumberPadded TEXT;

	_p TEXT;

	_i INTEGER;

	_c INTEGER;

	  

BEGIN

	PERFORM (SELECT checkpriv('generateserial'));

	

	SELECT string_to_array(pSerialPattern, '-') INTO _serialPatternArray;



	_serialNumber := pPrefix;

	

	_sequenceLength := (SELECT length(pSerialPattern) - length(regexp_replace(pSerialPattern, 'X', '', 'g')));

	_sequenceNumberPadded := (SELECT lpad(pSequenceNumber::TEXT, _sequenceLength, '0'));

	

	_c = 1;



	FOREACH _p IN ARRAY _serialPatternArray

	LOOP

		CASE 	WHEN _p LIKE 'Y%' THEN

				FOR _i IN 1..(SELECT length(_p)) 

				LOOP

					_serialNumber := _serialNumber || (SELECT FLOOR(RANDOM() * 10));

				END LOOP;

			WHEN _p LIKE 'X%' THEN

				_serialNumber := _serialNumber || (SELECT substr(_sequenceNumberPadded, _c, (SELECT length(_p))));

				_c := _c + length(_p);	

			ELSE

				_serialNumber := _serialNumber;

		END CASE;

	END LOOP;



	return _serialNumber;

END;$_$;",ames_dev.backup
"CREATE FUNCTION get_activity_code(proj_code character varying, task_summary character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (proj_code = 'JT01') AND (task_summary LIKE '%:%') THEN  
      RETURN trim( substring(task_summary,1,position(':' in task_summary)-1));
END IF;
RETURN null;
END;$$;",bgtTest.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_20160106.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_20160107.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_latest.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_production.backup
"CREATE FUNCTION get_all_config() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.configuration ;
      RETURN ref;
    END;
    $$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_all_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
      data.data_id, 
  data.management_id, 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  data.address2, 
  data.address3, 
  data.address4, 
  data.processed_dttm, 
  management.step, 
  management.assignment, 
  management.status,
      data_cleaning.sp_process_address1(address1) as adrress_correct1 ,
data_cleaning.sp_process_address2(address2) as adrress_correct2, 
data_cleaning.sp_process_address3(address3) as adrress_correct3,
data_cleaning.sp_process_address4(address4) as adrress_correct4
 FROM 
  data_cleaning.data, 
  data_cleaning.management
WHERE 
  data.management_id = management.management_id and management.step is null
order by data.data_id limit 10;	
      RETURN ref;
    END;
    $$;",data-cleaning_20160106.backup
"CREATE FUNCTION get_all_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
      data.data_id, 
  data.management_id, 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  data.address2, 
  data.address3, 
  data.address4, 
  data.processed_dttm, 
  management.step, 
  management.assignment, 
  management.status,
      data_cleaning.sp_process_address1(address1) as adrress_correct1 ,
data_cleaning.sp_process_address2(address2) as adrress_correct2, 
data_cleaning.sp_process_address3(address3) as adrress_correct3,
data_cleaning.sp_process_address4(address4) as adrress_correct4
 FROM 
  data_cleaning.data, 
  data_cleaning.management
WHERE 
  data.management_id = management.management_id and management.step is null
order by data.data_id limit 10;	
      RETURN ref;
    END;
    $$;",data-cleaning_latest.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_production.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.status = true
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_20160106.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.status = true
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_20160107.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.status = true
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_all_user_info() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.status = true
	order by user_id desc;	
      RETURN ref;
    END;
    $$;",data-cleaning_latest.backup
"CREATE FUNCTION get_approvalno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare no_out character varying;
begin

 --irul

select tahun||'.'||lpad(kode,2,'0')||'.'||lpad(no_urut::text,6,'0') into no_out
from bphtb_approval_final
where bphtb_approval_final.approval_id=$1;

return no_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_base_uom(_part_code character varying, _version_num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN 
    definition.uom_code
  FROM 
    inventory.information, 
    inventory.definition
  WHERE 
    information.id = definition.information_id AND
    information.part_code = _part_code AND 
    definition.version_num = _version_num;

END;
$$;",mdm.sql
"CREATE FUNCTION get_bayarno(spt_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare bayarno_out character varying;
begin

select tahun||lpad(sptno::text, 6, '0') into bayarno_out
from pad_spt s where s.id=$1;

return bayarno_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_berkaskeluarno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare no_out character varying;
begin

 --irul

select tahun||'.'||lpad(kode,2,'0')||'.'||lpad(no_urut::text,6,'0') into no_out
from bphtb_berkas_out
where bphtb_berkas_out.id=$1;

return no_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_berkasmasukno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare no_out character varying;
begin

 --irul

select tahun||'.'||lpad(kode,2,'0')||'.'||lpad(no_urut::text,6,'0') into no_out
from bphtb_berkas_in
where bphtb_berkas_in.id=$1;

return no_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_bulan(bulan integer, short boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
  bulan_out character varying;
begin

if $2 then
  if bulan=1 then 
    bulan_out:='Jan ';
  elseif bulan=2 then 
    bulan_out:='Peb ';
  elseif bulan=3 then 
    bulan_out:='Mar ';
  elseif bulan=4 then 
    bulan_out:='Apr ';
  elseif bulan=5 then 
    bulan_out:='Mei ';
  elseif bulan=6 then 
    bulan_out:='Jun ';
  elseif bulan=7 then 
    bulan_out:='Jul ';
  elseif bulan=8 then 
    bulan_out:='Agt ';
  elseif bulan=9 then 
    bulan_out:='Sep ';
  elseif bulan=10 then 
    bulan_out:='Okt ';
  elseif bulan=11 then 
    bulan_out:='Nop ';
  elseif bulan=12 then 
    bulan_out:='Des ';
  end if;
else
  if bulan=1 then 
    bulan_out:='Januari ';
  elseif bulan=2 then 
    bulan_out:='Pebruari ';
  elseif bulan=3 then 
    bulan_out:='Maret ';
  elseif bulan=4 then 
    bulan_out:='April ';
  elseif bulan=5 then 
    bulan_out:='Mei ' ;
  elseif bulan=6 then 
    bulan_out:='Juni ';
  elseif bulan=7 then 
    bulan_out:='Juli ';
  elseif bulan=8 then 
    bulan_out:='Agustus ';
  elseif bulan=9 then 
    bulan_out:='September ';
  elseif bulan=10 then 
    bulan_out:='Oktober ';
  elseif bulan=11 then 
    bulan_out:='Nopember ';
  elseif bulan=12 then 
    bulan_out:='Desember ';
  end if;
end if;

return bulan_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_bulan(bulan integer, short boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
  bulan_out character varying;
begin

if $2 then
  if bulan=1 then 
    bulan_out:='Jan ';
  elseif bulan=2 then 
    bulan_out:='Peb ';
  elseif bulan=3 then 
    bulan_out:='Mar ';
  elseif bulan=4 then 
    bulan_out:='Apr ';
  elseif bulan=5 then 
    bulan_out:='Mei ';
  elseif bulan=6 then 
    bulan_out:='Jun ';
  elseif bulan=7 then 
    bulan_out:='Jul ';
  elseif bulan=8 then 
    bulan_out:='Agt ';
  elseif bulan=9 then 
    bulan_out:='Sep ';
  elseif bulan=10 then 
    bulan_out:='Okt ';
  elseif bulan=11 then 
    bulan_out:='Nop ';
  elseif bulan=12 then 
    bulan_out:='Des ';
  end if;
else
  if bulan=1 then 
    bulan_out:='Januari ';
  elseif bulan=2 then 
    bulan_out:='Pebruari ';
  elseif bulan=3 then 
    bulan_out:='Maret ';
  elseif bulan=4 then 
    bulan_out:='April ';
  elseif bulan=5 then 
    bulan_out:='Mei ' ;
  elseif bulan=6 then 
    bulan_out:='Juni ';
  elseif bulan=7 then 
    bulan_out:='Juli ';
  elseif bulan=8 then 
    bulan_out:='Agustus ';
  elseif bulan=9 then 
    bulan_out:='September ';
  elseif bulan=10 then 
    bulan_out:='Oktober ';
  elseif bulan=11 then 
    bulan_out:='Nopember ';
  elseif bulan=12 then 
    bulan_out:='Desember ';
  end if;
end if;

return bulan_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_by_table_field_year_month_city_id(table_ character varying, field_ character varying, year_ integer, month_ integer, city_id bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN    
v_sql = '';
v_sql = v_sql || ' WITH RECURSIVE temp1(city_id, parent_city_id) AS ';
v_sql = v_sql || ' (';
v_sql = v_sql || ' SELECT  t1.city_id , t1.parent_city_id FROM ad_city t1 WHERE t1.city_id = '||cast($5 as varchar);
v_sql = v_sql || ' UNION ';
v_sql = v_sql || ' SELECT t2.city_id, t2.parent_city_id FROM ad_city t2 JOIN temp1 ON t2.parent_city_id = temp1.city_id';
v_sql = v_sql || ' )';
v_sql = v_sql || ' select coalesce(sum('||$2||'),null,0,sum('||$2||')) from '||$1||' t ';
v_sql = v_sql || ' join cm_time tm on t.time_id = tm.time_id and tm.year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar)||' ';
v_sql = v_sql || ' join cm_organization_place op on t.organization_id = op.organization_id and ';
v_sql = v_sql || ' op.city_id in (select city_id from temp1)';
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",1_first7_functions.sql
"CREATE FUNCTION get_by_table_field_year_month_municipality_id(table_ character varying, field_ character varying, year_ integer, month_ integer, municipality_id bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN    
v_sql = '';
v_sql = v_sql || ' WITH RECURSIVE temp1(municipality_id, parent_municipality_id) AS ';
v_sql = v_sql || ' (';
v_sql = v_sql || ' SELECT  t1.municipality_id , t1.parent_municipality_id FROM ad_municipality t1 WHERE t1.municipality_id = '||cast($5 as varchar);
v_sql = v_sql || ' UNION ';
v_sql = v_sql || ' SELECT t2.municipality_id, t2.parent_municipality_id FROM ad_municipality t2 JOIN temp1 ON t2.parent_municipality_id = temp1.municipality_id';
v_sql = v_sql || ' )';
v_sql = v_sql || ' select coalesce(sum('||$2||'),null,0,sum('||$2||')) from '||$1||' t ';
v_sql = v_sql || ' join cm_time tm on t.time_id = tm.time_id and tm.year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar)||' ';
v_sql = v_sql || ' join cm_organization_place op on t.organization_id = op.organization_id and ';
v_sql = v_sql || ' op.municipality_id in (select municipality_id from temp1)';
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",1_first7_functions.sql
"CREATE FUNCTION get_by_table_field_year_month_municipality_id(table_ character varying, field_ character varying, year_ integer, month_ integer, municipality_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' WITH RECURSIVE temp1(municipality_id, parent_municipality_id) AS ';
v_sql = v_sql || ' (';
v_sql = v_sql || ' SELECT  t1.municipality_id , t1.parent_municipality_id FROM ad_municipality t1 WHERE t1.municipality_id = '||cast($5 as varchar);
v_sql = v_sql || ' UNION ';
v_sql = v_sql || ' SELECT t2.municipality_id, t2.parent_municipality_id FROM ad_municipality t2 JOIN temp1 ON t2.parent_municipality_id = temp1.municipality_id';
v_sql = v_sql || ' )';
v_sql = v_sql || ' select coalesce(sum('||$2||'),null,0,sum('||$2||')) from '||$1||' t ';
v_sql = v_sql || ' join cm_time tm on t.time_id = tm.time_id and tm.year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar)||' ';
v_sql = v_sql || ' join cm_organization_place op on t.organization_id = op.organization_id and ';
v_sql = v_sql || ' op.municipality_id in (select municipality_id from temp1)';
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_by_table_field_year_month_organization_id(table_ character varying, field_ character varying, year_ integer, month_ integer, organization_id bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN    
v_sql = '';
v_sql = v_sql || ' select coalesce( '|| $2 ||',null,0,'|| $2 ||' )';
v_sql = v_sql || ' from '|| $1 ||' cb ';
v_sql = v_sql || ' join cm_organization o on cb.organization_id = o.organization_id ';
v_sql = v_sql || ' join cm_organization_place op on cb.organization_id = op.organization_id ';
v_sql = v_sql || ' join cm_time tm on tm.time_id = cb.time_id and year_ = '||cast($3 as varchar)||' and month_ = '||cast($4 as varchar)||' ';
v_sql = v_sql || ' where op.organization_id = ' || cast($5 as varchar);
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",1_first7_functions.sql
"CREATE FUNCTION get_by_table_field_year_month_organization_id(table_ character varying, field_ character varying, year_ integer, month_ integer, organization_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' select coalesce( '|| $2 ||',null,0,'|| $2 ||' )';
v_sql = v_sql || ' from '|| $1 ||' cb ';
v_sql = v_sql || ' join cm_organization o on cb.organization_id = o.organization_id ';
v_sql = v_sql || ' join cm_organization_place op on cb.organization_id = op.organization_id ';
v_sql = v_sql || ' join cm_time tm on tm.time_id = cb.time_id and year_ = '||cast($3 as varchar)||' and month_ = '||cast($4 as varchar)||' ';
v_sql = v_sql || ' where op.organization_id = ' || cast($5 as varchar);
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_by_table_field_year_month_state_id(table_ character varying, field_ character varying, year_ integer, month_ integer, statet_id bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN    
v_sql = '';
v_sql = v_sql || ' SELECT coalesce(sum(' || $2 || '),null,0,sum('|| $2 ||'))';
v_sql = v_sql || ' FROM ' || $1 || ' t ';
v_sql = v_sql || ' join cm_time tm on t.time_id = tm.time_id ';
v_sql = v_sql || ' join cm_organization_place op on t.organization_id = op.organization_id ';
v_sql = v_sql || ' WHERE ';
v_sql = v_sql || ' tm.year_ = ' || cast($3 as varchar)||' and ';
v_sql = v_sql || ' tm.month_ = '||cast($4 as varchar)||' and ';
v_sql = v_sql || ' op.state_id = ' || cast($5 as varchar);
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",1_first7_functions.sql
"CREATE FUNCTION get_by_table_field_year_month_state_id(table_ character varying, field_ character varying, year_ integer, month_ integer, statet_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' SELECT coalesce(sum(' || $2 || '),null,0,sum('|| $2 ||'))';
v_sql = v_sql || ' FROM ' || $1 || ' t ';
v_sql = v_sql || ' join cm_time tm on t.time_id = tm.time_id ';
v_sql = v_sql || ' join cm_organization_place op on t.organization_id = op.organization_id ';
v_sql = v_sql || ' WHERE ';
v_sql = v_sql || ' tm.year_ = ' || cast($3 as varchar)||' and ';
v_sql = v_sql || ' tm.month_ = '||cast($4 as varchar)||' and ';
v_sql = v_sql || ' op.state_id = ' || cast($5 as varchar);
EXECUTE v_sql INTO v_result /*USING $1, $2m, $3, $4, $5*/;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_callerid(peer_name character varying, number_b character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare

UID bigint;
DIR_ID bigint; 
CALLER_ID character varying; 

begin

select id from public.sip_peers where name=$1 into UID;
if not found then 
	raise exception 'NO SOURCE PEER/USER BY CHANNEL';
end if; 

--
-- gettting direction_id by number_b
-- 

select dr_list_item into DIR_ID from routing.directions 
	where $2 ~ dr_prefix 
	order by dr_prio 
	asc 
	limit 1; 

if not found then 
	raise exception 'NO DESTINATION BY NUMBER_B'; 
end if; 

--
-- get caller id
--
select set_callerid into CALLER_ID from routing.callerid 
	where direction_id = DIR_ID and sip_id = UID;
if not found then
	select set_callerid into CALLER_ID from routing.callerid 
		where direction_id = DIR_ID and sip_id is NULL; 
	if not found then 
		return '';
	end if; 
end if; 

return CALLER_ID;

end;


$_$;",real_express.sql
"CREATE FUNCTION get_car_stock_parts(bigint) RETURNS SETOF part_model
    LANGUAGE plpgsql STABLE ROWS 10
    AS $_$DECLARE 

	cid alias for $1;
	cmr car_model;
	pmr part_model;
	ptr part_type;

BEGIN

	-- for each car with id = cid, i.e. zero or one times
	for cmr in select * from car_model where id = cid loop

		-- for each required part type
		for ptr in select * from part_type t where t.required = true loop

			-- get single highest level stock part below car level and return this record
			for pmr in
				select * from part_model where part_type_id = ptr.id and part_modifier_id = 1 and
				(
						(car_id = cid)
					or
						(car_id = 0 and level in (
							select max(p.level) as level
							from part_model p
							where p.part_type_id = ptr.id
							and p.level <= cmr.level
						))
				)
				order by car_id desc limit 1
			loop
				return next pmr;
			end loop;
		end loop;
	end loop;

END$_$;",streetking-database.sql
"CREATE FUNCTION get_cluster_config(cluster_name text, OUT key text, OUT val text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
begin
    key := 'connection_lifetime';
    val := (30*60)::text;
    return next;
    return;
end;
$$;",stuck_orders.sql
"CREATE FUNCTION get_cluster_partitions(cluster_name text) RETURNS SETOF text
    LANGUAGE plpgsql
    AS $_$
declare
    the_limit           int;
    i                   int := 0;
    the_connection      text;
    the_cursor          refcursor;
    the_query           text;
    the_row             record;
    the_template        text := 'dbname=%s host=%s port=%s user=ms';
    the_db              text;
    the_address         text;
    the_port            int;
begin
    if cluster_name = 'bootstrap'
    then
        the_query := $$select 'postgres'::text as db, host(address)::text as address, native_port as port from plproxy.hosts$$;
    else
        the_query := $$select db::text, host(address)::text as address, bouncer_port as port from plproxy.client_dbs cd join plproxy.hosts h on h.id = cd.host_id where active$$;
    end if;
    open the_cursor for execute the_query;
    loop
        fetch the_cursor into the_db, the_address, the_port;
        exit when not found;
        the_connection := format(the_template, the_db, the_address, the_port)::text;
        i := i + 1;
        return next the_connection;
    end loop;
    if i = 0
    then
        return;
    end if;
    the_limit := 2;
    loop
        if the_limit >= i
        then
            exit;
        end if;
        the_limit := the_limit * 2;
    end loop;
    loop
        if i = the_limit
        then
            exit;
        end if;
        return next the_connection;
        i := i + 1;
    end loop;
    return;
end;
$_$;",stuck_orders.sql
"CREATE FUNCTION get_column_comment(column_name name, table_name oid) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE
	col_position pg_attribute.attnum%TYPE;
BEGIN
	SELECT attnum
	INTO col_position
	FROM pg_attribute
	WHERE attrelid=table_name
	  AND attstattarget=-1
	  AND attisdropped=false
	  AND attnum>0
	  AND attname=column_name;
	RETURN col_description(table_name, col_position::integer);
END;
$$;",schema-html.sql
"CREATE FUNCTION get_column_label(column_name name, table_name oid, lang character) RETURNS text
    LANGUAGE plpgsql
    AS $_$DECLARE
	col_comment text;
	str RECORD;
BEGIN
	col_comment := html.get_column_comment(column_name, table_name);
	FOR str IN SELECT foo FROM regexp_split_to_table(col_comment, E'\n') AS foo LOOP
		IF str.foo ~* E'^label@it="".*""$' THEN
			RETURN trim(both '""' from substring(str.foo from '"".*""'));
		END IF;
	END LOOP;
	RETURN initcap(translate(rtrim(column_name), '_', ' ')) || ':';
END;
$_$;",schema-html.sql
"CREATE FUNCTION get_column_max_size(column_name name, table_name oid) RETURNS integer
    LANGUAGE plpgsql
    AS $$DECLARE
	result  pg_attribute.atttypmod%TYPE;
	id_tipo pg_attribute.atttypid%TYPE;
	tipo pg_type%ROWTYPE;
BEGIN
	SELECT atttypmod, atttypid
	INTO result, id_tipo
	FROM pg_attribute
	WHERE attrelid=table_name
	  AND attstattarget=-1
	  AND attisdropped=false
	  AND attnum>0
	  AND attname=column_name;
	IF (result <> -1) THEN
		result := result - 4;
	ELSE
		SELECT *
		INTO tipo
		FROM pg_type
		WHERE oid=id_tipo;
		IF (tipo.typname = 'char') THEN
			result := tipo.typlen;
		ELSIF (tipo.typname = 'date') THEN
			-- typlen e' 4 cioe' basta un intero
			-- ma per una data facciamo 10 caratteri
			result := 10;
		END IF;
	END IF;
	-- Da aggiungere la gestione di atttypmod = -1
	-- per esempio le date e i caratteri
	RETURN result;
END;
$$;",schema-html.sql
"CREATE FUNCTION get_column_visible_size(column_name name, table_name oid) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
	col_comment text;
	str RECORD;
	result integer := 0;
BEGIN
	col_comment := html.get_column_comment(column_name, table_name);
	FOR str IN SELECT foo FROM regexp_split_to_table(col_comment, E'\n') AS foo LOOP
		IF str.foo ~* E'^size="".*""$' THEN
			result := to_number(trim(both '""' from substring(str.foo from '"".*""')), '99999');
		END IF;
	END LOOP;
	
	IF result = 0 THEN
		result := html.get_column_max_size(column_name, table_name);
	END IF;
	
	RETURN result;
END;
$_$;",schema-html.sql
"CREATE FUNCTION get_communication_id(user_id_f integer, user_id_s integer) RETURNS integer
LANGUAGE plpgsql
AS $$
declare
  comm_id INTEGER:=0;
  tmp INTEGER:=0;
begin
  SELECT COUNT(1) INTO tmp FROM USER_COMMUNICATIONS;
  IF tmp=0 THEN return 1;
  ELSE
    SELECT (MAX(communication_id)+1) INTO tmp
    FROM USER_COMMUNICATIONS;

    SELECT uc.communication_id INTO comm_id
    FROM USER_COMMUNICATIONS uc
      join user_communications uc2 ON uc.communication_id=uc2.communication_id
                                      AND uc.user_id=user_id_f and uc2.user_id=user_id_s;
    RETURN CASE WHEN comm_id IS NULL THEN tmp ELSE comm_id END;
  END IF;

  EXCEPTION WHEN OTHERS THEN RETURN tmp;
END;
$$;",scriptDB.sql
"CREATE FUNCTION get_communications(p_user_id integer) RETURNS refcursor
LANGUAGE plpgsql
AS $$
declare
  _communications  refcursor := '_communications';
begin
  OPEN _communications FOR
  SELECT uc.communication_id,
    last_mess_detail.message,
    last_mess_detail.user_from,
    all_users_detail.f_name,
    all_users_detail.i_name,
    all_users_detail.photo_src,
    last_corr_mess.active,
    last_mess_detail.date,
    own.photo_src own_photo_src,
    uc.user_id as partner
  FROM USER_COMMUNICATIONS uc
    JOIN USERS all_users_detail ON all_users_detail.user_id=uc.user_id
    JOIN (SELECT MAX(date) date, MAX(active) active, correspondence_id
          FROM MESSAGES
          GROUP BY correspondence_id) last_corr_mess ON last_corr_mess.correspondence_id=uc.communication_id
    JOIN MESSAGES last_mess_detail ON last_mess_detail.date=last_corr_mess.date
                                      AND last_mess_detail.correspondence_id=last_corr_mess.correspondence_id
    LEFT JOIN USERS own ON own.user_id= CASE WHEN last_mess_detail.user_from=p_user_id THEN p_user_id ELSE NULL END
  WHERE uc.communication_id IN (SELECT communication_id FROM USER_COMMUNICATIONS WHERE user_id=p_user_id) AND uc.user_id!=p_user_id
  ORDER BY  last_mess_detail.date DESC;
  RETURN _communications;
end;
$$;",scriptDB.sql
"CREATE FUNCTION get_conexion() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
		declare
		
			_config record;
			_text varchar default '';
		begin
			select * from clone.config into _config;

			_text = 'dbname='||_config.nombre||' user='||_config.usuario||' password='||_config.contrasenna||' host='||_config.direccion||' port='||_config.puerto;

			return _text;
			
		end;
	$$;",CH-II.sql
"CREATE FUNCTION get_conexion() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
		declare
		
			_config record;
			_text varchar default '';
		begin
			select * from clone.config into _config;

			_text = 'dbname='||_config.nombre||' user='||_config.usuario||' password='||_config.contrasenna||' host='||_config.direccion||' port='||_config.puerto;

			return _text;
			
		end;
	$$;",CH-III.sql
"CREATE FUNCTION get_control_sum(source integer[], coeff integer[]) RETURNS integer
    LANGUAGE plpgsql
    AS $$declare
   sum integer;
   m integer;
begin
   m := min_int(array_length(source, 1), array_length(coeff, 1));

   sum := 0;
   for i in 1 .. m loop
      sum := sum + source[i] * coeff[i];
   end loop;
	
   return sum;
end;$$;",create.sql
"CREATE FUNCTION get_control_value(source integer[], coeff integer[], divider integer, test10 boolean DEFAULT true) RETURNS integer
    LANGUAGE plpgsql
    AS $$declare
   r integer;
begin
   r := get_control_sum(source, coeff) % divider;
   if (test10 and r = 10) then
      r := 0;
   end if;

   return r;
end;$$;",create.sql
"CREATE FUNCTION get_current_process_status(u text) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$DECLARE
	p refcursor := 'current_process_status';
BEGIN
	OPEN p FOR SELECT search_types.type, webpage_status.address, process_list.date, process_status.status FROM search_types, webpage_status, process_list, process_status
	WHERE search_types.id = process_list.search_type AND webpage_status.id = web AND process_list.status = process_status.id AND puser = u AND process_list.status = 1 ORDER BY process DESC LIMIT 1;
	RETURN p;
END;$$;",krashr_db.sql
"CREATE FUNCTION get_date_interval(integer, text) RETURNS interval
    LANGUAGE plpgsql
    AS $_$

BEGIN
    return CAST( CAST($1 as TEXT) || ' ' || $2 as INTERVAL);
END;
$_$;",baseline-schema.sql
"CREATE FUNCTION get_dial_route(destination character varying, try integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare

dir routing.directions%ROWTYPE;
r routing.route%ROWTYPE;
rname varchar(32);

begin
--
-- Try to find direction by prefix;
-- 
select * into dir from routing.directions 
	where $1 ~ dr_prefix 
	order by dr_prio 
	asc 
	limit 1; 

if not found then 
	raise exception 'NO DIRECTION';
end if; 
--
-- Try to find route record that will give us type and destination id.
--
select * into r from routing.route 
	where route_direction_id = dir.dr_list_item 
	and route_step = $2  
	order by route_step asc limit 1; 

if not found then 
	raise exception 'NO ROUTE';
end if; 

-- Try to find destination id and name; 
-- case route_type (user) 
if r.route_type = 'user' then 
	select name into rname from public.sip_users where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if; 
	return rname;
end if; 
-- case route_type (context) 
if r.route_type = 'context' then 

end if;
-- case route_type (trunk) 
if r.route_type = 'trunk' then 
	select name into rname from public.sip_peers where id=r.route_desi_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if;
	return rname; 
end if; 
-- case route_type (trunkgroup) 
if r.route_type = 'tgroup' then 

end if; 
RAISE EXCEPTION 'This is the end. Some situation can not be handled.';
return 'END';

end
$_$;",real_express.sql
"CREATE FUNCTION get_dial_route3(exten character varying, current_try integer) RETURNS TABLE(dst_str character varying, dst_type character varying, try integer)
    LANGUAGE plpgsql
    AS $_$
declare

dir routing.directions%ROWTYPE;
r routing.route%ROWTYPE;
rname varchar(32);
trunk_id bigint; 

begin
--
-- Try to find direction by prefix;
-- 
select * into dir from routing.directions 
	where $1 ~ dr_prefix 
	order by dr_prio 
	asc 
	limit 1; 

if not found then 
	raise exception 'NO DIRECTION';
end if; 
--
-- Try to find route record that will give us type and destination id.
--
select * into r from routing.route 
	where route_direction_id = dir.dr_list_item 
	and route_step = $2  
	order by route_step asc limit 1; 

if not found then 
	raise exception 'NO ROUTE';
end if; 

dst_type = r.route_type;
try = current_try; 

-- Try to find destination id and name; 
-- case route_type (user) 
if r.route_type = 'user' then 
	select name into dst_str from public.sip_peers where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if; 
	
	return next;
	return;
end if; 
-- case route_type (trunk) 
if r.route_type = 'trunk' then 
	select name into dst_str from public.sip_peers where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if;
	return next;
	return;
end if; 

-- case route_type (context) 
if r.route_type = 'context' then 
	select context into dst_str from public.extensions_conf where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if; 
	return next; 
	return; 
end if; 

-- case route_type (trunkgroup) 
if r.route_type = 'tgrp' then 
-- находим последний транк в группе, который был заюзан крайний раз.
-- и уменьшаем кол-во попыток на -1 , что бы снова вернутся к группе. 
-- ВОПРОС: а как же определить заканчивание цикла ?  
-- ОТВЕТ: в перле. 
	try = current_try - 1; 
	select get_next_trunk_in_group into trunk_id from routing.get_next_trunk_in_group (r.route_dest_id);
	if trunk_id < 0 then 
		raise exception 'NO DESTINATION IN GROUP'; 
	end if; 

	select name into dst_str from public.sip_peers where id=trunk_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if;
	return next;
	return;

end if; 
RAISE EXCEPTION 'This is the end. Some situation can not be handled.';
return;

end
$_$;",real_express.sql
"CREATE FUNCTION get_dial_route4(peername character varying, exten character varying, current_try integer) RETURNS TABLE(dst_str character varying, dst_type character varying, try integer)
    LANGUAGE plpgsql
    AS $_$
 declare

 dir routing.directions%ROWTYPE;
 r routing.route%ROWTYPE;
 rname varchar(32);
 trunk_id bigint;
 sip_id bigint;

 begin

 --
 -- Get SIP ID from peername; 
 -- 

 select id from public.sip_peers where name=$1 into sip_id;
 if not found then
  raise exception 'NO SOURCE PEER/USER BY CHANNEL';
 end if;

 --
 -- Try to find direction by prefix;
 -- 
 select * into dir from routing.directions
  where $2 ~ dr_prefix
  order by dr_prio
  asc
  limit 1;

 if not found then
  raise exception 'NO DIRECTION';
 end if;

 --
 -- Try to find route record that will give us type and destination id.
 --

 --
 -- First try to search route record with peer sip ID 
 --

 select * into r from routing.route
  where route_direction_id = dir.dr_list_item
  and route_step = $3
  and route_sip_id = sip_id
  order by route_step asc limit 1;

 if not found then
 -- Try to find general route record with (route_sip_id = NULL) 
  select * into r from routing.route
    where route_direction_id = dir.dr_list_item
    and route_step = $3
    order by route_step asc limit 1;
  if not found then
    raise exception 'NO ROUTE';
  end if;
 end if;

 dst_type = r.route_type;
 try = current_try;

 -- Try to find destination id and name; 
 -- case route_type (user) 
 if r.route_type = 'user' then
  select name into dst_str from public.sip_peers where id=r.route_dest_id;
  if not found then
    raise exception 'NO DESTINATION';
  end if;

  return next;
  return;
 end if;
 -- case route_type (trunk) 
 if r.route_type = 'trunk' then
  select name into dst_str from public.sip_peers where id=r.route_dest_id;
  if not found then
    raise exception 'NO DESTINATION';
  end if;
  return next;
  return;
 end if;

 -- case route_type (context) 
 if r.route_type = 'context' then
  select context into dst_str from public.extensions_conf where id=r.route_dest_id;
  if not found then
    raise exception 'NO DESTINATION';
  end if;
  return next;
  return;
 end if;

 -- case route_type (trunkgroup) 
 if r.route_type = 'tgrp' then
  try = current_try - 1;
   select get_next_trunk_in_group into trunk_id from routing.get_next_trunk_in_group (r.route_dest_id);
  if trunk_id < 0 then
    raise exception 'NO DESTINATION IN GROUP';
  end if;

  select name into dst_str from public.sip_peers where id=trunk_id;
  if not found then
    raise exception 'NO DESTINATION';
  end if;
  return next;
  return;

 end if;
 RAISE EXCEPTION 'This is the end. Some situation can not be handled.';
 return;

 end
 $_$;",real_express.sql
"CREATE FUNCTION get_dial_route4(peername character varying, exten character varying, current_try integer) RETURNS TABLE(dst_str character varying, dst_type character varying, try integer)
    LANGUAGE plpgsql
    AS $_$
declare

dir routing.directions%ROWTYPE;
r routing.route%ROWTYPE;
rname varchar(32);
trunk_id bigint; 
sip_id bigint; 

begin

--
-- Get SIP ID from peername; 
-- 

select id from public.sip_peers where name=$1 into sip_id; 
if not found then 
	raise exception 'NO SOURCE PEER/USER BY CHANNEL';
end if; 

--
-- Try to find direction by prefix;
-- 
select * into dir from routing.directions 
	where $2 ~ dr_prefix 
	order by dr_prio 
	asc 
	limit 1; 

if not found then 
	raise exception 'NO DIRECTION';
end if; 

--
-- Try to find route record that will give us type and destination id.
--
 
--
-- First try to search route record with peer sip ID 
--

select * into r from routing.route 
	where route_direction_id = dir.dr_list_item 
	and route_step = $3 
	and route_sip_id = sip_id 
	order by route_step asc limit 1; 

if not found then 
-- Try to find general route record with (route_sip_id = NULL) 
	select * into r from routing.route 
		where route_direction_id = dir.dr_list_item 
		and route_step = $3
		and route_sip_id is NULL   
		order by route_step asc limit 1; 
	if not found then 
		raise exception 'NO ROUTE';
	end if;
end if;  

dst_type = r.route_type;
try = current_try; 

-- Try to find destination id and name; 
-- case route_type (user) 
if r.route_type = 'user' then 
	select name into dst_str from public.sip_peers where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if; 
	
	return next;
	return;
end if; 
-- case route_type (trunk) 
if r.route_type = 'trunk' then 
	select name into dst_str from public.sip_peers where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if;
	return next;
	return;
end if; 

-- case route_type (context) 
if r.route_type = 'context' then 
	select context into dst_str from public.extensions_conf where id=r.route_dest_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if; 
	return next; 
	return; 
end if; 

-- case route_type (trunkgroup) 
if r.route_type = 'tgrp' then 
-- находим последний транк в группе, который был заюзан крайний раз.
-- и уменьшаем кол-во попыток на -1 , что бы снова вернутся к группе. 
-- ВОПРОС: а как же определить заканчивание цикла ?  
-- ОТВЕТ: в перле. 
	try = current_try - 1; 
	select get_next_trunk_in_group into trunk_id from routing.get_next_trunk_in_group (r.route_dest_id);
	if trunk_id < 0 then 
		raise exception 'NO DESTINATION IN GROUP'; 
	end if; 

	select name into dst_str from public.sip_peers where id=trunk_id; 
	if not found then 
		raise exception 'NO DESTINATION'; 
	end if;
	return next;
	return;

end if; 
RAISE EXCEPTION 'This is the end. Some situation can not be handled.';
return;

end
$_$;",real_express.sql
"CREATE FUNCTION get_distance(_vector[], _vector[]) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$begin
  return (select sqrt(sum(pow(coalesce(t1.v, 0) - coalesce(t2.v, 0), 2)))
    from unnest($1) t1(i, v)
    full join unnest($2) t2(i, v)
    on t1.i = t2.i);
  /*return (select 1.0/greatest(count(1), 1e-10)
    from unnest($1) t1(i, v)
    join unnest($2) t2(i, v)
    on t1.i = t2.i);*/
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION get_doctor_nonce(i_doctor_id integer) RETURNS bit varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN (SELECT nonce FROM ""Doctor"" WHERE id = i_doctor_id);
END
$$;",baza.sql
"CREATE FUNCTION get_document(__document_id bigint) RETURNS common.inventory_document
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN
    (inventory.get_head(__document_id),
    inventory.get_meas_spec(__document_id),
    inventory.get_kind_spec(__document_id))::common.inventory_document;
END
$$;",mdm.sql
"CREATE FUNCTION get_domain(_uom_code character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN uom_domain FROM uom.information WHERE uom_code = _uom_code;

END;
$$;",mdm.sql
"CREATE FUNCTION get_domain_metadata_query(qname text, qkind text, OUT content text) RETURNS SETOF text
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
BEGIN

RETURN;

END
$$;",schema.sql
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' 
then 
	case when 
		data_process.qc_address1='' 
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' 
then 
	case when 
		data_process.qc_address2='' 
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' 
then 
	case when 
		data_process.qc_address3='' 
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' 
then 
	case when 
		data_process.qc_address4='' 
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_20160106.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' 
then 
	case when 
		data_process.qc_address1='' 
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' 
then 
	case when 
		data_process.qc_address2='' 
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' 
then 
	case when 
		data_process.qc_address3='' 
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' 
then 
	case when 
		data_process.qc_address4='' 
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_20160107.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' 
then 
	case when 
		data_process.qc_address1='' 
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' 
then 
	case when 
		data_process.qc_address2='' 
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' 
then 
	case when 
		data_process.qc_address3='' 
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' 
then 
	case when 
		data_process.qc_address4='' 
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_latest.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' or data_process.approve_address1 is null
then 
	case when 
		data_process.qc_address1='' or data_process.qc_address1 is null
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' or data_process.approve_address2 is null
then 
	case when 
		data_process.qc_address2='' or data_process.qc_address2 is null
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' or data_process.approve_address3 is null
then 
	case when 
		data_process.qc_address3=''  or data_process.qc_address3 is null
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' or data_process.approve_address4 is null
then 
	case when 
		data_process.qc_address4='' or  data_process.qc_address4 is null
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' or data_process.approve_address1 is null
then 
	case when 
		data_process.qc_address1='' or data_process.qc_address1 is null
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' or data_process.approve_address2 is null
then 
	case when 
		data_process.qc_address2='' or data_process.qc_address2 is null
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' or data_process.approve_address3 is null
then 
	case when 
		data_process.qc_address3=''  or data_process.qc_address3 is null
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' or data_process.approve_address4 is null
then 
	case when 
		data_process.qc_address4='' or  data_process.qc_address4 is null
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' or data_process.approve_address1 is null
then 
	case when 
		data_process.qc_address1='' or data_process.qc_address1 is null
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' or data_process.approve_address2 is null
then 
	case when 
		data_process.qc_address2='' or data_process.qc_address2 is null
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' or data_process.approve_address3 is null
then 
	case when 
		data_process.qc_address3=''  or data_process.qc_address3 is null
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' or data_process.approve_address4 is null
then 
	case when 
		data_process.qc_address4='' or  data_process.qc_address4 is null
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_production.backup
"CREATE FUNCTION get_export_data() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
	ref refcursor;
	
    BEGIN
	
      OPEN ref FOR 
	SELECT 
  data.appl_id, 
  data.address_id, 
  data.cust_id, 
  data.cust_type, 
  data.address_type, 
  data.state_desc, 
  data.country_lms, 
  data.city_lms, 
  data.flag, 
  data.address, 
  data.address1, 
  case when 
	data_process.approve_address1 = '' or data_process.approve_address1 is null
then 
	case when 
		data_process.qc_address1='' or data_process.qc_address1 is null
	then 
		data_process.verify_address1 
	else 
		data_process.qc_address1 
	end 
else 
	data_process.approve_address1 
end 
as adrress_correct1, 
  data.address2, 
    case when 
	data_process.approve_address2 = '' or data_process.approve_address2 is null
then 
	case when 
		data_process.qc_address2='' or data_process.qc_address2 is null
	then 
		data_process.verify_address2 
	else 
		data_process.qc_address2 
	end 
else 
	data_process.approve_address2 
end 
as adrress_correct2,
  data.address3, 

    case when 
	data_process.approve_address3 = '' or data_process.approve_address3 is null
then 
	case when 
		data_process.qc_address3=''  or data_process.qc_address3 is null
	then 
		data_process.verify_address3 
	else 
		data_process.qc_address3 
	end 
else 
	data_process.approve_address3 
end 
as adrress_correct3,
  data.address4, 
    case when 
	data_process.approve_address4 = '' or data_process.approve_address4 is null
then 
	case when 
		data_process.qc_address4='' or  data_process.qc_address4 is null
	then 
		data_process.verify_address4 
	else 
		data_process.qc_address4 
	end 
else 
	data_process.approve_address4 
end 
as adrress_correct4
FROM 
  data_cleaning.data, 
  data_cleaning.data_process
WHERE 
  data.data_id = data_process.data_id
	ORDER BY  data_process.data_id	;
	
      RETURN ref;
    END;
    $$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_factor(_uom_code_src character varying, _uom_code_dst character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
  __factor_1 double precision;
  __factor_2 double precision;
  __uom_domain_from character varying;
  __uom_domain_to character varying;

BEGIN

  -- визначити домен одиниці виміру, з якої приводимо
  __uom_domain_from := uom.get_domain(_uom_code := _uom_code_src);

  -- визначити домен одиниці виміру, до якої приводимо
  __uom_domain_to := uom.get_domain(_uom_code := _uom_code_dst);

  IF (__uom_domain_from = __uom_domain_to) THEN
    -- привести з вказаної одиниці до базової Сі = *
    __factor_1 := factor
      FROM 
        uom.information
      WHERE 
        uom_code = _uom_code_src;

    -- привести з базової Сі до вказаної = /
    __factor_2 := factor
      FROM 
        uom.information
      WHERE 
        uom_code = _uom_code_dst;

    RETURN __factor_1 / __factor_2;

  ELSE
    RAISE EXCEPTION 'units of measure are not in the same domain: ""%"" and ""%""', _uom_code_src, _uom_code_dst;
    --RETURN NULL;
  END IF;

END;
$$;",mdm.sql
"CREATE FUNCTION get_fecha_emision() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_em integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_emision INTO dia_em FROM config c LIMIT 1;
	IF (dia_em IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de emision en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_em || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_em) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION get_fecha_emision() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_em integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_emision INTO dia_em FROM config c LIMIT 1;
	IF (dia_em IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de emision en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_em || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_em) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION get_fecha_emision() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_em integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_emision INTO dia_em FROM config c LIMIT 1;
	IF (dia_em IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de emision en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_em || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_em) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION get_fecha_emision() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_em integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_emision INTO dia_em FROM config c LIMIT 1;
	IF (dia_em IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de emision en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_em || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_em) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION get_fecha_emision() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_em integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_emision INTO dia_em FROM config c LIMIT 1;
	IF (dia_em IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de emision en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_em || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_em) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION get_fecha_vencimiento() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_ven integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_vencimiento INTO dia_ven FROM config c LIMIT 1;
	IF (dia_ven IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de vencimiento en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_ven || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_ven) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION get_fecha_vencimiento() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_ven integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_vencimiento INTO dia_ven FROM config c LIMIT 1;
	IF (dia_ven IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de vencimiento en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_ven || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_ven) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION get_fecha_vencimiento() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_ven integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_vencimiento INTO dia_ven FROM config c LIMIT 1;
	IF (dia_ven IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de vencimiento en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_ven || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_ven) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION get_fecha_vencimiento() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_ven integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_vencimiento INTO dia_ven FROM config c LIMIT 1;
	IF (dia_ven IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de vencimiento en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_ven || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_ven) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION get_fecha_vencimiento() RETURNS date
    LANGUAGE plpgsql
    AS $$
DECLARE
	dia_ven integer;
	today integer;
	result date;
BEGIN 
	SELECT c.dia_vencimiento INTO dia_ven FROM config c LIMIT 1;
	IF (dia_ven IS NULL) THEN
		RAISE EXCEPTION 'Error grave: no existe dia de vencimiento en la tabla de configuración';
	END IF;
	today = date_part('day',now()::date);
	--Todavia no llegó el dia de emision
	result = dia_ven || '-' || date_part('month',now()) || '-' || date_part('year',now());
	IF (today > dia_ven) THEN
		result = result + '1 month'::interval;
	END IF;
	RETURN result;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION get_film_titles(id_no integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE 
 titles TEXT DEFAULT '';
 company   RECORD;
 cur_films CURSOR(id_no INTEGER) 
 FOR SELECT 
 FROM company
 WHERE id = id_no;
BEGIN
   -- Open the cursor
   OPEN cur_films(id_no);
 
   LOOP
    -- fetch row into the film
      FETCH cur_films INTO company;
    -- exit when no more row to fetch
      EXIT WHEN NOT FOUND;
 
    -- build the output
      IF company.name LIKE '%ful%' THEN 
         titles := titles || ',' || company.name || ':' || company.id;
      END IF;
   END LOOP;
  
   -- Close the cursor
   CLOSE cur_films;
 
   RETURN titles;
END; $$;",file(21Aprl).pgsql
"CREATE FUNCTION get_first_free_conto() RETURNS integer
    LANGUAGE plpgsql
    AS $$
		DECLARE
			a INTEGER;
		BEGIN
			SELECT MAX(numero) INTO a FROM conto;
			IF a IS NULL THEN
				a:=0;
			END IF;
			RETURN a+1;
		END;
	$$;",dump.sql
"CREATE FUNCTION get_first_free_spentr(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
		DECLARE
			a INTEGER;
			b INTEGER;
		BEGIN
			SELECT MAX(id_op) INTO a FROM spesa WHERE conto = $1;
			SELECT MAX(id_op) INTO b FROM entrata WHERE conto = $1;
			IF a IS NULL THEN
				a:=0;
			END IF;
			IF b IS NULL THEN
				b:=0;
			END IF;
			IF a>b THEN
				RETURN a+1;
			ELSE RETURN b+1;
			END IF;
		END;
	$_$;",dump.sql
"CREATE FUNCTION get_first_free_utente() RETURNS integer
    LANGUAGE plpgsql
    AS $$
		DECLARE
			a INTEGER;
		BEGIN
			SELECT MAX(userid) INTO a FROM utente;
			IF a IS NULL THEN
				a:=0;
			END IF;
			RETURN a+1;
		END;
	$$;",dump.sql
"CREATE FUNCTION get_firstpages_id(character varying) RETURNS integer
    AS $_$
    BEGIN
	RETURN (select id from firstpages where fp_filename=$1); 
    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup
"CREATE FUNCTION get_function_defs(p_schema character varying) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
   ref_function refcursor;
BEGIN
   OPEN ref_function FOR
        SELECT p.oid, p.proname AS name
              , p.proargtypes, proargnames
              , (fx.get_function_params(p_schema, p.proname::varchar)) As args
              , ds.description, p.prorettype
              , (CASE When Substr(tp.typname,1,3) = 'int' Then 'integer' Else tp.typname End) As rettypename
              , p.proretset, p.probin, p.proisstrict AS strict
              , p.prosrc AS body, l.lanname AS lang
              , u.usename, p.prosecdef, p.provolatile
              , p.proisagg, n.nspname
              , p.proargmodes, p.proallargtypes
       FROM pg_proc p
       LEFT OUTER JOIN pg_description ds ON ds.objoid = p.oid
       LEFT OUTER JOIN pg_type tp ON p.prorettype = tp.oid
       INNER JOIN pg_namespace n ON p.pronamespace = n.oid
       INNER JOIN pg_language l ON l.oid = p.prolang
       LEFT OUTER JOIN pg_user u ON u.usesysid = p.proowner
       WHERE n.nspname = p_schema
       ORDER BY p.proname, n.nspname;

   Return Next ref_function;
END;
$$;",utils.sql
"CREATE FUNCTION get_function_params(p_schema character varying, p_function character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
   rec record;
   r integer;
   v_params_arr varchar[];
   v_types varchar;
   v_types_arr integer[];
   v_type integer;
   v_type_name varchar;
   v_params_out varchar = '';

BEGIN
   SELECT proname, p.proargtypes, p.proargnames
          , p.proargmodes, p.proallargtypes INTO rec
   FROM pg_proc p
   INNER JOIN pg_namespace n ON p.pronamespace = n.oid
   WHERE n.nspname = p_schema
         AND proname = p_function;

   v_params_arr = rec.proargnames;   -- string_to_array(v_param_names, ',');
   v_types = array_to_string(rec.proargtypes, ',');

   If Length(v_types) > 0 Then
      v_types_arr = string_to_array(v_types, ',');

      FOR r IN array_lower(v_types_arr, 1)..array_upper(v_types_arr, 1) LOOP
          -- lookup name type
          v_type = v_types_arr[r];
          SELECT typname INTO v_type_name FROM pg_type
          WHERE oid = v_type;
          -- convert all int types to 'integer'
          If Substr(v_type_name, 1, 3) = 'int' Then
             v_type_name = 'integer';
          End If;
          -- add delimiter
          If Length(v_params_out) > 0 Then
             v_params_out = v_params_out || ', ';
          End If;
          -- add param name only when present
          If array_upper(v_params_arr, 1) > 0 Then
             v_params_out = v_params_out || v_params_arr[r] || ' ' || v_type_name;
           Else
             v_params_out = v_params_out || v_type_name;
          End If;
      END LOOP;
   End If;

   Return v_params_out;
END
$$;",utils.sql
"CREATE FUNCTION get_gateway_for_dataset(dataset_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$

DECLARE
  gateway_id UUID;
BEGIN
  SELECT INTO gateway_id parent_gateway_id FROM metadata.dataset where id = metadata.get_top_dataset_parent(dataset_id);

  RETURN gateway_id;

END;
$$;",baseline-schema.sql
"CREATE FUNCTION get_head(__document_id bigint) RETURNS common.facility_head
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  RETURN 
    (information.id, 
    information.gid, 
    information.facility_code, 
    information.version_num, 
    information.display_name, 
    information.published_date, 
    information.parent_facility_code, 
    information.facility_type)::common.facility_head
  FROM 
    facility.information
  WHERE 
    information.id = __document_id;
END;
$$;",mdm.sql
"CREATE FUNCTION get_head(__document_id bigint) RETURNS common.inventory_head
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  RETURN 
    (definition.id, 
    definition.gid, 
    information.display_name, 
    information.part_code, 
    definition.version_num, 
    definition.published_date, 
    definition.uom_code, 
    definition.curr_fsmt,
    'INVENTORY'::common.document_kind
    )::common.inventory_head
  FROM 
    inventory.information, 
    inventory.definition
  WHERE 
    information.id = definition.information_id AND
    definition.id = __document_id;
END;
$$;",mdm.sql
"CREATE FUNCTION get_head(__uom_code character varying) RETURNS common.uom_head
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  RETURN 
    (information.uom_code, 
    information.uom_domain, 
    information.base_uom_code, 
    information.factor)::common.uom_head
  FROM 
    uom.information
  WHERE 
    information.uom_code = __uom_code;
END;
$$;",mdm.sql
"CREATE FUNCTION get_head_batch() RETURNS common.inventory_head[]
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  RETURN 
    ARRAY (
      SELECT
        (definition.id, 
        definition.gid, 
        information.display_name, 
        information.part_code, 
        definition.version_num, 
        definition.published_date, 
        definition.uom_code, 
        definition.curr_fsmt,
        'INVENTORY'::common.document_kind
        )::common.inventory_head
      FROM 
        inventory.information, 
        inventory.definition
      WHERE 
        information.id = definition.information_id --AND
        --definition.id = __document_id
    );
END;
$$;",mdm.sql
"CREATE FUNCTION get_head_batch(__facility_type common.facility_kind DEFAULT NULL::common.facility_kind) RETURNS common.facility_head[]
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF (__facility_type IS NULL) THEN
    RETURN
      ARRAY (
        SELECT
          (information.id, 
          information.gid, 
          information.facility_code, 
          information.version_num, 
          information.display_name, 
          information.published_date, 
          information.parent_facility_code, 
          information.facility_type)::common.facility_head
        FROM 
          facility.information
      );
  ELSE
    RETURN 
      ARRAY (
        SELECT
          (information.id, 
          information.gid, 
          information.facility_code, 
          information.version_num, 
          information.display_name, 
          information.published_date, 
          information.parent_facility_code, 
          information.facility_type)::common.facility_head
        FROM 
          facility.information
        WHERE 
          information.facility_type = __facility_type
      );
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION get_head_batch(__uom_domain common.uom_domain_kind DEFAULT NULL::common.uom_domain_kind) RETURNS common.uom_head[]
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  IF (__uom_domain IS NULL) THEN
    RETURN
      ARRAY (
        SELECT 
          (information.uom_code, 
          information.uom_domain, 
          information.base_uom_code, 
          information.factor)::common.uom_head
        FROM 
          uom.information
      );
  ELSE
    RETURN 
      ARRAY (
        SELECT 
          (information.uom_code, 
          information.uom_domain, 
          information.base_uom_code, 
          information.factor)::common.uom_head
        FROM 
          uom.information
        WHERE 
          information.uom_domain = __uom_domain
      );
  END IF;
END;
$$;",mdm.sql
"CREATE FUNCTION get_id() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	declare
		id_table integer DEFAULT nextval('clone.my_seq');
		node_name varchar default (select nodo from clone.config);
		bd_name varchar default current_database();
		id_generic varchar default node_name || '_' || bd_name || '_' ||id_table::text;
		
	begin
		return id_generic;
	end;
	$$;",CH-II.sql
"CREATE FUNCTION get_id() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	declare
		id_table integer DEFAULT nextval('clone.my_seq');
		node_name varchar default (select nodo from clone.config);
		bd_name varchar default current_database();
		id_generic varchar default node_name || '_' || bd_name || '_' ||id_table::text;
		
	begin
		return id_generic;
	end;
	$$;",CH-III.sql
"CREATE FUNCTION get_input_text(column_name name, table_name oid, value text, read_only boolean DEFAULT true) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE
	result text;
BEGIN
	result := E'\n<label for=""' || column_name || '""';
	IF html.column_is_required(column_name, table_name) THEN
		result := result || ' class=""required""';
	END IF;
	result := result || '>' || html.get_column_label(column_name, table_name, 'it') || '</label>';
	result := result || E'\n<input type=""text"" name=""' || column_name || '"" id=""' || column_name || '"" ';
	result := result || 'size=""' || html.get_column_visible_size(column_name, table_name) || '"" ';
	result := result || 'maxlength=""' || html.get_column_max_size(column_name, table_name) || '"" ';
	result := result || 'value=""' || value || '""';
	IF read_only THEN
		result := result || ' readonly=""readonly"" ';
	END IF;
	result := result || ' />';
	RETURN result;
END;
$$;",schema-html.sql
"CREATE FUNCTION get_is_visible_age(v_age_id bigint, v_user_name character varying, v_role_name character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_count integer;
    v_result boolean;
BEGIN
v_count = 0;
v_result = false;
--
if (v_role_name is not null) then
  select count(*) into v_count from cb_age where age_id=v_age_id and roles like '%'||v_role_name||'%';
else
  if (v_user_name is not null) then
   select count(*) into v_count from cb_age where age_id=v_age_id and users like '%'||v_user_name||'%' and 1=1;
  else
   select count(*) into v_count from cb_age where age_id=v_age_id and users like '%'||'all'||'%' and 1=1;
  end if;
end if;
--
v_result = (v_count>0);
--
return v_result;
END
$$;",functions.sql
"CREATE FUNCTION get_is_visible_month(v_month_id bigint, v_year integer, v_user_name character varying, v_role_name character varying DEFAULT NULL::character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_admin integer;
    v_is_government integer;
    v_is_public integer;
    v_count integer;
    v_result boolean;
        v_c cursor for select * from regexp_split_to_table(v_role_name,',');
BEGIN
--ver. 1.0.0.8
    v_count = 0;
    v_result = false;
    v_is_admin = 0;
    v_is_government = 0;
    v_is_public = 0;
--
    select count(*) into v_is_admin from regexp_split_to_table(v_role_name,',') where regexp_split_to_table = 'ROLE_ADMIN';
    select count(*) into v_is_government from regexp_split_to_table(v_role_name,',') where regexp_split_to_table = 'ROLE_GOVERNMENT';
    select count(*) into v_is_public from regexp_split_to_table(v_role_name,',') where regexp_split_to_table = 'ROLE_PUBLIC';
--
    if v_is_admin <> 0 then
        select count(*) into v_count from cb_common_add cb join cm_time tm on cb.time_id = tm.time_id and tm.year_ = v_year;
        if v_count != 0 then
            select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id in (select distinct month_ from cb_common_add cb join cm_time tm on cb.time_id = tm.time_id and tm.year_ = v_year);
        else
-- no data in DB
            select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id = extract (month from now());
        end if;
    elsif (v_role_name is not null) then
--
        for rec in v_c loop
--
            if (rec.regexp_split_to_table = 'ROLE_GOVERNMENT' ) then
                if ( v_year = 2014 ) then
                    if v_user_name = 'tretiak' then
                        select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id >= 3;
                    else
                        select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id >= 4;
                    end if;
                    exit;
                elsif ( v_year < 2014 or v_year > extract (year from now()) ) then
                    v_count = 0;
                    exit;
                elsif ( v_year < extract (year from now()) ) then
                    select count(month_id) into v_count from cm_month where month_id = v_month_id;
                else
                    select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id <= extract(month from now());
                end if;
            elsif (rec.regexp_split_to_table = 'ROLE_PUBLIC' ) then
                if ( v_year = 2014 ) then
                    select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id >= 4;
                    exit;
                elsif ( v_year < 2014 or v_year > extract (year from now()) ) then
                    v_count = 0;
                    exit;
                elsif ( v_year < extract (year from now()) ) then
                    select count(month_id) into v_count from cm_month where month_id = v_month_id;
                else
                    select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id <= extract(month from now());
                end if;
            else
                select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id in (select distinct month_ from cb_common_add cb join cm_time tm on cb.time_id = tm.time_id and tm.year_ = v_year);
            end if;
        end loop;
    else
        select count(month_id) into v_count from cm_month where month_id = v_month_id and month_id in (select distinct month_ from cb_common_add cb join cm_time tm on cb.time_id = tm.time_id and tm.year_ = v_year);
    end if;
--
    v_result = (v_count > 0);
--
    return v_result;
END
$$;",functions.sql
"CREATE FUNCTION get_is_visible_report(v_report_id bigint, v_user_name character varying, v_role_name character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_count integer;
    v_result boolean;
    v_c cursor for select * from regexp_split_to_table(v_role_name,',');
BEGIN
--ver. 1.0.0.0
--
v_count = 0;
v_result = false;
--
if (v_role_name is not null) then
 for rec in v_c loop
  select count(*) into v_count from cm_report where report_id=v_report_id and roles like '%'||rec.regexp_split_to_table||'%';
  if (v_count > 0) then
   exit;
  end if;
 end loop;
else
  if (v_user_name is not null) then
   select count(*) into v_count from cm_report where report_id=v_report_id and users like '%'||v_user_name||'%' and 1=1;
  else
   select count(*) into v_count from cm_report where report_id=v_report_id and users like '%'||'all'||'%' and 1=1;
  end if;
end if;
--
v_result = (v_count>0);
--
return v_result;
END
$$;",functions.sql
"CREATE FUNCTION get_is_visible_value(v_value_id bigint, v_user_name character varying, v_role_name character varying DEFAULT NULL::character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_count integer;
    v_result boolean;
    v_c cursor for select * from regexp_split_to_table(v_role_name,',');
BEGIN
v_count = 0;
v_result = false;
--
if (v_role_name is not null) then
 v_count=0;
 for rec in v_c loop
  select count(*) into v_count from cb_value where value_id = v_value_id and roles like '%'||rec.regexp_split_to_table||'%';
  if v_count>0 then
   exit; --exit from loop
  end if;
 end loop;
else
 if (v_user_name is not null) then
  select count(*) into v_count from cb_value where value_id = v_value_id and users like '%'||v_user_name||'%';
 end if;
end if;
--
v_result = v_count>0;
--
return v_result;
END
$$;",functions.sql
"CREATE FUNCTION get_is_visible_year(v_year integer, v_user_name character varying, v_role_name character varying DEFAULT NULL::character varying) RETURNS boolean
LANGUAGE plpgsql
AS $$
DECLARE
    v_is_admin integer;
    v_count integer;
    v_result boolean;
        v_c cursor for select * from regexp_split_to_table(v_role_name,',');
BEGIN
--
--ver. 1.0.0.4
--
    v_count = 0;
    v_result = false;
--
    select count(*) into v_is_admin from regexp_split_to_table(v_role_name,',') where regexp_split_to_table='ROLE_ADMIN';
--
    if v_is_admin <> 0 then
        select count(year_) into v_count from cm_time where year_ = v_year and year_ in (select distinct year_ from cb_common_add cb join cm_time tm on cb.time_id=tm.time_id) and year_ > 2013;
    elsif (v_role_name is not null) then
        for rec in v_c loop
            if (rec.regexp_split_to_table = 'ROLE_PUBLIC') then
                select count(year_) into v_count from cm_time where year_ = v_year and year_ = extract(year from now());
            else
                select count(year_) into v_count from cm_time where year_ = v_year and year_ in (select distinct year_ from cb_common_add cb join cm_time tm on cb.time_id=tm.time_id) and year_ > 2013;
            end if;
--
            if v_count > 0 then
                exit; --from loop
            end if;
        end loop;
    else
        select count(year_) into v_count from cm_time where year_ = v_year and year_ = extract(year from now());
    end if;
--
    v_result = (v_count > 0);
--
    return v_result;
END
$$;",functions.sql
"CREATE FUNCTION get_kind_spec(__document_id bigint) RETURNS common.inventory_kind[]
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN
    ARRAY (
      SELECT 
        variety.inventory_type
      FROM 
        inventory.variety
      WHERE 
        variety.definition_id = __document_id
    );
END
$$;",mdm.sql
"CREATE FUNCTION get_kohirno(spt_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare kohirno_out character varying;
begin

select k.tahun||'-'||lpad(kohirno::text, 5, '0') into kohirno_out
from pad_kohir k
inner join pad_spt s on s.id=k.spt_id
where s.id=$1;

return kohirno_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_last_period_start_bil(integer, character varying, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		data DATE;
		datab DATE;
		periodo INTERVAL;
	BEGIN
		SELECT data_partenza INTO data FROM bilancio WHERE userid=$1 AND nome = $2;
		SELECT periodovalidita INTO periodo FROM bilancio WHERE userid=$1 AND nome = $2;
		WHILE (data + periodo <= $3) LOOP
			data=data+periodo;
		END LOOP;

		IF data > $3 THEN
			RETURN $3;
		ELSE 
			RETURN data;
		END IF;
	END;
$_$;",dump.sql
"CREATE FUNCTION get_last_period_start_cred(integer, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		data DATE;
		datab DATE;
		periodo INTERVAL;
	BEGIN
		SELECT data_creazione INTO data FROM conto WHERE numero = $1;
		SELECT scadenza_giorni INTO periodo FROM conto WHERE numero = $1;
		WHILE (data + periodo <= $2) LOOP
			data=data+periodo;
		END LOOP;

		IF data > $2 THEN
			RETURN $2;
		ELSE 
			RETURN data;
		END IF;
	END;
$_$;",dump.sql
"CREATE FUNCTION get_load_type_by_canton_id(v_canton_id bigint, v_time timestamp with time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_load_type_by_canton_id(v_canton_id bigint, v_time timestamp without time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where canton_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_load_type_by_municipality_id(v_municipality_id bigint, v_time timestamp with time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_load_type_by_municipality_id(v_municipality_id bigint, v_time timestamp without time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where municipality_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_load_type_by_state_id(v_state_id bigint, v_time timestamp with time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_load_type_by_state_id(v_state_id bigint, v_time timestamp without time zone, v_type character varying) RETURNS bigint
LANGUAGE plpgsql
AS $_$
declare
 v_m varchar(100);
 v_a varchar(100);
 v_result bigint;
begin
  --
  v_m = '%UI%';
  v_a = '%BUS%';
  --
  if ($3 = 'm') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a=0;
  elsif ($3 = 'a') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a>0;
  elsif ($3 = 'd') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m>0 and is_a>0;
  elsif ($3 = '-') then
	select
		count(municipality_id) into v_result
	from (
		SELECT
		 op.municipality_id,
		 sum(CASE WHEN opp.value like '%UI%' THEN 1 ELSE 0 END) AS is_m,
		 sum(CASE WHEN opp.value like '%BUS%' THEN 1 ELSE 0 END) AS is_a
		FROM
		 cm_organization_place op
		 JOIN cm_organization_parameter opp ON (op.organization_id = opp.organization_id AND opp.name::text = 'source_app'::text AND date_trunc('month'::text, opp.dt_value) = date_trunc('month'::text, $2))
		where state_id = $1
		group by op.municipality_id
	     ) tt
	where is_m=0 and is_a=0;
  end if;
  return v_result;
end;
$_$;",functions.sql
"CREATE FUNCTION get_meas_spec(__document_id bigint) RETURNS common.unit_conversion_type[]
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN
    ARRAY (
      SELECT 
        (definition.uom_code, 
        measurement.uom_code, 
        measurement.factor)::common.unit_conversion_type
      FROM 
        inventory.definition, 
        inventory.measurement
      WHERE 
        definition.id = measurement.definition_id AND 
        definition.id = __document_id
    );
END
$$;",mdm.sql
"CREATE FUNCTION get_message_from_queue(sender_id integer, queue_id integer, OUT o_message_id integer, OUT o_message_body text) RETURNS record
    LANGUAGE plpgsql
    AS $$BEGIN
  SELECT m_message_id, m_message_body FROM mps_message
  INTO o_message_id, o_message_body
  WHERE (m_receiver_id IS NULL OR m_receiver_id = sender_id) AND m_queue_id = queue_id
  ORDER BY m_arrival_time DESC
  LIMIT 1;
END;$$;",mps_db_dump_100Q_Idxs_SP.backup
"CREATE FUNCTION get_message_from_receiver(sender_id integer, receiver_id integer, OUT o_message_id integer, OUT o_message_body text) RETURNS record
    LANGUAGE plpgsql
    AS $$BEGIN
  SELECT m_message_id, m_message_body FROM mps_message
  INTO o_message_id, o_message_body
  WHERE m_receiver_id = sender_id AND m_sender_id = receiver_id
  ORDER BY m_arrival_time DESC
  LIMIT 1;
END;$$;",mps_db_dump_100Q_Idxs_SP.backup
"CREATE FUNCTION get_messages(p_user_id integer, p_communication_id integer) RETURNS refcursor
LANGUAGE plpgsql
AS $$
declare
  _messages  refcursor := '_messages';
begin
  OPEN _messages FOR
  SELECT us.f_name,
    us.i_name,
    '' photo,
    '' photo_src,
    us.user_id,
    mess.message,
    mess.date,
    mess.active,
    0 group_num,
    mess.id
  FROM MESSAGES mess
    JOIN USERS us ON us.user_id=CASE WHEN mess.user_from!=p_user_id THEN mess.user_from ELSE p_user_id END
                     AND p_communication_id IN (SELECT communication_id FROM USER_COMMUNICATIONS uc WHERE uc.user_id=p_user_id)
  where mess.correspondence_id=p_communication_id;
  RETURN _messages;
end;
$$;",scriptDB.sql
"CREATE FUNCTION get_neuron_doc_distance(neuron_id bigint, doc_id bigint) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
begin
  return get_distance(doc_get_vector($2),
    array(select (term_id, value)::_vector from neuron_vectors nv where nv.neuron_id = $1)::_vector[]);
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION get_nop_bank(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare nop_out character varying;
begin

 --irul
 --NOP: 32.79.010.004.007-0061.0
 --source: bphtb_bank, bphtb_sspd

if $2 then

select kd_propinsi||'.'||kd_dati2||'.'||kd_kecamatan||'.'||kd_kelurahan||'.'||kd_blok||'-'||no_urut||'.'||kd_jns_op into nop_out
from bphtb_bank
where bphtb_bank.id=$1;

else

select kd_propinsi||kd_dati2||kd_kecamatan||kd_kelurahan||kd_blok||no_urut||kd_jns_op into nop_out
from bphtb_bank
where bphtb_bank.id=$1;

end if;

return nop_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_nop_sspd(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare nop_out character varying;
begin

 --irul
 --NOP: 32.79.010.004.007-0061.0
 --source: bphtb_bank, bphtb_sspd

if $2 then

select kd_propinsi||'.'||kd_dati2||'.'||kd_kecamatan||'.'||kd_kelurahan||'.'||kd_blok||'-'||no_urut||'.'||kd_jns_op into nop_out
from bphtb_sspd
where bphtb_sspd.id=$1;

else

select kd_propinsi||kd_dati2||kd_kecamatan||kd_kelurahan||kd_blok||no_urut||kd_jns_op into nop_out
from bphtb_sspd
where bphtb_sspd.id=$1;

end if;

return nop_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_nop_thn_bank(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare nop_out character varying;
begin

 --irul
 --NOP: 32.79.010.004.007-0061.0:2014
 --source: bphtb_bank, bphtb_sspd

if $2 then

select kd_propinsi||'.'||kd_dati2||'.'||kd_kecamatan||'.'||kd_kelurahan||'.'||kd_blok||'-'||no_urut||'.'||kd_jns_op||'.'||thn_pajak_sppt into nop_out
from bphtb_bank
where bphtb_bank.id=$1;

else

select kd_propinsi||kd_dati2||kd_kecamatan||kd_kelurahan||kd_blok||no_urut||kd_jns_op||thn_pajak_sppt into nop_out
from bphtb_bank
where bphtb_bank.id=$1;

end if;

return nop_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_nop_thn_sspd(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare nop_out character varying;
begin

 --irul
 --NOP: 32.79.010.004.007-0061.0:2014
 --source: bphtb_bank, bphtb_sspd

if $2 then

select kd_propinsi||'.'||kd_dati2||'.'||kd_kecamatan||'.'||kd_kelurahan||'.'||kd_blok||'-'||no_urut||'.'||kd_jns_op||'.'||thn_pajak_sppt into nop_out
from bphtb_sspd
where bphtb_sspd.id=$1;

else

select kd_propinsi||kd_dati2||kd_kecamatan||kd_kelurahan||kd_blok||no_urut||kd_jns_op||thn_pajak_sppt into nop_out
from bphtb_sspd
where bphtb_sspd.id=$1;

end if;

return nop_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_nopd(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare nopd_out character varying;
begin


--menyesuaikan npwpd [nama_daerah] , NOPD: P.xxxxxx.3208.aaa.bbb.uu.kk

if $2 then
select c.rp||'.'||lpad( c.formno::text, 6, '0')||'.3208.'||k.kecamatankd||'.'||l.kelurahankd||'.'||lpad(u.id::text, 2, '0')||'.'||lpad(cu.konterid::text, 2, '0') into nopd_out
from pad_customer_usaha cu 
inner join pad_customer c on c.id=cu.customer_id
inner join tblkelurahan l on cu.kelurahan_id=l.id
inner join tblkecamatan k on l.kecamatan_id=k.id
inner join pad_usaha u on u.id=cu.usaha_id
where cu.id=$1;

else

select c.rp||lpad( c.formno::text, 6, '0')||'3208'||k.kecamatankd||l.kelurahankd||lpad(u.id::text, 2, '0')||lpad(cu.konterid::text, 2, '0') into nopd_out
from pad_customer_usaha cu 
inner join pad_customer c on c.id=cu.customer_id
inner join tblkelurahan l on cu.kelurahan_id=l.id
inner join tblkecamatan k on l.kecamatan_id=k.id
inner join pad_usaha u on u.id=cu.usaha_id
where cu.id=$1;

end if;

return nopd_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_npwpd(id bigint, formatted boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare npwpd_out character varying;
begin

/* 
NPWPD: P.xxxxxx.3208.aaa.bbb

ket : 
xxxxxx adalah kodefikasi nomor urut wp terdaftar
3208 adalah kodefikasi propinsi dan kabupaten/kota
aaa adalah kodefikasi nomor kode kecamatan
bbb adalah kodefikasi nomor kode kelurahan

nb untuk kec=LUAR KOTA:
jika pilihan kel = Luar Jawa Barat(000)
NPWPD = P.xxxxxx.0000.xxx.xxx
jika pilihan kel = Jawa Barat(001) 
NPWPD = P.xxxxxx.3200.xxx.xxx

*/

if $2 then

select c.rp||'.'||lpad( c.formno::text, 6, '0')||
case 
when k.kecamatankd='000' and l.kelurahankd='000' then '.0000.'
when k.kecamatankd='000' and l.kelurahankd='001' then '.3200.' else '.3208.' 
end
||k.kecamatankd||'.'||l.kelurahankd into npwpd_out
from pad_customer c
inner join tblkelurahan l on c.kelurahan_id=l.id
inner join tblkecamatan k on l.kecamatan_id=k.id
where c.id=$1;

else

select c.rp||lpad( c.formno::text, 6, '0')||
case 
when k.kecamatankd='000' and l.kelurahankd='000' then '0000'
when k.kecamatankd='000' and l.kelurahankd='001' then '3200' else '3208'
end
||k.kecamatankd||l.kelurahankd into npwpd_out
from pad_customer c
inner join tblkelurahan l on c.kelurahan_id=l.id
inner join tblkecamatan k on l.kecamatan_id=k.id
where c.id=$1;

end if;

return npwpd_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_number_of_users_online(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare record_count integer;
begin

	select
		count(*) into record_count
	from
		users as u
	where
		u.application_name = _application_name
		and last_activity::timestamp with time zone + cast(_session_timeout || ' minutes' as interval) > current_timestamp;	

	return record_count;
end;
$$;",20151231%20karental_user.sql
"CREATE FUNCTION get_number_of_users_online(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare record_count integer;
begin

	select
		count(*) into record_count
	from
		users as u
	where
		u.application_name = _application_name
		and last_activity::timestamp with time zone + cast(_session_timeout || ' minutes' as interval) > current_timestamp;	

	return record_count;
end;
$$;",20160222%20karental_user.sql
"CREATE FUNCTION get_number_of_users_online(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare record_count integer;
begin

	select
		count(*) into record_count
	from
		users as u
	where
		u.application_name = _application_name
		and last_activity::timestamp with time zone + cast(_session_timeout || ' minutes' as interval) > current_timestamp;	

	return record_count;
end;
$$;",20160325%20karental_user.sql
"CREATE FUNCTION get_online_count(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	return (
		select 
			count(*) 
		from 
			users
		where 
			lower(application_name) = lower(_application_name)
			and last_activity::time + cast(_session_timeout + ' minutes' as interval) < current_timestamp);
end;
$$;",20151231%20karental_user.sql
"CREATE FUNCTION get_online_count(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	return (
		select 
			count(*) 
		from 
			users
		where 
			lower(application_name) = lower(_application_name)
			and last_activity::time + cast(_session_timeout + ' minutes' as interval) < current_timestamp);
end;
$$;",20160222%20karental_user.sql
"CREATE FUNCTION get_online_count(_session_timeout integer, _application_name character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	return (
		select 
			count(*) 
		from 
			users
		where 
			lower(application_name) = lower(_application_name)
			and last_activity::time + cast(_session_timeout + ' minutes' as interval) < current_timestamp);
end;
$$;",20160325%20karental_user.sql
"CREATE FUNCTION get_password(par_email character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
    declare
      loc_password text;
    begin
      select into loc_password Users.user_password
      from Users, User_contacts
      where User_contacts.email = par_email;

      if loc_password isnull then
        loc_password = 'null';
      end if;
      return loc_password;
    end;
  $$;",foodcart.backup
"CREATE FUNCTION get_patient_nonce(i_patient_id integer) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN (SELECT nonce FROM ""Patient"" WHERE id = i_patient_id);
END;
$$;",baza.sql
"CREATE FUNCTION get_permission(peer_name character varying, number_b character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare 

UID bigint;
DIR_ID bigint; 

begin

--
-- we getting UID 
--

select id from public.sip_peers where name=$1 into UID;
if not found then 
	raise exception 'NO SOURCE PEER/USER BY CHANNEL';
end if; 

--
-- gettting direction_id by number_b
-- 

select dr_list_item into DIR_ID from routing.directions 
	where $2 ~ dr_prefix 
	order by dr_prio 
	asc 
	limit 1; 

if not found then 
	raise exception 'NO DESTINATION BY NUMBER_B'; 
end if; 



perform id from routing.permissions 
	where direction_id=DIR_ID 
	and peer_id=UID;
	
if not found then 
	return false; 
end if; 

return true; 

end;

--
-- Функция завершена 30.11.11
-- Модификация 09.12.11 (убрали u_type и проверку по типу прав peer/user)
--
$_$;


ALTER FUNCTION routing.get_permission(peer_name character varying, number_b character varying) OWNER TO asterisk;

--
-- TOC entry 2091 (class 0 OID 0)
-- Dependencies: 38
-- Name: FUNCTION get_permission(peer_name character varying, number_b character varying); Type: COMMENT; Schema: routing; Owner: asterisk
--

COMMENT ON FUNCTION get_permission(peer_name character varying, number_b character varying) IS 'Процедура получения прав доступа на текущий звонок с номера А (канала А) на номер Б (направление Б). Исходные данные: 
- обрезанное имя канала (SIP/kyivstar-000001 = kyivstar), 
- номер Б 

Задача: 
1. найти указанное направление по номеру Б. 
2. Получить хотя бы одну запись из таблицы permissions. 

Тогда право есть. Иначе - permission denied and get out :-) ';


--
-- TOC entry 39 (class 1255 OID 16726)
-- Dependencies: 8 393
-- Name: route_test(); Type: FUNCTION; Schema: routing; Owner: asterisk
--

CREATE FUNCTION route_test() RETURNS trigger
    LANGUAGE plpgsql
    AS $$ 
begin 
if NEW.route_type = 'trunk' then  
	perform  id from public.sip_peers where id=NEW.route_dest_id; 
	if not found then 
		raise exception 'sip peer not found with same id';
	end if;
end if;  
if NEW.route_type = 'user' then 
	perform  id from public.sip_peers where id=NEW.route_dest_id; 
	if not found then 
		raise exception 'sip user not found with same id';
	end if; 
end if;
if NEW.route_type = 'context' then 
	perform id from public.extensions_conf where id=NEW.route_dest_id; 
	if not found then 
		raise exception 'context not found'; 
	end if ; 
end if; 
if NEW.route_type = 'tgroup' then 
	perform tgrp_id from routing.trunkgroups where tgrp_id=NEW.route_dest_id; 
	if not found then 
		raise exception 'trunkgroup not found'; 
	end if;
end if;
return NEW;
end;
$$;",real_express.sql
"CREATE FUNCTION get_phase_email(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec	RECORD;
	myemail	varchar(320);
BEGIN
	myemail := null;
	FOR myrec IN SELECT entitys.primary_email
		FROM entitys INNER JOIN entity_subscriptions ON entitys.entity_id = entity_subscriptions.entity_id
		WHERE (entity_subscriptions.entity_type_id = $1) LOOP

		IF (myemail is null) THEN
			IF (myrec.primary_email is not null) THEN
				myemail := myrec.primary_email;
			END IF;
		ELSE
			IF (myrec.primary_email is not null) THEN
				myemail := myemail || ', ' || myrec.primary_email;
			END IF;
		END IF;

	END LOOP;

	RETURN myemail;
END;
$_$;",employee.sql
"CREATE FUNCTION get_phase_entitys(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec			RECORD;
	myentitys		varchar(320);
BEGIN
	myentitys := null;
	FOR myrec IN SELECT entitys.entity_name
		FROM entitys INNER JOIN entity_subscriptions ON entitys.entity_id = entity_subscriptions.entity_id
		WHERE (entity_subscriptions.entity_type_id = $1) LOOP

		IF (myentitys is null) THEN
			IF (myrec.entity_name is not null) THEN
				myentitys := myrec.entity_name;
			END IF;
		ELSE
			IF (myrec.entity_name is not null) THEN
				myentitys := myentitys || ', ' || myrec.entity_name;
			END IF;
		END IF;

	END LOOP;

	RETURN myentitys;
END;
$_$;",employee.sql
"CREATE FUNCTION get_phase_status(boolean, boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	ps		varchar(16);
BEGIN
	ps := 'Draft';
	IF ($1 = true) THEN
		ps := 'Approved';
	END IF;
	IF ($2 = true) THEN
		ps := 'Rejected';
	END IF;

	RETURN ps;
END;
$_$;",employee.sql
"CREATE FUNCTION get_printer_id(character varying, inet, character varying) RETURNS integer
    AS $_$
    BEGIN
	RETURN (select id from printers where printer_name=$1 and ip_adress=$2 and mandat_id=get_mandat_id($3)); 
    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup
"CREATE FUNCTION get_printer_id(character varying, inet, character varying) RETURNS integer
    AS $_$
    BEGIN
	RETURN (select id from printers where printer_name=$1 and ip_adress=$2 and mandat_id=get_mandat_id($3)); 
    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup.sql
"CREATE FUNCTION get_process_status(p integer, u text) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$DECLARE
	s refcursor := 'process_status';
BEGIN
	OPEN s FOR SELECT status FROM process_list WHERE process = p AND puser = u;
	RETURN s;
END;$$;",krashr_db.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",crezoo_20110121
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",database.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",hr_database.pgsql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",nlp.dump
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",pgex_backup.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",schema.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",sqlex_backup.pgsql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",streetking-database.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION get_proj4_from_srid(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
BEGIN
	RETURN proj4text::text FROM spatial_ref_sys WHERE srid= $1;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION get_project_id_by_folder_id(folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
project_id INTEGER;
parent_folder_id INTEGER;
BEGIN
	

	IF $1 IS NOT NULL THEN

		SELECT core_project_has_folder.project_id INTO project_id FROM core_project_has_folder WHERE core_project_has_folder.folder_id = $1;
		IF project_id IS NOT NULL THEN
			RETURN project_id;
		ELSE
			SELECT core_folders.id INTO parent_folder_id FROM core_folders WHERE core_folders.data_entity_id =
				(SELECT data_entity_pid FROM core_data_entity_has_data_entities WHERE data_entity_cid = (SELECT data_entity_id FROM core_folders WHERE id=folder_id) AND (data_entity_pid IN (SELECT data_entity_id FROM core_folders)));

			RETURN get_project_id_by_folder_id(parent_folder_id);
		END IF;

		

	ELSE

		RETURN NULL;

	END IF;

END;$_$;",open-lims.sql
"CREATE FUNCTION get_project_supplementary_folder(folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
supplementary_folder_id INTEGER;
BEGIN
	

	IF $1 IS NOT NULL THEN

		SELECT core_folders.id INTO supplementary_folder_id FROM core_folders WHERE core_folders.data_entity_id IN
				(SELECT data_entity_cid FROM core_data_entity_has_data_entities WHERE data_entity_pid = (SELECT data_entity_id FROM core_folders WHERE id=folder_id) AND (data_entity_cid IN (SELECT data_entity_id FROM core_folders)))
				AND TRIM(LOWER(name)) = 'supplementary';

		RETURN supplementary_folder_id;

	ELSE

		RETURN NULL;

	END IF;

END;$_$;",open-lims.sql
"CREATE FUNCTION get_pt_info(u_id text, u_pw text, p_id text, OUT pt_name text, OUT furigana text, OUT birthday date, OUT gender smallint, OUT pt_memo text) RETURNS SETOF record
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    SET search_path TO public, pg_temp
    AS $$BEGIN
  if is_correct_pw(u_id, u_pw) then
      return query
          select
              patient.pt_name
              , patient.furigana
              , patient.birthday
              , patient.gender
              , patient.pt_memo
          from patient
          where pt_id = p_id
          ;
  else
      return query
          select
              patient.pt_name
              , patient.furigana
              , patient.birthday
              , patient.gender
              , patient.pt_memo
          from patient
          where 1=0
          ;
  end if;
END$$;",setup.dump
"CREATE FUNCTION get_publication_rating(pid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE rating INTEGER;
BEGIN
  SELECT SUM(votes.values) AS rating FROM votes WHERE votes.publicationid = pid
  INTO rating;
  RETURN rating;
END
$$;",dbm
"CREATE FUNCTION get_publication_rating(pid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE rating INTEGER;
BEGIN
  SELECT SUM(votes.values) AS rating FROM votes WHERE votes.publicationid = pid
  INTO rating;
  RETURN rating;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION get_queue_from_receiver(receiver_id integer, OUT o_queue_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$BEGIN
  SELECT m_queue_id FROM mps_message
  INTO o_queue_id
  WHERE m_receiver_id = receiver_id
  ORDER BY m_arrival_time DESC
  LIMIT 1;
END;$$;",mps_db_dump_100Q_Idxs_SP.backup
"CREATE FUNCTION get_random_float(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    start_int ALIAS FOR $1;
    end_int ALIAS FOR $2;
BEGIN
    RETURN (random() * (end_int-start_int) + start_int);
END;
$_$;",e4_vmele.backup
"CREATE FUNCTION get_random_int(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
    start_int ALIAS FOR $1;
    end_int ALIAS FOR $2;
BEGIN
    RETURN trunc(random() * (end_int-start_int) + start_int);
END;
$_$;",e4_vmele.backup
"CREATE FUNCTION get_random_number(integer, integer) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $_$
DECLARE
    start_int ALIAS FOR $1;
    end_int ALIAS FOR $2;
BEGIN
    RETURN trunc(random() * (end_int-start_int) + start_int);
END;
$_$;",libdb.backup.sql
"CREATE FUNCTION get_random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, get_random_number(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION get_rekening(rekeningkd character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare 
  rekening_out character varying;
begin

  rekening_out := replace(rekeningkd, '.', '');
  rekening_out := concat(
    coalesce(nullif(substring(rekeningkd,1,1)||'.','.'),''),
    coalesce(nullif(substring(rekeningkd,2,1)||'.','.'),''),
    coalesce(nullif(substring(rekeningkd,3,1)||'.','.'),''),
    coalesce(nullif(substring(rekeningkd,4,2)||'.','.'),''),
    coalesce(nullif(substring(rekeningkd,6,2)||'.','.'),''),
    coalesce(nullif(substring(rekeningkd,8,2)||'.','.'),'')
  );
  rekening_out := substring(rekening_out,1,length(rekening_out)-1);
  rekening_out := '1.20.05.00.00.'||rekening_out;
return rekening_out;
   
end
$$;",db_padl.sql
"CREATE FUNCTION get_report_header(v_header_id bigint, v_canton_id bigint, v_state_id bigint, v_municipality_id bigint, v_month_id bigint, v_year integer) RETURNS character varying
LANGUAGE plpgsql
AS $$
declare
    v_count  integer;
    v_result text;
begin
    v_count = 0;
    v_result = '';
--
    select header_name
    into v_result
    from cm_report_header
    where header_id = v_header_id;
--
    select count(*)
    into v_count
    from cm_report_header_alternatives
    where header_id = v_header_id;
--
    if v_count > 0
    then
        if (v_canton_id > -1 and v_state_id > -1 and v_municipality_id > -1)
        then
            select header_name
            into v_result
            from cm_report_header_alternatives
            where header_id = v_header_id and canton_id = 1 and state_id = 1 and municipality_id = 1;
        elsif (v_canton_id > -1 and v_state_id > -1 and v_municipality_id = -1)
            then
                select header_name
                into v_result
                from cm_report_header_alternatives
                where header_id = v_header_id and canton_id = 1 and state_id = 1 and municipality_id = -1;
        elsif (v_canton_id > -1 and v_state_id = -1 and v_municipality_id = -1)
            then
                select header_name
                into v_result
                from cm_report_header_alternatives
                where header_id = v_header_id and canton_id = 1 and state_id = -1 and municipality_id = -1;
        elsif (v_canton_id = -1 and v_state_id = -1 and v_municipality_id = -1)
            then
                select header_name
                into v_result
                from cm_report_header_alternatives
                where header_id = v_header_id and canton_id = -1 and state_id = -1 and municipality_id = -1;
        end if;
    end if;
--
    v_result = replace(v_result, ':selected_month:', format_date(1, v_month_id, v_year));
    v_result = replace(v_result, ':selected_month_name:', format_month(v_month_id, v_year));
    if (v_month_id > 1)
    then
        v_result = replace(v_result, ':previous_month:', format_date(1, v_month_id - 1, v_year));
        v_result = replace(v_result, ':previous_month_name:', format_month(v_month_id - 1, v_year));
    else
        v_result = replace(v_result, ':previous_month:', format_date(1, 12, v_year - 1));
        v_result = replace(v_result, ':previous_month_name:', format_month(12, v_year - 1));
    end if;

    return v_result;
end
$$;",functions.sql
"CREATE FUNCTION get_reporting_list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec	RECORD;
	mylist	varchar(320);
BEGIN
	mylist := null;
	FOR myrec IN SELECT entitys.entity_name
		FROM reporting INNER JOIN entitys ON reporting.report_to_id = entitys.entity_id
		WHERE (reporting.primary_report = true) AND (reporting.entity_id = $1) 
	LOOP

		IF (mylist is null) THEN
			mylist := myrec.entity_name;
		ELSE
			mylist := mylist || ', ' || myrec.entity_name;
		END IF;
	END LOOP;

	RETURN mylist;
END;
$_$;",employee.sql
"CREATE FUNCTION get_reports_id(inet, character varying, character varying, character varying, character varying, integer) RETURNS integer
    AS $_$
    BEGIN
	RETURN (SELECT id FROM reports WHERE printer_id=get_printer_id($2,$1,$3) and doc_name=$5 and page_copy=$6 and cups_user=$4);

    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup
"CREATE FUNCTION get_reports_id(inet, character varying, character varying, character varying, character varying, integer) RETURNS integer
    AS $_$
    BEGIN
	RETURN (SELECT id FROM reports WHERE printer_id=get_printer_id($2,$1,$3) and doc_name=$5 and page_copy=$6 and cups_user=$4);

    END;
$_$
    LANGUAGE plpgsql;",cupslog_plain.backup.sql
"CREATE FUNCTION get_sample_id_by_folder_id(folder_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
sample_id INTEGER;
parent_folder_id INTEGER;
BEGIN
	

	IF $1 IS NOT NULL THEN

		SELECT core_sample_has_folder.sample_id INTO sample_id FROM core_sample_has_folder WHERE core_sample_has_folder.folder_id = $1;
		IF sample_id IS NOT NULL THEN
			RETURN sample_id;
		ELSE
			SELECT core_folders.id INTO parent_folder_id FROM core_folders WHERE core_folders.data_entity_id =
				(SELECT data_entity_pid FROM core_data_entity_has_data_entities WHERE data_entity_cid = (SELECT data_entity_id FROM core_folders WHERE id=folder_id) AND (data_entity_pid IN (SELECT data_entity_id FROM core_folders)));

			RETURN get_sample_id_by_folder_id(parent_folder_id);
		END IF;

		

	ELSE

		RETURN NULL;

	END IF;

END;$_$;",open-lims.sql
"CREATE FUNCTION get_sptno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare sptno_out character varying;
begin

select tahun||'-'||lpad(sptno::text, 6, '0') into sptno_out
from pad_spt s where s.id=$1;

return sptno_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_sspd_approvalno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare no_out character varying;
begin

 --irul

select tahun||'.'||lpad(kode,2,'0')||'.'||lpad(no_urut::text,6,'0') into no_out
from bphtb_sspd_approval 
where bphtb_sspd_approval.id=$1;

return no_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_sspdno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare sspd_out character varying;
begin

 --irul
 --SSPDNO: 32.79.2014.333.22.123456 ->mubazir
 --SSPDNO: 32792014333-22.123456    ->mubazir

-- select kd_propinsi||'.'||kd_dati2||'.'||tahun||'.'||lpad(ppat_id::text,3,'0')||'-'||lpad(kode,2,'0')||'.'||lpad(no_sspd::text,6,'0') into sspd_out
select tahun||'.'||lpad(kode,2,'0')||'.'||lpad(no_sspd::text,6,'0') into sspd_out
from bphtb_sspd 
where bphtb_sspd.id=$1;

return sspd_out;
   
end
$_$;",db_bphtb.sql
"CREATE FUNCTION get_sspdno(spt_id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare sspdno_out character varying;
begin

select ss.tahun||'-'||lpad(sspdno::text, 6, '0') into sspdno_out
from pad_sspd ss
inner join pad_spt s on s.id=ss.spt_id
where s.id=$1 and ss.is_valid=1;

return sspdno_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_stpno(id bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare stpno_out character varying;
begin

select max(tahun)||'-'||lpad(max(stpdno)::text, 6, '0') into stpno_out
from pad_stpd where spt_id=$1;

return stpno_out;
   
end
$_$;",db_padl.sql
"CREATE FUNCTION get_str_similarity(p_string_1 text, p_string_2 text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE v_sim numeric := 0;
BEGIN
	WITH the_data AS (
	SELECT t1.term_1, t2.term_2
		, array_length(term_1, 1) as len_term_1
		, array_length(term_2, 1) as len_term_2
	FROM ( SELECT show_trgm(regexp_replace(p_string_1, '[^a-zA-Z ]+', '', 'g')) as term_1 ) t1
	CROSS JOIN (
		SELECT show_trgm(regexp_replace(p_string_2, '[^a-zA-Z ]+', '', 'g')) as term_2
		) t2
	)
	
	SELECT 	CASE WHEN len_term_1 < len_term_2 THEN n_match/len_term_1
		     ELSE n_match/len_term_2
		END as similarity INTO v_sim
	FROM the_data t1
	CROSS JOIN (
		SELECT count(*)::numeric as n_match
		FROM ( 	SELECT unnest(term_1) as term
			FROM the_data ) t1
		INNER JOIN ( 	SELECT unnest(term_2) as term
			FROM the_data ) t2 
			ON t1.term = t2.term
		) t2;

	RETURN v_sim;

END;
$$;",table_irci.sql
"CREATE FUNCTION get_sum_by_table_field_date_canton_id(table_ character varying, field_ character varying, year_ integer, month_ integer, canton_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' select sum('||$2||') from '||$1||' where canton_id='||cast($5 as varchar)||' and year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar);
EXECUTE v_sql INTO v_result;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_sum_by_table_field_date_municipality_id(table_ character varying, field_ character varying, year_ integer, month_ integer, municipality_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' WITH RECURSIVE temp1(municipality_id, parent_municipality_id) AS ';
v_sql = v_sql || ' (';
v_sql = v_sql || ' SELECT  t1.municipality_id , t1.parent_municipality_id FROM ad_municipality t1 WHERE t1.municipality_id = '||cast($5 as varchar);
v_sql = v_sql || ' UNION ';
v_sql = v_sql || ' SELECT t2.municipality_id, t2.parent_municipality_id FROM ad_municipality t2 JOIN temp1 ON t2.parent_municipality_id = temp1.municipality_id';
v_sql = v_sql || ' )';
v_sql = v_sql || ' select coalesce(sum('||$2||'),null,0,sum('||$2||')) from '||$1||' where year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar)||' and ';
v_sql = v_sql || ' municipality_id in (select municipality_id from temp1)';
EXECUTE v_sql INTO v_result;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_sum_by_table_field_date_state_id(table_ character varying, field_ character varying, year_ integer, month_ integer, canton_id bigint) RETURNS numeric
LANGUAGE plpgsql
AS $_$
DECLARE
    v_sql varchar(2048);
    v_result numeric;
BEGIN
v_sql = '';
v_sql = v_sql || ' select sum('||$2||') from '||$1||' where state_id='||cast($5 as varchar)||' and year_='||cast($3 as varchar)||' and month_='||cast($4 as varchar);
EXECUTE v_sql INTO v_result;
return v_result;
END
$_$;",functions.sql
"CREATE FUNCTION get_top_dataset_parent(dataset_id uuid) RETURNS uuid
    LANGUAGE plpgsql
    AS $$

DECLARE
  parent_id UUID;
BEGIN
  SELECT INTO parent_id parent_dataset_id FROM metadata.dataset where id = dataset_id;

  IF parent_id is NOT NULL THEN
    parent_id := metadata.get_top_dataset_parent(parent_id);
  ELSE
    parent_id = dataset_id;
  END IF;

  RETURN parent_id;

END;
$$;",baseline-schema.sql
"CREATE FUNCTION get_total_card_work_detail(username character varying, userstep character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      total integer;
    BEGIN
      total:= (select count(*) from (
SELECT distinct (data_id) 
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying and step = userstep
  ) as sub);
      RETURN total;
    END;
    $_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_trial_property_field(myfield text, myid integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
  BEGIN
return (SELECT  trial_properties.value
         FROM trial_properties
    JOIN trial_properties_catalogue ON trial_properties.idproperty = trial_properties_catalogue.id
   WHERE trial_properties_catalogue.name ~* myfield::text AND trial_properties.idtrial = myid
  LIMIT 1);  END;
$$;",sql_template.sql
"CREATE FUNCTION get_uom_conversion_factors(_part_code character varying, _version_num integer, _uom_domain_from character varying, _uom_domain_to character varying) RETURNS common.unit_conversion_type[]
    LANGUAGE plpgsql
    AS $$
DECLARE  
BEGIN

  RETURN 
    ARRAY (
      SELECT
        (definition.uom_code, 
        measurement.uom_code, 
        measurement.factor)::common.unit_conversion_type
      FROM 
        inventory.definition, 
        inventory.measurement, 
        inventory.information, 
        uom.information uom_from, 
        uom.information uom_to
      WHERE 
        definition.id = measurement.definition_id AND
        information.id = definition.information_id AND
        uom_from.uom_code = definition.uom_code AND
        uom_to.uom_code = measurement.uom_code AND
        information.part_code = _part_code AND 
        definition.version_num = _version_num AND 
        uom_from.uom_domain = _uom_domain_from::common.uom_domain_kind AND 
        uom_to.uom_domain = _uom_domain_to::common.uom_domain_kind
      );

END
$$;",mdm.sql
"CREATE FUNCTION get_user_by_step(step character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT DISTINCT assignment FROM data_cleaning.management where management.step =  $1 and management.assignment is not null;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160107.backup
"CREATE FUNCTION get_user_by_step(step character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT DISTINCT assignment FROM data_cleaning.management where management.step =  $1 and management.assignment is not null;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_user_by_step(step character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT DISTINCT assignment FROM data_cleaning.management where management.step =  $1 and management.assignment is not null;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_user_by_step(step character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT DISTINCT assignment FROM data_cleaning.management where management.step =  $1 and management.assignment is not null;
      RETURN ref;
    END;
    $_$;",data-cleaning_production.backup
"CREATE FUNCTION get_user_by_step(step character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT DISTINCT assignment FROM data_cleaning.management where management.step =  $1 and management.assignment is not null;
      RETURN ref;
    END;
    $_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_20160106.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_20160107.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_latest.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_production.backup
"CREATE FUNCTION get_user_info(login_username character varying, login_password character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT * FROM data_cleaning.users u
      WHERE u.user_name = $1 and u.password = $2 and u.status = true;	
      RETURN ref;
    END;
    $_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_user_info(p_user_id integer) RETURNS SETOF refcursor
LANGUAGE plpgsql
AS $$
declare

  _owner  refcursor := '_owner';
  _friends  refcursor := '_friends';
  _user_books refcursor := '_user_books';
begin
  OPEN _friends FOR
  SELECT  us.user_id,
    us.f_name,
    us.i_name,
    us.photo_src,
    us.email,
    us.dob
  FROM friendship fr
    JOIN users us ON us.user_id=fr.child_user_id
  WHERE fr.parent_user_id=p_user_id;
  RETURN NEXT _friends;

  OPEN _user_books FOR
  SELECT b.book_id,
    b.book_name,
    b.image_src
  FROM user_books ub JOIN books b ON ub.book_id=b.book_id
  WHERE ub.user_id=p_user_id;
  RETURN NEXT _user_books;

  OPEN _owner FOR
  SELECT  us.user_id,
    us.f_name,
    us.i_name,
    us.dob,
    us.photo_src,
    us.email
  FROM USERS us where us.user_id=p_user_id;
  RETURN NEXT _owner;

end;
$$;",scriptDB.sql
"CREATE FUNCTION get_user_name_by_email(_email character varying, _application_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	declare username varchar(250);
begin
	select
		user_name
	from
		users
	where
		lower(application_name) = lower(_application_name)
		and lower(email) = lower(_email)
	limit 1
	into 
		username;
	return username;
end;$$;",20151231%20karental_user.sql
"CREATE FUNCTION get_user_name_by_email(_email character varying, _application_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	declare username varchar(250);
begin
	select
		user_name
	from
		users
	where
		lower(application_name) = lower(_application_name)
		and lower(email) = lower(_email)
	limit 1
	into 
		username;
	return username;
end;$$;",20160222%20karental_user.sql
"CREATE FUNCTION get_user_name_by_email(_email character varying, _application_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	declare username varchar(250);
begin
	select
		user_name
	from
		users
	where
		lower(application_name) = lower(_application_name)
		and lower(email) = lower(_email)
	limit 1
	into 
		username;
	return username;
end;$$;",20160325%20karental_user.sql
"CREATE FUNCTION get_user_password(param_username character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
declare
	decrypted_password_bytes bytea;
	aes_key varchar(48);
	aes_key_bytes bytea;
	decrypted_password varchar(32);

	datafile text default 'key.txt';

	user_pwd bytea;
	stm varchar(100);
begin

	aes_key := pg_read_file(datafile, 0, 16);
	aes_key_bytes := convert_to(aes_key, 'UTF-8');

	execute 'select ""password""
	        from aems.""Users""
	        where username = $1' into user_pwd using param_username;

	decrypted_password_bytes := aems.request_decryption(aes_key_bytes, user_pwd);
	decrypted_password := convert_from(decrypted_password_bytes, 'UTF-8');

	return decrypted_password;
end;
$_$;",AEMS%2027-03-2018.backup
"CREATE FUNCTION get_vector_norm(_vector[]) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$begin
  return (select sqrt(sum(pow(v,2))) from unnest($1) v(t,v));
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION get_working_status(username character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_working_status(username character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_working_status(username character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying;
      RETURN ref;
    END;
    $_$;",data-cleaning_production.backup
"CREATE FUNCTION get_working_status(username character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying;
      RETURN ref;
    END;
    $_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION get_working_status(username character varying, userstep character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying and step = userstep;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160111.backup
"CREATE FUNCTION get_working_status(username character varying, userstep character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying and step = userstep;
      RETURN ref;
    END;
    $_$;",data-cleaning_20160113.backup
"CREATE FUNCTION get_working_status(username character varying, userstep character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  count(*) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying and step = userstep;
      RETURN ref;
    END;
    $_$;",data-cleaning_production.backup
"CREATE FUNCTION get_working_status(username character varying, userstep character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
    DECLARE
      ref refcursor;
    BEGIN
      OPEN ref FOR SELECT 
  data_cleaning.get_total_card_work_detail($1,$2) as total_card , sum(totaltime) as total_time, sum(totaltime)/count(*) as speed
FROM 
  data_cleaning.work_detail
  where user_name = $1 and datework = current_date::character varying and step = userstep;
      RETURN ref;
    END;
    $_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION getaccess(par_id bigint, par_lname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
	declare
		loc_id text;
		loc_res text;
	
	begin
		select into loc_id id, position from employees where id=par_id;
		
		if loc_id is null then
			loc_res = 'Person not authorized';
		
		else
			loc_res = 'Access granted';
		
		end if;
			return loc_res;
	end;

$$;",backup.sql
"CREATE FUNCTION getallstatusposts(par_sender_id bigint) RETURNS SETOF status
    LANGUAGE plpgsql
    AS $$BEGIN
SELECT * FROM status WHERE par_sender_id = sender_id;
END;$$;",socialnetworkdb.sql
"CREATE FUNCTION getcategories(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
  declare
	semsubjId_ alias for $1;
        cat_ text;
        temp_ text;
  begin
	cat_ = '';
        for temp_ in select cat_id||'$'||cat_name||'$'||weight||'$'||aggregation as info from category where semsubj_id = semsubjId_ loop
		cat_ = cat_||temp_||'@';
	end loop;
	
       
        return cat_;
  end;
$_$;",myEskwelaDB_May_20
"CREATE FUNCTION getclasses(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
  declare
	profId_ alias for $1;
        classes_ text;
        temp_ text;
  begin
	classes_ = '';
        for temp_ in select s.subj_code||'$'||s.description||'$'||ss.schedule||'$'||ss.section_code||'$'||ss.schoolyear||'$'||ss.semsubj_id as info from semsubject ss, subject s where ss.schoolyear = getcurrsem() and ss.fac_id = profId_ and s.subj_code = ss.subj_code order by s.subj_code loop
		classes_ = classes_||temp_||'@';
	end loop;
	
       
        return classes_;
  end;
$_$;",myEskwelaDB_May_20
"CREATE FUNCTION getcoursesstringforuser(userid text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE
   result_courses VARCHAR(500);
   user_course RECORD;
BEGIN
 result_courses := '';
 FOR user_course IN
         (SELECT c.description AS courseName
         FROM    locum_db.locum_Courses        AS c
               , locum_db.Locum_Qualifications AS lq
         WHERE lq.user_Id  = $1
         AND   c.course_Id = lq.course_Id
         ORDER BY  c.description)
 LOOP
         result_courses := result_courses || ',' || user_course.courseName;
 END LOOP;
 RETURN SUBSTR(result_courses, 2, 500);
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getcurrsem() RETURNS text
    LANGUAGE plpgsql
    AS $$
  declare
        b text;
  begin
        select into b schoolyear from sy order by (substring(schoolyear, 7, 4) || substring(schoolyear, 1,1))::numeric desc limit 1;
	--select into b max(schoolyear) from sy;
        if b isnull then
             b = 'NOT FOUND!!!';
        end if;
        return b;
  end;
$$;",myEskwelaDB_May_20
"CREATE FUNCTION getcustfiletypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pcustFileType 	ALIAS FOR $1;

	_custFileTypeId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getcustfiletypeid'));



	IF pcustFileType IS NULL THEN

		RETURN null;

	END IF;



	SELECT custfiletype_id

	INTO _custFileTypeId

	FROM custfiletype

	WHERE custfiletype_name = pcustFileType;



	IF _custFileTypeId IS NULL THEN

		RAISE EXCEPTION 'getcustfiletypeid: file Type % not found.', 

			pcustFileType;

	END IF;



	RETURN _custFileTypeId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getcustid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pCust 	ALIAS FOR $1;

	_custId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getcustid'));



	SELECT cust_id

	INTO _custId

	FROM cust

	WHERE cust_number = pCust;



	IF _custId IS NULL THEN

		RAISE EXCEPTION 'getcustid: Customer % Not Found in AeryonMES', 

			pCust;

	END IF;



	RETURN _custId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getcustparamid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pType 			ALIAS FOR $1;

	pParam			ALIAS FOR $2;

	_custParam		RECORD;

BEGIN

	PERFORM (SELECT checkpriv('getcustparamid'));



	IF pParam IS NULL THEN

		RAISE EXCEPTION 'getcustparamid: Custom Parameter Name cannot be null.';

	END IF;



	IF pType != 'r' AND pType != 'p' THEN

		RAISE EXCEPTION 'getcustparamid: Custom Parameter Type must be r or p.';

	END IF;



	SELECT 	custparam_id

	INTO _custParam

	FROM custparam

	WHERE custparam_param = pParam

	AND custparam_type = pType

	AND custparam_void_timestamp IS NULL;



	IF _custParam.custparam_id IS NULL THEN

		RAISE EXCEPTION 'getcustparamid: Custom Parameter % of Type % not found or is inactive', 

			pParam,

			pType;

	END IF;



	RETURN _custParam.custparam_id;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getcustparamvaluepart(text, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$DECLARE

	pParam	 		ALIAS FOR $1;

	pItemNumber		ALIAS FOR $2;

	pRevision		ALIAS FOR $3;

	pSerialNumber		ALIAS FOR $4;

	_custParamValue		TEXT;

	_partId 		INTEGER;

	_custParamId		INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('getcustparamvaluepart'));



	_custParamId := (SELECT getcustparamid('p', pParam));

		

	_partId = (SELECT getpartid(pItemNumber, pRevision, pSerialNumber));



	_custParamValue := (	SELECT 	partcustparamvalue_value

				FROM viewpartcustparamvalue

				WHERE custparam_id = _custParamId

				AND part_id = _partId

				AND partcustparamvalue_void_timestamp IS NULL

				ORDER BY partcustparamvalue_submit_timestamp DESC

				LIMIT 1);



	RETURN _custParamValue;

END;$_$;",ames_dev.backup
"CREATE FUNCTION getcustparamvaluerecord(text, text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$DECLARE

	pParam	 		ALIAS FOR $1;

	pRecordType		ALIAS FOR $2;

	pRecordId		ALIAS FOR $3;

	_custParamValue		TEXT;

	_recordTypeId 		INTEGER;

	_custParamId		INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('getcustparamvaluerecord'));



	IF pRecordId IS NULL THEN

		RAISE EXCEPTION 'getcustparamvaluerecord: Record ID cannot be null.';

	END IF;	



	_custParamId := (SELECT getcustparamid('r', pParam));

		

	_recordTypeId := (SELECT getrecordtypeid(pRecordType));



	_custParamValue := (	SELECT 	recordcustparamvalue_value

				FROM viewrecordcustparamvalue

				WHERE custparam_id = _custParamId

				AND recordtype_id = _recordTypeId

				AND recordcustparamvalue_record_id = pRecordId

				AND recordcustparamvalue_void_timestamp IS NULL

				ORDER BY recordcustparamvalue_submit_timestamp DESC

				LIMIT 1);



	RETURN _custParamValue;

END;$_$;",ames_dev.backup
"CREATE FUNCTION getdatatypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pDataType 		ALIAS FOR $1;

	_dataType		RECORD;

BEGIN

	PERFORM (SELECT checkpriv('getdatatypeid'));



	SELECT 	datatype_id,

		datatype_active

	INTO _dataType

	FROM datatype

	WHERE datatype_type = lower(pDataType);



	IF _dataType.datatype_id IS NULL THEN

		RAISE EXCEPTION 'getdatatypeid: Data Type % Not Found in AeryonMES', 

			pDataType;

	ELSIF _dataType.datatype_active = false THEN

		RAISE EXCEPTION 'getdatatypeid: Data Type % is inactive', 

			pDataType;

	END IF;



	RETURN _dataType.datatype_id;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getdatediff(startdate date, enddate date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$ DECLARE 
BEGIN
RETURN  (($2) - ($1));
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdayofweek(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    return CAST(EXTRACT(DOW FROM $1) AS INTEGER) + 1;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdayofweek(timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    return CAST(EXTRACT(DOW FROM $1) AS INTEGER) + 1;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdaysstringforuser(branch integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE
	   result_day VARCHAR(500);
	BEGIN
	 SELECT CASE 
		WHEN b.working_day = '111111'
		THEN '2_Mon,3_Tue,4_Wed,5_Thu,6_Fri,7_Sat'
		WHEN b.working_day ='111100'
		THEN '2_Mon,3_Tue,4_Wed,5_Thu'
		WHEN b.working_day ='111110'
		THEN '2_Mon,3_Tue,4_Wed,5_Thu,6_Fri'
		ELSE '2_Mon,3_Tue,4_Wed,5_Thu,6_Fri,7_Sat'
		END AS workingDay INTO result_day
	FROM  locum_db.branch_details b
	WHERE branch_id = $1;
	RETURN result_day;
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdaytype(eventdate date, op_time timestamp without time zone, cl_time timestamp without time zone, lch_start_time timestamp without time zone, lch_end_time timestamp without time zone) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$DECLARE
   l_result VARCHAR(30) := '' ; 
BEGIN
	SELECT CASE
				WHEN (TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
				TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) = interval '00:00' THEN
					CASE
						WHEN locum_db.getdayofweek(eventdate) = 7 THEN	-- Check for Saturday
							CASE
								WHEN ((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) > interval '05:00')
									THEN 'Full'
								ELSE  'AM'
							END
						ELSE
							CASE
								WHEN ((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) > interval '05:00')
									THEN 'Full'
								ELSE  'AM'
							END
						END
				WHEN (TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
				TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) > interval '00:00' THEN
					CASE
						WHEN locum_db.getdayofweek(eventdate) = 7 THEN	-- Check for Saturday
							CASE
								WHEN ((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) -
								(TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) > interval '05:00')
									THEN 'Full'
								ELSE  'AM'
							END
						ELSE
							CASE
								WHEN ((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) -
								(TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) > interval '05:00')
								THEN 'Full'
							ELSE  'AM'
						END
					END
				END
		INTO l_result ;

	RETURN ( l_result ) ;
END;
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdaytype1(eventdate date, op_time timestamp without time zone, cl_time timestamp without time zone, lch_start_time timestamp without time zone, lch_end_time timestamp without time zone) RETURNS character varying
    LANGUAGE plpgsql IMMUTABLE
    AS $$DECLARE
   l_result VARCHAR(30) := '' ; 
BEGIN
	SELECT CASE

		
				WHEN (TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
				TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) = interval '00:00' THEN
					CASE
						WHEN locum_db.getdayofweek(eventdate) = 7 THEN	-- Check for Saturday
							CASE
								WHEN (((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI'))) < interval '05:00' AND  ((extract(hour from op_Time)>=13)))
									THEN 'PM'
								ELSE  'Full'
								
							END
						ELSE
							CASE
								WHEN (((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) < interval '05:00') AND ( (extract(hour from op_Time)>=13)))
									THEN 'PM'
								ELSE  'Full'
							END
						END
				WHEN (TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
				TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) > interval '00:00' THEN
					CASE
						WHEN locum_db.getdayofweek(eventdate) = 7 THEN	-- Check for Saturday
							CASE
								WHEN (((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) -
								(TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI'))) < interval '05:00' AND  ((extract(hour from op_Time)>=13)))
									THEN 'PM'
								ELSE  'Full'
							END
						ELSE
							CASE
								WHEN (((TO_TIMESTAMP(TO_CHAR(cl_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(op_Time,'HH24:MI'),'HH24:MI')) -
								(TO_TIMESTAMP(TO_CHAR(lch_End_Time,'HH24:MI'),'HH24:MI') -
								TO_TIMESTAMP(TO_CHAR(lch_Start_Time,'HH24:MI'),'HH24:MI')) < interval '05:00') AND ( (extract(hour from op_Time)>=13)))
								THEN 'PM'
							ELSE  'Full'
						END
					END
				END
		INTO l_result ;

	RETURN ( l_result ) ;
END;
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getdevicelistcountbygroup(groupid integer, filer integer[]) RETURNS integer
    AS $$
declare
	t integer;			
BEGIN
	SELECT count(deviceid) as c into t FROM devicesetting where deviceid in (select deviceid from devicegroupdevice where devicegroupdevice.devicegroupid=groupid) and subtype = any( filer );	
	return t;
End;
$$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION getdevicelistcountbygroupnofiler(groupid integer) RETURNS integer
    AS $$
declare
	t integer;			
BEGIN
	SELECT count(deviceid) as c into t FROM devicesetting where deviceid in (select deviceid from devicegroupdevice where devicegroupdevice.devicegroupid=groupid);	
	return t;
End;
$$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION getdifftsinsec(lastactivity timestamp without time zone) RETURNS numeric
    LANGUAGE plpgsql
    AS $$     DECLARE   RESULT NUMERIC;  BEGIN  RESULT := EXTRACT(HOUR FROM LOCALTIMESTAMP - LASTACTIVITY)*3600 +  EXTRACT(MINUTE FROM LOCALTIMESTAMP - LASTACTIVITY)*60 +  EXTRACT( SECOND FROM LOCALTIMESTAMP - LASTACTIVITY);    return RESULT; END; $$;",bgtTest.backup
"CREATE FUNCTION getdoctypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pDocType 	ALIAS FOR $1;

	_docTypeId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getdoctypeid'));



	SELECT doctype_id

	INTO _docTypeId

	FROM doctype

	WHERE doctype_name = pDocType;



	IF _docTypeId IS NULL THEN

		RAISE EXCEPTION 'getdoctypeid:  Doc Type % Not Found in AeryonMES', 

			pDocType;

	END IF;



	RETURN _docTypeId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getenumerationxml(enu text) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     r record;
     res xml;
  BEGIN

       FOR r IN SELECT trim(regexp_split_to_table(trim(enu, '[]'), E'\\|'), ' ') AS part LOOP
         res := xmlconcat(res, xmlelement(name ""enumeration"", xmlattributes( r.part as value)));
       END LOOP;
     return res;
  END;
$$;",test.sql
"CREATE FUNCTION geteventidsforbulkbooking(branchid integer, startdate date, enddate date, userid text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE 
	   result_eventIds VARCHAR(500);
	   schedule_event RECORD;
	BEGIN
		result_eventIds := '';
		FOR schedule_event IN
			(SELECT a.id AS eventId FROM locum_db.locum_schedule_events a WHERE a.branch_id = $1 AND a.event_date between $2 and $3 AND a.user_id=$4)
		LOOP
			result_eventIds := result_eventIds || ',' || schedule_event.eventId;
		END LOOP;
		RETURN SUBSTR(result_eventIds, 2, 500);
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION geteventidsforpayment(paymentid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE 
   result_eventIds VARCHAR(500);
   schedule_event RECORD;
BEGIN
	result_eventIds := '';
	FOR schedule_event IN
		(SELECT a.schedule_id AS eventId FROM locum_db.locum_claim_details a WHERE a.claim_id = $1 AND a.claim_status = 'clm' ORDER BY created_date)
	LOOP
		result_eventIds := result_eventIds || ',' || schedule_event.eventId;
	END LOOP;
	RETURN SUBSTR(result_eventIds, 2, 500);
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getexportaddress1(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    address character varying;
	
    BEGIN
	address:=(select COALESCE(trim(approve_address1) or (approve_address1 = ''),COALESCE(trim(qc_address1) or qc_address1='',verify_address1)) from data_cleaning.data_process where data_id = $1);	
	if(address is null)
	then
		
	end if;
      RETURN address;
    END;
    $_$;",data-cleaning_20160106.backup
"CREATE FUNCTION getexportaddress1(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
    DECLARE
    address character varying;
	
    BEGIN
	address:=(select COALESCE(trim(approve_address1) or (approve_address1 = ''),COALESCE(trim(qc_address1) or qc_address1='',verify_address1)) from data_cleaning.data_process where data_id = $1);	
	if(address is null)
	then
		
	end if;
      RETURN address;
    END;
    $_$;",data-cleaning_latest.backup
"CREATE FUNCTION getfilepart(text, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE

  pItemNumber ALIAS FOR $1;

  pRevision ALIAS FOR $2;

  pSerialNumber ALIAS FOR $3;

  pFileName ALIAS FOR $4;

  _partId	INTEGER;

  _partFile RECORD;

  _hexData TEXT;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('getfilepart'));

		

	_partId := (SELECT getpartid(pItemNumber, pRevision, pSerialNumber));



	SELECT 	partfile_id,

		partfile_partfiledata_id

	INTO _partFile

	FROM partfile

	WHERE partfile_filename = pFileName

	AND partfile_part_id = _partId

	AND partfile_void_timestamp IS NULL;



	IF _partFile.partfile_id IS NULL THEN

		RAISE EXCEPTION 'getfilepart: File with Name % does not exist for Item Number % Revision % Serial Number %.', 

			pFileName,

			pItemNumber,

			pRevision,

			pSerialNumber;

	END IF;



	SELECT encode(partfiledata_data, $$hex$$)

	INTO _hexData

	FROM partfiledata

	WHERE partfiledata_id = _partFile.partfile_partfiledata_id;



	RETURN _hexData;

END$_$;",ames_dev.backup
"CREATE FUNCTION getfilerecord(text, integer, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$

DECLARE

  pRecordType ALIAS FOR $1;

  pRecordId ALIAS FOR $2;

  pFileName ALIAS FOR $3;

  _recordTypeId	INTEGER;

    _recordFile RECORD;

  _hexData	TEXT;



  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('getfilerecord'));

		

	_recordTypeId := (SELECT getrecordtypeid(pRecordType));

	

	SELECT recordfile_id,

		recordfile_recordfiledata_id

	INTO _recordFile

	FROM recordfile

	WHERE recordfile_filename = pFileName

	AND recordfile_recordtype_id = _recordTypeId

	AND recordfile_record_id = pRecordId

	AND recordfile_void_timestamp IS NULL;



	IF _recordFile.recordfile_id IS NULL THEN

		RAISE EXCEPTION 'getfilerecord: File with Name % and File Type % does not exist for Record Type % with ID %.', 

			pFileName,

			pFileType,

			pRecordType,

			pRecordId;

	END IF;



	SELECT encode(recordfiledata_data, $$hex$$)

	INTO _hexData

	FROM recordfiledata

	WHERE recordfiledata_id = _recordFile.recordfile_recordfiledata_id;



	RETURN _hexData;

END$_$;",ames_dev.backup
"CREATE FUNCTION getfiletypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pFileType 	ALIAS FOR $1;

	_fileTypeId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getfiletypeid'));



	IF pfileType IS NULL THEN

		RETURN null;

	END IF;



	SELECT filetype_id

	INTO _fileTypeId

	FROM filetype

	WHERE filetype_mediatypename = pFileType;



	IF _fileTypeId IS NULL THEN

		RAISE EXCEPTION 'getfiletypeid: file Type % not found.', 

			pfileType;

	END IF;



	RETURN _fileTypeId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getfollowers(par_member_id bigint) RETURNS SETOF bigint
    LANGUAGE plpgsql
    AS $$BEGIN
SELECT follower_id FROM followrelation WHERE member_id = par_member_id;
END;$$;",socialnetworkdb.sql
"CREATE FUNCTION getinitials(text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE initials TEXT;
BEGIN
       SELECT CASE
WHEN 'foreName' = $1 
                      THEN substr(u.fore_name::text, 1, 1) || substr(COALESCE(u.last_name, ''::character varying)::text, 1, 2) 
ELSE 
                     substr(u.last_name::text, 1, 1) || substr(COALESCE(u.fore_name, ''::character varying)::text, 1, 2) 
END  AS initials INTO initials
FROM locum_db.users u
WHERE  u.user_id= $2;
return initials;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getintervaltointeger(intervaltime timestamp with time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$ DECLARE 
BEGIN
RETURN CAST(EXTRACT(EPOCH FROM $1)/3600 AS Float);
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getintervaltointeger(intervaltime timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$ DECLARE 
	BEGIN
		RETURN CAST(EXTRACT(EPOCH FROM $1)/3600 AS Float);
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getitemid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 	ALIAS FOR $1;

	_itemId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getitemid'));



	SELECT item_id

	INTO _itemId

	FROM item

	WHERE item_number = pItemNumber;



	IF _itemId IS NULL THEN

		RAISE EXCEPTION 'getitemid: Item Number % Not Found in AeryonMES', 

			pItemNumber;

	END IF;



	RETURN _itemId;

END;



	$_$;",ames_dev.backup
"CREATE FUNCTION getlevelpoints() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	ret Integer;
BEGIN
    IF (SELECT count(*)::int FROM ""levels"") > 0 THEN
        SELECT INTO ret ""minimumPoints"" FROM ""levels"" WHERE ""levelId"" = (SELECT max(""levelId"")::int FROM ""levels"");
        ret := ret * 2;
    ELSE
        ret := 1000;
    END IF; 
    RETURN ret;
END
$$;",MiMissionMVC_20171210_193535.sql
"CREATE FUNCTION getlineid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pLine 	ALIAS FOR $1;

	_lineId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getlineid'));



	SELECT line_id

	INTO _lineId

	FROM line

	WHERE line_name = pLine;



	IF _lineId IS NULL THEN

		RAISE EXCEPTION 'getlineid: line % Not Found in AeryonMES.', 

			pLine;

	END IF;



	RETURN _lineId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getlocid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pLoc 	ALIAS FOR $1;

	_locId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getlocid'));



	SELECT loc_id

	INTO _locId

	FROM loc

	WHERE loc_number = pLoc;



	IF _locId IS NULL THEN

		RAISE EXCEPTION 'getlocid: Location % Not Found in AeryonMES', 

			pLoc;

	END IF;



	RETURN _locId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getlocumaccessagencyname(userid text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE
	   name VARCHAR(500);
	   agency_name RECORD;
	   default_agency_name RECORD;
	BEGIN
	name := '';
	FOR agency_name IN
	(
		SELECT ad.agency_name AS Agency
		FROM  locum_db.agency_locum_assocs a
		INNER JOIN locum_db.agency_details AS ad ON (ad.id = a.agency_id) 
		WHERE a.user_id = $1
		ORDER BY ad.agency_name
	)
	LOOP 
		name := name || ',' || agency_name.Agency;
	END LOOP;
		IF name <> '' THEN
			RETURN SUBSTR(name, 2, 500);
		ELSE
	               FOR default_agency_name IN
	               (
		          SELECT agc_det.agency_name
		          FROM locum_db.agency_details as agc_det
		          WHERE EXISTS (SELECT '1' from locum_db.system_parameters as sys_param
		          WHERE  sys_param.sys_key = 'DEFAULT' and sys_param.sys_type = 'Agency'
		          and agc_det.id = cast(sys_param.value as integer)) 
	               )
	               LOOP 
		            name:= default_agency_name;
			    RETURN SUBSTR(name,2,3);
	               END LOOP;
		 END IF ;
	RETURN name ;	
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getmacachdung() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaCachDung char(6);
BEGIN
IF (EXISTS (SELECT * FROM public.""LoaiCachDung"")) THEN
	SELECT CAST(RIGHT(""MaCachDung"", 4) as INTEGER)
	FROM public.""LoaiCachDung""
	ORDER BY ""MaCachDung"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaCachDung = 'CD' || RIGHT('0000' || CAST(MaSoKB + 1 AS CHAR(4)), 4 );
	return MaCachDung;
END;
$$;",database.backup
"CREATE FUNCTION getmachitietphieukham() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoPK integer;
	MaChiTietPhieuKham char(10);
BEGIN


IF (EXISTS (SELECT * FROM public.""ChiTietPhieuKham"")) THEN
	SELECT CAST(RIGHT(""MaChiTietPhieuKham"", 8) as INTEGER)
	FROM public.""ChiTietPhieuKham""
	ORDER BY ""MaChiTietPhieuKham"" desc
	LIMIT 1
	INTO MaSoPK;
ELSE
	MaSoPK = 0;
END IF;
	MaChiTietPhieuKham = 'PK' || RIGHT('00000000' || CAST(MaSoPK + 1 AS CHAR(8)), 8 );
	RETURN MaChiTietPhieuKham;
END;
$$;",database.backup
"CREATE FUNCTION getmadichvu() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaDichVu char(6);
BEGIN
IF (EXISTS (SELECT * FROM public.""LoaiDichVu"")) THEN
	SELECT CAST(RIGHT(""MaDichVu"", 4) as INTEGER)
	FROM public.""LoaiDichVu""
	ORDER BY ""MaDichVu"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaDichVu = 'DZ' || RIGHT('0000' || CAST(MaSoKB + 1 AS CHAR(4)), 4 );
	return MaDichVu;
END;
$$;",database.backup
"CREATE FUNCTION getmadonvi() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaDonVi char(6);
BEGIN
IF (EXISTS (SELECT * FROM public.""LoaiDonVi"")) THEN
	SELECT CAST(RIGHT(""MaDonVi"", 4) as INTEGER)
	FROM public.""LoaiDonVi""
	ORDER BY ""MaDonVi"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaDonVi = 'DV' || RIGHT('0000' || CAST(MaSoKB + 1 AS CHAR(4)), 4 );
	return MaDonVi;
END;
$$;",database.backup
"CREATE FUNCTION getmainmenubyuid(userid integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$    DECLARE

      ref1 refcursor:= 'listCursor';         

      QueryString varchar(4000):='';     

    BEGIN    

         OPEN ref1  FOR SELECT trim(""displayName"") as ""displayName"" ,trim(""screenName"") as ""screenName"",""isVesselMenu"" FROM smartship.""Menu"" where ""isVesselMenu""=false and ""isActive""=true order by id asc;   -- Open the first cursor

      RETURN next ref1;    

    END;

    $$;",voxac-plain.backup
"CREATE FUNCTION getmakhambenh() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaKhamBenh char(10);
BEGIN


IF (EXISTS (SELECT * FROM public.""KhamBenh"")) THEN
	SELECT CAST(RIGHT(""MaKhamBenh"", 8) as INTEGER)
	FROM public.""KhamBenh""
	ORDER BY ""MaKhamBenh"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaKhamBenh = 'KB' || RIGHT('00000000' || CAST(MaSoKB + 1 AS CHAR(8)), 8 );
	RETURN MaKhamBenh;
END;
$$;",database.backup
"CREATE FUNCTION getmaloaibenh() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaKhamBenh char(10);
BEGIN
IF (EXISTS (SELECT * FROM public.""LoaiBenh"")) THEN
	SELECT CAST(RIGHT(""MaLoaiBenh"", 4) as INTEGER)
	FROM public.""LoaiBenh""
	ORDER BY ""MaLoaiBenh"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaKhamBenh = 'LB' || RIGHT('0000' || CAST(MaSoKB + 1 AS CHAR(4)), 4 );
	return MaKhamBenh;
END;
$$;",database.backup
"CREATE FUNCTION getmanagedoutageforintfinwindow(integer, character varying, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        ipid ALIAS FOR $2;
        xtime ALIAS FOR $3;
        ytime ALIAS FOR $4;
        downtime float8 := 0.0;
        orec RECORD;
   BEGIN
        FOR orec IN SELECT DISTINCT ifservices.id AS ifServiceId 
                FROM ifservices, ipinterface, node 
                WHERE ifservices.ipInterfaceId = ipInterface.id 
                        AND ipinterface.nodeid = node.nodeid 
                        AND ifservices.status = 'A' 
                        AND ipinterface.ismanaged = 'M' 
                        AND ipinterface.ipaddr = ipid 
                        AND node.nodeid = nid 
                        AND node.nodetype = 'A'
        LOOP
                BEGIN
                        downtime := downtime + getOutageTimeInWindow( orec.ifServiceId, xtime, ytime);
                END;
        END LOOP;
        RETURN downtime;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmanagedoutagefornodeinwindow(integer, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        xtime ALIAS FOR $2;
        ytime ALIAS FOR $3;
        downtime float8 := 0.0;
        orec RECORD;
   BEGIN
        FOR orec IN SELECT DISTINCT ifservices.id AS ifServiceId 
                FROM ifservices, ipinterface, node 
                WHERE ifservices.ipInterfaceId = ipInterface.id 
                        AND ipinterface.nodeid = node.nodeid 
                        AND ifservices.status = 'A' 
                        AND ipinterface.ismanaged = 'M' 
                        AND node.nodeid = nid 
                        AND node.nodetype = 'A'
        LOOP
                BEGIN
                        downtime := downtime + getOutageTimeInWindow( orec.ifServiceId, xtime, ytime);
                END;
        END LOOP;
        RETURN downtime;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmanagedservicecountforintf(integer, character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        ipid ALIAS FOR $2;
        orec RECORD;
        counter float8;
   BEGIN
        counter = 0;
        FOR orec IN SELECT DISTINCT ifservices.ipInterfaceId, ifservices.serviceid
                FROM ifservices, ipinterface, node 
                WHERE ifservices.ipInterfaceId = ipInterface.id 
                        AND ipinterface.nodeid = node.nodeid 
                        AND ifservices.status = 'A' 
                        AND ipinterface.ismanaged = 'M' 
                        AND ipinterface.ipaddr = ipid 
                        AND node.nodeid = nid 
                        AND node.nodetype = 'A'
        LOOP
                BEGIN
                        counter := counter + 1;
                END;
        END LOOP;
        RETURN counter;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmanagedservicecountfornode(integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        orec RECORD;
        counter float8;
   BEGIN
        counter = 0;
        FOR orec IN SELECT DISTINCT ifservices.ipInterfaceId, ifservices.serviceid
                FROM ifservices, ipinterface, node 
                WHERE ifservices.ipInterfaceId = ipInterface.id 
                        AND ipinterface.nodeid = node.nodeid 
                        AND ifservices.status = 'A' 
                        AND ipinterface.ismanaged = 'M' 
                        AND node.nodeid = nid 
                        AND node.nodetype = 'A'
        LOOP
                BEGIN
                         counter := counter + 1;
                END;
        END LOOP;
        RETURN counter;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmanagepercentavailintfwindow(integer, character varying, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        ipid ALIAS FOR $2;
        xtime ALIAS FOR $3;
        ytime ALIAS FOR $4;
        downtime float8 := 0.0;
        count integer := 0;
        rollingWindow float := 0;
        totalServiceTime float := 0;
   BEGIN
        IF xtime < ytime THEN
                rollingWindow := EXTRACT (EPOCH FROM (ytime - xtime));
                downtime := getManagedOutageForIntfInWindow(nid, ipid, ytime, xtime)/1000;
        ELSE
                rollingWindow := EXTRACT (EPOCH FROM (xtime - ytime));
                downtime := getManagedOutageForIntfInWindow(nid, ipid, xtime, ytime)/1000;
        END IF;
        count := getManagedServiceCountForIntf(nid, ipid);
        totalServiceTime := count * rollingWindow;

        IF totalServiceTime > 0 THEN
                RETURN  100 * (1 - (downtime / totalServiceTime));
        ELSE
                IF totalServiceTime = 0 THEN
                        RETURN 100;
                ELSE
                        RETURN -1;
                END IF;
        END IF;    
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmanagepercentavailnodewindow(integer, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        nid ALIAS FOR $1;
        xtime ALIAS FOR $2;
        ytime ALIAS FOR $3;
        downtime float8 := 0.0;
        count integer := 0;
        rollingWindow float := 0;
        totalServiceTime float := 0;
   BEGIN
        IF xtime < ytime THEN
                rollingWindow := EXTRACT (EPOCH FROM (ytime - xtime));
                downtime := getManagedOutageForNodeInWindow(nid, ytime, xtime)/1000;
        ELSE
                rollingWindow := EXTRACT (EPOCH FROM (xtime - ytime));
                downtime := getManagedOutageForNodeInWindow(nid, xtime, ytime)/1000;
        END IF;
        count := getManagedServiceCountForNode(nid);
        totalServiceTime := count * rollingWindow;

        IF totalServiceTime > 0 THEN
                RETURN 100 * (1 - (downtime / totalServiceTime));
        ELSE
                IF totalServiceTime = 0 THEN
                        RETURN 100;
                ELSE
                        RETURN -1;
                END IF;
        END IF;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getmathuoc() RETURNS character
    LANGUAGE plpgsql
    AS $$
DECLARE
	MaSoKB integer;
	MaThuoc char(6);
BEGIN
IF (EXISTS (SELECT * FROM public.""LoaiThuoc"")) THEN
	SELECT CAST(RIGHT(""MaThuoc"", 4) as INTEGER)
	FROM public.""LoaiThuoc""
	ORDER BY ""MaThuoc"" desc
	LIMIT 1
	INTO MaSoKB;
ELSE
	MaSoKB = 0;
END IF;
	MaThuoc = 'LT' || RIGHT('0000' || CAST(MaSoKB + 1 AS CHAR(4)), 4 );
	return MaThuoc;
END;
$$;",database.backup
"CREATE FUNCTION getmenubyuid(_userid integer, _vesselid text) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$    DECLARE

      ref1 refcursor:= 'listCursor';         

    BEGIN    

    OPEN ref1  FOR SELECT trim(m.""displayName"") as ""displayName"" ,trim(m.""screenName"") as ""screenName"",m.""isVesselMenu"" FROM smartship.""Menu"" m inner join smartship.""VesselRole"" r

on m.""id""=r.""screenXId"" inner join smartship.uservesselrole vr on vr.roleid=r.""roleXId"" where m.""isVesselMenu""=true and m.""isActive""=true and vr.userid=_userId and vr.vesselid=_vesselId order by m.id asc;

      RETURN next ref1;    

    END;

    $$;",voxac-plain.backup
"CREATE FUNCTION getmilesforpostcodes(frompostcode text, topostcode text) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE
miles VARCHAR(10);
BEGIN
SELECT  TO_CHAR(distance, 'FM990.00') 
INTO    miles
FROM    locum_db.postcode_distance
WHERE   ((from_postcode = $1 AND to_postcode = $2)
OR 
(from_postcode = $2 AND to_postcode = $1)) 
LIMIT 1 ;
--
        IF ($1 = $2) THEN
           miles = '0' ;
        END IF ;
IF miles IS NULL 
THEN miles = '-1' ;
END IF ;
RETURN ( miles ) ;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getminutosprod(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare tiempo interval;
declare minutos integer;
begin
	tiempo = (select sum(do_fecha_fin - do_fechaini) 
	from documento_flujo  
	join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	join proceso on(documento.proceso_id=proceso.id)
	where proceso.id=idproceso and documento_flujo.do_estado='F' and
	(documento_flujo.do_fechaini BETWEEN fechaini and fechafin) and
	(documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	minutos = (select (extract('epoch' from tiempo)/60)::integer);
	return minutos;
end;
$$;",VTz-8rcK_modelosigedoc
"CREATE FUNCTION getminutosprod(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare tiempo interval;
declare minutos integer;
begin
	tiempo = (select sum(do_fecha_fin - do_fechaini) 
	from documento_flujo  
	join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	join proceso on(documento.proceso_id=proceso.id)
	where proceso.id=idproceso and documento_flujo.do_estado='F' and
	(documento_flujo.do_fechaini BETWEEN fechaini and fechafin) and
	(documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	minutos = (select (extract('epoch' from tiempo)/60)::integer);
	return minutos;
end;
$$;",VvBq-zuB_modelosigedoc
"CREATE FUNCTION getmoduleid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pModule 	ALIAS FOR $1;

	_moduleId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getmoduleid'));



	SELECT module_id

	INTO _moduleId

	FROM module

	WHERE module_name = pModule;



	IF _moduleId IS NULL THEN

		RAISE EXCEPTION 'getmoduleid: Module % Not Found in AeryonMES', 

			pModule;

	END IF;



	RETURN _moduleId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getmonth(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
    pDate ALIAS FOR $1;
    vResult integer;
  BEGIN
    vResult := EXTRACT('month' FROM pDate);
    RETURN vResult;
  END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION getmonth(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
    pDate ALIAS FOR $1;
    vResult integer;
  BEGIN
    vResult := EXTRACT('month' FROM pDate);
    RETURN vResult;
  END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION getmonth(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
   pDate ALIAS FOR $1;
   vResult integer;
 BEGIN
   vResult := EXTRACT('month' FROM pDate);
   RETURN vResult;
 END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION getmonth(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
   pDate ALIAS FOR $1;
   vResult integer;
 BEGIN
   vResult := EXTRACT('month' FROM pDate);
   RETURN vResult;
 END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION getnextpaymentdate(ngroupid integer, szinvtext character varying DEFAULT 'invoice_cutoff_day'::character varying, szpaytext character varying DEFAULT 'payment_cutoff_day'::character varying) RETURNS date
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE 
  --
  nGroupId       ALIAS FOR $1 ;
  szInvText      ALIAS FOR $2 ;
  szPayText      ALIAS FOR $3 ;
  dPayDate       DATE := NULL ;
BEGIN
    --
    SELECT   CASE 
                    WHEN current_date <= MAX(defInvDate) THEN MAX(payDate.dts)
                    ELSE MAX(nextPayDate.dts)
             END AS  actualPayDate
    INTO     dPayDate
    FROM
            (
                    SELECT   generate_series(defPayDate.dt, defPayDate.dt - 7, CAST('-1 day' AS INTERVAL)) AS dts
                    FROM   
                       ( SELECT TO_DATE(TO_CHAR(current_date, 'yyyy-mm-') || 
                                   locum_db.getDefaultvalueFor(nGroupId, szPayText), 'yyyy-mm-dd') AS dt
                       ) defPayDate
            ) AS payDate
           ,(
                    SELECT   generate_series(defNextPayDate.ndt::DATE, defNextPayDate.ndt::DATE - 7, CAST('-1 day' AS INTERVAL)) AS dts
                    FROM   
                       ( SELECT TO_DATE(TO_CHAR(current_date, 'yyyy-mm-') || 
                                   locum_db.getDefaultvalueFor(nGroupId, szPayText), 'yyyy-mm-dd')
                                   + CAST('1 month' AS INTERVAL) AS ndt
                       ) defNextPayDate
            ) AS nextPayDate
           , TO_DATE(TO_CHAR(current_date, 'yyyy-mm-') || 
                   locum_db.getDefaultvalueFor(nGroupId, szInvText), 'yyyy-mm-dd') AS defInvDate
    WHERE   locum_db.getdayofweek(payDate.dts) BETWEEN 2 AND 6
    AND     locum_db.getdayofweek(nextPayDate.dts) BETWEEN 2 AND 6
    ;
    --
    RETURN (dPayDate) ;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getoutagetimeinwindow(integer, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        ifsrvid ALIAS FOR $1;
        xtime ALIAS FOR $2;
        ytime ALIAS FOR $3;
        orec RECORD;
        lostTime timestamp without time zone;
        gainTime timestamp without time zone;
        downtime float8;
        zero CONSTANT float8 := 0.0;
        epochTime CONSTANT timestamp without time zone := to_timestamp('01 Jan 1970 00:00:00', 'DD Mon YYYY HH24:MI:SS');
   BEGIN
        downtime = zero;
        FOR orec IN SELECT ifLostService,ifRegainedService
                FROM outages 
                WHERE ifServiceId = ifsrvid 
                        AND (
                                (ifRegainedService IS NULL AND ifLostService <= xtime)
                                OR (ifRegainedService > ytime)
                        )
        LOOP
         BEGIN
                gainTime := epochTime;
                lostTime := orec.ifLostService;
                IF orec.ifRegainedService IS NOT NULL THEN
                        gainTime := orec.ifRegainedService;
                END IF;
                --
                -- Find the appropriate records
                --
                IF xtime > lostTime THEN
                 --
                 -- for any outage to be in window of 
                 -- opportunity the lost time must ALWAYS be
                 -- less that the x time.
                 --
                 IF gainTime = epochTime THEN
                  --
                  -- if the gain time is epochTime then the outage
                  -- does not have an uptime.
                  --
                   IF ytime > lostTime THEN
                    downtime := downtime + EXTRACT(EPOCH FROM (xtime - ytime));
                   ELSE
                    downtime := downtime + EXTRACT(EPOCH FROM (xtime - lostTime));
                   END IF;
                 ELSE
                  IF xtime > gainTime AND gainTime > ytime THEN
                   --
                   -- regain time between x and y
                   --
                    IF ytime > lostTime THEN
                     downtime := downtime + EXTRACT (EPOCH FROM (gainTime - ytime));
                    ELSE
                     downtime := downtime + EXTRACT (EPOCH FROM (gainTime - lostTime));
                    END IF; 
                  ELSE
                   IF gainTime > xtime THEN
                   --
                   -- regain time greater than x, lost less that x
                   --
                    IF ytime > lostTime THEN
                     downtime := downtime + EXTRACT (EPOCH FROM (xtime - ytime));
                    ELSE
                     downtime := downtime + EXTRACT (EPOCH FROM (xtime - lostTime));
                    END IF;
                   -- end gainTime > xtime
                   END IF;
                  -- end xtime > gainTime AND gainTime > ytime
                  END IF;
                 -- end gaintime == epochTime
                 END IF;
                -- end xtime > lostTime
                END IF;
         END;
        END LOOP;
        RETURN downtime*1000.0;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getpartid(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 	ALIAS FOR $1;

	pRevision 	ALIAS FOR $2;

	pSerialNumber 	ALIAS FOR $3;

	_partid 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getpartid'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, null, true));



	SELECT part_id

	INTO _partid

	FROM part

	WHERE part_item_id = getitemid(pItemNumber) 

	AND part_rev = pRevision 

	AND part_serialnumber = pSerialNumber;



	RETURN _partid;

END;



	$_$;",ames_dev.backup
"CREATE FUNCTION getpartlogactionid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pPartLogAction 		ALIAS FOR $1;

	_partLogActionId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getpartlogactionid'));



	SELECT partlogaction_id

	INTO _partLogActionId

	FROM partlogaction

	WHERE partlogaction_name = pPartLogAction;



	IF _partLogActionId IS NULL THEN

		RAISE EXCEPTION 'getpartlogactionid: Part Log Action % Not Found in AeryonMES', 

			_partLogActionId;

	END IF;



	RETURN _partLogActionId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getpartscrapcodeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pPartScrapCode 	ALIAS FOR $1;

	_partScrapCodeId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getpartscrapcodeid'));



	SELECT partscrapcode_id

	INTO _partScrapCodeId

	FROM partscrapcode

	WHERE partscrapcode_code = pPartScrapCode;



	IF _partScrapCodeId IS NULL THEN

		RAISE EXCEPTION 'getpartscrapcodeid: Part Scrap Code % Not Found in AeryonMES', 

			pPartScrapCode;

	END IF;



	RETURN _partScrapCodeId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getpartstateid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pPartState	ALIAS FOR $1;

	_partStateId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getpartstateid'));



	SELECT partstate_id 

	INTO _partStateId

	FROM partstate

	WHERE partstate_name = pPartState;



	IF _partStateId IS NULL THEN

		RAISE EXCEPTION 'getpartstateid: Part State % Not Found in AeryonMES', 

		pPartState;

	END IF;



	RETURN _partStateId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getpatientfiobyid(patient_id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	RETURN fio FROM patient WHERE id = patient_id;
END;
$$;",Dump.sql
"CREATE FUNCTION getpercentavailabilityinwindow(integer, timestamp without time zone, timestamp without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
   DECLARE
        ipifid ALIAS FOR $1;
        xtime ALIAS FOR $2;
        ytime ALIAS FOR $3;
        downtime float8;
   BEGIN
        downtime := getOutageTimeInWindow(ipifid, xtime, ytime);
        IF xtime > ytime THEN
                RETURN 100 * (1 - (downtime / (EXTRACT(EPOCH FROM (xtime - ytime))* 1000)));
        ELSE
                RETURN 100 * (1 - (downtime / (EXTRACT(EPOCH FROM (ytime - xtime))* 1000)));
        END IF;
   END;
$_$;",init-opennms.sql
"CREATE FUNCTION getperiod() RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
	return CAST(DATE_PART('YEAR', CURRENT_DATE) AS TEXT) || getSemester();
END
$$;",escola.sql
"CREATE FUNCTION getprivid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pPriv 		ALIAS FOR $1;

	_privId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getprivid'));



	SELECT priv_id

	INTO _privId

	FROM priv

	WHERE priv_name = pPriv;



	IF _privId IS NULL THEN

		RAISE EXCEPTION 'getprivid: Privilege % Not Found in AeryonMES', 

			pPriv;

	END IF;



	RETURN _privId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getrecordlogactionid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	precordlogAction 		ALIAS FOR $1;

	_recordlogActionId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getrecordlogactionid'));



	SELECT recordlogaction_id

	INTO _recordlogActionId

	FROM recordlogaction

	WHERE recordlogaction_name = precordlogAction;



	IF _recordlogActionId IS NULL THEN

		RAISE EXCEPTION 'getrecordlogactionid: Part Log Action % Not Found in AeryonMES', 

			_recordlogActionId;

	END IF;



	RETURN _recordlogActionId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getrecordtypeid(text, boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pRecordType 	ALIAS FOR $1;

	pAllowNull	ALIAS FOR $2;

	_recordTypeId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getrecordtypeid'));



	IF pRecordType IS NULL AND pAllowNull = true THEN

		RETURN null;

	END IF;



	SELECT recordtype_id

	INTO _recordTypeId

	FROM recordtype

	WHERE recordtype_name = pRecordType;



	IF _recordTypeId IS NULL THEN

		RAISE EXCEPTION 'getrecordtypeid: Record Type % Not Found in AeryonMES', 

			pRecordType;

	END IF;



	RETURN _recordTypeId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getroleid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pRole 		ALIAS FOR $1;

	_roleId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getroleid'));



	SELECT role_id

	INTO _roleId

	FROM role

	WHERE role_name = pRole;



	IF _roleId IS NULL THEN

		RAISE EXCEPTION 'getroleid: Role % Not Found in AeryonMES', 

			pRole;

	END IF;



	RETURN _roleId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getroom_reserve(numhabitacion integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare
	ref refcursor;
begin
	open ref for select X.codhabitacion, X.codreserva, R.fechainicior,
	R.fechafinr from reservaxhabitacion as X, reserva as R
	where X.codreserva=R.codreserva and X.codhabitacion=numhabitacion;
	return ref;
end;
$$;",dbBackup.sql
"CREATE FUNCTION getroom_reserve(numhabitacion integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
declare
	ref refcursor;
begin
	open ref for select X.codhabitacion, X.codreserva, R.fechainicior,
	R.fechafinr from reservaxhabitacion as X, reserva as R
	where X.codreserva=R.codreserva and X.codhabitacion=numhabitacion;
	return ref;
end;
$$;",dbBackupfinal.sql
"CREATE FUNCTION getroomstatus(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
x INTEGER;
BEGIN
select st into x from roomst where roomid = $1 and statusdate::date <=
to_timestamp($2,'DD/MM/YYYY HH24:MI')::date order by statusdate::date desc, regdate desc limit
1;
IF x is null THEN
x = 8;
END IF;
return x;
END;$_$;",hms.sql
"CREATE FUNCTION getscale(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
  declare
        semsubjId_ alias for $1;
        scale_ text;
        temp_ text;
  begin
	scale_ = '';
        for temp_ in select scale_id||'$'||rangehigh||'$'||rangelow||'$'||scale as info from scale where semsubj_id = semsubjId_ loop
		scale_ = scale_||temp_||'@';
	end loop;
	
       
        return scale_;
  end;
$_$;",myEskwelaDB_May_20
"CREATE FUNCTION getsearchfilms(nname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
rec RECORD;
sm text:='';
BEGIN
IF (SELECT count(*) FROM films WHERE position(nname in film_name)>=1)>0 THEN
	FOR rec in (SELECT id FROM films WHERE position(nname in film_name)>=1) LOOP
	sm:= sm || rec.id || ' ';
	END LOOP;
END IF;
RETURN sm;
END;
$$;",videodata(update).backup
"CREATE FUNCTION getsearchfilms(nname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
rec RECORD;
sm text:='';
BEGIN
IF (SELECT count(*) FROM films WHERE position(nname in film_name)>=1)>0 THEN
	FOR rec in (SELECT id FROM films WHERE position(nname in film_name)>=1) LOOP
	sm:= sm || rec.id || ' ';
	END LOOP;
END IF;
RETURN sm;
END;
$$;",videodata(update).txt
"CREATE FUNCTION getsemester() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	semestre INT;
BEGIN
	case when date_part('month', CURRENT_DATE) between 1 and 6
	--case when date_part('month', /*cast('01/01/2014' as date)*/) between 1 and 6
		then semestre := 1;
		else semestre := 2;
	end case;
	return semestre;
END
$$;",escola.sql
"CREATE FUNCTION getstationid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

DECLARE

	pStation 	ALIAS FOR $1;

	_stationId 	INTEGER;

BEGIN

	PERFORM (SELECT checkpriv('getstationid'));



	SELECT station_id

	INTO _stationId

	FROM station

	WHERE station_name = pStation;



	IF _stationId IS NULL THEN

		RAISE EXCEPTION 'getstationid: Station % Not Found in AeryonMES.', 

			pStation;

	END IF;



	RETURN _stationId;

END;

$_$;",ames_dev.backup
"CREATE FUNCTION getstatusname(istatus integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$declare myret character varying;
begin
   if istatus = 1 then
     myret = 'New Sales';
   elseif istatus = 2 then
     myret = 'Cancelled';
   elseif istatus = 3 then
     myret = 'Paid';
   end if;
   return myret;
end;
$$;",work.backup
"CREATE FUNCTION getstkmoveloc(integer) RETURNS text
    AS $_$
DECLARE
  pStockMoveID ALIAS FOR $1;
  pLocCode INTEGER;
BEGIN
	SELECT INTO pLocCode LocCode FROM StockMoves WHERE StockMoveNo = pStockMoveID;
	IF pLocCode ISNULL THEN
		RAISE EXCEPTION ""StockNoveNo does not spec a valid LocCode."";
	ELSE
		RETURN pLocCode;
	END IF;
END;$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION getstkmoveloc(integer) RETURNS text
    AS $_$
DECLARE
  pStockMoveID ALIAS FOR $1;
  pLocCode INTEGER;
BEGIN
	SELECT INTO pLocCode LocCode FROM StockMoves WHERE StockMoveNo = pStockMoveID;
	IF pLocCode ISNULL THEN
		RAISE EXCEPTION ""StockNoveNo does not spec a valid LocCode."";
	ELSE
		RETURN pLocCode;
	END IF;
END;$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION getstudents(text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
  declare
	secCode_ alias for $1;
        sy_ alias for $2;
        subjCode_ alias for $3;
        temp_ record;
        studList text;
  begin
	studList = '';
        for temp_ in select s.id||'$'||s.lName||', '||s.fName||' '||s.mName||'$'||r.registration_id as info 
		     from student s, semstudent ss, registration r, semsubject sb
		     where sb.subj_code = subjCode_ and sb.schoolyear = sy_ and sb.section_code = secCode_ and sb.semsubj_id = r.semsubj_id and r.semstudent_id = ss.semstudent_id and ss.id = s.id order by s.lName loop
		studList = studList||temp_.info||'@';
	end loop;
	
       
        return studList;
  end;
$_$;",myEskwelaDB_May_20
"CREATE FUNCTION gettenloaibenh(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	tenloaibenh text;
begin
	select ""TenLoaiBenh"" from ""LoaiBenh"" where ""MaLoaiBenh""=$1 into tenloaibenh;
	return tenloaibenh;
end;
$_$;",database.backup
"CREATE FUNCTION getthongso(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
	giatri text;
begin
	select ""GiaTri"" from ""ThongSo"" where ""Ten""=$1 into giatri;
	return giatri;
end;
$_$;",database.backup
"CREATE FUNCTION gettienthuoc(character varying) RETURNS money
    LANGUAGE plpgsql
    AS $_$
DECLARE
	result money;
BEGIN
	SELECT SUM(""DonGiaThucTe""*""SoLuong"")
	FROM ""ChiTietPhieuKham""
	WHERE ""MaKhamBenh"" = $1
	GROUP BY ""MaKhamBenh""
	LIMIT 1
	INTO result;
	if result is NULL then	result := money '0'; end if;
	return result;
	
END
$_$;",database.backup
"CREATE FUNCTION gettienthuoc(character) RETURNS money
    LANGUAGE plpgsql
    AS $_$
DECLARE
	result money;
BEGIN
	SELECT SUM(""DonGia""*""SoLuong"")
	FROM ""ChiTietHoaDon""
	WHERE ""MaHoaDon"" = $1
	GROUP BY ""MaHoaDon""
	LIMIT 1
	INTO result;
	if result is NULL then	result := money '0'; end if;
	return result;
	
END
$_$;",database.backup
"CREATE FUNCTION gettimedifferstring(starttime time without time zone, endtime time without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$ DECLARE 
	BEGIN
	RETURN  (locum_db.gettimeintervaltointeger($2) - locum_db.gettimeintervaltointeger($1));
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettimeintervaltointeger(time without time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$ DECLARE 
	BEGIN
	RETURN CAST(EXTRACT(EPOCH FROM $1)/3600 AS Float);
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettimestampwithouttimezone(timestamp with time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    return ($1::TIMESTAMP WITHOUT TIME ZONE);
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettinhtrangkhambenh(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
 Begin
    IF ( exists (select * from ""ChiTietPhieuKham"" Where ""MaKhamBenh"" = $1 ))
    THEN 
	if( exists (select * from ""KhamBenh"" where ""MaKhamBenh"" = $1 and cast(""TienKhamThucTe"" AS nuMERIC) <> 0))
		Then	return 2;
		else return 1;	
		end if;
    ELSE
       return 0; 
    END IF;
END $_$;",database.backup
"CREATE FUNCTION gettotalblockbookingapps(groupid integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	BEGIN
		RETURN (SELECT CAST(count(tab.*) AS integer) AS count
		FROM   (SELECT b.branch_id
			     , a.emp_name
			     , a.hol_type
			     , min(a.start_date) AS start_date
			     , max(a.end_date) AS end_date
			FROM locum_db.emp_holidays a
			JOIN locum_db.vacancy_details b ON b.emp_id = a.emp_id AND b.treat_as_bulk = true
			WHERE a.status_flag::text = 'con'::text 
			AND (EXISTS (SELECT '1'
				     FROM locum_db.locum_schedule_events c
				     WHERE c.vacancy_id = b.id AND c.status_flag::text = 'app'::text))
			AND (EXISTS (SELECT '1'
				     FROM locum_db.branch_details x
				     WHERE x.branch_id = a.branch_id
				     AND   current_date BETWEEN COALESCE(x.start_date, current_date)
										AND COALESCE(x.end_date, current_date) 
				     AND   x.group_id = groupid))
		GROUP BY b.branch_id
		       , a.emp_name
		       , a.hol_type
		HAVING min(a.start_date) >= 'now'::text::date 
		AND    min(a.start_date) <= ('now'::text::date + '2 mons'::interval)) tab);
	END
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettotalfulltimevacancyapps(groupid integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	BEGIN
		RETURN (SELECT CAST(count(tab.*) AS integer) AS count
		FROM   (SELECT a.id
			     , a.branch_id
			     , a.user_id
			     , b.branch_name
			     , btrim((((COALESCE(c.title, ''::character varying)::text || ' '::text) || c.fore_name::text) || ' '::text) || COALESCE(c.last_name, ''::character varying)::text, ' '::text) AS locum_name
			     , to_char(a.applied_date, 'dd Mon, yyyy'::text) AS applied_date
			     , (SELECT d.description
				FROM locum_db.codes d
				WHERE d.code::text = a.status_flag::text AND d.code_type::text = 'STATUS'::text) AS status_flag
			     , c.email
			     , adet.telephone_mobile
			     , a.contact_method
			FROM locum_db.full_time_vacancy_applications a
 			JOIN locum_db.branch_details b ON b.branch_id = a.branch_id AND current_date BETWEEN COALESCE(a.start_date, current_date)
												     AND COALESCE(a.end_date, current_date)  AND b.group_id = groupid
 			JOIN locum_db.users c ON c.user_id::text = a.user_id::text
  			JOIN locum_db.address_details adet ON adet.address_id::text = c.address_id::text
  			WHERE a.status_flag::text = 'app'::text) tab);
	END
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettotalhour(opentime timestamp with time zone, closetime timestamp with time zone, lchopentime timestamp with time zone, lchclosetime timestamp with time zone) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$DECLARE 
	totalworkhrs		DOUBLE PRECISION;
	tOpenTime		ALIAS FOR $1 ;
	tCloseTime		ALIAS FOR $2 ;
	tLunchStartTime		ALIAS FOR $3 ;
	tLunchEndTime		ALIAS FOR $4 ;
BEGIN
	--
	totalworkhrs := locum_db.gettotalhour(tOpenTime::TIMESTAMP WITHOUT TIME ZONE
                                         ,tCloseTime::TIMESTAMP WITHOUT TIME ZONE
                                         ,tLunchStartTime::TIMESTAMP WITHOUT TIME ZONE
                                         ,tLunchEndTime::TIMESTAMP WITHOUT TIME ZONE
                                         ) ;
	--
	RETURN  totalworkhrs;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION gettotalpendinguserratings(groupid integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
	BEGIN
		RETURN (SELECT COUNT(lr.*) AS userratings
			FROM locum_db.locum_rating lr
			Inner Join locum_db.locum_schedule_events ls on ls.id = lr.event_id
			WHERE ls.status_flag IN ('con', 'pay')
			AND   ls.event_date < current_timestamp
			AND   EXISTS(SELECT '1'
				     FROM   locum_db.branch_details a
				     WHERE a.branch_id = ls.branch_id
				     AND   current_date BETWEEN COALESCE(a.start_date, current_date)
								AND COALESCE(a.end_date, current_date) 
				     AND   a.group_id = groupid));
	END
$$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getusername(text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE UserName TEXT;
BEGIN
       SELECT CASE
		WHEN 'foreName' = $1 
                      THEN INITCAP(TRIM((u.fore_name||' '||COALESCE(u.last_name))))
		ELSE 
                     INITCAP((TRIM(COALESCE(u.last_name)|| ' ' ||u.fore_name)))
		END  AS locumName INTO UserName
	FROM locum_db.users u
	WHERE  u.user_id= $2;
	return UserName;
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getusernamefromquestion(questionid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  SELECT users.username
  FROM publications
    INNER JOIN questions on publications.publicationid = questions.publicationid
    INNER JOIN users on publications.userid = users.userid
  where questions.publicationid = $1;
END;

$_$;",dbm
"CREATE FUNCTION getusernamefromquestion(questionid integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  SELECT users.username
  FROM publications
    INNER JOIN questions on publications.publicationid = questions.publicationid
    INNER JOIN users on publications.userid = users.userid
  where questions.publicationid = $1;
END;

$_$;",lbaw_v2.sql
"CREATE FUNCTION getuserrank(_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    ret INTEGER;
BEGIN
    SELECT INTO ret ""level"" FROM ""users"" WHERE ""userId"" = _id;
    SELECT INTO ret ""rank"" FROM ""levels"" WHERE ""levelId"" = ret;
    RETURN ret;
END
$$;",MiMissionMVC_20171210_193535.sql
"CREATE FUNCTION getusrid(text DEFAULT ""current_user""()) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE

	pUserName 	ALIAS FOR $1;

	_usrInfo 	RECORD;

BEGIN

	PERFORM (SELECT checkpriv('getusrid'));

	SELECT usr_id, usr_active

	INTO _usrInfo

	FROM usr

	WHERE usr_username = pUserName;



	IF _usrInfo.usr_id IS NULL THEN

		RAISE EXCEPTION 'getusrid: User % does not exist.', 

			pUserName;

	ELSIF _usrInfo.usr_active = false THEN

		RAISE EXCEPTION 'getusrid: User % is inactive.', 

			pUserName;

	END IF;

	

	RETURN _usrInfo.usr_id;

END;

	$_$;",ames_dev.backup
"CREATE FUNCTION getvacancyidsforbulkbooking(branchid integer, startdate date, enddate date) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$ DECLARE 
	   result_Ids VARCHAR(500);
	   vacancy_details RECORD;
	BEGIN
		result_Ids := '';
		FOR vacancy_details IN
			(SELECT a.id AS vacId FROM locum_db.vacancy_details a WHERE a.branch_id = $1 AND a.event_date between $2 and $3 AND a.treat_as_bulk=true)
		LOOP
			result_Ids := result_Ids || '|' || vacancy_details.vacId;
		END LOOP;
		RETURN SUBSTR(result_Ids, 2, 500);
	END;
	$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION getvisibleusers() RETURNS SETOF member
    LANGUAGE plpgsql
    AS $$BEGIN
SELECT * FROM member WHERE member_visibility = true;
END;$$;",socialnetworkdb.sql
"CREATE FUNCTION gomonth(date, integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
declare
	tdKpv alias for $1;
	tnPeriod alias for $2;
	lnYear int;
	lnMonth int;
	lnDay int;
	lnCount int2;
begin
	lnDay := day(tdKpv);
	lnMonth := month(tdKpv) + tnPeriod;
	if lnMonth > 12 then
		lnCount:= lnMonth / 12 ::int2;
		lnMonth := lnMonth - 12 * lnCount;
		lnYear := YEAR(tdKpv) + lnCount;
	else
		lnYear := YEAR(tdKpv);
	end if;
         return  date(lnYear,lnMonth,lnDay);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION grad(latgrad double precision, latmin double precision) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
BEGIN
    
  RETURN (abs(latgrad)+latmin/60)*latgrad/abs(latgrad);
END;    
$$;",dump.sql
"CREATE FUNCTION grafica_barras_multiples(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, texto_leyenda text[], modo text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_barras_multiples (nombre_grafica,titulo_principal,marquilla_ejex,marquilla_ejey, datos,  texto_leyenda, modo, formato) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_barras_simples(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, texto_leyenda text[], modo text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_barras_simples (nombre_grafica,titulo_principal,marquilla_ejex,marquilla_ejey, datos,  texto_leyenda, modo, formato) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_caja(nombre_grafica text, titulo_principal text, marquilla_ejey text, datos text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_caja(nombre_grafica,titulo_principal, marquilla_ejey , datos ,   formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_contorno(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, texto_leyenda text[], formato text, tipo text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_contorno (nombre_grafica,titulo_principal,marquilla_ejex,marquilla_ejey, datos,  texto_leyenda, formato, tipo) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_dispersion(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_dispersion(nombre_grafica,titulo_principal, marquilla_ejex,marquilla_ejey ,datos ,  formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_histograma(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_histograma(nombre_grafica,titulo_principal, marquilla_ejex , marquilla_ejey , datos ,   formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_histograma_3d(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, marquilla_ejez text, datos text, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_histograma_3d(nombre_grafica,titulo_principal, marquilla_ejex,marquilla_ejey ,marquilla_ejez,datos ,  formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_lineas(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, leyenda text[], formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_lineas(nombre_grafica,titulo_principal, marquilla_ejex , marquilla_ejey , datos , leyenda , formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_lineas_puntos(nombre_grafica text, titulo_principal text, marquilla_ejex text, marquilla_ejey text, datos text, leyenda text[], formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_lineas_puntos(nombre_grafica,titulo_principal, marquilla_ejex , marquilla_ejey , datos , leyenda , formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_mapa_de_calor(nombre_grafica text, titulo_principal text, datos text, texto_leyenda text[], formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_mapa_de_calor(nombre_grafica,titulo_principal, datos,  texto_leyenda, formato) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_pie(nombre_grafica text, titulo_principal text, datos text, texto_leyenda text[], porciento boolean, formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_pie (nombre_grafica,titulo_principal, datos,  texto_leyenda, porciento, formato) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION grafica_puntos(nombre_grafica text, titulo_principal text, datos text, leyenda text[], formato text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
salida text;
salida2 text;
salida3 text;
salida4 text;
begin
  
      BEGIN
      select * into salida from  pgrgraphic.r_puntos(nombre_grafica,titulo_principal,  datos , leyenda , formato ) ;

      EXCEPTION  
         WHEN OTHERS THEN
      GET STACKED DIAGNOSTICS salida = MESSAGE_TEXT,salida2 = RETURNED_SQLSTATE, salida3 = PG_EXCEPTION_DETAIL, salida4 = PG_EXCEPTION_HINT;
       return 'Error:'|| salida||'--'||salida2||'--'||salida3||'--'||salida4; 
      end;    
   
   
  return salida;


end;

$$;",pgrgraphic--1.0.0.sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;





counter NUMERIC;















BEGIN









SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x







FROM viewclasses v







WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;











RETURN round(x,4);









END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;


counter NUMERIC;







BEGIN




SELECT COALESCE(SUM(gradevalue*credits) / SUM(credits),0) into x



FROM viewclasses v



WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;





RETURN round(x,4);




END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;
counter NUMERIC;



BEGIN
IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND termid = $2 AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;

SELECT SUM(gradevalue*credits) / SUM(credits) into x

FROM viewclasses v

WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;


RETURN round(x,4);
END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;
counter NUMERIC;



BEGIN
IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND termid = $2 AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;

SELECT SUM(gradevalue*credits) / SUM(credits) into x

FROM viewclasses v

WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;


RETURN round(x,4);
END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;
counter NUMERIC;



BEGIN
IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND termid = $2 AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;

SELECT SUM(gradevalue*credits) / SUM(credits) into x

FROM viewclasses v

WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;


RETURN round(x,4);
END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x NUMERIC;
counter NUMERIC;



BEGIN
IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND termid = $2 AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;

SELECT SUM(gradevalue*credits) / SUM(credits) into x

FROM viewclasses v

WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;


RETURN round(x,4);
END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION gwa(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND termid = $2 AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

sid INTEGER;

tid INTEGER;

BEGIN

	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;

	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;



	return gwa(sid, tid);

END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return gwa(sid, tid);
END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return gwa(sid, tid);
END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return gwa(sid, tid);
END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return gwa(sid, tid);
END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION gwa(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return gwa(sid, tid);
END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION hash_accepted(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""Accepted"", ""Accepted_state_log"" 
	WHERE ""state""=_state AND ""Accepted"".""rid""=""Accepted_state_log"".""rid"" ORDER BY ""Accepted_state_log"".""id"" ASC)::TEXT)::UUID;
END;$$;",dcds128.sql
"CREATE FUNCTION hash_currreq(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""CurrReq"", ""CurrReq_state_log"" 
	WHERE ""state""=_state AND ""CurrReq"".""rid""=""CurrReq_state_log"".""rid"" ORDER BY ""CurrReq_state_log"".""id"" ASC)::TEXT)::UUID;
END;$$;",dcds128.sql
"CREATE FUNCTION hash_pending(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""Pending"", ""Pending_state_log"" 
	WHERE ""state""=_state AND ""Pending"".""rid""=""Pending_state_log"".""rid"" ORDER BY ""Pending_state_log"".""id"" ASC)::TEXT)::UUID;
END;$$;",dcds128.sql
"CREATE FUNCTION hash_rejected(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""Rejected"", ""Rejected_state_log"" 
	WHERE ""state""=_state AND ""Rejected"".""rid""=""Rejected_state_log"".""rid"" ORDER BY ""Rejected_state_log"".""id"" ASC)::TEXT)::uuid;
END;$$;",dcds128.sql
"CREATE FUNCTION hash_trvlcost(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""TrvlCost"", ""TrvlCost_state_log"" 
	WHERE ""state""=_state AND ""TrvlCost"".""rid""=""TrvlCost_state_log"".""rid"" ORDER BY ""TrvlCost_state_log"".""fid"" ASC)::TEXT)::UUID;
END;$$;",dcds128.sql
"CREATE FUNCTION hash_trvlmaxamnt(_state integer) RETURNS uuid
    LANGUAGE plpgsql
    AS $$BEGIN
	RETURN md5(ARRAY(SELECT ""phash"" FROM ""TrvlMaxAmnt"", ""TrvlMaxAmnt_state_log"" 
	WHERE ""state""=_state AND ""TrvlMaxAmnt"".""rid""=""TrvlMaxAmnt_state_log"".""rid"" ORDER BY ""TrvlMaxAmnt_state_log"".""fid"" ASC)::TEXT)::UUID;
END;$$;",dcds128.sql
"CREATE FUNCTION hay_chofer(id_cont integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
id_ch int;
BEGIN
aux='SI';
SELECT contratos.cont_id_chof INTO id_ch from contratos WHERE contratos.id_contrato=id_cont;
if(id_ch ISNULL)THEN
aux='NO';
END IF;
RETURN aux;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION hay_chofer(id_cont integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
id_ch int;
BEGIN
aux='SI';
SELECT contratos.cont_id_chof INTO id_ch from contratos WHERE contratos.id_contrato=id_cont;
if(id_ch ISNULL)THEN
aux='NO';
END IF;
RETURN aux;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION hay_chofer(id_cont integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
id_ch int;
BEGIN
aux='SI';
SELECT contratos.cont_id_chof INTO id_ch from contratos WHERE contratos.id_contrato=id_cont;
if(id_ch ISNULL)THEN
aux='NO';
END IF;
RETURN aux;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION hay_chofer(id_cont integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
id_ch int;
BEGIN
aux='SI';
SELECT contratos.cont_id_chof INTO id_ch from contratos WHERE contratos.id_contrato=id_cont;
if(id_ch ISNULL)THEN
aux='NO';
END IF;
RETURN aux;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION hay_chofer(id_cont integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
aux VARCHAR;
id_ch int;
BEGIN
aux='SI';
SELECT contratos.cont_id_chof INTO id_ch from contratos WHERE contratos.id_contrato=id_cont;
if(id_ch ISNULL)THEN
aux='NO';
END IF;
RETURN aux;
END
$$;",backup1.sql
"CREATE FUNCTION hdb_catalog.inject_table_defaults(view_schema text, view_name text, tab_schema text, tab_name text) RETURNS void
    LANGUAGE plpgsql
    AS $$
    DECLARE
        r RECORD;
    BEGIN
      FOR r IN SELECT column_name, column_default FROM information_schema.columns WHERE table_schema = tab_schema AND table_name = tab_name AND column_default IS NOT NULL LOOP
          EXECUTE format('ALTER VIEW %I.%I ALTER COLUMN %I SET DEFAULT %s;', view_schema, view_name, r.column_name, r.column_default);
      END LOOP;
    END;
$$;",sample_data.sql
"CREATE FUNCTION hdb_catalog.inject_table_defaults(view_schema text, view_name text, tab_schema text, tab_name text) RETURNS void
    LANGUAGE plpgsql
    AS $$
    DECLARE
        r RECORD;
    BEGIN
      FOR r IN SELECT column_name, column_default FROM information_schema.columns WHERE table_schema = tab_schema AND table_name = tab_name AND column_default IS NOT NULL LOOP
          EXECUTE format('ALTER VIEW %I.%I ALTER COLUMN %I SET DEFAULT %s;', view_schema, view_name, r.column_name, r.column_default);
      END LOOP;
    END;
$$;",schem_data.sql
"CREATE FUNCTION hex_to_int(hexval character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  result int;
BEGIN
  EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;
  RETURN result;
END;
$$;",backup.sql
"CREATE FUNCTION historialpacpro(idpacient bigint, idprova bigint, data_inici timestamp without time zone DEFAULT NULL::timestamp without time zone) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  nom varchar;
  cognom varchar;
  ret varchar :='';
  sql1 text;
  sql2 text;
  sql3 text;
  rec record;
  rec2 record;
  rec3 record;
  minim bigint;
  maxim bigint;
  data_res date;
  valoracio varchar :='';
  valors_ref varchar:='';
  provatecnica bigint;
  res_char varchar :='';
  
BEGIN
  IF data_inici is null Then
    data_inici := current_timestamp;
  END IF;
  -- consulta base
  -- select * from provestecnica join resultats  on provestecnica.idprova = 101 and resultats.idprovatecnica=provestecnica.idprovatecnica join analitiques on resultats.idanalitica=analitiques.idanalitica and analitiques.idpacient=1 and resultats.dataresultat<=current_timestamp order by resultats.idprovatecnica,resultats.dataresultat desc;
  -- select MIN(cast(resultats.resultats as float)),Max(cast(resultats.resultats as float)) from provestecnica join resultats  on provestecnica.idprova = 101 and resultats.idprovatecnica=provestecnica.idprovatecnica join analitiques on resultats.idanalitica=analitiques.idanalitica and analitiques.idpacient=1 and resultats.dataresultat<=current_timestamp;
  -- select Max(cast(resultats.resultats as float)) from provestecnica join resultats  on provestecnica.idprova = 101 and resultats.idprovatecnica=provestecnica.idprovatecnica join analitiques on resultats.idanalitica=analitiques.idanalitica and analitiques.idpacient=1 and resultats.dataresultat<=current_timestamp;
  provatecnica := 0;
  -- Resultats per aquest pacient i aquesta prova, a partit de la data_inici
  sql2 := 'select * from provestecnica join resultats  on provestecnica.idprova ='|| idprova ||' and resultats.idprovatecnica=provestecnica.idprovatecnica join analitiques on resultats.idanalitica=analitiques.idanalitica and analitiques.idpacient='||idpacient||' and analitiques.dataanalitica<= '''||data_inici||'''order by resultats.idprovatecnica,analitiques.dataanalitica desc;';
  FOR rec2 in execute(sql2) LOOP
    data_res  := to_char(rec2.dataanalitica,'YYYY-MM-DD');
    
    IF provatecnica != rec2.idprovatecnica THEN
      provatecnica := rec2.idprovatecnica;
      sql1 :='select * from pacients join catalegproves on pacients.idpacient ='||idpacient ||' and catalegproves.idprova = '||idprova||' join provestecnica on provestecnica.idprova='||idprova||' and provestecnica.idprovatecnica='||provatecnica||';';
      FOR rec in execute(sql1) LOOP
        ret := ret|| rec.idpacient ||'+++'||rec.nom||'+++'||rec.cognoms||'+++'||rec.idprovatecnica||'+++'||rec.idprova||'+++'||rec.nom_prova|| e' \n';
      END LOOP; 
    END IF;
    -- SORTIDA
    IF rec2.resultat_numeric THEN
      --MINIM and Maxim
      sql3 := 'select MIN(cast(resultats.resultats as float)),MAX(cast(resultats.resultats as float)) from provestecnica join resultats  on provestecnica.idprova ='|| idprova ||' and resultats.idprovatecnica=provestecnica.idprovatecnica join analitiques on resultats.idanalitica=analitiques.idanalitica and analitiques.idpacient='||idpacient||' and analitiques.dataanalitica<= '''||data_inici||''' and provestecnica.idprovatecnica= '||provatecnica||';';
      FOR rec3 in execute(sql3) LOOP
        minim := rec3.min;
        maxim := rec3.max;
      END LOOP;
      -- VALORACIO
      -- 1 ->  NORMAL 
      -- 2 ->  PATOLÒGIC
      -- 3 ->  PÀNIC
      valoracio := valorar_idresultat(rec2.idresultat);
      -- Valors de referencia
      IF valoracio = '1' THEN
        valors_ref :='';
        res_char := 'NORMAL';
      ELSEIF valoracio = '2' THEN
        valors_ref := '('||rec2.minpat||' - '||rec2.maxpat||')';
        res_char := 'PATOLOGIC';
      ELSEIF valoracio = '3' THEN
        valors_ref := '('||rec2.minpan||' - '||rec2.maxpan||')';
        res_char := 'PANIC';
      END IF;

      IF cast(rec2.resultats as int) = maxim THEN
        ret := ret||rec2.idanalitica||'---' ||data_res||' --- '||provatecnica||'---'||rec2.resultats||'-'||'      '||'-'||res_char||' -'||valors_ref||' -MAX'|| e' \n';
      ELSEIF cast(rec2.resultats as int) = minim THEN
        ret := ret||rec2.idanalitica||'---'||data_res||' --- '||provatecnica||'---'||rec2.resultats||'-'||'      '||'-'||res_char||' -'||valors_ref||' -MIN'|| e' \n';
      ELSE
        ret := ret||rec2.idanalitica||'---' ||data_res||' --- '||provatecnica||'---'||rec2.resultats||'-'||'      '||'-'||res_char||' -'||valors_ref|| e' \n';
      END IF;

    ELSE
      --valoracio alfpat
      valoracio := valorar_idresultat(rec2.idresultat);
      IF valoracio = '1' THEN
        res_char := 'NORMAL';
      ELSE
        res_char := 'PATOLOGIC';
      END IF;
      ret := ret||rec2.idanalitica||'---' ||data_res||'-'||provatecnica||'-'||rec2.resultats||'-'||'      '||'-'||res_char|| e' \n';
    END IF;
  END LOOP;
RETURN ret;
EXCEPTION 
  WHEN unique_violation THEN return '-1'; 
  WHEN foreign_key_violation THEN return '-2'; 
  WHEN not_null_violation THEN return '-3';
  --WHEN others THEN return '-4'; 
END;
$$;",lab_clinic.sql
"CREATE FUNCTION hit_denda(pokok bigint, persen integer, jth_tempo date) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE 
  denda bigint;
  x integer;
  y integer;
  z integer;
  
begin
        
        x   = (extract(year from now()) - extract(year from jth_tempo)) * 12;
        y   = (extract(month from now()) - extract(month from jth_tempo));
        z   = x + y + 1;
        
        if (extract(day from now()) <= extract(day from jth_tempo)) then
            z = z - 1;
        end if;
        if (z < 1) then
            z = 0;
        end if;
        if (z > 24) then
            z = 24;
        end if;

            
        denda  = round(z * (persen / 100.0) * pokok);
        return denda;
   
end
$$;",db_padl.sql
"CREATE FUNCTION holiday(date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$


declare
xx timestamp;
x_month integer;
x_day integer;
b boolean;

begin
select $1 + time '00:00' into xx;
select EXTRACT(MONTH FROM xx) into x_month;
select extract(day from xx) into x_day;
select 
(x_day = 1 and x_month = 1) or 
(x_day = 7 and x_month = 1) or 
(x_day = 8 and x_month = 3) or 
(x_day = 1 and x_month = 5) or
(x_day = 2 and x_month = 5) or
(x_day = 9 and x_month = 5) or
(x_day = 7 and x_month = 7) or
(x_day = 24 and x_month = 8) or
(x_day = 14 and x_month = 10) or
(x_day = 6 and x_month = 12) or
(x_day = 19 and x_month = 12) into b;
return b;
end
$_$;",MovieStore_script.sql
"CREATE FUNCTION hour(timestamp with time zone) RETURNS integer     AS $_$ BEGIN  RETURN date_part('hour', $1)::integer; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION i18_language_find_by_a23c(p_alpha23code character) RETURNS i18_language
    LANGUAGE plpgsql STABLE COST 5
    AS $$
declare
  res i18_language;
begin
  select *
    into strict res
   from i18_language
  where p_alpha23code in (alpha2code, alpha3code);
  return res;
exception
  when NO_DATA_FOUND then
    --'I1800015', 'language alpha2code or alpha3code ""%s"" not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('I1800015', p_alpha23code);
  when TOO_MANY_ROWS then
    --'I1800016', 'language alpha2code or alpha3code ""%s"" not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('I1800016', p_alpha23code);
end;
$$;",metadict.sql
"CREATE FUNCTION i18_language_find_by_a2c(p_alpha2code character) RETURNS i18_language
    LANGUAGE plpgsql STABLE COST 5
    AS $$
declare
  res i18_language;
begin
  select *
    into strict res
   from i18_language
  where alpha2code = p_alpha2code;
  return res;
exception
  when NO_DATA_FOUND then
    --I1800001='language alpha2code=% not found (in i18_language)'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('I1800001', p_alpha2code);
  when TOO_MANY_ROWS then
    --I1800002='language alpha2code=% not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('I1800002', p_alpha2code);
end;
$$;",metadict.sql
"CREATE FUNCTION i18_language_find_by_a3c(p_alpha3code character) RETURNS i18_language
    LANGUAGE plpgsql STABLE COST 5
    AS $$
declare
  res i18_language;
begin
  select *
    into strict res
   from i18_language
  where alpha3code = p_alpha3code;
  return res;
exception
  when NO_DATA_FOUND then
    -- 'I1800003', 'language alpha3code=% not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('I1800003', p_alpha3code);
  when TOO_MANY_ROWS then
    -- 'I1800004', 'language alpha3code=% not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('I1800004', p_alpha3code);
end;
$$;",metadict.sql
"CREATE FUNCTION id_query(qtype text, qtext text, qnumber integer, OUT content text, OUT ttl integer, OUT prio integer, OUT type text, OUT domain_id integer, OUT disabled boolean, OUT name text, OUT auth boolean) RETURNS SETOF record
    LANGUAGE plpgsql STABLE ROWS 1
    AS $_$
DECLARE
  ip integer[];
BEGIN

  CASE qtype
    WHEN 'SOA', 'NS' THEN

RETURN QUERY EXECUTE format('SELECT
content::text,ttl,prio,type::text,id,false,''%2$s''::text,true FROM cpe_authorities
WHERE type = ''%1$s''
', qtype, qtext);

    WHEN 'A' THEN

ip := REGEXP_MATCHES(qtext, '^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.in-addr\.arpa$');

IF ip IS NOT NULL THEN

RETURN QUERY EXECUTE format('SELECT
  name,
  ttl,
  0,
  type::text,
  domain_id,
  false,
  format(templ, %3$s, %4$s, %5$s, %6$s) AS content,
  true
FROM (
  SELECT *,
    ''%2$s''::text AS name
  FROM cpe_pseudo_records
  WHERE
    range >> ''%3$s.%4$s.%5$s.%6$s''::ipaddress AND
    type = ''%1$s'' AND
    domain_id = %7$s
)
AS foo;', qtype, qtext, ip[4], ip[3], ip[2], ip[1], qnumber);

ELSE

  RETURN;

END IF;

END CASE;

END
$_$;",schema.sql
"CREATE FUNCTION identidad_del_chofer(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
res VARCHAR:=NULL;
BEGIN
SELECT choferes.numero_id INTO res FROM choferes WHERE choferes.id_chofer=$1;
if(res ISNULL)THEN res:='NO';
END IF;
RETURN res;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION identidad_del_chofer(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
res VARCHAR:=NULL;
BEGIN
SELECT choferes.numero_id INTO res FROM choferes WHERE choferes.id_chofer=$1;
if(res ISNULL)THEN res:='NO';
END IF;
RETURN res;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION identidad_del_chofer(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
res VARCHAR:=NULL;
BEGIN
SELECT choferes.numero_id INTO res FROM choferes WHERE choferes.id_chofer=$1;
if(res ISNULL)THEN res:='NO';
END IF;
RETURN res;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION identidad_del_chofer(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
res VARCHAR:=NULL;
BEGIN
SELECT choferes.numero_id INTO res FROM choferes WHERE choferes.id_chofer=$1;
if(res ISNULL)THEN res:='NO';
END IF;
RETURN res;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION identidad_del_chofer(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
res VARCHAR:=NULL;
BEGIN
SELECT choferes.numero_id INTO res FROM choferes WHERE choferes.id_chofer=$1;
if(res ISNULL)THEN res:='NO';
END IF;
RETURN res;
END
$_$;",backup1.sql
"CREATE FUNCTION if(boolean, character varying, character varying) RETURNS character varying     AS $_$ BEGIN  IF ($1) THEN   RETURN $2;  END IF;  RETURN $3; END; $_$     LANGUAGE plpgsql IMMUTABLE;",2.8.2_postgresql.sql
"CREATE FUNCTION if(boolean, character varying, integer) RETURNS integer     AS $_$ BEGIN  IF ($1) THEN   RETURN $2;  END IF;  RETURN $3; END; $_$     LANGUAGE plpgsql IMMUTABLE;",2.8.2_postgresql.sql
"CREATE FUNCTION if(boolean, integer, integer) RETURNS integer     AS $_$ BEGIN  IF ($1) THEN   RETURN $2;  END IF;  RETURN $3; END; $_$     LANGUAGE plpgsql IMMUTABLE;",2.8.2_postgresql.sql
"CREATE FUNCTION if(boolean, timestamp with time zone, timestamp with time zone) RETURNS timestamp with time zone     AS $_$ BEGIN  IF ($1) THEN   RETURN $2;  END IF;  RETURN $3; END; $_$     LANGUAGE plpgsql IMMUTABLE;",2.8.2_postgresql.sql
"CREATE FUNCTION ifnull(character, character) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null then
		 return  $2;
	else
		 return  $1;
			
	end if;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION ifnull(date, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 is null then
		 return  $2;
	else
		 return  $1;
	end if;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION ifnull(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 isnull then
		 return  $2;
	else
		return $1;
	end if;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION ifnull(numeric, integer) RETURNS integer     AS $_$ BEGIN  IF ($1 IS NULL) THEN   RETURN $2;  END IF;  RETURN $1::integer; END; $_$     LANGUAGE plpgsql IMMUTABLE;",2.8.2_postgresql.sql
"CREATE FUNCTION ifnull(numeric, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
begin
	if $1 isnull then
		 return  $2;
	else
		return $1;
	end if;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION importe_total() RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;

BEGIN

SELECT sum(contratos.importe_total) INTO tot from contratos ;
return tot;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION importe_total() RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;

BEGIN

SELECT sum(contratos.importe_total) INTO tot from contratos ;
return tot;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION importe_total() RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;

BEGIN

SELECT sum(contratos.importe_total) INTO tot from contratos ;
return tot;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION importe_total() RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;

BEGIN

SELECT sum(contratos.importe_total) INTO tot from contratos ;
return tot;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION importe_total() RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;

BEGIN

SELECT sum(contratos.importe_total) INTO tot from contratos ;
return tot;
END
$$;",backup1.sql
"CREATE FUNCTION in_cls(usr integer, objtyp integer, obj integer, tgt_cls integer, OUT in_cls boolean) RETURNS boolean
    AS $$
DECLARE
clsid integer;
BEGIN
SELECT obj_cls INTO STRICT clsid FROM usr_obj WHERE usr_id = usr AND obj_typ = objtyp AND obj_id = obj;
LOOP
	in_cls := tgt_cls = clsid;
	EXIT WHEN in_cls OR clsid < 10;
	SELECT parent INTO clsid FROM classes WHERE master=usr AND typ= objtyp AND id= clsid;
END LOOP;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
	in_cls:=false;
END
$$
    LANGUAGE plpgsql;",init_db.sql
"CREATE FUNCTION increment(i integer) RETURNS integer AS $$
BEGIN
	RETURN i + 1;
END;
$$ LANGUAGE plpgsql;",gosql_test.go
"CREATE FUNCTION influxdb_fdw_abs(int) RETURNS int AS $$
BEGIN
RETURN abs($1);
END
$$ LANGUAGE plpgsql IMMUTABLE;",influxdb_fdw_post.out
"CREATE FUNCTION info_all_master_query(OUT id integer, OUT name text, OUT master text, OUT last_check integer, OUT notified_serial integer, OUT type text) RETURNS SETOF record
    LANGUAGE plpgsql STABLE ROWS 1
    AS $$
DECLARE
  r iprange;
BEGIN

RETURN QUERY EXECUTE '
SELECT
h_int(basedomain::text),
basedomain::text,
''''::text,
0,
to_char(now(),''YYYYMMDDHH24'')::integer,
''MASTER''::text
FROM cpe_formats
';

FOR r IN SELECT cpe_ranges.range FROM cpe_ranges LOOP

RETURN QUERY EXECUTE format('
SELECT
h_int(fake_inaddr_arpa),
fake_inaddr_arpa,
''''::text,
0,
to_char(now(),''YYYYMMDDHH24'')::integer,
''MASTER''::text
FROM fake_inaddr_arpa(''%s'');
',r);

END LOOP;

END
$$;",schema.sql
"CREATE FUNCTION informehistorial(id_pacient bigint, id_analitica bigint DEFAULT NULL::bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  sql1 text;
  sql2 text;
  sql3 text;
  rec record;
  rec2 record;
  trobat boolean := False;
  analitica bigint;
  id_resultat bigint;
  ret varchar :='';
  data_analitica timestamp;
  resultat varchar :='';
  valoracio varchar;
  prova int := 0;
  n_prova varchar;
BEGIN
  sql1 := 'SELECT * FROM pacients WHERE idpacient = ' || id_pacient || ';';

  FOR rec IN EXECUTE(sql1) LOOP
    trobat := True;
  END LOOP;

  IF NOT trobat THEN
    return '-5';
  END IF;

  trobat := False;

  IF id_analitica is not NULL THEN
    sql1 := 'SELECT idanalitica FROM analitiques WHERE idanalitica = ' || id_analitica || ' and idpacient = ' || id_pacient || ';';
    
    FOR rec IN EXECUTE(sql1) LOOP
      trobat := True;
      analitica := rec.idanalitica;
    END LOOP;
    
    IF NOT trobat THEN
      return '-6';
    END IF;
  ELSE
    sql1 := 'SELECT idanalitica FROM analitiques WHERE idpacient = ' || id_pacient || ' order by dataanalitica desc limit 1;';
    FOR rec IN EXECUTE(sql1) LOOP
      trobat := True;
      analitica := rec.idanalitica;	
      data_analitica := rec.dataanalitica;	
    END LOOP;
    
    IF NOT trobat THEN
      return '-7';
    END IF;
  END IF;

  /* #####################################################################
   # HASTA AQUI, TANTO COMO EL PACIENTE COMO LA ANALITICA EXISTEN
   #####################################################################	
  */
  -- select * from resultats join provestecnica on resultats.idanalitica= 2 and provestecnica.idprovatecnica=resultats.idprovatecnica;
  -- select provestecnica.idprova,resultats.dataresultat from resultats join provestecnica on resultats.idanalitica= 12 and provestecnica.idprovatecnica=resultats.idprovatecnica group by resultats.dataresultat, provestecnica.idprova;
  trobat := False;
  sql1 := 'select provestecnica.idprova from resultats join provestecnica on resultats.idanalitica= ' || analitica || ' and provestecnica.idprovatecnica=resultats.idprovatecnica group by provestecnica.idprova;';
  
  FOR rec IN EXECUTE(sql1) LOOP
    trobat := True;
    IF prova != rec.idprova THEN
      prova := rec.idprova;
      ret := ret||historialpacpro(id_pacient,prova,data_analitica);
    END IF;
  END LOOP;
  
  IF NOT trobat THEN
    return '-8';
  END IF;

RETURN ret;
EXCEPTION 
  WHEN unique_violation THEN return '-1'; 
  WHEN foreign_key_violation THEN return '-2'; 
  WHEN not_null_violation THEN return '-3';
  --WHEN others THEN return '-4'; 
END;
$$;",lab_clinic.sql
"CREATE FUNCTION ingreso_anno(integer) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total FROM contratos
WHERE (date_part('YEAR', contratos.fecha_entrega)=$1);
RETURN total;
END
$_$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION ingreso_anno(integer) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total FROM contratos
WHERE (date_part('YEAR', contratos.fecha_entrega)=$1);
RETURN total;
END
$_$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION ingreso_anno(integer) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total FROM contratos
WHERE (date_part('YEAR', contratos.fecha_entrega)=$1);
RETURN total;
END
$_$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION ingreso_anno(integer) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total FROM contratos
WHERE (date_part('YEAR', contratos.fecha_entrega)=$1);
RETURN total;
END
$_$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION ingreso_anno(integer) RETURNS real
    LANGUAGE plpgsql
    AS $_$
DECLARE
total float;
BEGIN
SELECT sum(contratos.importe_total) INTO total FROM contratos
WHERE (date_part('YEAR', contratos.fecha_entrega)=$1);
RETURN total;
END
$_$;",backup1.sql
"CREATE FUNCTION ingreso_mes(mes integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
BEGIN
SELECT sum(importe_total) into tot 
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto

WHERE date_part('month', fecha_entrega) = mes;
RETURN tot;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION ingreso_mes(mes integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
BEGIN
SELECT sum(importe_total) into tot 
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto

WHERE date_part('month', fecha_entrega) = mes;
RETURN tot;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION ingreso_mes(mes integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
BEGIN
SELECT sum(importe_total) into tot 
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto

WHERE date_part('month', fecha_entrega) = mes;
RETURN tot;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION ingreso_mes(mes integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
BEGIN
SELECT sum(importe_total) into tot 
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto

WHERE date_part('month', fecha_entrega) = mes;
RETURN tot;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION ingreso_mes(mes integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
tot float;
BEGIN
SELECT sum(importe_total) into tot 
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto

WHERE date_part('month', fecha_entrega) = mes;
RETURN tot;
END
$$;",backup1.sql
"CREATE FUNCTION initgeoonce1564812() RETURNS void AS $$
BEGIN
if not exists (select constraint_name 
                   from information_schema.constraint_column_usage 
                   where table_schema = 'remocra' and table_name = 'commune'  and constraint_name = 'enforce_dims_geometrie') then
		ALTER TABLE remocra.commune ADD CONSTRAINT enforce_dims_geometrie CHECK (st_ndims(geometrie) = 2);
		ALTER TABLE remocra.commune ADD CONSTRAINT enforce_geotype_geometrie CHECK (geometrytype(geometrie) = 'MULTIPOLYGON'::text);
		ALTER TABLE remocra.commune ADD CONSTRAINT enforce_srid_geometrie CHECK (st_srid(geometrie) = 2154);
END IF;

if not exists (select constraint_name 
                   from information_schema.constraint_column_usage 
                   where table_schema = 'remocra' and table_name = 'permis'  and constraint_name = 'enforce_dims_geometrie') then
		ALTER TABLE remocra.permis ADD CONSTRAINT enforce_dims_geometrie CHECK (st_ndims(geometrie) = 2);
		ALTER TABLE remocra.permis ADD CONSTRAINT enforce_geotype_geometrie CHECK (geometrytype(geometrie) = 'POINT'::text);
		ALTER TABLE remocra.permis ADD CONSTRAINT enforce_srid_geometrie CHECK (st_srid(geometrie) = 2154);
END IF;

if not exists (select constraint_name 
                   from information_schema.constraint_column_usage 
                   where table_schema = 'remocra' and table_name = 'alerte'  and constraint_name = 'enforce_dims_geometrie') then
		ALTER TABLE remocra.alerte ADD CONSTRAINT enforce_dims_geometrie CHECK (st_ndims(geometrie) = 2);
		ALTER TABLE remocra.alerte ADD CONSTRAINT enforce_geotype_geometrie CHECK (geometrytype(geometrie) = 'POINT'::text);
		ALTER TABLE remocra.alerte ADD CONSTRAINT enforce_srid_geometrie CHECK (st_srid(geometrie) = 2154);
END IF;

if not exists (select constraint_name 
                   from information_schema.constraint_column_usage 
                   where table_schema = 'remocra' and table_name = 'alerte_elt'  and constraint_name = 'enforce_dims_geometrie') then
		ALTER TABLE remocra.alerte_elt ADD CONSTRAINT enforce_dims_geometrie CHECK (st_ndims(geometrie) = 2);
		ALTER TABLE remocra.alerte_elt ADD CONSTRAINT enforce_srid_geometrie CHECK (st_srid(geometrie) = 2154);
END IF;

END;
$$ LANGUAGE plpgsql;",003.sql
"CREATE FUNCTION integer2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res xml;
  BEGIN
     res := xmlelement(name ""simpleType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                        xmlattributes('en' as ""xml:lang""), 
                        'Implementation of ' ||item.item || '. Defined as: ' || item.definition)),
          
             xmlelement(name restriction, 
                        xmlattributes('integer' as base))
              );


     return res;
  END;
$$;",test.sql
"CREATE FUNCTION inventory_held_by_customer(p_inventory_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_customer_id INTEGER;
BEGIN

  SELECT customer_id INTO v_customer_id
  FROM rental
  WHERE return_date IS NULL
  AND inventory_id = p_inventory_id;

  RETURN v_customer_id;
END $$;",videoclub.sql
"CREATE FUNCTION inventory_in_stock(p_inventory_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_rentals INTEGER;
    v_out     INTEGER;
BEGIN
    -- AN ITEM IS IN-STOCK IF THERE ARE EITHER NO ROWS IN THE rental TABLE
    -- FOR THE ITEM OR ALL ROWS HAVE return_date POPULATED

    SELECT count(*) INTO v_rentals
    FROM rental
    WHERE inventory_id = p_inventory_id;

    IF v_rentals = 0 THEN
      RETURN TRUE;
    END IF;

    SELECT COUNT(rental_id) INTO v_out
    FROM inventory LEFT JOIN rental USING(inventory_id)
    WHERE inventory.inventory_id = p_inventory_id
    AND rental.return_date IS NULL;

    IF v_out > 0 THEN
      RETURN FALSE;
    ELSE
      RETURN TRUE;
    END IF;
END $$;",videoclub.sql
"CREATE FUNCTION ip_to_bit(ip text) RETURNS bit
    LANGUAGE plpgsql
    AS $$
DECLARE oct numeric[4];
BEGIN
	select regexp_split_to_array(ip, '\.') into oct;
        RETURN cast(cast(oct[1] * 16777216 + oct[2] * 65536 + oct[3] * 256 + oct[4] as bigint) as bit(32));
END;
$$;",data_analysis.psql
"CREATE FUNCTION iplike(i_ipaddress text, i_rule text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
  declare
    c_i integer;
    c_r text;

    c_addrwork text;
    c_addrtemp text;
    c_rulework text;
    c_ruletemp text;
    c_scopeid text;

    i integer;

  begin
    if i_ipaddress is NULL or i_ipaddress is null then
        return 'f';
    end if;

    if i_rule = '*.*.*.*' or i_rule = '*:*:*:*:*:*:*:*' then
        return 't';
    end if;

    -- First, strip apart the IP address into octets, and
    -- verify that they are legitimate (0-255)
    --
    -- IPv4
    if i_ipaddress ~ E'^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' and i_rule ~ E'^[0-9*,-]+\.[0-9*,-]+\.[0-9*,-]+\.[0-9*,-]+$' then
        c_addrwork := i_ipaddress;
        c_rulework := i_rule;

        i := 0;
        while i < 4 loop
            if (strpos(c_addrwork, '.') > 0) then
                c_i := to_number(substr(c_addrwork, 0, strpos(c_addrwork, '.')), '999');
            else 
                c_i := to_number(c_addrwork, '999');
            end if;

            if c_i > 255 then
                return 'f';
            end if;
            c_addrwork := ltrim(ltrim(c_addrwork, '0123456789'), '.');

            if (strpos(c_rulework, '.') > 0) then
                c_r := substr(c_rulework, 0, strpos(c_rulework, '.'));
            else
                c_r := c_rulework;
            end if;

            if not check_rule(c_i, c_r) then
                return 'f';
            end if;

            c_rulework := ltrim(ltrim(c_rulework, '0123456789,-*'), '.');

            i := i + 1;
        end loop;
    -- IPv6
    elsif i_ipaddress ~ E'^[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+:[0-9a-f]+(%[0-9]+)?$' and i_rule ~ E'^[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+:[0-9a-f*,-]+(%[0-9*,-]+)?$' then
        c_addrwork := i_ipaddress;
        c_rulework := i_rule;

        -- TODO Add support for scope identifiers

        i := 0;
        while i < 8 loop
            if (strpos(c_addrwork, ':') > 0) then
                c_addrtemp = substr(c_addrwork, 0, strpos(c_addrwork, ':'));
            else 
                c_addrtemp = c_addrwork;
            end if;
            if (strpos(c_addrtemp, '%') > 0) then
                -- Strip off the scope ID for now
                c_scopeid = substr(c_addrtemp, strpos(c_addrtemp, '%') + 1);
                c_addrtemp = substr(c_addrtemp, 0, strpos(c_addrtemp, '%'));
            end if;
            while length(c_addrtemp) < 4 loop
                c_addrtemp := '0' || c_addrtemp;
            end loop;
            c_i := cast(cast('x' || cast(c_addrtemp as text) as bit(16)) as integer);

            -- Max 16-bit integer value
            if c_i > 65535 then
                return 'f';
            end if;
            c_addrwork := ltrim(ltrim(c_addrwork, '0123456789abcdef'), ':');

            if (strpos(c_rulework, ':') > 0) then
                c_r := substr(c_rulework, 0, strpos(c_rulework, ':'));
            else
                c_r := c_rulework;
            end if;

            if not check_hex_rule(c_i, c_r) then
                return 'f';
            end if;

            c_rulework := ltrim(ltrim(c_rulework, '0123456789abcdef,-*'), ':');

            i := i + 1;
        end loop;
    else
        return 'f';
    end if;	

  return 't';
end;
$_$;",init-opennms.sql
"CREATE FUNCTION is_am(emp_id integer, start_date date, end_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
half numeric;
begin
	SELECT INTO half
		(CASE 	WHEN AM.BREAK_OUT <= AM.DUTY_IN THEN
					0.5
				END
		) AS HALF
	FROM(
		SELECT
		(CASE	WHEN S.BREAK_OUT < S.DUTY_END AND S.DUTY_END < S.DUTY_START THEN
				S.BREAK_OUT::interval + '24 hour'::interval
			ELSE
				S.BREAK_OUT::interval
			END
		) AS BREAK_OUT,
		(CASE	WHEN ATT.DUTY_IN::interval < S.DUTY_END AND S.DUTY_END < S.DUTY_START THEN
				ATT.DUTY_IN::interval + '24 hour'::interval
			ELSE
				ATT.DUTY_IN::interval
			END
		) AS DUTY_IN
	FROM
		ATTENDANCE ATT INNER JOIN SHIFT_POLICY S ON		
			S.SHIFT_ID = ATT.SHIFT_ID
	WHERE
		ATT.ATTENDANCE_DATE BETWEEN start_date
		AND end_date
		AND ATT.ABSENCE IS NULL
		AND ATT.EMPLOYEE_ID = emp_id
	)AM;

 if(half = 0.5)then
	return half;
 else
	half:=0;
 end if;
 return half;
end;
$$;",hr_main.sql
"CREATE FUNCTION is_answer_accepted(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE date_solved TIMESTAMP;
  DECLARE answer_accepted INTEGER;
BEGIN
  SELECT solved_date FROM answers WHERE answers.publicationid = aid
  INTO date_solved;

  IF date_solved is null THEN
    answer_accepted := 0;
  ELSE
    answer_accepted :=1;
  END IF;

  return answer_accepted;
END
$$;",dbm
"CREATE FUNCTION is_answer_accepted(aid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE date_solved TIMESTAMP;
  DECLARE answer_accepted INTEGER;
BEGIN
  SELECT solved_date FROM answers WHERE answers.publicationid = aid
  INTO date_solved;

  IF date_solved is null THEN
    answer_accepted := 0;
  ELSE
    answer_accepted :=1;
  END IF;

  return answer_accepted;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION is_correct_pw(u_id text, u_pw text) RETURNS boolean
    LANGUAGE plpgsql STRICT SECURITY DEFINER
    SET search_path TO public, pg_temp
    AS $$declare passed boolean;
BEGIN
	select (pw = u_pw) into passed
	from operator
	where operator_id = u_id
	;
	
	return passed;
END;$$;",setup.dump
"CREATE FUNCTION is_empty(p_val character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
	If Trim(Coalesce(p_val, '')) = '' Then
   	Return true;
    Else
    	Return false;
   End If;
END;
$$;",utils.sql
"CREATE FUNCTION is_integer(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
            BEGIN
                PERFORM cast($1 AS INTEGER);
                RETURN 1;
            EXCEPTION
                WHEN INVALID_TEXT_REPRESENTATION THEN
                    RETURN 0;
            END;
            $_$;",rcd-test-data.sql
"CREATE FUNCTION is_movie_available(movie_id integer) RETURNS bit
    LANGUAGE plpgsql
    AS $$DECLARE
	productcount integer;
BEGIN
	SELECT COUNT(id) FROM product where product.movie_id = movieid INTO productcount;
	return 1;
END$$;",finalDB.sql
"CREATE FUNCTION is_null_or_empty(p_array character varying[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    i integer;
    v_item varchar;
BEGIN
    IF array_lower(p_array, 1) Is Null THEN
       Return true;
    END IF;

    FOR i IN array_lower(p_array, 1)..array_upper(p_array, 1) LOOP
        If p_array[i] is not null Then
           v_item = Trim(p_array[i]);
           If Length(v_item) > 0 Then
              Return false;
           End If;
        End If;
    END LOOP;

    -- by this point, no valid array elements found
    Return true;
END;
$$;",utils.sql
"CREATE FUNCTION is_null_or_empty(p_array numeric[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
    i integer;
BEGIN
    IF array_lower(p_array, 1) Is Null THEN
       Return true;
    END IF;

    FOR i IN array_lower(p_array, 1)..array_upper(p_array, 1) LOOP
        If p_array[i] is not null Then
           Return false;
        End If;
    END LOOP;

    -- by this point, no valid array elements found
    Return true;
END;
$$;",utils.sql
"CREATE FUNCTION is_pm(emp_id integer, start_date date, end_date date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
half numeric;
begin
	SELECT INTO half
		(CASE 	WHEN PM.BREAK_IN >= PM.DUTY_OUT THEN
					0.5
				END
		) AS HALF
	FROM(
	SELECT
		(CASE	WHEN S.BREAK_IN < S.DUTY_END AND S.DUTY_END < S.DUTY_START THEN
				S.BREAK_IN::interval + '24 hour'::interval
			ELSE
				S.BREAK_IN::interval
			END
		) AS BREAK_IN,
		(CASE	WHEN ATT.DUTY_OUT < S.DUTY_END AND S.DUTY_END < S.DUTY_START THEN
				ATT.DUTY_OUT::interval + '24 hour'::interval
			ELSE
				ATT.DUTY_OUT::interval
			END
		) AS DUTY_OUT
	FROM
		ATTENDANCE ATT INNER JOIN SHIFT_POLICY S ON		
			S.SHIFT_ID = ATT.SHIFT_ID
	WHERE
		ATT.ATTENDANCE_DATE BETWEEN start_date
		AND end_date
		AND ATT.ABSENCE IS NULL
		AND ATT.EMPLOYEE_ID = emp_id
	)PM;

 if(half = 0.5)then
	return half;
 else
	half:=0;
 end if;
 return half;
end;
$$;",hr_main.sql
"CREATE FUNCTION is_reset_medidor(p_imei character) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
  
DECLARE
p_capacidad INTEGER := 0;
p_promedio INTEGER := 0;
p_resultado BOOLEAN := false;
BEGIN

p_promedio = (SELECT AVG(consumo)
		FROM lecturacion
		WHERE imei = p_imei);

p_capacidad = ( SELECT capacidad
	FROM medidor
	WHERE imei = p_imei and estado ='Habilitado');
	
IF (p_promedio <> 0 and p_capacidad <> 0 ) THEN
	p_resultado = (p_promedio * 1.5) >= p_capacidad;
END IF;

RETURN p_resultado;
END;
$$;",saguapac-presentacion.sql
"CREATE FUNCTION isblackdomain(url text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE COST 120
    AS $$
DECLARE
sspos integer;
domainname text;
findeddomains text;
result bool:=false;
BEGIN
domainname:= extractdomain(url);
select host into findeddomains from blacklist where host like(domainname)   limit 1;
SELECT INTO sspos position(domainname in findeddomains)  LIMIT 1;

if (sspos > 0)
then
result:=true;
end if;
RETURN result;
END;
$$;",02.sql
"CREATE FUNCTION isbranchworkingondate(branchid integer, eventdate date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$ DECLARE 
BEGIN
	RETURN (SELECT CASE (SELECT SUBSTR(TRIM(TO_CHAR(a.working_day, '0000009')), CAST(TO_NUMBER(TO_CHAR($2, 'D'), '9') AS INTEGER), 1)
			     FROM locum_db.branch_details a 
			     WHERE a.branch_id = $1)
		WHEN '1' THEN TRUE
		ELSE FALSE
	       END); 
END;
$_$;",LMS%20Basic%20DB%20creation%20Script.sql
"CREATE FUNCTION ishoadonpay(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(select * from ""KhamBenh"" where ""MaKhamBenh""= $1 and CAST(""TienKhamThucTe"" AS NUMERIC) <> 0);
	end
	$_$;",database.backup
"CREATE FUNCTION isnumeric(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE x NUMERIC;
BEGIN
    x = $1::NUMERIC;
    RETURN TRUE;
EXCEPTION WHEN others THEN
    RETURN FALSE;
END;
$_$;",2016-02-22%20backup.sql
"CREATE FUNCTION isodow(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
begin
return (extract (dow from $1) +6)::int % 7;
end;$_$;",fahstats.schema
"CREATE FUNCTION isodow(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
begin
return (extract (dow from $1) +6)::int % 7;
end;$_$;",ks2.schema
"CREATE FUNCTION iswhitedomain(url text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE COST 99
    AS $$
DECLARE
sspos integer;
domainname text;
findeddomains text;
result bool:=false;
BEGIN
domainname:= extractdomain(url);
--select host into findeddomains from whitelist where host like(domainname)   limit 1;
--select host into findeddomains from whitelist where  extractdomain(url) ~ host  limit 1;
--SELECT INTO sspos position(domainname in findeddomains)  LIMIT 1;
select count (1) into sspos from whitelist where  extractdomain(url) ~ host  limit 1;
if (sspos > 0)
then
result:=true;
end if;
RETURN result;
END;
$$;",02.sql
"CREATE FUNCTION java_guid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
    BEGIN 
        return uuid_in(md5(random()::text || now()::text)::cstring);
    END;
$$;",create.sql
"CREATE FUNCTION json_array_map(json_arr json, path text[]) RETURNS json[]
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
    rec json;
    len int;
    ret json[];
BEGIN
    -- If json_arr is not an array, return an empty array as the result
    BEGIN
        len := json_array_length(json_arr);
    EXCEPTION
        WHEN OTHERS THEN
            RETURN ret;
    END;

    -- Apply mapping in a loop
    FOR rec IN SELECT json_array_elements#>path FROM json_array_elements(json_arr)
    LOOP
        ret := array_append(ret,rec);
    END LOOP;
    RETURN ret;
END $$;",dudf
"CREATE FUNCTION last_record() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE last_record INTEGER;
BEGIN
SELECT ""id"" FIRST_VALUE INTO last_record FROM tbarticle ORDER BY ""id"" DESC LIMIT 1;
RETURN last_record;
END
$$;",05072015235607.sql
"CREATE FUNCTION lastcost(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$

DECLARE

v_cost numeric;
v_parts_id alias for $1;

BEGIN

  SELECT INTO v_cost sellprice FROM invoice i
  JOIN ap a ON (a.id = i.trans_id)
  WHERE i.parts_id = v_parts_id
  ORDER BY a.transdate desc, a.id desc
  LIMIT 1;

  IF v_cost IS NULL THEN
    v_cost := 0;
  END IF;

RETURN v_cost;
END;
$_$;",empty.sql
"CREATE FUNCTION len(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
		return char_length($1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION lml_event(p_class_name text, p_event_name text) RETURNS lml_event
    LANGUAGE plpgsql COST 1
    AS $_$
declare
  -- ищет код события по его имени и имени класса
  res      lml_event;
begin
  select e.*
    into strict res
    from lml_class c,
         lml_event e
   where e.class_id = c.id
     and c.name = p_class_name
     and e.name = p_event_name;
  return res;
exception
  when NO_DATA_FOUND then
    -- 'ENV00002', 'event %2$s not found in class %1$s'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('ENV00002', p_class_name, p_event_name);
    --execute env_raise_exception('P0002', 'ENV00002', p_class_name, p_event_name);
  when TOO_MANY_ROWS then
    -- 'ENV00003', 'event %2$s not unique in class %1$s'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('ENV00003', p_class_name, p_event_name);
    --execute env_raise_exception('23505', 'ENV00003', p_class_name, p_event_name);
end;
$_$;",metadict.sql
"CREATE FUNCTION lml_event_status(OUT ""STARTED"" smallint, OUT ""PROCESSING"" smallint, OUT ""ENDED"" smallint) RETURNS record
    LANGUAGE plpgsql IMMUTABLE COST 1
    AS $$
begin
  -- возвращает константные значения статусов событий
  -- STARTED, PROCESSED, ENDED
  ""STARTED"" := 1;
  ""PROCESSING"" := 2;
  ""ENDED"" := 3;
  return;
end;
$$;",metadict.sql
"CREATE FUNCTION login(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
     declare
        username_ alias for $1;
        password_ alias for $2; 
        num_ int;
        info text;
        
     begin
	SELECT into num_ acct_id from user_account where username = username_ and password = password_;

	SELECT into info fac_id||','||fName||','||mName||','||lName||',faculty'||','||college||','||department as info1 from faculty where acct_id = num_;

	if info isnull then
		SELECT into info id||','||fName||','||mName||','||lName||',student' as info1 from student where acct_id = num_;
	end if;

	if info isnull then 
		info = 'invalid';
        end if;
        return info;
     end;
  $_$;",myEskwelaDB_May_20
"CREATE FUNCTION login(username character varying, contrasena character varying, host character varying, codaplicacion character varying, codidioma character varying, OUT ses_idsesion character varying, OUT ses_fhologueo character varying, OUT ses_fhoultimaconsulta character varying, OUT ses_scodaplicacion character varying, OUT ses_snumusuario character varying, OUT ses_srutusuario character varying, OUT ses_snomusuario character varying, OUT ses_scodidioma character varying, OUT ses_data01 character varying, OUT ses_data02 character varying, OUT ses_data03 character varying, OUT ses_data04 character varying, OUT ses_data05 character varying, OUT expiracontrasena character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xses_idsesion       varchar(100);
    declare xnumusuario			numeric(10);
    declare xrutusuario			varchar(10);
    declare xdvusuario 			varchar(10);
    declare xusername			varchar(20);
    declare xcontrasena			varchar(40);
    declare xapepaterno 		varchar(40);
    declare xapematerno 		varchar(40);
    declare xnombre 			varchar(100);
    declare xtelefono			varchar(20);
    declare xemail 				varchar(100);
    declare xindvigencia		varchar(1);  
    declare xfhocontrasena		date;
    declare xcantintentos		numeric(4,0);
    declare xfechaactual			varchar(20);
    declare xnombre_completo	varchar(255);
    declare xrut_completo       varchar(255);

    begin
        numerror := '0';
        msjerror := ' ';

        select
            u.idusuario,
            u.rut,
            u.dv,
            u.contrasena, 
            u.apepaterno,
            u.apematerno,
            u.nombres,
            u.telefono,
            u.email,
            u.indvigencia,
            u.feccontrasena,
            u.cantintentos
        into
            xnumusuario,
            xrutusuario,
            xdvusuario,
            xcontrasena, 
            xapepaterno,
            xapematerno,
            xnombre,
            xtelefono,
            xemail,
            xindvigencia,
            xfhocontrasena,
            xcantintentos
        from
            usuario u
        where
            upper(nomusuario) = upper(username);

if found then
    return;
else
RAISE EXCEPTION 'No existe el usuario %',$1;


   

end if;



        


        ses_idsesion			:= xses_idsesion;
        ses_fhologueo 			:= xfechaactual;
        ses_fhoultimaconsulta	:= xfechaactual;
        ses_scodaplicacion		:= codaplicacion;
        ses_snumusuario         := trim(to_char(xnumusuario, '99999999'));
        ses_srutusuario         := xrutusuario;
        ses_snomusuario         := xnombre_completo;
        ses_scodidioma			:= xtelefono;
        ses_data01				:= xemail;
        ses_data02				:= ' ';
        ses_data03				:= ' ';
        ses_data04				:= ' ';
        ses_data05				:= codidioma;

    end;

$_$;",bak-04-11-2014.sql
"CREATE FUNCTION login(username character varying, contrasena character varying, host character varying, codaplicacion character varying, codidioma character varying, OUT ses_idsesion character varying, OUT ses_fhologueo character varying, OUT ses_fhoultimaconsulta character varying, OUT ses_scodaplicacion character varying, OUT ses_snumusuario character varying, OUT ses_srutusuario character varying, OUT ses_snomusuario character varying, OUT ses_scodidioma character varying, OUT ses_data01 character varying, OUT ses_data02 character varying, OUT ses_data03 character varying, OUT ses_data04 character varying, OUT ses_data05 character varying, OUT expiracontrasena character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xses_idsesion       varchar(100);
    declare xnumusuario			numeric(10);
    declare xrutusuario			varchar(10);
    declare xdvusuario 			varchar(10);
    declare xusername			varchar(20);
    declare xcontrasena			varchar(40);
    declare xapepaterno 		varchar(40);
    declare xapematerno 		varchar(40);
    declare xnombre 			varchar(100);
    declare xtelefono			varchar(20);
    declare xemail 				varchar(100);
    declare xindvigencia		varchar(1);  
    declare xfhocontrasena		date;
    declare xcantintentos		numeric(4,0);
    declare xfechaactual			varchar(20);
    declare xnombre_completo	varchar(255);
    declare xrut_completo       varchar(255);

    begin
        numerror := '0';
        msjerror := ' ';

        select
            u.idusuario,
            u.rut,
            u.dv,
            u.contrasena, 
            u.apepaterno,
            u.apematerno,
            u.nombres,
            u.telefono,
            u.email,
            u.indvigencia,
            u.feccontrasena,
            u.cantintentos
        into
            xnumusuario,
            xrutusuario,
            xdvusuario,
            xcontrasena, 
            xapepaterno,
            xapematerno,
            xnombre,
            xtelefono,
            xemail,
            xindvigencia,
            xfhocontrasena,
            xcantintentos
        from
            usuario u
        where
            upper(nomusuario) = upper(username);

if found then
    return;
else
RAISE EXCEPTION 'No existe el usuario %',$1;


   

end if;



        


        ses_idsesion			:= xses_idsesion;
        ses_fhologueo 			:= xfechaactual;
        ses_fhoultimaconsulta	:= xfechaactual;
        ses_scodaplicacion		:= codaplicacion;
        ses_snumusuario         := trim(to_char(xnumusuario, '99999999'));
        ses_srutusuario         := xrutusuario;
        ses_snomusuario         := xnombre_completo;
        ses_scodidioma			:= xtelefono;
        ses_data01				:= xemail;
        ses_data02				:= ' ';
        ses_data03				:= ' ';
        ses_data04				:= ' ';
        ses_data05				:= codidioma;

    end;

$_$;",bak-06-11-2014.sql
"CREATE FUNCTION login(username character varying, contrasena character varying, host character varying, codaplicacion character varying, codidioma character varying, OUT ses_idsesion character varying, OUT ses_fhologueo character varying, OUT ses_fhoultimaconsulta character varying, OUT ses_scodaplicacion character varying, OUT ses_snumusuario character varying, OUT ses_srutusuario character varying, OUT ses_snomusuario character varying, OUT ses_scodidioma character varying, OUT ses_data01 character varying, OUT ses_data02 character varying, OUT ses_data03 character varying, OUT ses_data04 character varying, OUT ses_data05 character varying, OUT expiracontrasena character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $_$

    declare xses_idsesion       varchar(100);
    declare xnumusuario			numeric(10);
    declare xrutusuario			varchar(10);
    declare xdvusuario 			varchar(10);
    declare xusername			varchar(20);
    declare xcontrasena			varchar(40);
    declare xapepaterno 		varchar(40);
    declare xapematerno 		varchar(40);
    declare xnombre 			varchar(100);
    declare xtelefono			varchar(20);
    declare xemail 				varchar(100);
    declare xindvigencia		varchar(1);  
    declare xfhocontrasena		date;
    declare xcantintentos		numeric(4,0);
    declare xfechaactual			varchar(20);
    declare xnombre_completo	varchar(255);
    declare xrut_completo       varchar(255);

    begin
        numerror := '0';
        msjerror := ' ';

        select
            u.idusuario,
            u.rut,
            u.dv,
            u.contrasena, 
            u.apepaterno,
            u.apematerno,
            u.nombres,
            u.telefono,
            u.email,
            u.indvigencia,
            u.feccontrasena,
            u.cantintentos
        into
            xnumusuario,
            xrutusuario,
            xdvusuario,
            xcontrasena, 
            xapepaterno,
            xapematerno,
            xnombre,
            xtelefono,
            xemail,
            xindvigencia,
            xfhocontrasena,
            xcantintentos
        from
            usuario u
        where
            upper(nomusuario) = upper(username);

if found then
    return;
else
RAISE EXCEPTION 'No existe el usuario %',$1;


   

end if;



        


        ses_idsesion			:= xses_idsesion;
        ses_fhologueo 			:= xfechaactual;
        ses_fhoultimaconsulta	:= xfechaactual;
        ses_scodaplicacion		:= codaplicacion;
        ses_snumusuario         := trim(to_char(xnumusuario, '99999999'));
        ses_srutusuario         := xrutusuario;
        ses_snomusuario         := xnombre_completo;
        ses_scodidioma			:= xtelefono;
        ses_data01				:= xemail;
        ses_data02				:= ' ';
        ses_data03				:= ' ';
        ses_data04				:= ' ';
        ses_data05				:= codidioma;

    end;

$_$;",bak18.11.sql
"CREATE FUNCTION login(username character varying, in_contrasena character varying, OUT out_id integer, OUT out_email character varying, OUT out_nombre character varying, OUT out_apellido_paterno character varying, OUT out_apellido_materno character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    declare _id                 integer;
    declare _email              varchar(100);
    declare _nombre       		varchar(100);
    declare _apellido_paterno	varchar(100);
	declare _apellido_materno	varchar(100);
	
    begin
        numerror := 0;
        msjerror := ' ';

        select
            idusuario,
            email,
            nombres,
            apepaterno,
            apematerno
        into
            _id,
            _email,
            _nombre,
            _apellido_paterno,
            _apellido_materno
        from
            usuario
        where
            upper(nomusuario) = upper(username) and  in_contrasena = contrasena;

        if found then
		out_id := _id;
        out_email := _email;
        out_nombre := _nombre;
		out_apellido_paterno := _apellido_paterno;
		out_apellido_materno := _apellido_materno;
        return;

        else
        numerror := '1';
        msjerror := 'Datos de inicio de sesión inválidos.';
        end if;
    end;
$$;",3-2-15.sql
"CREATE FUNCTION login(username character varying, in_contrasena character varying, OUT out_id integer, OUT out_email character varying, OUT out_nombre character varying, OUT out_apellido_paterno character varying, OUT out_apellido_materno character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

    declare _id                 integer;
    declare _email              varchar(100);
    declare _nombre       		varchar(100);
    declare _apellido_paterno	varchar(100);
	declare _apellido_materno	varchar(100);
	
    begin
        numerror := 0;
        msjerror := ' ';

        select
            idusuario,
            email,
            nombres,
            apepaterno,
            apematerno
        into
            _id,
            _email,
            _nombre,
            _apellido_paterno,
            _apellido_materno
        from
            usuario
        where
            upper(nomusuario) = upper(username) and  in_contrasena = contrasena;

        if found then
		out_id := _id;
        out_email := _email;
        out_nombre := _nombre;
		out_apellido_paterno := _apellido_paterno;
		out_apellido_materno := _apellido_materno;
        return;

        else
        numerror := '1';
        msjerror := 'Datos de inicio de sesión inválidos.';
        end if;
    end;
$$;",bkup.sql
"CREATE FUNCTION login(usua character varying, pass character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$

 DECLARE
  Nivel integer;

begin
  select Lvl_Permisos INTO Nivel from view_USUARIOS WHERE nombre=usua AND contraseña=pass AND Activo=1;
  RETURN Nivel;
end;
$$;",respaldo_001.sql
"CREATE FUNCTION login(usuario character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
	DECLARE 
		retorno boolean default false;
		contar int default 0;
	BEGIN
		SELECT 
			count(*) INTO contar 
		FROM
			admin_usuarios 
		WHERE 
			nickname = $1 AND clave = md5($2 || $1 || 'ok') AND estado = TRUE;
		IF contar > 0 THEN
			retorno = TRUE;
		ELSE
			retorno = FALSE;
		END IF;
		RETURN retorno;
	END
$_$;",bd_SistFarmaciaRespaldo.sql
"CREATE FUNCTION login(vparams json) RETURNS json
    LANGUAGE plpgsql
    AS $$

DECLARE
	pUserid varchar;
	pPassword varchar;
	vStatus INT;
	vErrorCode INT;	
	vErrorMsg varchar;
	vLogin varchar;
	vResult varchar;
BEGIN
	pUserid = vparams->>'userid';
	pPassword = vparams->>'password';
	vStatus = 0;

	IF (pUserid = '' or pUserid IS NULL) or (pPassword = '' or pPassword IS NULL) then
		vStatus = -1;
		vErrorCode = 1001;
		vErrorMsg = 'Invalid login parameters';
		SELECT json_build_object('status',vStatus,'error_code',vErrorCode,'error_msg',vErrorMsg) INTO vResult;
	ELSE
		SELECT json_build_object('status',vStatus,'result',array_agg(temp)) INTO vResult
		FROM (select * from ""user"" where user_id = pUserid and password = pPassword) temp;
	END IF;
	RETURN vResult;
	EXCEPTION WHEN OTHERS THEN
	vErrorCode = 120;
	vStatus = -1;
	GET STACKED DIAGNOSTICS vErrorMsg = MESSAGE_TEXT;
	SELECT json_build_object('status',vStatus,'error_code',vErrorCode,'error_msg',vErrorMsg,'result',null) into vResult;
	RETURN vResult;
END

$$;",backup_local_db.sql
"CREATE FUNCTION login_function(trol character varying, usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol JOIN rol_usuario ON rol_usuario.rol_id_rol=rol.id_rol WHERE rol.tipo_rol=trol;

SELECT rol_usuario.usuario_id_user INTO id_u 
FROM rol_usuario JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE rol_usuario.rol_id_rol=id_r AND usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_r NOTNULL AND id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION login_function(trol character varying, usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol JOIN rol_usuario ON rol_usuario.rol_id_rol=rol.id_rol WHERE rol.tipo_rol=trol;

SELECT rol_usuario.usuario_id_user INTO id_u 
FROM rol_usuario JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE rol_usuario.rol_id_rol=id_r AND usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_r NOTNULL AND id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION login_function(trol character varying, usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol JOIN rol_usuario ON rol_usuario.rol_id_rol=rol.id_rol WHERE rol.tipo_rol=trol;

SELECT rol_usuario.usuario_id_user INTO id_u 
FROM rol_usuario JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE rol_usuario.rol_id_rol=id_r AND usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_r NOTNULL AND id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION login_function(trol character varying, usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol JOIN rol_usuario ON rol_usuario.rol_id_rol=rol.id_rol WHERE rol.tipo_rol=trol;

SELECT rol_usuario.usuario_id_user INTO id_u 
FROM rol_usuario JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE rol_usuario.rol_id_rol=id_r AND usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_r NOTNULL AND id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION login_function(trol character varying, usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT rol.id_rol INTO id_r FROM rol JOIN rol_usuario ON rol_usuario.rol_id_rol=rol.id_rol WHERE rol.tipo_rol=trol;

SELECT rol_usuario.usuario_id_user INTO id_u 
FROM rol_usuario JOIN usuarios ON usuarios.id_user=rol_usuario.usuario_id_user
WHERE rol_usuario.rol_id_rol=id_r AND usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_r NOTNULL AND id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup1.sql
"CREATE FUNCTION login_function(usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT usuarios.id_user INTO id_u 
FROM usuarios 
WHERE usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION login_function(usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT usuarios.id_user INTO id_u 
FROM usuarios 
WHERE usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION login_function(usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT usuarios.id_user INTO id_u 
FROM usuarios 
WHERE usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION login_function(usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT usuarios.id_user INTO id_u 
FROM usuarios 
WHERE usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION login_function(usr character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
resultado BOOLEAN:=FALSE;
id_r int;
id_u int;
pas VARCHAR;
BEGIN
SELECT usuarios.id_user INTO id_u 
FROM usuarios 
WHERE usuarios.usuario=usr AND usuarios.password_usuario=pass;
if(id_u NOTNULL)THEN
SELECT usuarios.password_usuario INTO pas FROM usuarios WHERE usuarios.id_user=id_u;
if(pas=pass)THEN
  resultado:= TRUE;
END IF;
END IF;
RETURN resultado;
END
$$;",backup1.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    AS $$
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$
    LANGUAGE plpgsql;",dbsetup.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    AS $$
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$
    LANGUAGE plpgsql;",xenia_all.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",database.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",fearth_db.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",hr_database.pgsql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",nlp.dump
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",pgex_backup.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",postgres.sql.txt
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",schema.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",snow_db_postgres.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",sqlex_backup.pgsql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",streetking-database.sql
"CREATE FUNCTION longtransactionsenabled() RETURNS boolean
    LANGUAGE plpgsql
    AS $$ 
DECLARE
	rec RECORD;
BEGIN
	FOR rec IN SELECT oid FROM pg_class WHERE relname = 'authorized_tables'
	LOOP
		return 't';
	END LOOP;
	return 'f';
END;
$$;",vkdb-schema.sql
"CREATE FUNCTION ltrim(character) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  trim(leading chr(32) from $1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION mat_snapshot_create(src text, ""table"" text, primkey text) RETURNS void
    LANGUAGE plpgsql
    AS $_$DECLARE

srctbl ALIAS FOR $1;
dsttbl ALIAS FOR $2;
prmkey ALIAS FOR $3;

BEGIN

-- Create new table 


EXECUTE ('CREATE TABLE ' || dsttbl || ' AS SELECT * FROM ' || srctbl); 

-- Create primary key 

EXECUTE ('ALTER TABLE ' || dsttbl || ' ADD PRIMARY KEY(' || prmkey || ')');



END;
$_$;",streetking-database.sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;







BEGIN



SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x



FROM viewclasses



WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;



BEGIN


IF (SELECT COUNT(*) FROM viewclasses WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11) = 0
	THEN RETURN 0;
END IF;


SELECT SUM(gradevalue * credits) / SUM(credits) into x

FROM viewclasses

WHERE studentid = $1 AND coursename like 'math%' AND (coursename <> 'math 1' AND coursename <> 'math 2') AND gradeid <= 11;



RETURN round(x,4);



END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'math%' AND (coursename != 'math 1' AND coursename != 'math 2') AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'math%' AND (coursename != 'math 1' AND coursename != 'math 2') AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

BEGIN

SELECT SUM(gradevalue * credits) / SUM(credits) into x
FROM viewclasses
WHERE studentid = $1 AND coursename like 'math%' AND (coursename != 'math 1' AND coursename != 'math 2') AND gradeid <= 11;

RETURN round(x,4);

END$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;

sid INTEGER;

tid INTEGER;

BEGIN





-- old query

-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x

-- FROM viewclasses

-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;





-- new query: arg1 = studenttermid

SELECT studentid into sid FROM studentterms where studenttermid = $1;

SELECT termid into tid FROM studentterms where studenttermid = $1;





SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x

FROM viewclasses

WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;







RETURN round(x,4);







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;


-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;


-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;


-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;


-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION mathgwa(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE x numeric;
sid INTEGER;
tid INTEGER;
BEGIN


-- old query
-- SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
-- FROM viewclasses
-- WHERE studentid = $1 AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11;


-- new query: arg1 = studenttermid
SELECT studentid into sid FROM studentterms where studenttermid = $1;
SELECT termid into tid FROM studentterms where studenttermid = $1;


SELECT COALESCE(SUM(gradevalue * credits) / SUM(credits),0) into x
FROM viewclasses
WHERE studentid = sid AND coursename like 'Math%' AND (coursename <> 'Math 1' AND coursename <> 'Math 2') AND gradeid <= 11 AND termid <= tid;



RETURN round(x,4);



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION measurement2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql STABLE STRICT
    SET search_path TO gsc_db, public
    AS $$

  DECLARE
     res xml;
     valAtt xml := xmlelement(name attribute, xmlattributes('values' as name,
                                                         'gcdml:positiveDoubleList' as type,
                                                         'required' as use));
    uomType text := 'token';

    restrictionPrefix text := CASE WHEN item.value_type = 'named measurement' 
                                   THEN 'gcdml:NamedMeasurement' 
                                   ELSE 'gcdml:Measurement' END; 
    
  BEGIN

  res := xmlconcat(
         xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                              xmlattributes('en' as ""xml:lang""), 
                              'Implemantation of ' ||item.item || '. Defined as: ' || item.definition)),
          xmlelement(name ""complexContent"", 
             xmlelement(name restriction, 
                        xmlattributes(restrictionPrefix || 'MIGSType' as base),
                
                xmlelement(name attribute, xmlattributes('uom' as ""name"",
                                                         uomType as type,
                                                         'required' as use))
             )
          )
       ),
       -- now GCD version

        xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'Type' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", xmlattributes('en' as ""xml:lang""), 
                                                 'GCD implementation with additional attributes. ' || item.definition)),
          xmlelement(name ""complexContent"", 
             xmlelement(name restriction, 
                        xmlattributes(restrictionPrefix || 'Type' as base),
                xmlelement(name attribute, xmlattributes('uom' as ""name"",
                                                         uomType as type,
                                                         'required' as use))
             )
          )
       )-- end second xml
     ); -- end xmlconcat


     return res;
  END;
$$;",test.sql
"CREATE FUNCTION member_propagate_address(p_from_person_id integer, p_to_person_ids integer[], p_include_residence boolean, p_include_mailing boolean) RETURNS void
    AS $$
DECLARE
    v_from_member RECORD;
    i integer;
BEGIN
    SELECT INTO v_from_member address_id, mailing_address_id
      FROM member 
      WHERE person_id = p_from_person_id;

    i := 1;
    WHILE NOT p_to_person_ids[i] IS NULL LOOP
       IF p_include_residence THEN
           PERFORM member_set_address(false, p_to_person_ids[i],
                   v_from_member.address_id);
       END IF;
       IF p_include_mailing THEN
           PERFORM member_set_address(true, p_to_person_ids[i],
                   v_from_member.mailing_address_id);
       END IF;
       i := i + 1;
    END LOOP;

END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION mensajes_rom(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR SELECT * from msg where msg.romid=$1;
	RETURN MYCURS;
END;
$_$;",todo.sql
"CREATE FUNCTION merge_fields(t_row ""MEMBERS"") RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
   -- t2_row table2%ROWTYPE;
BEGIN
    --SELECT * INTO t2_row FROM table2 WHERE ... ;
    --RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$;",server.sql
"CREATE FUNCTION min_int(left_value integer, right_value integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$declare
   m integer;
begin
   if (left_value < right_value) then
      m = left_value;
   else
      m = right_value;
   end if;

   return m;
end;$$;",create.sql
"CREATE FUNCTION minmax(a integer, b integer, c integer, OUT min integer, OUT max integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
min=least(a,b,c);
max=greatest(a,b,c);
end;
$$;",file(21Aprl).pgsql
"CREATE FUNCTION minmax(a integer, b integer, c integer, OUT min integer, OUT max integer) RETURNS record
    LANGUAGE plpgsql
    AS $$
begin
min=least(a,b,c);
max=greatest(a,b,c);
end;
$$;",mydb_dump(20th_April).pgsql
"CREATE FUNCTION mis_connection_calculate_end_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT LEAST(
                (SELECT end_date from mis where id=mis1_id), 
                (SELECT end_date from mis where id=mis2_id)));
END;
$$;",db_dump1
"CREATE FUNCTION mis_connection_calculate_end_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT LEAST(
                (SELECT end_date from mis where id=mis1_id), 
                (SELECT end_date from mis where id=mis2_id)));
END;
$$;",db_dump2
"CREATE FUNCTION mis_connection_calculate_end_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT LEAST(
                (SELECT end_date from mis where id=mis1_id), 
                (SELECT end_date from mis where id=mis2_id)));
END;
$$;",db_dump3
"CREATE FUNCTION mis_connection_calculate_end_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT LEAST(
                (SELECT end_date from mis where id=mis1_id), 
                (SELECT end_date from mis where id=mis2_id)));
END;
$$;",db_dump4
"CREATE FUNCTION mis_connection_calculate_start_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT GREATEST(
                (SELECT start_date from mis where id=mis1_id), 
                (SELECT start_date from mis where id=mis2_id)));
END;
$$;",db_dump1
"CREATE FUNCTION mis_connection_calculate_start_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT GREATEST(
                (SELECT start_date from mis where id=mis1_id), 
                (SELECT start_date from mis where id=mis2_id)));
END;
$$;",db_dump2
"CREATE FUNCTION mis_connection_calculate_start_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT GREATEST(
                (SELECT start_date from mis where id=mis1_id), 
                (SELECT start_date from mis where id=mis2_id)));
END;
$$;",db_dump3
"CREATE FUNCTION mis_connection_calculate_start_date(mis1_id integer, mis2_id integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
BEGIN
    RETURN (SELECT GREATEST(
                (SELECT start_date from mis where id=mis1_id), 
                (SELECT start_date from mis where id=mis2_id)));
END;
$$;",db_dump4
"CREATE FUNCTION mixs2epicollect(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$

  DECLARE
     res xml;
  BEGIN
     
     IF item.value_type IN ('measurement', 'named measurement', 'text') THEN
       res := mixs2epicollectInput(item);
     ELSIF item.value_type = 'enumeration' THEN
       res := mixs2epicollectInput(item);
     ELSIF item.value_type = 'reference' THEN
       res := mixs2epicollectInput(item);

     ELSIF item.value_type IN ('regime', 'named regime') THEN
       res := mixs2epicollectInput(item);

     ELSIF item.value_type = 'treatment' THEN
       res := mixs2epicollectInput(item);

     ELSIF item.value_type IN ('integer') THEN
       res := mixs2epicollectInput(item);

     ELSIF item.value_type = 'boolean' THEN
       res := mixs2epicollectInput(item);
     
     ELSIF item.value_type = 'timestamp' THEN
       res := mixs2epicollectInput(item);
     
     ELSE
       res := mixs2epicollectInput(item);
     
     END IF;

     return res;
  END;
$$;",test.sql
"CREATE FUNCTION mixs2epicollectinput(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$

  DECLARE
     res xml;
     empty xml := xmlcomment(item.item || ' not implemented yet');

     label_elem xml := xmlelement(name ""label"",
                                  item.label
                                  );

     unit_elem xml := xmlelement(name ""input"", 
                      xmlattributes( item.item || '_uom' as ref,
                                     'true' as required
                                     ),
                       xmlelement(name ""label"", 'unit of measurement')
                      );

     text_elem xml := xmlelement(name ""input"", 
                      xmlattributes( item.item as ref,
                                     CASE WHEN item.requirement = 'M'
                                          THEN 'true'
                                          ELSE 'false' END as required
                                     ),
                       label_elem
                      );

     num_elem xml := xmlelement(name ""input"", 
                      xmlattributes( item.item as ref,
                                     CASE WHEN item.requirement = 'M'
                                          THEN 'true'
                                          ELSE 'false' END as required,
                                     'true' as numeric
                                     ),
                       label_elem
                      ); 
  BEGIN
    

     IF item.value_type = 'text' THEN
       res := text_elem;
     ELSIF item.value_type = 'measurement' THEN
       res := xmlconcat(num_elem, unit_elem);
     ELSIF item.value_type = 'named measurement' THEN
       res :=  xmlconcat(text_elem, num_elem, unit_elem);
     ELSIF item.value_type = 'enumeration' THEN
       res := empty;
     ELSIF item.value_type = 'reference' THEN
       res := text_elem;

     ELSIF item.value_type IN ('regime', 'named regime') THEN
       res := empty;

     ELSIF item.value_type = 'treatment' THEN
       res := empty;

     ELSIF item.value_type = 'integer' THEN
       res := num_elem;

     ELSIF item.value_type = 'boolean' THEN
       -- selection
       res := empty;
     
     ELSIF item.value_type = 'timestamp' THEN
       res := empty;
     
     ELSE
       res := empty;
     
     END IF;



     return res;
  END;
$$;",test.sql
"CREATE FUNCTION mod_articulos_nombre(integer, integer[], integer[], integer[], OUT id integer, OUT cod character, OUT nomcorto text, OUT nomlargo text, OUT nomcomercial text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare


  p_idfamilia alias for $1;
  p_idgrupo alias for $2;
  p_idpropiedad alias for $3;
  p_idvalor alias for $4;
  P_Sql text;
  r record;
  p_from_familia text;
  
  p_where_grupo text;
  p_having_propiedad text;
  p_having_valor text;
  
 begin


        if p_idfamilia=0 then
		p_from_familia:='mod_propiedades_heredadas_bsc(0';
	else
		p_from_familia:='mod_propiedades_heredadas_bsc('||p_idfamilia;
	end if;
	
	p_where_grupo:=case when array_length(p_idgrupo,1)> 0 then ' and array[grupo_id] && array'||translate(p_idgrupo::text,'{}','[]') else '' end; -- El grupo esté entre los pasados (un grupo compone todas las propiedades heredadas o no de un artículo)
	p_having_propiedad:=case when array_length(p_idpropiedad,1)> 0 then ' and array_agg(propiedad_id) && array'||translate(p_idpropiedad::text,'{}','[]') else '' end; --la propiedad esté incluida en el grupo que estamos analizando
	p_having_valor:=case when array_length(p_idvalor,1)> 0 then ' and (array_agg(familia_propiedad_id) && array'||translate(p_idvalor::text,'{}','[]') else '' end; -- el id de valor esté en el grupo que estamos analizando
	
		
		
		-- el with nos devuelve todo el grupo de propiedades-valores y familias que compone la familia pasada
	p_sql:=		'with jerarquia as( '||chr(10);
	p_sql:=p_sql||'		select distinct familia_id,familia, propiedad_id, propiedad, familia_propiedad_id, valor, orden '||chr(10);
	p_sql:=p_sql||'		from  ( '||chr(10);
	p_sql:=p_sql||'			select familia_id,familia,propiedad_id, propiedad, familia_propiedad_id, valor, orden  from '||p_from_familia||',false)  '||chr(10); --ascendentes
	p_sql:=p_sql||'			union distinct '||chr(10);
	p_sql:=p_sql||'			select familia_id,familia,propiedad_id, propiedad, familia_propiedad_id, valor, orden  from '||p_from_familia||',true) '||chr(10); --descendentes
	p_sql:=p_sql||'		) t '||chr(10);
	p_sql:=p_sql||') '||chr(10);
 
	p_sql:=p_sql||'select grupo.id as grupo_id, '||chr(10);
	p_sql:=p_sql||'		string_agg(case when jerarquia.propiedad_id is null and familia_componer.describe like ''cod%'' then familias.codfamilia '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and '||chr(10);
	p_sql:=p_sql||'							(corto.describe like ''cod%'' or largo.describe like ''cod%''  or comercial.describe like ''cod%'') then '||chr(10); 
	p_sql:=p_sql||'							famprop.cod '||chr(10);
	p_sql:=p_sql||'						else '''' end '||chr(10);
	p_sql:=p_sql||'					,'''' ORDER BY jerarquia.orden)::character(15) '||chr(10);
	p_sql:=p_sql||'				 as codarticulo, --sustituye todos los espacios en blanco consecutivos por NADA'||chr(10);
	p_sql:=p_sql||'		trim(string_agg(case when jerarquia.propiedad_id is null and familia_componer.describe like ''%valor%'' then jerarquia.familia||'' '' '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (corto.describe like ''%propiedad + valor'') then '||chr(10);
	p_sql:=p_sql||'							famprop.separador||pcorto.tcorto||'' ''||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (corto.describe like ''%propiedad'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||pcorto.tcorto '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (corto.describe like ''%valor'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						else '''' end '||chr(10);
	p_sql:=p_sql||'					,'''' ORDER BY jerarquia.orden) '||chr(10);
	p_sql:=p_sql||'			)	as tcorto, --sustituye todos los espacios en blanco consecutivos por uno solo'||chr(10);
	p_sql:=p_sql||'		trim(string_agg(case when jerarquia.propiedad_id is null and familia_componer.describe like ''%valor%'' then jerarquia.familia||'' '' '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (largo.describe like ''%propiedad + valor'') then '||chr(10);
	p_sql:=p_sql||'							case when length(famprop.separador)=0 then '' '' else famprop.separador end||plargo.tlargo||'' ''||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (largo.describe like ''%propiedad'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||plargo.tlargo '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (largo.describe like ''%valor'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						else '''' end '||chr(10);
	p_sql:=p_sql||'					,'''' ORDER BY jerarquia.orden) '||chr(10);
	p_sql:=p_sql||'			)	as tlargo, '||chr(10);
	p_sql:=p_sql||'		trim(string_agg(case when jerarquia.propiedad_id is null and familia_componer.describe like ''%valor%'' then jerarquia.familia||'' '' '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (comercial.describe like ''%propiedad + valor'') then '||chr(10);
	p_sql:=p_sql||'							case when length(famprop.separador)=0 then '' '' else famprop.separador end||pcomercial.tcomercial||'' ''||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (comercial.describe like ''%propiedad'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||pcomercial.tcomercial '||chr(10);
	p_sql:=p_sql||'						when jerarquia.propiedad_id is not null and (comercial.describe like ''%valor'') then case when length(famprop.separador)=0 then '' '' else famprop.separador end||jerarquia.valor '||chr(10);
	p_sql:=p_sql||'						else '''' end '||chr(10);
	p_sql:=p_sql||'					, '''' ORDER BY jerarquia.orden) '||chr(10);
	p_sql:=p_sql||'			)	as tcomercial '||chr(10);
	p_sql:=p_sql||'from articulos grupo '||chr(10);
	p_sql:=p_sql||'		inner join( '||chr(10);
	p_sql:=p_sql||'			jerarquia '||chr(10);
	p_sql:=p_sql||'		left JOIN '||chr(10);
	p_sql:=p_sql||'			(articulos_propiedades inner join familias_propiedades famprop on articulos_propiedades.fp_id=famprop.id '||chr(10);
	p_sql:=p_sql||'				INNER JOIN (propiedades pcorto inner join propiedades_componer corto on pcorto.componertcorto_id=corto.id) ON famprop.propiedad_id=pcorto.id '||chr(10);
	p_sql:=p_sql||'				INNER JOIN (propiedades plargo inner join propiedades_componer largo on plargo.componertlargo_id=largo.id) ON famprop.propiedad_id=plargo.id '||chr(10);
	p_sql:=p_sql||'				INNER JOIN (propiedades pcomercial inner join propiedades_componer comercial on pcomercial.componertcomercial_id=comercial.id ) ON famprop.propiedad_id=pcomercial.id '||chr(10);
	p_sql:=p_sql||'			) on jerarquia.familia_propiedad_id=articulos_propiedades.fp_id '||chr(10);
	p_sql:=p_sql||'		LEFT JOIN '||chr(10);
	p_sql:=p_sql||'			(familias inner join propiedades_componer familia_componer on familias.componer_id=familia_componer.id)  '||chr(10);
	p_sql:=p_sql||'			on jerarquia.familia_id=familias.id  and jerarquia.propiedad_id is null '||chr(10);
	p_sql:=p_sql||'	) on grupo.id=articulos_propiedades.grupo_id or familias.id is not null '||chr(10);
	p_sql:=p_sql||'where grupo.familia_id '||case when p_idfamilia=0 then ' is not null ' else '='||p_idfamilia end||p_where_grupo||chr(10);--haya grupo creado en la familia de análisis y el grupo pertenezca a alguno de los pasados
	p_sql:=p_sql||'group by grupo.id '||chr(10);
	p_sql:=p_sql||case when length(p_having_propiedad)>0 then 'having '||p_having_propiedad||p_having_valor else '' end||chr(10);
	p_sql:=p_sql||'	order by grupo.id '||chr(10); 
	

		
 --raise exception '%',p_sql;
 return query execute p_sql;

END;
$_$;",2016-02-22%20backup.sql
"CREATE FUNCTION mod_propedades_combinacion_valida(integer, integer[], integer[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
    p_idfamilia alias for $1;
    p_propiedades alias for $2;
    p_valores alias for $3;
    p_pos_prop_dependiente integer;
    r record;
    p_propiedad_id integer;
    p_valor_id integer;
    p_compatible boolean;
    
    i integer;
begin
	--búsqueda de todos los elementos dependientes de la familia

	for r in
		select f.propiedad_id,array_search(f.propiedad_id,p_propiedades) as pospropiedad,array_agg(v.fp2_id::text||'|'||f2.propiedad_id::text||'|'||array_search(f2.propiedad_id,p_propiedades)::text) as vligues
		from mod_propiedades_heredadas_bsc(p_idfamilia,false) f	inner join familias_valoresligados v on f.familia_propiedad_id=v.fp_id
			inner join familias_propiedades f2 on v.fp2_id=f2.id
		where f.familia_propiedad_id = any(p_valores) and (array[f2.propiedad_id] && p_propiedades) --el valor está entre la combinación a analizar, y la propiedad ligada está entre las propiedades de la combinación
		group by f.propiedad_id,array_search(f.propiedad_id,p_propiedades) loop
		if array_length(r.vligues,1)>0 then --hay alguna ligadura para uno de los valores a evaluar
			p_compatible:=false;
			for i in 1..array_length(r.vligues,1) loop -- por cada atadura encontrada, de un valor evaluamos su propiedad, para ver si dicha propiedad está en el vector de propiedades
					p_valor_id:=split_part(r.vligues[i],'|',1);
					p_propiedad_id:=split_part(r.vligues[i],'|',2);
					p_pos_prop_dependiente:=split_part(r.vligues[i],'|',3);
					if p_valores[p_pos_prop_dependiente]=p_valor_id then
						p_compatible:=true;
						exit;
					end if;	
			end loop;
			if not p_compatible then 
				return p_compatible;
			end if;	
		end if;
	end loop;
	return true;
	
end;

$_$;",2016-02-22%20backup.sql
"CREATE FUNCTION mod_propiedades_elementos_combinatoria(integer, OUT id integer, OUT propiedad_valor text, OUT orden integer) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $_$
declare
  p_familia_id alias for $1;
begin	
   return query
    select distinct case when propiedad_id is null then familia_id else familia_propiedad_id end as id,
	 case when propiedad_id is null then familia else propiedad||': '||valor end as familia_propiedad,
		t1.orden as orden
	from mod_propiedades_heredadas_bsc (p_familia_id,false) t1
	order by orden;

END;
$_$;",2016-02-22%20backup.sql
"CREATE FUNCTION month(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
         return  datepart(""month"",$1)
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION month_year_to_timestamp(v_month numeric, v_year numeric) RETURNS timestamp with time zone
LANGUAGE plpgsql
AS $$
begin
    return to_timestamp(1 || '.' || v_month || '.' || v_year, 'dd.mm.yyyy');
end
$$;",functions.sql
"CREATE FUNCTION monthname(date) RETURNS text
    AS $_$
DECLARE
  vDate ALIAS FOR $1;
  vResult text;
BEGIN
  vResult := monthname(getmonth(vdate::timestamp));
  RETURN vResult;
END;

$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION monthname(date) RETURNS text
    AS $_$
DECLARE
  vDate ALIAS FOR $1;
  vResult text;
BEGIN
  vResult := monthname(getmonth(vdate::timestamp));
  RETURN vResult;
END;

$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION monthname(integer) RETURNS text
    AS $_$
DECLARE
    pMonth ALIAS FOR $1;
    vResult text;
BEGIN
    vResult := CASE 
	WHEN pMonth = 1 THEN 'January'
	WHEN pMonth = 2 THEN 'February'
	WHEN pMonth = 3 THEN 'March'
	WHEN pMonth = 4 THEN 'April'
	WHEN pMonth = 5 THEN 'May'
	WHEN pMonth = 6 THEN 'June'
	WHEN pMonth = 7 THEN 'Jully'
	WHEN pMonth = 8 THEN 'August'
	WHEN pMonth = 9 THEN 'September'
	WHEN pMonth = 10 THEN 'October'
	WHEN pMonth = 11 THEN 'November'
	WHEN pMonth = 12 THEN 'December'
        WHEN (pMonth < 1) OR (pMonth > 12) THEN null
    END;
    RETURN vResult;
END;

$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION monthname(integer) RETURNS text
    AS $_$
DECLARE
    pMonth ALIAS FOR $1;
    vResult text;
BEGIN
    vResult := CASE 
	WHEN pMonth = 1 THEN 'January'
	WHEN pMonth = 2 THEN 'February'
	WHEN pMonth = 3 THEN 'March'
	WHEN pMonth = 4 THEN 'April'
	WHEN pMonth = 5 THEN 'May'
	WHEN pMonth = 6 THEN 'June'
	WHEN pMonth = 7 THEN 'Jully'
	WHEN pMonth = 8 THEN 'August'
	WHEN pMonth = 9 THEN 'September'
	WHEN pMonth = 10 THEN 'October'
	WHEN pMonth = 11 THEN 'November'
	WHEN pMonth = 12 THEN 'December'
        WHEN (pMonth < 1) OR (pMonth > 12) THEN null
    END;
    RETURN vResult;
END;

$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION monthname(timestamp with time zone) RETURNS text
    AS $_$
DECLARE
   vDate ALIAS FOR $1;
   vResult text;
 BEGIN
   vResult := monthname(getmonth(vdate));
   RETURN vResult;
 END;
 

$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION monthname(timestamp with time zone) RETURNS text
    AS $_$
DECLARE
   vDate ALIAS FOR $1;
   vResult text;
 BEGIN
   vResult := monthname(getmonth(vdate));
   RETURN vResult;
 END;
 

$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION mostrar_xls(integer, integer, integer, character varying) RETURNS SETOF ct_listaxlsresultado
    LANGUAGE plpgsql
    AS $_$
DECLARE
   inDia ALIAS FOR $1;
    inMes ALIAS FOR $2;  
    inAnio ALIAS FOR $3;
    inTipoFuncion ALIAS FOR $4;
    outXLSCount INTEGER;
    outXlsResultadoListRow public.ct_listaxlsresultado;
    outFechaMostrar DATE;
BEGIN

	SELECT 
          INTO  outXLSCount count(*)
    FROM
     empleado
      LEFT OUTER JOIN funcion ON (empleado.cedula = funcion.cedula)
      LEFT OUTER JOIN public.xlsresultado ON (funcion.cedula = public.xlsresultado.cedula)
    WHERE
    funcion.tipo=inTipoFuncion AND
    (date_part('year',public.xlsresultado.fechapago)=inAnio
      AND
      date_part('month',public.xlsresultado.fechapago)=inMes
      AND
      date_part('day',public.xlsresultado.fechapago)=inDia); 
	
    SELECT 
    	INTO outFechaMostrar
     to_date( CAST (inAnio as VARCHAR(4))||'-'||CAST (inMes as VARCHAR(2)) ||'-'|| CAST (inDia as VARCHAR(2)), 'YYYY-MM-DD');
        
        
    
    IF outXLSCount=0 THEN
		  FOR outXlsResultadoListRow IN
              SELECT  DISTINCT
                CAST(random()*100000000000000 AS text) as id,
                outFechaMostrar as fechapago,
                empleado.cedula,
                empleado.nombres,
                empleado.apellidos,
                CASE empleado.tipo_cuenta
                	WHEN '04' THEN 'Ahorro'
                    WHEN '03' THEN 'Corriente'                
                END as tipo_cuenta,
                empleado.num_cuenta,
                0.00 as valor_total,
                '' as concepto
              FROM
                empleado
               -- LEFT OUTER JOIN funcion ON (empleado.cedula = funcion.cedula)
                INNER JOIN funcion ON (empleado.cedula = funcion.cedula)
               WHERE
               funcion.tipo=inTipoFuncion 
          LOOP
       			RETURN NEXT outXlsResultadoListRow;
      	  END LOOP;


        ELSE
           
          FOR outXlsResultadoListRow IN           
           SELECT 
                    CAST(random()*100000000000000 AS text) as id,
                    xlsresultado.fechapago,
                    empleado.cedula,
                    empleado.nombres,
                    empleado.apellidos,
                    CASE empleado.tipo_cuenta
                	WHEN '04' THEN 'Ahorros'
                    WHEN '03' THEN 'Corriente'                
                	END as tipo_cuenta,
                    empleado.num_cuenta,
                    xlsresultado.valor_total,
                    xlsresultado.concepto
              FROM
                empleado
                LEFT OUTER JOIN funcion ON (empleado.cedula = funcion.cedula)
                LEFT OUTER JOIN public.xlsresultado ON (funcion.cedula = public.xlsresultado.cedula)
              WHERE
              funcion.tipo =inTipoFuncion
                AND
                (date_part('year',xlsresultado.fechapago)=inAnio
                AND
                date_part('month',xlsresultado.fechapago)=inMes
                AND
                date_part('day',xlsresultado.fechapago)=inDia)
           UNION 
           		SELECT  DISTINCT
                CAST(random()*100000000000000 AS text) as id,
                outFechaMostrar fechapago,
                empleado.cedula,
                empleado.nombres,
                empleado.apellidos,
                 CASE empleado.tipo_cuenta
                	WHEN '04' THEN 'Ahorros'
                    WHEN '03' THEN 'Corriente'                
                	END as tipo_cuenta,
                empleado.num_cuenta,
                0.00 as valor_total,
                '' as concepto
              FROM
                empleado
                --LEFT OUTER JOIN funcion ON (empleado.cedula = funcion.cedula)
                INNER JOIN funcion ON (empleado.cedula = funcion.cedula)
                WHERE
                funcion.tipo=inTipoFuncion
                AND
                empleado.cedula NOT IN ( SELECT   DISTINCT                
                                                empleado.cedula                                                
                                          FROM
                                            empleado
                                              LEFT OUTER JOIN funcion ON (empleado.cedula = funcion.cedula)
                                              LEFT OUTER JOIN public.xlsresultado ON (funcion.cedula = public.xlsresultado.cedula)
                                          WHERE
                                           funcion.tipo=inTipoFuncion AND
                                            (
                                            date_part('year',xlsresultado.fechapago)=inAnio
                                            AND
                                            date_part('month',xlsresultado.fechapago)=inMes
                                            AND
                                            date_part('day',xlsresultado.fechapago)=inDia) 
                                         )
                	
                
           	 LOOP
       			RETURN NEXT outXlsResultadoListRow;
      		END LOOP;
            
        END IF;
    
    
    

END;
$_$;",reporteNomina5.dump
"CREATE FUNCTION myfunction() RETURNS SETOF company
    LANGUAGE plpgsql
    AS $$
DECLARE 
cur CURSOR FOR SELECT * FROM company;
rec company%ROWTYPE;
 BEGIN
 OPEN cur;
 -- RAISE NOTICE 'id,name,age,salary';
loop
FETCH cur INTO rec;
RAISE NOTICE 'id %,name %,age %,salary %',rec.id,rec.name,rec.age,rec.salary;
   if not found then
        exit ;
   end if;
end loop;
RETURN;
END;
$$;",file(21Aprl).pgsql
"CREATE FUNCTION mylpad(bigint, integer, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
       MYNUMBER ALIAS FOR $1;
       MYLEN ALIAS FOR $2;
       MYPAD ALIAS FOR $3;
BEGIN
     IF (length(MYNUMBER::TEXT) > MYLEN) THEN
       RETURN (MYNUMBER::TEXT);
     END IF;
     RETURN LPAD(MYNUMBER::TEXT,MYLEN,MYPAD);
END;
$_$;",db.sql
"CREATE FUNCTION neurons_get_max() RETURNS bigint
    LANGUAGE plpgsql
    AS $$begin
  return round(pow((select count(1) from neurons), 0.67));
end;$$;",AIST5.4.schema.sql
"CREATE FUNCTION newid() RETURNS character varying
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$ 
DECLARE 
  v_seed_value varchar(32); 
BEGIN 
select 
md5( 
inet_client_addr()::varchar || 
timeofday() || 
inet_server_addr()::varchar || 
to_hex(inet_client_port()) 
) 
into v_seed_value; 

return (substr(v_seed_value,1,8) || '-' || 
        substr(v_seed_value,9,4) || '-' || 
        substr(v_seed_value,13,4) || '-' || 
        substr(v_seed_value,17,4) || '-' || 
        substr(v_seed_value,21,12)); 
END; 
$$;",tcc-2013-01-12.backup
"CREATE FUNCTION nombre_instit(tipo character varying, nro character varying, nombre character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
	DECLARE
		ret text := '';
	BEGIN
		IF tipo IS NOT NULL AND tipo <> ''THEN
			ret := ret || tipo;
			IF nro IS NOT NULL AND nro <> '' THEN
				ret := ret ||' N° '||nro;
			END IF;
		END IF;
		IF nombre IS NOT NULL AND nombre <> '' THEN
			ret := ret || ' ""'|| nombre || '""';
		END IF;

		return ret;
	END;
$$;",estudio2x.sql
"CREATE FUNCTION notificacionmain(scedula integer, pn character varying, pa character varying, sn character varying, sa character varying, sexo character, nacion character, parro integer, lug character varying, parrot integer, lugt character varying, num_delito integer, descdelito character varying, telef character varying, edc character varying, profe character varying, fechan date, numfich integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
                                            
 BEGIN 
  
  IF exists(Select * from individuos AS Ind WHERE Ind.cedula = SCedula) THEN
  
   PERFORM RegistrarFicha(SCedula,Num_Delito,DescDelito,Telef,EdC,Profe,(CAST(FechaN AS Date)),NumFich);
  
  ELSE
  
   PERFORM RegistrarIndividuo(SCedula,PN,PA,SN,SA,Sexo,Nacion,Parro,Lug,ParroT,LugT);
   PERFORM RegistrarFicha(SCedula,Num_Delito,DescDelito,Telef,EdC,Profe,(CAST(FechaN AS Date)),NumFich);
   
  END IF;
  
 END;
$$;",respaldo_001.sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns1group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_credits + otherMST_credits;



END;$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns1group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_credits + otherMST_credits;



END;$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns1group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_credits + otherMST_credits;



END;$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns1group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_credits + otherMST_credits;



END;$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns1group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_credits + otherMST_credits;



END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns1group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns1group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_units + otherMST_units;



END;$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns1group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_units + otherMST_units;



END;$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns1group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_units + otherMST_units;



END;$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns1group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_units + otherMST_units;



END;$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns1group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns1group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')

		LIMIT 2;

	END IF;



	return ns1group_units + otherMST_units;



END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns1group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_units + otherMST_units;

END;$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns1group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_units + otherMST_units;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns1group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_units + otherMST_units;

END;$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION ns1correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns1group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_credits + otherMST_credits;

END;$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION ns1correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns1group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
		LIMIT 2;
	END IF;

	return ns1group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION ns1correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns1group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

CREATE TEMPORARY TABLE allmstPass AS
SELECT v.gradevalue as x, v.credits as y, v.coursename
FROM viewclasses v
WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
ORDER BY v.termid ASC;

SELECT SUM(x * y) into ns1group_credits
FROM allmstPass
WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')
LIMIT 2;

IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN
SELECT SUM(x * y) into otherMST_credits
FROM allmstPass
WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')
LIMIT 2;
END IF;

return ns1group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns2group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_credits + otherMST_credits;



END;$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns2group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_credits + otherMST_credits;



END;$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns2group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_credits + otherMST_credits;



END;$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns2group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_credits + otherMST_credits;



END;$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_credits numeric DEFAULT 0;

otherMST_credits numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(x * y) into ns2group_credits

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(x * y) into otherMST_credits

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_credits + otherMST_credits;



END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns2group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns2group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_units + otherMST_units;



END;$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns2group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_units + otherMST_units;



END;$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns2group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_units + otherMST_units;



END;$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns2group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_units + otherMST_units;



END;$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

ns2group_units numeric DEFAULT 0;

otherMST_units numeric DEFAULT 0;



BEGIN



	CREATE TEMPORARY TABLE allmstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10

		ORDER BY v.termid ASC;



	SELECT SUM(y) into ns2group_units

	FROM allmstPass 

	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN

		SELECT SUM(y) into otherMST_units

		FROM allmstPass

		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')

		LIMIT 2;

	END IF;



	return ns2group_units + otherMST_units;



END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns2group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_units + otherMST_units;

END;$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns2group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_units + otherMST_units;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_units numeric DEFAULT 0;
otherMST_units numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(y) into ns2group_units
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(y) into otherMST_units
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_units + otherMST_units;

END;$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION ns2correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns2group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_credits + otherMST_credits;

END;$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION ns2correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

	CREATE TEMPORARY TABLE allmstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC;

	SELECT SUM(x * y) into ns2group_credits
	FROM allmstPass 
	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
		SELECT SUM(x * y) into otherMST_credits
		FROM allmstPass
		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
		LIMIT 2;
	END IF;

	return ns2group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION ns2correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
ns2group_credits numeric DEFAULT 0;
otherMST_credits numeric DEFAULT 0;

BEGIN

CREATE TEMPORARY TABLE allmstPass AS
SELECT v.gradevalue as x, v.credits as y, v.coursename
FROM viewclasses v
WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename != 'math 2' AND v.coursename != 'math 1' AND v.gradeid < 10
ORDER BY v.termid ASC;

SELECT SUM(x * y) into ns2group_credits
FROM allmstPass
WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')
LIMIT 2;

IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN
SELECT SUM(x * y) into otherMST_credits
FROM allmstPass
WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')
LIMIT 2;
END IF;

return ns2group_credits + otherMST_credits;

END;$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION objects_classes_to_name(obj objects_classes) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	case obj
		when 'task'     then return 'Задача';
		when 'member'   then return 'Пользователь';
		when 'division' then return 'Подразделение';
	end case;
	return concat('Функция objects_classes_to_name требует исправлений. Тип: ', obj);
end
$$;",shema.sql
"CREATE FUNCTION obtener_cant_miembros_clan(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT cant_miembros FROM clan WHERE id_clan=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_costo_edificio(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT costo_edificio FROM edificio WHERE id_edificio=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_costo_unidad(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT costo FROM unidad WHERE id_unidad=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_exp_clan(name text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT experiencia FROM clan WHERE nombre=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_expbase_edificios(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT experiencia_base FROM edificio WHERE id_edificio=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_id_aldea(id text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT id_aldea FROM aldea WHERE id_jugador=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_id_clan(name text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT id_clan FROM clan WHERE nombre=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_nivel_edificio(id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT nivel_edificio FROM edificio_jugador WHERE id_edificio_jugador = $1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_nombre_clan(id integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT nombre FROM clan WHERE id_clan=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_nombre_edificio(idedificio integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
BEGIN 

RETURN(SELECT nombre_edificio FROM edificio WHERE id_edificio=$1);

END;
$_$;",Postgres.sql
"CREATE FUNCTION obtener_nombre_unidad(idunidad integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
BEGIN 

RETURN(SELECT nombre FROM unidad WHERE id_unidad=$1);

END; 
$_$;",Postgres.sql
"CREATE FUNCTION obtener_saldo(id text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN (SELECT saldo FROM jugador WHERE id_jugador=$1);
END;
$_$;",Postgres.sql
"CREATE FUNCTION okco(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare f_login alias for $1;
	declare f_password alias for $2;
	declare id integer;
	declare retour integer;
begin
	select into id id_client from client where pseudo=f_login and mdp=f_password;
	if not found
	then
	  retour=0;
	else
	  retour=id;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION okcoadmin(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare f_login alias for $1;
	declare f_password alias for $2;
	declare id integer;
	declare retour integer;
begin
	select into id id_client from client where pseudo=f_login and mdp=f_password and statut=1;
	if not found
	then
	  retour=0;
	else
	  retour=id;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION optode_data_selector() RETURNS refcursor
    AS $$
DECLARE 
mycurs refcursor; 
BEGIN

drop table if exists dphase;
drop table if exists optode_temp;
drop table if exists sbe16_temperature;
drop table if exists sbe16_pressure;
drop table if exists sbe16_conductivity;
drop table if exists set1;
drop table if exists set2;
drop table if exists set3;

create temp table dphase as
select distinct on (date_trunc('hour',data_timestamp)) 
date_trunc('hour',data_timestamp) as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and parameter_code = 'OPTODE_DPHASE'
;

create temp table optode_temp as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and parameter_code = 'OPTODE_TEMP'
;

create temp table sbe16_temperature as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'WATER_TEMP'
;


create temp table sbe16_pressure as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'WATER_PRESSURE'
;

create temp table sbe16_conductivity as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'CONDUCTIVITY'
;

create temp table set1 as
select 
	dphase.obs_time,
	dphase.depth,
	dphase.parameter_value as optode_dphase,
	optode_temp.parameter_value as optode_temperature
from dphase full join optode_temp on 
(
dphase.obs_time = optode_temp.obs_time
AND
dphase.depth = optode_temp.depth
)
;

create temp table set2 as
select 
	set1.obs_time,
	set1.depth,
	set1.optode_dphase,
	set1.optode_temperature,
	sbe16_temperature.parameter_value as sbe16_temperature
from set1 full join sbe16_temperature on 
(
set1.obs_time = sbe16_temperature.obs_time
AND
set1.depth = sbe16_temperature.depth
)
;

create temp table set3 as
select 
	set2.obs_time,
	set2.depth,
	set2.optode_dphase,
	set2.optode_temperature,
        set2.sbe16_temperature,
	sbe16_pressure.parameter_value as sbe16_pressure
from set2 full join sbe16_pressure on 
(
set2.obs_time = sbe16_pressure.obs_time
AND
set2.depth = sbe16_pressure.depth
)
;

create temp table set4 as
select 
	set3.obs_time,
	set3.depth,
	set3.optode_dphase,
	set3.optode_temperature,
        set3.sbe16_temperature,
	set3.sbe16_pressure,
	sbe16_conductivity.parameter_value as sbe16_conductivity
from set3 full join sbe16_conductivity on 
(
set3.obs_time = sbe16_conductivity.obs_time
AND
set3.depth = sbe16_conductivity.depth
)
;

OPEN mycurs FOR  select * from set4 order by obs_time;
RETURN mycurs; 
END;
$$
    LANGUAGE plpgsql;",ABOS20110308.sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into CSEgroup_credits

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_credits + otherELE_credits;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into CSEgroup_credits

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into CSEgroup_credits

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_credits + otherELE_credits;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into CSEgroup_credits

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_credits + otherELE_credits;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_credits numeric DEFAULT 0;

otherELE_credits numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(x * y) into CSEgroup_credits

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(x * y) into otherELE_credits

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_credits + otherELE_credits;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION overcs197_correction(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
CSEgroup_credits numeric DEFAULT 0;
otherELE_credits numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(x * y) into CSEgroup_credits
	FROM allelePass
	WHERE v.domain = 'C197'
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(x * y) into otherELE_credits
		FROM allelePass
		WHERE v.domain <> 'C197'
		LIMIT 1;
	END IF;

	return CSEgroup_credits + otherELE_credits;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into CSEgroup_units

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_units + otherELE_units;

END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into CSEgroup_units

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into CSEgroup_units

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_units + otherELE_units;

END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into CSEgroup_units

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_units + otherELE_units;

END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

CSEgroup_units numeric DEFAULT 0;

otherELE_units numeric DEFAULT 0;



BEGIN

	CREATE TEMPORARY TABLE allelePass AS 

	SELECT v.gradevalue as x, v.credits as y

	FROM viewclasses v 

	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10

	ORDER BY v.termid ASC;



	SELECT SUM(y) into CSEgroup_units

	FROM allelePass

	WHERE v.domain = 'C197'

	LIMIT 2;



	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN

		SELECT SUM(y) into otherELE_units

		FROM allelePass

		WHERE v.domain <> 'C197'

		LIMIT 1;

	END IF;



	return CSEgroup_units + otherELE_units;

END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION overcs197_dcorrection(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
CSEgroup_units numeric DEFAULT 0;
otherELE_units numeric DEFAULT 0;

BEGIN
	CREATE TEMPORARY TABLE allelePass AS 
	SELECT v.gradevalue as x, v.credits as y
	FROM viewclasses v 
	WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10
	ORDER BY v.termid ASC;

	SELECT SUM(y) into CSEgroup_units
	FROM allelePass
	WHERE v.domain = 'C197'
	LIMIT 2;

	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN
		SELECT SUM(y) into otherELE_units
		FROM allelePass
		WHERE v.domain <> 'C197'
		LIMIT 1;
	END IF;

	return CSEgroup_units + otherELE_units;
END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION pagar_cuota(id_empresa character varying, remuneracion_total double precision, cantidad_empleados integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_emp character varying;
	result boolean;
BEGIN
	result = false;
	--Verifico que los datos sean correctos
	IF (id_empresa IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un ID de la empresa. Solicitud rechazada';
	ELSE
		SELECT e.id_usuario INTO id_emp FROM empresa e WHERE e.id_usuario = id_empresa;
		IF (id_emp IS NULL) THEN
			RAISE EXCEPTION 'No existe el usuario con ID %',id_emp;
		END IF;
	END IF;
	IF (remuneracion_total IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar las remuneraciones totales. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar la cantidad de empleados. Solicitud rechazada';
	END IF;
	IF (remuneracin_total <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar un monto de remuneraciones percibidas. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar una cantidad de empleados. Solicitud rechazada';
	END IF;
	RETURN result;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION pagar_cuota(id_empresa character varying, remuneracion_total double precision, cantidad_empleados integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_emp character varying;
	result boolean;
BEGIN
	result = false;
	--Verifico que los datos sean correctos
	IF (id_empresa IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un ID de la empresa. Solicitud rechazada';
	ELSE
		SELECT e.id_usuario INTO id_emp FROM empresa e WHERE e.id_usuario = id_empresa;
		IF (id_emp IS NULL) THEN
			RAISE EXCEPTION 'No existe el usuario con ID %',id_emp;
		END IF;
	END IF;
	IF (remuneracion_total IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar las remuneraciones totales. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar la cantidad de empleados. Solicitud rechazada';
	END IF;
	IF (remuneracin_total <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar un monto de remuneraciones percibidas. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar una cantidad de empleados. Solicitud rechazada';
	END IF;
	RETURN result;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION pagar_cuota(id_empresa character varying, remuneracion_total double precision, cantidad_empleados integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_emp character varying;
	result boolean;
BEGIN
	result = false;
	--Verifico que los datos sean correctos
	IF (id_empresa IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un ID de la empresa. Solicitud rechazada';
	ELSE
		SELECT e.id_usuario INTO id_emp FROM empresa e WHERE e.id_usuario = id_empresa;
		IF (id_emp IS NULL) THEN
			RAISE EXCEPTION 'No existe el usuario con ID %',id_emp;
		END IF;
	END IF;
	IF (remuneracion_total IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar las remuneraciones totales. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar la cantidad de empleados. Solicitud rechazada';
	END IF;
	IF (remuneracin_total <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar un monto de remuneraciones percibidas. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar una cantidad de empleados. Solicitud rechazada';
	END IF;
	RETURN result;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION pagar_cuota(id_empresa character varying, remuneracion_total double precision, cantidad_empleados integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	id_emp character varying;
	result boolean;
BEGIN
	result = false;
	--Verifico que los datos sean correctos
	IF (id_empresa IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un ID de la empresa. Solicitud rechazada';
	ELSE
		SELECT e.id_usuario INTO id_emp FROM empresa e WHERE e.id_usuario = id_empresa;
		IF (id_emp IS NULL) THEN
			RAISE EXCEPTION 'No existe el usuario con ID %',id_emp;
		END IF;
	END IF;
	IF (remuneracion_total IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar las remuneraciones totales. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar la cantidad de empleados. Solicitud rechazada';
	END IF;
	IF (remuneracin_total <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar un monto de remuneraciones percibidas. Solicitud rechazada';
	END IF;
	IF (cantidad_empleados <= 0) THEN
		RAISE EXCEPTION 'Debe ingresar una cantidad de empleados. Solicitud rechazada';
	END IF;
	RETURN result;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION parse_json() RETURNS void
    LANGUAGE plpgsql
    AS $$
  DECLARE json_object json;
  DECLARE item json;
  BEGIN
    SELECT ('{ ""Name"":""My Name"", ""Items"" :[{ ""Id"" : 1, ""Name"" : ""Name 1""}, { ""Id"" : 2, ""Name 2"" : ""Item2 Name""}]}')::json into json_object;
    RAISE NOTICE 'Parsing %', json_object->>'Name';
    FOR item IN SELECT * FROM json_array_elements((json_object->>'Items')::json)
    LOOP
       RAISE NOTICE 'Parsing Item % %', item->>'Id', item->>'Name';
    END LOOP;
  END;
  $$;",dudf
"CREATE FUNCTION part_properties(bigint, bigint) RETURNS part_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 

	parameter alias for $1;
	parameter_type_id alias for $2;
	
	res part_properties;

BEGIN

	res = part_properties_empty();

	if parameter_type_id = 1 then		-- 1;""Power"";""""
		res.power = (parameter :: double precision / 10000);
	elseif parameter_type_id = 6 then	-- 6;""Power modifier"";""""
		res.power_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 2 then	-- 2;""Handling"";""""
		res.handling = (parameter :: double precision / 10000);
	elseif parameter_type_id = 4 then	-- 4;""Handling modifier"";""""
		res.handling_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 3 then	-- 3;""Traction"";""""
		res.traction = (parameter :: double precision / 10000);
	elseif parameter_type_id = 10 then	-- 10;""Traction modifier"";""""
		res.traction_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 5 then	-- 5;""Braking"";""""
		res.braking = (parameter :: double precision / 10000);
	elseif parameter_type_id = 11 then	-- 11;""Braking modifier"";""""
		res.braking_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 8 then	-- 8;""NOS"";""""
		res.nos = (parameter :: double precision / 10000);
	elseif parameter_type_id = 12 then	-- 12;""NOS modifier"";""""
		res.nos_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 13 then	-- 13;""Aerodynamics"";""""
		res.aero = (parameter :: double precision / 10000);
	elseif parameter_type_id = 9 then	-- 9;""Aerodynamics modifier"";""""
		res.aero_m = 1 + (parameter :: double precision / 10000);
	else 					-- unknown parameter
		raise exception 'part_properties: unknown parameter type';
	end if;


RETURN res;

END$_$;",streetking-database.sql
"CREATE FUNCTION part_properties(bigint, bigint, bigint, bigint) RETURNS part_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 

	parameter0 alias for $1;
	parameter double precision;
	parameter_type_id alias for $2;
	improvement alias for $3;
	wear alias for $4;
	improvement_car double precision;
	wear_car double precision;
	res part_properties;

BEGIN
	SELECT ""value"" FROM game_config WHERE ""key"" = 'improvement_car' INTO improvement_car;
	SELECT ""value"" FROM game_config WHERE ""key"" = 'wear_car' INTO wear_car;

	parameter = parameter0 * (1 + improvement_car * (improvement / 10000.0)) * (1 - wear_car * (wear / 10000.0));

	res = part_properties_empty();

	if parameter_type_id = 1 then		-- 1;""Power"";""""
		res.power = (parameter :: double precision / 10000);
	elseif parameter_type_id = 6 then	-- 6;""Power modifier"";""""
		res.power_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 2 then	-- 2;""Handling"";""""
		res.handling = (parameter :: double precision / 10000);
	elseif parameter_type_id = 4 then	-- 4;""Handling modifier"";""""
		res.handling_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 3 then	-- 3;""Traction"";""""
		res.traction = (parameter :: double precision / 10000);
	elseif parameter_type_id = 10 then	-- 10;""Traction modifier"";""""
		res.traction_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 5 then	-- 5;""Braking"";""""
		res.braking = (parameter :: double precision / 10000);
	elseif parameter_type_id = 11 then	-- 11;""Braking modifier"";""""
		res.braking_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 8 then	-- 8;""NOS"";""""
		res.nos = (parameter :: double precision / 10000);
	elseif parameter_type_id = 12 then	-- 12;""NOS modifier"";""""
		res.nos_m = 1 + (parameter :: double precision / 10000);
	elseif parameter_type_id = 13 then	-- 13;""Aerodynamics"";""""
		res.aero = (parameter :: double precision / 10000);
	elseif parameter_type_id = 9 then	-- 9;""Aerodynamics modifier"";""""
		res.aero_m = 1 + (parameter :: double precision / 10000);
	else 					-- unknown parameter
		raise exception 'part_properties: unknown parameter type';
	end if;


RETURN res;

END$_$;",streetking-database.sql
"CREATE FUNCTION part_properties_add(part_properties, part_properties) RETURNS part_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 

	l alias for $1;
	r alias for $2;
	
	res part_properties;

BEGIN

	res.power = l.power + r.power;
	res.power_m = l.power_m * r.power_m;

	res.traction = l.traction + r.traction;
	res.traction_m = l.traction_m * r.traction_m;

	res.braking = l.braking + r.braking;
	res.braking_m = l.braking_m * r.braking_m;

	res.handling = l.handling + r.handling;
	res.handling_m = l.handling_m * r.handling_m;

	res.aero = l.aero + r.aero;
	res.aero_m = l.aero_m * r.aero_m;

	res.nos = l.nos + r.nos;
	res.nos_m = l.nos_m * r.nos_m;

RETURN res;

END$_$;",streetking-database.sql
"CREATE FUNCTION part_properties_empty() RETURNS part_properties
    LANGUAGE plpgsql IMMUTABLE
    AS $$DECLARE 
	res part_properties;
BEGIN
	res.power = 0;
	res.power_m = 1;

	res.traction = 0;
	res.traction_m = 1;

	res.braking = 0;
	res.braking_m = 1;

	res.handling = 0;
	res.handling_m = 1;

	res.aero = 0;
	res.aero_m = 1;

	res.nos = 0;
	res.nos_m = 1;

RETURN res;

END$$;",streetking-database.sql
"CREATE FUNCTION part_to_consumable(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'CONSUMABLE'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION part_to_producible(__component component_specification) RETURNS material_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __component.part_code,
    __component.version_num,
    __component.quantity,
    __component.uom_code,
    'PRODUCIBLE'::common.material_kind
  )::common.material_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION password_is_ok(p_login character varying, p_password character varying) RETURNS boolean
    AS $$
DECLARE
    v_password varchar;
    v_password_old varchar;
    v_ts timestamp;
BEGIN
    SELECT INTO v_password, v_password_old
        password, password_old
        FROM app_user WHERE login = p_login;

    IF  p_password = v_password  OR  p_password = v_password_old THEN
        RETURN FALSE;
    ELSE 
        RETURN TRUE;
    END IF;

END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION pct(value bigint, base bigint) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
begin
	return case when base <> 0 then 100.0 * value / base else 100 end;
end;
$$;",cbcc_db_init.sql
"CREATE FUNCTION person_get_age_category(p_person_id integer) RETURNS character
    AS $$
DECLARE
    v_member record;
    v_age_cat  char(1);
BEGIN
    SELECT into v_member  date_of_birth, age_category
        FROM member
        WHERE person_id = p_person_id;
    IF FOUND THEN
        SELECT into v_age_cat
            calc_age_category(v_member.date_of_birth, v_member.age_category);
    ELSE
        v_age_cat := 'A';
    END IF;

    RETURN v_age_cat;

END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION personnel_price(integer, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 
BEGIN

	return round(personnel_salary($1, $2) / 2);

END$_$;",streetking-database.sql
"CREATE FUNCTION personnel_salary(integer, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 
	rep alias for $1;
	eng alias for $2;
BEGIN

	return 2500 + (250 * rep + 500 * eng + 5 * rep * eng);

END$_$;",streetking-database.sql
"CREATE FUNCTION personnel_training_cost_engineering(integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 
	skill alias for $1;
BEGIN

	return 1500 * skill;

END$_$;",streetking-database.sql
"CREATE FUNCTION personnel_training_cost_repair(integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$DECLARE 
	skill alias for $1;
BEGIN

	return 500 * skill;

END$_$;",streetking-database.sql
"CREATE FUNCTION pga_is_leap_year(smallint) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    IF $1 % 4 != 0 THEN
        RETURN FALSE;
    END IF;

    IF $1 % 100 != 0 THEN
        RETURN TRUE;
    END IF;

    RETURN $1 % 400 = 0;
END;
$_$;",export_postgress.sql
"CREATE FUNCTION pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jscid           ALIAS FOR $1;
    jscstart        ALIAS FOR $2;
    jscend          ALIAS FOR $3;
    jscminutes      ALIAS FOR $4;
    jschours        ALIAS FOR $5;
    jscweekdays     ALIAS FOR $6;
    jscmonthdays    ALIAS FOR $7;
    jscmonths       ALIAS FOR $8;

    nextrun         timestamp := '1970-01-01 00:00:00-00';
    runafter        timestamp := '1970-01-01 00:00:00-00';

    bingo            bool := FALSE;
    gotit            bool := FALSE;
    foundval        bool := FALSE;
    daytweak        bool := FALSE;
    minutetweak        bool := FALSE;

    i                int2 := 0;
    d                int2 := 0;

    nextminute        int2 := 0;
    nexthour        int2 := 0;
    nextday            int2 := 0;
    nextmonth       int2 := 0;
    nextyear        int2 := 0;


BEGIN
    -- No valid start date has been specified
    IF jscstart IS NULL THEN RETURN NULL; END IF;

    -- The schedule is past its end date
    IF jscend IS NOT NULL AND jscend < now() THEN RETURN NULL; END IF;

    -- Get the time to find the next run after. It will just be the later of
    -- now() + 1m and the start date for the time being, however, we might want to
    -- do more complex things using this value in the future.
    IF date_trunc('MINUTE', jscstart) > date_trunc('MINUTE', (now() + '1 Minute'::interval)) THEN
        runafter := date_trunc('MINUTE', jscstart);
    ELSE
        runafter := date_trunc('MINUTE', (now() + '1 Minute'::interval));
    END IF;

    --
    -- Enter a loop, generating next run timestamps until we find one
    -- that falls on the required weekday, and is not matched by an exception
    --

    WHILE bingo = FALSE LOOP

        --
        -- Get the next run year
        --
        nextyear := date_part('YEAR', runafter);

        --
        -- Get the next run month
        --
        nextmonth := date_part('MONTH', runafter);
        gotit := FALSE;
        FOR i IN (nextmonth) .. 12 LOOP
            IF jscmonths[i] = TRUE THEN
                nextmonth := i;
                gotit := TRUE;
                foundval := TRUE;
                EXIT;
            END IF;
        END LOOP;
        IF gotit = FALSE THEN
            FOR i IN 1 .. (nextmonth - 1) LOOP
                IF jscmonths[i] = TRUE THEN
                    nextmonth := i;

                    -- Wrap into next year
                    nextyear := nextyear + 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
           END LOOP;
        END IF;

        --
        -- Get the next run day
        --
        -- If the year, or month have incremented, get the lowest day,
        -- otherwise look for the next day matching or after today.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter)) THEN
            nextday := 1;
            FOR i IN 1 .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextday := date_part('DAY', runafter);
            gotit := FALSE;
            FOR i IN nextday .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. (nextday - 1) LOOP
                    IF jscmonthdays[i] = TRUE THEN
                        nextday := i;

                        -- Wrap into next month
                        IF nextmonth = 12 THEN
                            nextyear := nextyear + 1;
                            nextmonth := 1;
                        ELSE
                            nextmonth := nextmonth + 1;
                        END IF;
                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Was the last day flag selected?
        IF nextday = 32 THEN
            IF nextmonth = 1 THEN
                nextday := 31;
            ELSIF nextmonth = 2 THEN
                IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                    nextday := 29;
                ELSE
                    nextday := 28;
                END IF;
            ELSIF nextmonth = 3 THEN
                nextday := 31;
            ELSIF nextmonth = 4 THEN
                nextday := 30;
            ELSIF nextmonth = 5 THEN
                nextday := 31;
            ELSIF nextmonth = 6 THEN
                nextday := 30;
            ELSIF nextmonth = 7 THEN
                nextday := 31;
            ELSIF nextmonth = 8 THEN
                nextday := 31;
            ELSIF nextmonth = 9 THEN
                nextday := 30;
            ELSIF nextmonth = 10 THEN
                nextday := 31;
            ELSIF nextmonth = 11 THEN
                nextday := 30;
            ELSIF nextmonth = 12 THEN
                nextday := 31;
            END IF;
        END IF;

        --
        -- Get the next run hour
        --
        -- If the year, month or day have incremented, get the lowest hour,
        -- otherwise look for the next hour matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR daytweak = TRUE) THEN
            nexthour := 0;
            FOR i IN 1 .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nexthour := date_part('HOUR', runafter);
            gotit := FALSE;
            FOR i IN (nexthour + 1) .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nexthour LOOP
                    IF jschours[i] = TRUE THEN
                        nexthour := i - 1;

                        -- Wrap into next month
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nextday = d THEN
                            nextday := 1;
                            IF nextmonth = 12 THEN
                                nextyear := nextyear + 1;
                                nextmonth := 1;
                            ELSE
                                nextmonth := nextmonth + 1;
                            END IF;
                        ELSE
                            nextday := nextday + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        --
        -- Get the next run minute
        --
        -- If the year, month day or hour have incremented, get the lowest minute,
        -- otherwise look for the next minute matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR nexthour > date_part('HOUR', runafter) OR daytweak = TRUE) THEN
            nextminute := 0;
            IF minutetweak = TRUE THEN
        d := 1;
            ELSE
        d := date_part('YEAR', runafter)::int2;
            END IF;
            FOR i IN d .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextminute := date_part('MINUTE', runafter);
            gotit := FALSE;
            FOR i IN (nextminute + 1) .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nextminute LOOP
                    IF jscminutes[i] = TRUE THEN
                        nextminute := i - 1;

                        -- Wrap into next hour
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nexthour = 23 THEN
                            nexthour = 0;
                            IF nextday = d THEN
                                nextday := 1;
                                IF nextmonth = 12 THEN
                                    nextyear := nextyear + 1;
                                    nextmonth := 1;
                                ELSE
                                    nextmonth := nextmonth + 1;
                                END IF;
                            ELSE
                                nextday := nextday + 1;
                            END IF;
                        ELSE
                            nexthour := nexthour + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Build the result, and check it is not the same as runafter - this may
        -- happen if all array entries are set to false. In this case, add a minute.

        nextrun := (nextyear::varchar || '-'::varchar || nextmonth::varchar || '-' || nextday::varchar || ' ' || nexthour::varchar || ':' || nextminute::varchar)::timestamptz;

        IF nextrun = runafter AND foundval = FALSE THEN
                nextrun := nextrun + INTERVAL '1 Minute';
        END IF;

        -- If the result is past the end date, exit.
        IF nextrun > jscend THEN
            RETURN NULL;
        END IF;

        -- Check to ensure that the nextrun time is actually still valid. Its
        -- possible that wrapped values may have carried the nextrun onto an
        -- invalid time or date.
        IF ((jscminutes = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscminutes[date_part('MINUTE', nextrun) + 1] = TRUE) AND
            (jschours = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jschours[date_part('HOUR', nextrun) + 1] = TRUE) AND
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonthdays[date_part('DAY', nextrun)] = TRUE OR
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,t}' AND
             ((date_part('MONTH', nextrun) IN (1,3,5,7,8,10,12) AND date_part('DAY', nextrun) = 31) OR
              (date_part('MONTH', nextrun) IN (4,6,9,11) AND date_part('DAY', nextrun) = 30) OR
              (date_part('MONTH', nextrun) = 2 AND ((pgagent.pga_is_leap_year(date_part('DAY', nextrun)::int2) AND date_part('DAY', nextrun) = 29) OR date_part('DAY', nextrun) = 28))))) AND
            (jscmonths = '{f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonths[date_part('MONTH', nextrun)] = TRUE)) THEN


            -- Now, check to see if the nextrun time found is a) on an acceptable
            -- weekday, and b) not matched by an exception. If not, set
            -- runafter = nextrun and try again.

            -- Check for a wildcard weekday
            gotit := FALSE;
            FOR i IN 1 .. 7 LOOP
                IF jscweekdays[i] = TRUE THEN
                    gotit := TRUE;
                    EXIT;
                END IF;
            END LOOP;

            -- OK, is the correct weekday selected, or a wildcard?
            IF (jscweekdays[date_part('DOW', nextrun) + 1] = TRUE OR gotit = FALSE) THEN

                -- Check for exceptions
                SELECT INTO d jexid FROM pgagent.pga_exception WHERE jexscid = jscid AND ((jexdate = nextrun::date AND jextime = nextrun::time) OR (jexdate = nextrun::date AND jextime IS NULL) OR (jexdate IS NULL AND jextime = nextrun::time));
                IF FOUND THEN
                    -- Nuts - found an exception. Increment the time and try again
                    runafter := nextrun + INTERVAL '1 Minute';
                    bingo := FALSE;
                    minutetweak := TRUE;
            daytweak := FALSE;
                ELSE
                    bingo := TRUE;
                END IF;
            ELSE
                -- We're on the wrong week day - increment a day and try again.
                runafter := nextrun + INTERVAL '1 Day';
                bingo := FALSE;
                minutetweak := FALSE;
                daytweak := TRUE;
            END IF;

        ELSE
            runafter := nextrun + INTERVAL '1 Minute';
            bingo := FALSE;
            minutetweak := TRUE;
        daytweak := FALSE;
        END IF;

    END LOOP;

    RETURN nextrun;
END;
$_$;",export_postgress.sql
"CREATE FUNCTION pgagent.pga_is_leap_year(smallint) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
BEGIN
    IF $1 % 4 != 0 THEN
        RETURN FALSE;
    END IF;

    IF $1 % 100 != 0 THEN
        RETURN TRUE;
    END IF;

    RETURN $1 % 400 = 0;
END;
$_$;",conscripts.bak
"CREATE FUNCTION pgagent.pga_next_schedule(integer, timestamp with time zone, timestamp with time zone, boolean[], boolean[], boolean[], boolean[], boolean[]) RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $_$
DECLARE
    jscid           ALIAS FOR $1;
    jscstart        ALIAS FOR $2;
    jscend          ALIAS FOR $3;
    jscminutes      ALIAS FOR $4;
    jschours        ALIAS FOR $5;
    jscweekdays     ALIAS FOR $6;
    jscmonthdays    ALIAS FOR $7;
    jscmonths       ALIAS FOR $8;

    nextrun         timestamp := '1970-01-01 00:00:00-00';
    runafter        timestamp := '1970-01-01 00:00:00-00';

    bingo            bool := FALSE;
    gotit            bool := FALSE;
    foundval        bool := FALSE;
    daytweak        bool := FALSE;
    minutetweak        bool := FALSE;

    i                int2 := 0;
    d                int2 := 0;

    nextminute        int2 := 0;
    nexthour        int2 := 0;
    nextday            int2 := 0;
    nextmonth       int2 := 0;
    nextyear        int2 := 0;


BEGIN
    -- No valid start date has been specified
    IF jscstart IS NULL THEN RETURN NULL; END IF;

    -- The schedule is past its end date
    IF jscend IS NOT NULL AND jscend < now() THEN RETURN NULL; END IF;

    -- Get the time to find the next run after. It will just be the later of
    -- now() + 1m and the start date for the time being, however, we might want to
    -- do more complex things using this value in the future.
    IF date_trunc('MINUTE', jscstart) > date_trunc('MINUTE', (now() + '1 Minute'::interval)) THEN
        runafter := date_trunc('MINUTE', jscstart);
    ELSE
        runafter := date_trunc('MINUTE', (now() + '1 Minute'::interval));
    END IF;

    --
    -- Enter a loop, generating next run timestamps until we find one
    -- that falls on the required weekday, and is not matched by an exception
    --

    WHILE bingo = FALSE LOOP

        --
        -- Get the next run year
        --
        nextyear := date_part('YEAR', runafter);

        --
        -- Get the next run month
        --
        nextmonth := date_part('MONTH', runafter);
        gotit := FALSE;
        FOR i IN (nextmonth) .. 12 LOOP
            IF jscmonths[i] = TRUE THEN
                nextmonth := i;
                gotit := TRUE;
                foundval := TRUE;
                EXIT;
            END IF;
        END LOOP;
        IF gotit = FALSE THEN
            FOR i IN 1 .. (nextmonth - 1) LOOP
                IF jscmonths[i] = TRUE THEN
                    nextmonth := i;

                    -- Wrap into next year
                    nextyear := nextyear + 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
           END LOOP;
        END IF;

        --
        -- Get the next run day
        --
        -- If the year, or month have incremented, get the lowest day,
        -- otherwise look for the next day matching or after today.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter)) THEN
            nextday := 1;
            FOR i IN 1 .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextday := date_part('DAY', runafter);
            gotit := FALSE;
            FOR i IN nextday .. 32 LOOP
                IF jscmonthdays[i] = TRUE THEN
                    nextday := i;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. (nextday - 1) LOOP
                    IF jscmonthdays[i] = TRUE THEN
                        nextday := i;

                        -- Wrap into next month
                        IF nextmonth = 12 THEN
                            nextyear := nextyear + 1;
                            nextmonth := 1;
                        ELSE
                            nextmonth := nextmonth + 1;
                        END IF;
                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Was the last day flag selected?
        IF nextday = 32 THEN
            IF nextmonth = 1 THEN
                nextday := 31;
            ELSIF nextmonth = 2 THEN
                IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                    nextday := 29;
                ELSE
                    nextday := 28;
                END IF;
            ELSIF nextmonth = 3 THEN
                nextday := 31;
            ELSIF nextmonth = 4 THEN
                nextday := 30;
            ELSIF nextmonth = 5 THEN
                nextday := 31;
            ELSIF nextmonth = 6 THEN
                nextday := 30;
            ELSIF nextmonth = 7 THEN
                nextday := 31;
            ELSIF nextmonth = 8 THEN
                nextday := 31;
            ELSIF nextmonth = 9 THEN
                nextday := 30;
            ELSIF nextmonth = 10 THEN
                nextday := 31;
            ELSIF nextmonth = 11 THEN
                nextday := 30;
            ELSIF nextmonth = 12 THEN
                nextday := 31;
            END IF;
        END IF;

        --
        -- Get the next run hour
        --
        -- If the year, month or day have incremented, get the lowest hour,
        -- otherwise look for the next hour matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR daytweak = TRUE) THEN
            nexthour := 0;
            FOR i IN 1 .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nexthour := date_part('HOUR', runafter);
            gotit := FALSE;
            FOR i IN (nexthour + 1) .. 24 LOOP
                IF jschours[i] = TRUE THEN
                    nexthour := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nexthour LOOP
                    IF jschours[i] = TRUE THEN
                        nexthour := i - 1;

                        -- Wrap into next month
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nextday = d THEN
                            nextday := 1;
                            IF nextmonth = 12 THEN
                                nextyear := nextyear + 1;
                                nextmonth := 1;
                            ELSE
                                nextmonth := nextmonth + 1;
                            END IF;
                        ELSE
                            nextday := nextday + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        --
        -- Get the next run minute
        --
        -- If the year, month day or hour have incremented, get the lowest minute,
        -- otherwise look for the next minute matching or after the current one.
        IF (nextyear > date_part('YEAR', runafter) OR nextmonth > date_part('MONTH', runafter) OR nextday > date_part('DAY', runafter) OR nexthour > date_part('HOUR', runafter) OR daytweak = TRUE) THEN
            nextminute := 0;
            IF minutetweak = TRUE THEN
        d := 1;
            ELSE
        d := date_part('YEAR', runafter)::int2;
            END IF;
            FOR i IN d .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            nextminute := date_part('MINUTE', runafter);
            gotit := FALSE;
            FOR i IN (nextminute + 1) .. 60 LOOP
                IF jscminutes[i] = TRUE THEN
                    nextminute := i - 1;
                    gotit := TRUE;
                    foundval := TRUE;
                    EXIT;
                END IF;
            END LOOP;
            IF gotit = FALSE THEN
                FOR i IN 1 .. nextminute LOOP
                    IF jscminutes[i] = TRUE THEN
                        nextminute := i - 1;

                        -- Wrap into next hour
                        IF (nextmonth = 1 OR nextmonth = 3 OR nextmonth = 5 OR nextmonth = 7 OR nextmonth = 8 OR nextmonth = 10 OR nextmonth = 12) THEN
                            d = 31;
                        ELSIF (nextmonth = 4 OR nextmonth = 6 OR nextmonth = 9 OR nextmonth = 11) THEN
                            d = 30;
                        ELSE
                            IF pgagent.pga_is_leap_year(nextyear) = TRUE THEN
                                d := 29;
                            ELSE
                                d := 28;
                            END IF;
                        END IF;

                        IF nexthour = 23 THEN
                            nexthour = 0;
                            IF nextday = d THEN
                                nextday := 1;
                                IF nextmonth = 12 THEN
                                    nextyear := nextyear + 1;
                                    nextmonth := 1;
                                ELSE
                                    nextmonth := nextmonth + 1;
                                END IF;
                            ELSE
                                nextday := nextday + 1;
                            END IF;
                        ELSE
                            nexthour := nexthour + 1;
                        END IF;

                        gotit := TRUE;
                        foundval := TRUE;
                        EXIT;
                    END IF;
                END LOOP;
            END IF;
        END IF;

        -- Build the result, and check it is not the same as runafter - this may
        -- happen if all array entries are set to false. In this case, add a minute.

        nextrun := (nextyear::varchar || '-'::varchar || nextmonth::varchar || '-' || nextday::varchar || ' ' || nexthour::varchar || ':' || nextminute::varchar)::timestamptz;

        IF nextrun = runafter AND foundval = FALSE THEN
                nextrun := nextrun + INTERVAL '1 Minute';
        END IF;

        -- If the result is past the end date, exit.
        IF nextrun > jscend THEN
            RETURN NULL;
        END IF;

        -- Check to ensure that the nextrun time is actually still valid. Its
        -- possible that wrapped values may have carried the nextrun onto an
        -- invalid time or date.
        IF ((jscminutes = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscminutes[date_part('MINUTE', nextrun) + 1] = TRUE) AND
            (jschours = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jschours[date_part('HOUR', nextrun) + 1] = TRUE) AND
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonthdays[date_part('DAY', nextrun)] = TRUE OR
            (jscmonthdays = '{f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,t}' AND
             ((date_part('MONTH', nextrun) IN (1,3,5,7,8,10,12) AND date_part('DAY', nextrun) = 31) OR
              (date_part('MONTH', nextrun) IN (4,6,9,11) AND date_part('DAY', nextrun) = 30) OR
              (date_part('MONTH', nextrun) = 2 AND ((pgagent.pga_is_leap_year(date_part('DAY', nextrun)::int2) AND date_part('DAY', nextrun) = 29) OR date_part('DAY', nextrun) = 28))))) AND
            (jscmonths = '{f,f,f,f,f,f,f,f,f,f,f,f}' OR jscmonths[date_part('MONTH', nextrun)] = TRUE)) THEN


            -- Now, check to see if the nextrun time found is a) on an acceptable
            -- weekday, and b) not matched by an exception. If not, set
            -- runafter = nextrun and try again.

            -- Check for a wildcard weekday
            gotit := FALSE;
            FOR i IN 1 .. 7 LOOP
                IF jscweekdays[i] = TRUE THEN
                    gotit := TRUE;
                    EXIT;
                END IF;
            END LOOP;

            -- OK, is the correct weekday selected, or a wildcard?
            IF (jscweekdays[date_part('DOW', nextrun) + 1] = TRUE OR gotit = FALSE) THEN

                -- Check for exceptions
                SELECT INTO d jexid FROM pgagent.pga_exception WHERE jexscid = jscid AND ((jexdate = nextrun::date AND jextime = nextrun::time) OR (jexdate = nextrun::date AND jextime IS NULL) OR (jexdate IS NULL AND jextime = nextrun::time));
                IF FOUND THEN
                    -- Nuts - found an exception. Increment the time and try again
                    runafter := nextrun + INTERVAL '1 Minute';
                    bingo := FALSE;
                    minutetweak := TRUE;
            daytweak := FALSE;
                ELSE
                    bingo := TRUE;
                END IF;
            ELSE
                -- We're on the wrong week day - increment a day and try again.
                runafter := nextrun + INTERVAL '1 Day';
                bingo := FALSE;
                minutetweak := FALSE;
                daytweak := TRUE;
            END IF;

        ELSE
            runafter := nextrun + INTERVAL '1 Minute';
            bingo := FALSE;
            minutetweak := TRUE;
        daytweak := FALSE;
        END IF;

    END LOOP;

    RETURN nextrun;
END;
$_$;",conscripts.bak
"CREATE FUNCTION pgagent.pgagent_schema_version() RETURNS smallint
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- RETURNS PGAGENT MAJOR VERSION
    -- WE WILL CHANGE THE MAJOR VERSION, ONLY IF THERE IS A SCHEMA CHANGE
    RETURN 3;
END;
$$;",conscripts.bak
"CREATE FUNCTION pgagent_schema_version() RETURNS smallint
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- RETURNS PGAGENT MAJOR VERSION
    -- WE WILL CHANGE THE MAJOR VERSION, ONLY IF THERE IS A SCHEMA CHANGE
    RETURN 3;
END;
$$;",export_postgress.sql
"CREATE FUNCTION ploomap_ratiodisc_width(ep_min integer, ep_max integer, seuil real, query character varying) RETURNS SETOF ploomap_ratiodisc_row
    LANGUAGE plpgsql
    AS $$
DECLARE
  r ploomap_ratiodisc_row;
  o ploomap_ratiodisc_row;
  ref refcursor;
  vmin float(8);
  vmax float(8);
  count integer := 0;
  keepf float(8);
  keep integer;
  q varchar;
BEGIN
 EXECUTE 'SELECT COUNT(*) FROM (' || query || ') AS a' INTO count;
 keep := round(count * seuil);
 q := query || ' ORDER BY data DESC LIMIT ' || keep;
 -- we get the count, min and max
 OPEN ref FOR EXECUTE q;
 LOOP
  FETCH ref INTO r;
  EXIT WHEN r IS NULL;
  IF vmin IS NULL OR r.data < vmin THEN
   vmin := r.data;
  END IF;
  IF vmax IS NULL OR r.data > vmax THEN
   vmax := r.data;
  END IF;
 END LOOP;
 CLOSE ref;
 -- we make the final data
 OPEN ref FOR EXECUTE q;
 LOOP
  FETCH ref INTO r;
  EXIT WHEN r IS NULL;
  o := r;
  o.data = round((o.data - vmin) * (ep_max - ep_min) / (vmax - vmin) + ep_min);
  IF o.data IS NOT NULL THEN
    RETURN NEXT o;
  END IF;
 END LOOP;
 CLOSE ref;
 RETURN;
END;
$$;",database.sql
"CREATE FUNCTION plusone(integer) RETURNS integer AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;",gporca.out
"CREATE FUNCTION plusone(integer) RETURNS integer AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;",gporca_optimizer.out
"CREATE FUNCTION plusone(numeric) RETURNS numeric AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;",gporca.out
"CREATE FUNCTION plusone(numeric) RETURNS numeric AS $$
BEGIN
    SELECT $1 + 1;
END;
$$ LANGUAGE plpgsql volatile;",gporca_optimizer.out
"CREATE FUNCTION pointfrombearinganddistance(dstarte double precision, dstartn double precision, dbearing double precision, ddistance double precision, ""precision"" integer, srid integer) RETURNS geometry
    LANGUAGE plpgsql
    AS $$
  DECLARE
      dangle1    double precision;
      dangle1rad double precision;
      ddeltan    double precision;
      ddeltae    double precision;
      dende      double precision;
      dendn      double precision;
      ""precision"" int;
      srid int;
BEGIN
    precision := CASE WHEN precision IS NULL THEN 3 ELSE precision END;
    srid := CASE WHEN srid IS NULL THEN 4326 ELSE srid END;
  BEGIN
    IF
      dstarte   IS NULL OR
      dstartn   IS NULL OR
      dbearing  IS NULL OR
      ddistance IS NULL
    THEN RETURN NULL;
    END IF;
    IF dbearing < 90
    THEN
      dangle1    := 90 - dbearing;
      dangle1rad := dangle1 * PI() / 180;
      ddeltae    := Cos(dangle1rad) * ddistance;
      ddeltan    := Sin(dangle1rad) * ddistance;
    END if;
    IF dbearing < 180
    THEN
      dangle1    := dbearing - 90;
      dangle1rad := dangle1 * PI() / 180;
      ddeltae    := Cos(dangle1rad) * ddistance;
      ddeltan    := Sin(dangle1rad) * ddistance * -1;
    END if;
    IF dbearing < 270
    THEN
      dangle1    := 270 - dbearing;
      dangle1rad := dangle1 * PI() / 180;
      ddeltae    := Cos(dangle1rad) * ddistance * -1;
      ddeltan    := Sin(dangle1rad) * ddistance * -1;
    END if;
    IF dbearing <= 360
    THEN
      dangle1    := dbearing - 270;
      dangle1rad := dangle1 * PI() / 180;
      ddeltae    := Cos(dangle1rad) * ddistance * -1;
      ddeltan    := Sin(dangle1rad) * ddistance;
    END IF;
    dende := ddeltae + dstarte;
    dendn := ddeltan + dstartn;
    RETURN ST_SetSRID(ST_MakePoint(round(dende::numeric, precision), round(dendn::numeric, precision)), :CRS);
  END;
END;
$$;",database_setup.sql
"CREATE FUNCTION populate() RETURNS integer AS $$
DECLARE
    -- declarations
BEGIN
    PERFORM my_function();
END;
$$ LANGUAGE plpgsql;",parse.rs
"CREATE FUNCTION populateclientstable() RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
DROP TABLE IF EXISTS Clients; 
CREATE TABLE Clients as SELECT DISTINCT b_column as UUID from mastercsv;
ALTER TABLE clients add  CONSTRAINT client_pk PRIMARY KEY (UUID); 
    RETURN 1;
    END;
    $$;",data.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	jtsver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_jts_version() INTO jtsver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  jtsver IS NOT NULL THEN
		fullver = fullver || ' JTS=""' || jtsver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$
    LANGUAGE plpgsql IMMUTABLE;",dbsetup.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	jtsver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_jts_version() INTO jtsver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  jtsver IS NOT NULL THEN
		fullver = fullver || ' JTS=""' || jtsver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$
    LANGUAGE plpgsql IMMUTABLE;",xenia_all.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",database.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",fearth_db.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",nlp.dump
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",postgres.sql.txt
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",schema.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",snow_db_postgres.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",streetking-database.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	libxmlver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (procs from ' || dbproc || ' need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",vkdb-schema.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	fullver = fullver || ' DBPROC=""' || dbproc || '""';
	fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (needs proc upgrade)';
	END IF;

	RETURN fullver;
END
$$;",crezoo_20110121
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	projver text;
	geosver text;
	usestats bool;
	dbproc text;
	relproc text;
	fullver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_uses_stats() INTO usestats;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;

	fullver = 'POSTGIS=""' || libver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF usestats THEN
		fullver = fullver || ' USE_STATS';
	END IF;

	fullver = fullver || ' DBPROC=""' || dbproc || '""';
	fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (needs proc upgrade)';
	END IF;

	RETURN fullver;
END
$$;",tgdb_local_20100705_00_schema.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	svnver text;
	projver text;
	geosver text;
	gdalver text;
	libxmlver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text;
	rast_scr_ver text;
	topo_scr_ver text;
	json_lib_ver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libjson_version() INTO json_lib_ver;
	BEGIN
		SELECT postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			gdalver := NULL;
			RAISE NOTICE 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;
	select postgis_svn_version() INTO svnver;
	BEGIN
		SELECT postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			topo_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_lib_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	fullver = 'POSTGIS=""' || libver;

	IF  svnver IS NOT NULL THEN
		fullver = fullver || ' r' || svnver;
	END IF;

	fullver = fullver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL=""' || gdalver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON=""' || json_lib_ver || '""';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from ""' || dbproc || '"" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from ""' || topo_scr_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from ""' || rast_lib_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from ""' || rast_scr_ver || '"" need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",hr_database.pgsql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	svnver text;
	projver text;
	geosver text;
	gdalver text;
	libxmlver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text;
	rast_scr_ver text;
	topo_scr_ver text;
	json_lib_ver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libjson_version() INTO json_lib_ver;
	BEGIN
		SELECT postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			gdalver := NULL;
			RAISE NOTICE 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;
	select postgis_svn_version() INTO svnver;
	BEGIN
		SELECT postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			topo_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_lib_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	fullver = 'POSTGIS=""' || libver;

	IF  svnver IS NOT NULL THEN
		fullver = fullver || ' r' || svnver;
	END IF;

	fullver = fullver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL=""' || gdalver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON=""' || json_lib_ver || '""';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from ""' || dbproc || '"" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from ""' || topo_scr_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from ""' || rast_lib_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from ""' || rast_scr_ver || '"" need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",pgex_backup.sql
"CREATE FUNCTION postgis_full_version() RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $$
DECLARE
	libver text;
	svnver text;
	projver text;
	geosver text;
	gdalver text;
	libxmlver text;
	dbproc text;
	relproc text;
	fullver text;
	rast_lib_ver text;
	rast_scr_ver text;
	topo_scr_ver text;
	json_lib_ver text;
BEGIN
	SELECT postgis_lib_version() INTO libver;
	SELECT postgis_proj_version() INTO projver;
	SELECT postgis_geos_version() INTO geosver;
	SELECT postgis_libjson_version() INTO json_lib_ver;
	BEGIN
		SELECT postgis_gdal_version() INTO gdalver;
	EXCEPTION
		WHEN undefined_function THEN
			gdalver := NULL;
			RAISE NOTICE 'Function postgis_gdal_version() not found.  Is raster support enabled and rtpostgis.sql installed?';
	END;
	SELECT postgis_libxml_version() INTO libxmlver;
	SELECT postgis_scripts_installed() INTO dbproc;
	SELECT postgis_scripts_released() INTO relproc;
	select postgis_svn_version() INTO svnver;
	BEGIN
		SELECT postgis_topology_scripts_installed() INTO topo_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			topo_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_topology_scripts_installed() not found. Is topology support enabled and topology.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_scripts_installed() INTO rast_scr_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_scr_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_scripts_installed() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	BEGIN
		SELECT postgis_raster_lib_version() INTO rast_lib_ver;
	EXCEPTION
		WHEN undefined_function THEN
			rast_lib_ver := NULL;
			RAISE NOTICE 'Function postgis_raster_lib_version() not found. Is raster support enabled and rtpostgis.sql installed?';
	END;

	fullver = 'POSTGIS=""' || libver;

	IF  svnver IS NOT NULL THEN
		fullver = fullver || ' r' || svnver;
	END IF;

	fullver = fullver || '""';

	IF  geosver IS NOT NULL THEN
		fullver = fullver || ' GEOS=""' || geosver || '""';
	END IF;

	IF  projver IS NOT NULL THEN
		fullver = fullver || ' PROJ=""' || projver || '""';
	END IF;

	IF  gdalver IS NOT NULL THEN
		fullver = fullver || ' GDAL=""' || gdalver || '""';
	END IF;

	IF  libxmlver IS NOT NULL THEN
		fullver = fullver || ' LIBXML=""' || libxmlver || '""';
	END IF;

	IF json_lib_ver IS NOT NULL THEN
		fullver = fullver || ' LIBJSON=""' || json_lib_ver || '""';
	END IF;

	-- fullver = fullver || ' DBPROC=""' || dbproc || '""';
	-- fullver = fullver || ' RELPROC=""' || relproc || '""';

	IF dbproc != relproc THEN
		fullver = fullver || ' (core procs from ""' || dbproc || '"" need upgrade)';
	END IF;

	IF topo_scr_ver IS NOT NULL THEN
		fullver = fullver || ' TOPOLOGY';
		IF topo_scr_ver != relproc THEN
			fullver = fullver || ' (topology procs from ""' || topo_scr_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_lib_ver IS NOT NULL THEN
		fullver = fullver || ' RASTER';
		IF rast_lib_ver != relproc THEN
			fullver = fullver || ' (raster lib from ""' || rast_lib_ver || '"" need upgrade)';
		END IF;
	END IF;

	IF rast_scr_ver IS NOT NULL AND rast_scr_ver != relproc THEN
		fullver = fullver || ' (raster procs from ""' || rast_scr_ver || '"" need upgrade)';
	END IF;

	RETURN fullver;
END
$$;",sqlex_backup.pgsql
"CREATE FUNCTION postgres_fdw_abs(int) RETURNS int AS $$
BEGIN
RETURN abs($1);
END
$$ LANGUAGE plpgsql IMMUTABLE;",postgres_fdw.out
"CREATE FUNCTION postgres_fdw_abs(int) RETURNS int AS $$
BEGIN
RETURN abs($1);
END
$$ LANGUAGE plpgsql IMMUTABLE;",sqlite_fdw_post.out
"CREATE FUNCTION precio_cot_odc_art(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
 resultado integer;
 precio_linea integer;
 DECLARE reg RECORD;
 DECLARE reg2 RECORD;
BEGIN
FOR reg IN SELECT art_cod, art_cant, art_desc FROM det_cot_odc_art WHERE doc_cod = $1 LOOP
FOR reg2 IN SELECT art_precio FROM articulo WHERE art_cod = reg.art_cod LOOP
 precio_linea = (reg.art_cant * reg2.art_precio)- ((reg.art_cant * reg2.art_precio)* reg.art_desc)/100;
END LOOP;
resultado = resultado + precio_linea;
END LOOP;
 RETURN resultado;
END;
$_$;",serviventas.sql
"CREATE FUNCTION prepare_verify(text DEFAULT ''::text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
	declare
		license text;
	BEGIN
		create temp table temp1 as
			select $1;
		copy (select * from temp1) to '/tmp/prep_ver'; -- to '/tmp/prep_ver\';
		drop table temp1;
	END;
$_$;",baza.sql
"CREATE FUNCTION prettyprintxml(con xml) RETURNS text
    LANGUAGE plpgsql STABLE STRICT
    SET search_path TO public, gsc_db
    AS $$

  DECLARE
    xmlc text;
    r RECORD;
    res text := '';
  BEGIN
   xmlc := XMLSERIALIZE ( CONTENT con AS text );

   FOR r IN select regexp_replace(xmlc, E'(<[^>]*>)', E'\\1\n','gi') as part LOOP
     res := res || r.part;
   END LOOP;



     return res;
  END;
$$;",test.sql
"CREATE FUNCTION prev_year() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare previous integer;
begin
	previous := cast(extract(year from current_date - interval '1 year') as integer);
	return previous;
end;
$$;",heartbeat.backup
"CREATE FUNCTION primal_to_buyable(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'BUYABLE'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION producible_to_assembly(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'ASSEMBLY'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION producible_to_part(__material material_specification) RETURNS component_specification
    LANGUAGE plpgsql
    AS $$
BEGIN

  RETURN (
    __material.part_code,
    __material.version_num,
    __material.quantity,
    __material.uom_code,
    'PART'::common.component_kind
  )::common.component_specification;

END;
$$;",mes-idea.sql
"CREATE FUNCTION project_permission_group(project_id integer, group_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE
	permission_rec RECORD;
	position1_rec RECORD; 
	position4_rec RECORD;   
	position5_rec RECORD;         
BEGIN
	FOR permission_rec IN SELECT CAST(permission::BIT(7) AS TEXT) AS permission FROM core_project_permissions WHERE core_project_permissions.project_id = $1 AND core_project_permissions.group_id = $2
LOOP

	SELECT INTO position1_rec SUBSTRING(permission_rec.permission FROM 1 FOR 1) AS resultchar;
	SELECT INTO position4_rec SUBSTRING(permission_rec.permission FROM 4 FOR 1) AS resultchar;
	SELECT INTO position5_rec SUBSTRING(permission_rec.permission FROM 5 FOR 1) AS resultchar;

IF position1_rec.resultchar = '1' THEN
	RETURN TRUE;
ELSE

	IF position4_rec.resultchar = '1' THEN
		RETURN TRUE;
	ELSE

		IF position5_rec.resultchar = '1' THEN
			RETURN TRUE;
		END IF;

	END IF;

END IF;
END LOOP;
RETURN FALSE;
END;$_$;",open-lims.sql
"CREATE FUNCTION project_permission_organisation_unit(project_id integer, organisation_unit_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE
	permission_rec RECORD;
	position1_rec RECORD; 
	position4_rec RECORD;   
	position5_rec RECORD;         
BEGIN
	FOR permission_rec IN SELECT CAST(permission::BIT(7) AS TEXT) AS permission FROM core_project_permissions WHERE core_project_permissions.project_id = $1 AND core_project_permissions.organisation_unit_id = $2
LOOP

	SELECT INTO position1_rec SUBSTRING(permission_rec.permission FROM 1 FOR 1) AS resultchar;
	SELECT INTO position4_rec SUBSTRING(permission_rec.permission FROM 4 FOR 1) AS resultchar;
	SELECT INTO position5_rec SUBSTRING(permission_rec.permission FROM 5 FOR 1) AS resultchar;

IF position1_rec.resultchar = '1' THEN
	RETURN TRUE;
ELSE

	IF position4_rec.resultchar = '1' THEN
		RETURN TRUE;
	ELSE

		IF position5_rec.resultchar = '1' THEN
			RETURN TRUE;
		END IF;

	END IF;

END IF;
END LOOP;
RETURN FALSE;
END;$_$;",open-lims.sql
"CREATE FUNCTION project_permission_user(project_id integer, user_id integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE
	permission_rec RECORD;
	position1_rec RECORD; 
	position4_rec RECORD;   
	position5_rec RECORD;         
BEGIN
	FOR permission_rec IN SELECT CAST(permission::BIT(7) AS TEXT) AS permission FROM core_project_permissions WHERE core_project_permissions.project_id = $1 AND core_project_permissions.user_id = $2
LOOP

	SELECT INTO position1_rec SUBSTRING(permission_rec.permission FROM 1 FOR 1) AS resultchar;
	SELECT INTO position4_rec SUBSTRING(permission_rec.permission FROM 4 FOR 1) AS resultchar;
	SELECT INTO position5_rec SUBSTRING(permission_rec.permission FROM 5 FOR 1) AS resultchar;

IF position1_rec.resultchar = '1' THEN
	RETURN TRUE;
ELSE

	IF position4_rec.resultchar = '1' THEN
		RETURN TRUE;
	ELSE

		IF position5_rec.resultchar = '1' THEN
			RETURN TRUE;
		END IF;

	END IF;

END IF;
END LOOP;
RETURN FALSE;
END;$_$;",open-lims.sql
"CREATE FUNCTION prs_person_kind(OUT ""UNDEFINED"" smallint, OUT ""INDIVIDUAL"" smallint, OUT ""LEGAL"" smallint) RETURNS record
    LANGUAGE plpgsql IMMUTABLE COST 1
    AS $$
begin
  -- возвращает константные значения типа персоны (физ./юр. лицо)
  ""UNDEFINED"" := 0; -- не указано
  ""INDIVIDUAL"" := 1; -- физическое лицо
  ""LEGAL"" := 2; -- юридическое лицо
  return;
end;
$$;",metadict.sql
"CREATE FUNCTION prueba(tiempo interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare minutos integer;
begin
	
	
	minutos = (select (extract('epoch' from tiempo)/60)::integer);
	return minutos;
end;
$$;",VTz-8rcK_modelosigedoc
"CREATE FUNCTION prueba(tiempo interval) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare minutos integer;
begin
	
	
	minutos = (select (extract('epoch' from tiempo)/60)::integer);
	return minutos;
end;
$$;",VvBq-zuB_modelosigedoc
"CREATE FUNCTION public._calc_interval(start_ timestamp without time zone, end_ character varying) RETURNS timestamp without time zone
    LANGUAGE plpgsql STABLE
    AS $$
BEGIN
    return (
       SELECT start_ + end_::interval
    )::timestamp;
END;
$$;",dump.sql
"CREATE FUNCTION public.acs_datatype__date_output_function(p_attribute_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return 'to_char(' || p_attribute_name || ', ''YYYY-MM-DD'')';
END;
$$;",pgdumpall.txt.sql
"CREATE FUNCTION public.acs_datatype__timestamp_output_function(p_attribute_name text) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
BEGIN
  return 'to_char(' || p_attribute_name || ', ''YYYY-MM-DD HH24:MI:SS'')';
END;
$$;",pgdumpall.txt.sql
"CREATE FUNCTION public.aux_referee(bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return (
    select applicant
    from matches
    left outer join refereecandidatures r on matches.id = r.match
    where id = $1 and confirmed notnull 
  );
END;
$_$;",pgbak.sql
"CREATE FUNCTION public.bot_average(n integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
avg real;
total real;
BEGIN
SELECT AVG(price) INTO avg FROM (SELECT price FROM menu_items ORDER BY price ASC LIMIT n) AS p;
RETURN avg;
END;
$$;",output
"CREATE FUNCTION public.branch_find_all() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select su.id,
  su.name,
  su.family,
  su.e_mail,
  su.password,
  b.id     as b_id,
  b.name   as b_name,
  b.adress as b_adress,
  s.id     as s_id,
  s.name   as s_name
from system_users su,
  branches b,
  subdivisions s
where su.branch_id = b.id
      and su.subdivision_id = s.id;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.calculate_distance(lat1 double precision, lon1 double precision, lat2 double precision, lon2 double precision, units character varying) RETURNS double precision
    LANGUAGE plpgsql
    AS $$

    DECLARE

        dist float = 0;

        radlat1 float;

        radlat2 float;

        theta float;

        radtheta float;

    BEGIN

        IF lat1 = lat2 OR lon1 = lon2

            THEN RETURN dist;

        ELSE

            radlat1 = pi() * lat1 / 180;

            radlat2 = pi() * lat2 / 180;

            theta = lon1 - lon2;

            radtheta = pi() * theta / 180;

            dist = sin(radlat1) * sin(radlat2) + cos(radlat1) * cos(radlat2) * cos(radtheta);



            IF dist > 1 THEN dist = 1; END IF;



            dist = acos(dist);

            dist = dist * 180 / pi();

            dist = dist * 60 * 1.1515;



            IF units = 'K' THEN dist = dist * 1.609344; END IF;

            IF units = 'N' THEN dist = dist * 0.8684; END IF;



            RETURN dist;

        END IF;

    END;

$$;",dump-postgres.sql
"CREATE FUNCTION public.calculo_total(fecha_f date, fecha_i date, cantidad integer, total integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

    DIFERENCIA INT := 0;

    SUMADOR INT := 0;

BEGIN

    SELECT DATE_PART('day',AGE(FECHA_F,FECHA_I)) INTO DIFERENCIA;

    SUMADOR := (TOTAL*CAST(DIFERENCIA AS INT));

    RETURN SUMADOR;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.cargos_de_una_persona(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
    reg RECORD;
    cargos text;
BEGIN
    FOR REG IN (SELECT  
						
	coalesce(upper(tipo), ' ') || coalesce(' '||(case when  tipo_cargo.descripcion is null then tipo_hora.descripcion else tipo_cargo.descripcion end) ,' ') || coalesce(': '||cantidad_horas::text, ' ') as sabor,
	(case when historico = true then 'SI' else 'NO' end) as historico ,
	tipo
	FROM 
	cargo_por_persona
	inner join persona using(idpersona)
	left outer join tipo_cargo  using(idtipo_cargo)
	left outer join tipo_hora  using(idtipo_hora)

	WHERE
	historico = false and
	activo = true and
	cargo_por_persona.idpersona =$1
	order by 
		bloque,
		activo desc,
		apellido, nombres,
		fecha_inicio,
		cargo_por_persona.idtipo_hora) LOOP
	cargos:=  coalesce(cargos,'') ||coalesce(reg.sabor,'') ||coalesce(' | ','');
       
    END LOOP;
   RETURN cargos;
END
$_$;",sicd_public.sql
"CREATE FUNCTION public.certcredits(certkey integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN (
	SELECT SUM(credits) 
	FROM course c
	INNER JOIN certificatecourse cc
	ON c.coursekey=cc.coursekey
	INNER JOIN certificate cert 
	ON cc.certificatekey=cert.certificatekey
	WHERE cert.certificatekey=certkey
);
END;
$$;",TechCertificate.sql
"CREATE FUNCTION public.certcredits(certkey integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN (
	SELECT SUM(credits) 
	FROM course c
	INNER JOIN certificatecourse cc
	ON c.coursekey=cc.coursekey
	INNER JOIN certificate cert 
	ON cc.certificatekey=cert.certificatekey
	WHERE cert.certificatekey=certkey
);
END;
$$;",all.sql
"CREATE FUNCTION public.check_cantidad_carrito(codigo integer, codigo_s integer, rut_u integer, empresa_h integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

    CANTIDAD_CARRO INT;

BEGIN

    SELECT CANTIDAD INTO CANTIDAD_CARRO FROM CARRITO 

    WHERE COD_HERRAMIENTA=CODIGO

    AND COD_SUCURSAL = CODIGO_S

    AND RUT = RUT_U

    AND EMPRESA = EMPRESA_H;

    RETURN CANTIDAD_CARRO;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN -1;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.check_date(id character varying, begining date, ending date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare exists integer;
begin
select count(""invoice_number"") into exists
from invoice natural join ticket natural join did_work
where invoice.invoice_number = id and
did_work.end_time >= begining and 
did_work.end_time <= ending;
return exists; end; $$;",plumbingdb_backup
"CREATE FUNCTION public.check_fecha_final(finicio date, ffinal date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

BEGIN

    IF FFINAL>FINICIO THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.check_user_project(uname text, project text) RETURNS TABLE(check_user_project text, role text)
    LANGUAGE plpgsql COST 1
    AS $_$
declare projid integer;
declare groupid integer;
declare clientid integer;
declare is_public boolean;
declare role text;
begin
projid:=0;
role:=null;
select p.id,public,project_group_id,g.client_id from projects p,project_groups g where p.project_group_id = g.id and p.name=$2 into projid,is_public,groupid,clientid;

--RAISE NOTICE '%', projid;
if projid=0 OR projid IS NULL then
	RETURN QUERY SELECT 'TR.noProject'::text,role;
else
	if lower($1) = 'guest' then
			if is_public = true then RETURN QUERY SELECT 'OK'::text,'public'::text;
			else RETURN QUERY SELECT 'TR.noPublicAccess'::text,role; 
			end if;
	else
			--first check if user is (client) administrator
			select roles.name 
			from users,users_roles,roles 
			where users.user_id=users_roles.user_id AND users_roles.role_id=roles.id AND roles.name='admin' AND
			user_name=$1 and  ((client_id is null and project_group_id is null) or (client_id=clientid and project_group_id is null)) INTO role;
			if role > '' then
				--RAISE NOTICE 'admin, proj:%, client:%', projid, clientid;
				RETURN QUERY SELECT 'OK'::text, role;
			else
				select roles.name 
				from users,users_roles,roles 
				where users.user_id=users_roles.user_id AND users_roles.role_id=roles.id AND 
				user_name=$1 and project_group_id=groupid INTO role;
				if role > '' then
					--RAISE NOTICE 'user, group:%, client:%', groupid, clientid;
					RETURN QUERY SELECT 'OK'::text, role;
				else
					if is_public = true then RETURN QUERY SELECT 'OK'::text,'public'::text;
					else RETURN QUERY SELECT 'TR.noPermission'::text, role;
					end if;
				end if;
			end if;
	end if;
end if;
end;
$_$;",setup_v21.sql
"CREATE FUNCTION public.checkadmin(rut_u integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE 

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM ADMINISTRADOR WHERE RUT=RUT_U;

    IF(CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkcarrito(codigo integer, codigo_s integer, rut_u integer, empresa_h integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM CARRITO 

    WHERE COD_HERRAMIENTA=CODIGO

    AND COD_SUCURSAL = CODIGO_S

    AND RUT = RUT_U

    AND EMPRESA = EMPRESA_H;

    IF(CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkcategoria(codigo integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM CATEGORIA WHERE COD_CATEGORIA=CODIGO;

    IF(CONTADOR>0) THEN

        RETURN TRUE;

    ELSE 

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkempresa(codigo integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN 

    SELECT COUNT(*) INTO CONTADOR FROM EMPRESA WHERE COD_EMPRESA=CODIGO;

    IF (CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;    

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkherramienta(codigo integer, empresa_h integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM HERRAMIENTA 

    WHERE COD_HERRAMIENTA=CODIGO

    AND EMPRESA = EMPRESA_H;

    IF(CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkstock(codigo integer, codigo_s integer, empresa_h integer, comuna_h integer, fecha_i character varying, fecha_f character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

    CANTIDAD INT;

BEGIN    

    SELECT TEMPORAL.STOCK INTO CANTIDAD FROM

    (SELECT (SH.STOCK - SUM(D.CANTIDAD)) AS STOCK

    FROM HERRAMIENTA H JOIN CATEGORIA C 

    ON H.COD_CATEGORIA = C.COD_CATEGORIA

    JOIN SUCURSAL_HERRAMIENTA SH

    ON H.COD_HERRAMIENTA = SH.COD_HERRAMIENTA

    AND H.EMPRESA = SH.EMPRESA

    JOIN SUCURSAL SU

    ON SH.COD_SUCURSAL = SU.COD_SUCURSAL

    JOIN DETALLE D 

    ON D.COD_H = SH.COD_HERRAMIENTA

    AND D.EMPRESA = SH.EMPRESA

    AND D.COD_SUCURSAL = SH.COD_SUCURSAL

    JOIN EMPRESA E

    ON E.COD_EMPRESA = SU.COD_EMPRESA

    WHERE D.ID_A IN (SELECT A.COD_ARRIENDO FROM ARRIENDO A JOIN DETALLE D 

                                    ON A.COD_ARRIENDO = D.ID_A JOIN SUCURSAL_HERRAMIENTA H

                                    ON D.COD_H = H.COD_HERRAMIENTA

                                    AND D.EMPRESA = H.EMPRESA

                                    AND D.COD_SUCURSAL = H.COD_SUCURSAL

                                    WHERE A.FECHA_INICIO BETWEEN TO_DATE(FECHA_I,'DD/MM/YYYY') AND TO_DATE(FECHA_F,'DD/MM/YYYY')

                                    OR A.FECHA_FINAL BETWEEN TO_DATE(FECHA_I,'DD/MM/YYYY') AND TO_DATE(FECHA_F,'DD/MM/YYYY')

                                    AND H.COD_HERRAMIENTA = CODIGO

                                    GROUP BY A.COD_ARRIENDO)

    AND SU.COMUNA = COMUNA_H

    AND SH.COD_HERRAMIENTA = CODIGO

    AND SH.COD_SUCURSAL = CODIGO_S

    GROUP BY H.COD_HERRAMIENTA, H.NOMBRE, H.DESCRIPCION, H.URL_FOTO, SH.PRECIO, C.NOMBRE, H.EMPRESA, E.NOMBRE, SU.COD_SUCURSAL, SU.NOMBRE, SH.STOCK   

    UNION 

    SELECT SH.STOCK AS STOCK

    FROM HERRAMIENTA H JOIN CATEGORIA C 

    ON H.COD_CATEGORIA = C.COD_CATEGORIA

    JOIN SUCURSAL_HERRAMIENTA SH

    ON H.COD_HERRAMIENTA = SH.COD_HERRAMIENTA

    AND H.EMPRESA = SH.EMPRESA

    JOIN SUCURSAL SU

    ON SH.COD_SUCURSAL = SU.COD_SUCURSAL

    FULL OUTER JOIN DETALLE D 

    ON D.COD_H = SH.COD_HERRAMIENTA

    AND D.EMPRESA = SH.EMPRESA

    AND D.COD_SUCURSAL = SH.COD_SUCURSAL

    JOIN EMPRESA E

    ON E.COD_EMPRESA = SU.COD_EMPRESA

    WHERE (H.COD_HERRAMIENTA,SH.COD_SUCURSAL) NOT IN (SELECT H.COD_HERRAMIENTA,H.COD_SUCURSAL FROM ARRIENDO A JOIN DETALLE D 

                                ON A.COD_ARRIENDO = D.ID_A JOIN SUCURSAL_HERRAMIENTA H

                                ON D.COD_H = H.COD_HERRAMIENTA

                                AND D.EMPRESA = H.EMPRESA

                                AND D.COD_SUCURSAL = H.COD_SUCURSAL

                                WHERE A.FECHA_INICIO BETWEEN TO_DATE(FECHA_I,'DD/MM/YYYY') AND TO_DATE(FECHA_F,'DD/MM/YYYY')

                                OR A.FECHA_FINAL BETWEEN TO_DATE(FECHA_I,'DD/MM/YYYY') AND TO_DATE(FECHA_F,'DD/MM/YYYY')

                                AND H.COD_HERRAMIENTA = CODIGO)

    AND SU.COMUNA = COMUNA_H

    AND SH.COD_HERRAMIENTA = CODIGO

    AND SH.COD_SUCURSAL = CODIGO_S) AS TEMPORAL;

    RETURN CANTIDAD;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN            

            SELECT STOCK INTO CANTIDAD FROM SUCURSAL_HERRAMIENTA WHERE COD_HERRAMIENTA = CODIGO AND COD_SUCURSAL = CODIGO_S AND EMPRESA = EMPRESA_H;

            RETURN CANTIDAD;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checksucursal(codigo integer, empresa_s integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN 

    SELECT COUNT(*) INTO CONTADOR FROM SUCURSAL WHERE COD_SUCURSAL=CODIGO AND COD_EMPRESA = EMPRESA_S;

    IF (CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;    

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.checkuser(rut_u integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE 

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM USUARIO WHERE RUT=RUT_U;

    IF(CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.cleanup_for_search(s character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
      DECLARE
        new_s varchar :='';
      begin
        new_s = replace(s, '.',' ');
        new_s = replace(new_s, '&',' ');
        RETURN new_s;
      end
      $$;",Clean-05-09-2020-plain-sql.backup
"CREATE FUNCTION public.competitors(id bigint) RETURNS character varying[]
    LANGUAGE plpgsql
    AS $$
BEGIN
  return (
    select team
    from bdproject.matchcandidatures
    where match = id
    and confirmed notnull
  );
END;
$$;",pgbak.sql
"CREATE FUNCTION public.contar_cargos() RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	      where activo = true and
	      historico = false) ;
    
    RETURN total;
END;
$$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos(character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	      where activo = true and
		bloque = $1) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_por_bloque(character) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	      where 	idtipo_cargo is not null and
			activo = true and
			historico = false and
		bloque ='bloque2'and idpersona =1) ;
    
    RETURN total;
END;
$$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_por_bloque(character, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	      where 	idtipo_cargo is not null and
			activo = true and
			historico = false and
		bloque ilike $1 and idpersona =$2) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_segun_tipo(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
              WHERE	idtipo_cargo is not null and
			cargo_por_persona.idtipo_cargo  = $1 and
			activo = true  and
			historico = false) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_segun_tipo(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
              WHERE	idtipo_cargo is not null and
			cargo_por_persona.idtipo_cargo  = $1 and
			activo = true  and
			historico = false and
			idpersona = $2) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_segun_tipo_jerarquico(boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	inner join tipo_cargo on tipo_cargo.idtipo_cargo=cargo_por_persona.idtipo_cargo
              WHERE
  		tipo_cargo.jerarquico  =  $1 and
  		cargo_por_persona.activo = true  and
	      historico = false) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.contar_cargos_segun_tipo_jerarquico(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT count(idcargo_por_persona) as cantidad
	      FROM cargo_por_persona
	inner join tipo_cargo on tipo_cargo.idtipo_cargo=cargo_por_persona.idtipo_cargo
              WHERE	cargo_por_persona.idtipo_cargo is not null and
			tipo_cargo.jerarquico  =  true and
			cargo_por_persona.activo = true  and
			historico = false and
			idpersona = $1) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.controllo_mail(mail character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

BEGIN
	IF (EXISTS (SELECT *
		   FROM utente
		   WHERE email = mail))
	THEN RETURN TRUE;
	ELSE RETURN FALSE;
	END IF;
END;

$$;",db8.sql
"CREATE FUNCTION public.count_node(anyarray, node_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
                DECLARE
                  table_name text;
                  sel_count integer;
                  counter integer;
                BEGIN
                counter := 0;
                FOREACH table_name IN ARRAY $1
                LOOP
                  RAISE NOTICE 'processing table %',table_name;
                  EXECUTE format('
                 SELECT COUNT(*) FROM %I AS x
                    WHERE x.connection_node_start_id = %L
                    OR x.connection_node_end_id = %L'
                      , table_name, $2, $2)
                     INTO sel_count;
                  RAISE NOTICE 'counted % appearences of
                     connection_node_id % ', sel_count, $2;
                  counter := counter + sel_count;
                  IF counter > 1 THEN
                 EXIT;
                  END IF;
                END LOOP;
                RETURN counter;
                END
                $_$;",work_empty_schema_2020-01-15.sql
"CREATE FUNCTION public.cube(num integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN num * num * num;
END;
$$;",all.sql
"CREATE FUNCTION public.datediff(units character varying, start_t timestamp without time zone, end_t timestamp without time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $$
   DECLARE
     diff_interval INTERVAL; 
     diff INT = 0;
     years_diff INT = 0;
   BEGIN
     IF units IN ('yy', 'yyyy', 'year', 'mm', 'm', 'month') THEN
       years_diff = DATE_PART('year', end_t) - DATE_PART('year', start_t);
 
       IF units IN ('yy', 'yyyy', 'year') THEN
         -- SQL Server does not count full years passed (only difference between year parts)
         RETURN years_diff;
       ELSE
         -- If end month is less than start month it will subtracted
         RETURN years_diff * 12 + (DATE_PART('month', end_t) - DATE_PART('month', start_t)); 
       END IF;
     END IF;
 
     -- Minus operator returns interval 'DDD days HH:MI:SS'  
     diff_interval = end_t - start_t;
 
     diff = diff + DATE_PART('day', diff_interval);
 
     IF units IN ('wk', 'ww', 'week') THEN
       diff = diff/7;
       RETURN diff;
     END IF;
 
     IF units IN ('dd', 'd', 'day') THEN
       RETURN diff;
     END IF;
 
     diff = diff * 24 + DATE_PART('hour', diff_interval); 
 
     IF units IN ('hh', 'hour') THEN
        RETURN diff;
     END IF;
 
     diff = diff * 60 + DATE_PART('minute', diff_interval);
 
     IF units IN ('mi', 'n', 'minute') THEN
        RETURN diff;
     END IF;
 
     diff = diff * 60 + DATE_PART('second', diff_interval);
 
     RETURN diff;
   END;
   $$;",VBSchema.sql
"CREATE FUNCTION public.f_buscadatum_utm(long double precision, lat double precision) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    V_UTM_NORTE INTEGER[];
    V_UTM_SUL   INTEGER[];
    V_GOMO INTEGER;
BEGIN
    V_UTM_NORTE := ARRAY[32601, 32602, 32603, 32604, 32605, 32606, 32607, 32608, 32609, 32610, 32611, 32612, 32613, 
                         32614, 32615, 32616, 32617, 32618, 32619, 32620, 32621, 32622, 32623, 32624, 32625, 32626, 
                         32627, 32628, 32629, 32630, 32631, 32632, 32633, 32634, 32635, 32636, 32637, 32638, 32639, 
                         32640, 32641, 32642, 32643, 32644, 32645, 32646, 32647, 32648, 32649, 32650, 32651, 32652, 
                         32653, 32654, 32655, 32656, 32657, 32658, 32659, 32660];
                        
    V_UTM_SUL := ARRAY[32701, 32702, 32703, 32704, 32705, 32706, 32707, 32708, 32709, 32710, 32711, 32712, 32713, 
                       32714, 32715, 32716, 32717, 32718, 32719, 32720, 32721, 32722, 32723, 32724, 32725, 32726, 
                       32727, 32728, 32729, 32730, 32731, 32732, 32733, 32734, 32735, 32736, 32737, 32738, 32739, 
                       32740, 32741, 32742, 32743, 32744, 32745, 32746, 32747, 32748, 32749, 32750, 32751, 32752, 
                       32753, 32754, 32755, 32756, 32757, 32758, 32759, 32760];                 

    IF LONG >=0 THEN
      V_GOMO := 31 + TRUNC(ABS(LONG)/6);
    ELSE 
      V_GOMO := 31 - TRUNC(ABS(LONG)/6);
    END IF;
    RAISE NOTICE 'CODIGO:%', V_GOMO;

    IF LAT >= 0 THEN
       return V_UTM_NORTE[V_GOMO];
    ELSE 
       return V_UTM_SUL[V_GOMO];
    END IF;
END;
$$;",database_agdatabox-api.db
"CREATE FUNCTION public.f_interpolador_ponto_id(p_interpolacao integer, p_refinterpolacao text, p_grade text, p_expoente double precision, p_elementos integer, p_raio double precision, p_coluna text) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$
DECLARE
    Cur_Amostras   	 refcursor;
    V_Pontos   		 GEOMETRY;
    V_Distancia 	 FLOAT;
    V_Medida    	 FLOAT;
    V_Soma      	 FLOAT:=0;
    V_Numerador		 FLOAT:=0;
    V_Denominador	 FLOAT:=0;
    V_Estimado		 FLOAT:=0;
    i 			 integer:=0;
    V_QUERY_SELECT 	 text;
BEGIN
  -- os parâmetros de entrada da função são ($1 -> código do ponto a ser interpolado, 
						--$2 -> nome da amostra, 
						--$3 -> nome da tabela que armazena os pixels (pixelmapa), 
						--$4 -> expoente da interpolacao, 
						--$5 -> numero de elementos, 
						--$6 -> raio (em metros), 
						--$7 -> nome da coluna de interpolação

						
	   V_QUERY_SELECT := 'SELECT  a.geometry, st_distance(st_centroid(b.geometry), a.geometry) as distancia,  a.'||P_Coluna||' as medida
           FROM '||P_RefInterpolacao||' a, '||P_Grade||'  b
           WHERE b.codigo = '||P_interpolacao;
           IF P_Elementos > 0 THEN
		V_QUERY_SELECT := V_QUERY_SELECT ||' order by distancia LIMIT '||P_Elementos ;
	   ELSE
	        V_QUERY_SELECT := V_QUERY_SELECT ||' and st_contains(st_buffer(st_centroid(b.geometry), '||P_Raio||'), a.geometry)';
           END IF;
           raise notice 'sql: %',v_query_select;
	OPEN Cur_Amostras FOR EXECUTE   V_QUERY_SELECT;
	LOOP FETCH Cur_Amostras INTO V_Pontos, V_Distancia, V_Medida;
	  EXIT WHEN NOT FOUND;
           i:= i+1;
           V_Numerador := V_Numerador + (V_Medida/(V_Distancia^P_Expoente));
           V_Denominador := V_Denominador + (1/(V_Distancia^P_Expoente));
        END LOOP;
        IF i > 0 THEN
            V_Soma := V_Numerador/V_Denominador;
        ELSE
           RETURN 0;
        END IF;
      CLOSE Cur_Amostras;
      RETURN V_Soma;
END;
$_$;",database_agdatabox-api.db
"CREATE FUNCTION public.f_verificapermissaoselect(p_objeto text, p_autorizado integer, p_autorizante integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
   v_tipoobjeto varchar(60);
   v_permissao  integer default null;
   v_id_validos integer[] ;
   v_retorno boolean default false;
   V_textosaida text;
   v_sql text;
   v_posicao integer default 0;
   v_chaveprimaria text;
   v_colunaidusuario text;
begin
     select obj_visibilidade
         from tb_objeto where Obj_nomeobjetobanco = p_objeto into v_tipoobjeto;
     if v_tipoobjeto = 'IRRESTRITA' then
        return '';    
      else
        select obj_chaveprimaria, obj_colunaidusuario from tb_objeto 
                        where obj_nomeobjetobanco   = p_objeto into v_chaveprimaria, v_colunaidusuario;
        select per_codigo from v_permissaoselect where per_autorizadocodigo  = p_autorizado
                                                 and   per_autorizantecodigo = p_autorizante
                                                 and   obj_nomeobjetobanco   = p_objeto into v_permissao;
        if v_permissao is null then
           v_textosaida:=(' '||v_chaveprimaria||' = -1'); -- não tem permissao
           return v_textosaida;
        else
 --         select Obj_chaveprimaria, Obj_colunaidautorizante from tb_objeto where upper(obj_nomeobjetobanco) = upper(p_objeto) into v_nomecolunaID, V_colunaautorizante; 
          v_sql := 'select array_agg('||v_chaveprimaria||') from '|| p_objeto||'  where '||v_colunaidusuario||' = '||p_autorizante;
          execute v_sql into v_id_validos; 
          if v_id_validos is null then
             v_textosaida :=(' '||v_chaveprimaria||' = 0'); -- tem permissao mas não tem dados
             return v_textosaida;
          else 
             v_textosaida := '(';
           for i in 1..array_upper(v_id_validos, 1) loop
                v_textosaida := v_textosaida||' '||v_id_validos[i]||', '; 
           end loop;
                v_textosaida := v_textosaida||')';
                select replace (v_textosaida, ', )', ')') into v_textosaida;
           end if;
      end if;
     end if;
      return v_textosaida;
end;
$$;",database_agdatabox-api.db
"CREATE FUNCTION public.fechacompleta(pfecha character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
    DECLARE
     dia varchar;
     mes varchar;
     mesletra varchar;
     anio varchar;
     fecha varchar;
    BEGIN  
	
	select cast(cast(pfecha as date) as varchar) into fecha;
        dia:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'DD');
        mes:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'MM');
        if mes='01' then
           mesletra='Enero';
        end if;
        if mes='02' then
           mesletra='Febrero';
        end if;
        if mes='03' then
           mesletra='Marzo';
        end if;
        if mes='04' then
           mesletra='Abril';
        end if;
        if mes='05' then
           mesletra='Mayo';
        end if;
        if mes='06' then
           mesletra='Junio';
        end if;
        if mes='07' then
           mesletra='Julio';
        end if;
        if mes='08' then
           mesletra='Agosto';
        end if;
        if mes='09' then
           mesletra='Septiembre';
        end if;
        if mes='10' then
           mesletra='Octubre';
        end if;
        if mes='11' then
           mesletra='Noviembre';
        end if;
        if mes='12' then
           mesletra='Diciembre';
        end if;
        anio:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'YYYY');
        RETURN dia || ' de ' || mesletra || ' del ' || anio;
    END;
    $$;",esquemaDB.backup
"CREATE FUNCTION public.fechacompleta2(pfecha character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
    DECLARE
     dia varchar;
     mes varchar;
     mesletra varchar;
     anio varchar;
     fecha varchar;
    BEGIN  
	
	select cast(cast(pfecha as date) as varchar) into fecha;
        dia:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'DD');
        mes:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'MM');
        if mes='01' then
           mesletra='Enero';
        end if;
        if mes='02' then
           mesletra='Febrero';
        end if;
        if mes='03' then
           mesletra='Marzo';
        end if;
        if mes='04' then
           mesletra='Abril';
        end if;
        if mes='05' then
           mesletra='Mayo';
        end if;
        if mes='06' then
           mesletra='Junio';
        end if;
        if mes='07' then
           mesletra='Julio';
        end if;
        if mes='08' then
           mesletra='Agosto';
        end if;
        if mes='09' then
           mesletra='Septiembre';
        end if;
        if mes='10' then
           mesletra='Octubre';
        end if;
        if mes='11' then
           mesletra='Noviembre';
        end if;
        if mes='12' then
           mesletra='Diciembre';
        end if;
        anio:=to_char(to_timestamp(fecha, 'YYYY-MM-DD'), 'YYYY');
        RETURN dia || ' de ' || mesletra || ' del ' || anio;
    END;
    $$;",esquemaDB.backup
"CREATE FUNCTION public.find_all_for_operator() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select
  t.id      as t_id,
  t.name    as t_name,
  t.text,
  t.system_user_id,
  su.name   as su_name,
  su.family as su_family,
  su.subdivision_id,
  sd.name as sd_name,
  t.status_id,
  st.name as status,
  t.executor_id,
  t.operator_id

from tasks t, system_users su, subdivisions sd, status st
where t.system_user_id = su.id and t.status_id = st.id and su.subdivision_id = sd.id  and operator_id = 294;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.find_org_disambiguated_descendents(required_source_id character varying, required_source_type character varying, current_level integer) RETURNS SETOF public.org_disambiguated_descendent
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
DECLARE
    current_result org_disambiguated_descendent;
BEGIN
FOR current_result IN SELECT p1.id, p1.source_id, p1.source_parent_id, p1.org_type, p1.name, p1.city, p1.region, p1.country, current_level AS level FROM org_disambiguated p1 WHERE p1.source_parent_id = required_source_id AND p1.source_type = required_source_type LOOP
    RETURN NEXT current_result;
    RETURN QUERY SELECT * FROM find_org_disambiguated_descendents(current_result.source_id, required_source_type, current_level + 1);    
END LOOP;
END
$$;",orcid4.sql
"CREATE FUNCTION public.first_password() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	rnd integer;
	passchange varchar(12);
BEGIN
	passchange := trunc(random()*1000);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);
	passchange := passchange || trunc(random()*1000);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);
	rnd := trunc(65+random()*25);
	passchange := passchange || chr(rnd);

	RETURN passchange;
END;
$$;",hschool.sql
"CREATE FUNCTION public.fn_formatn(n integer, l integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare 
	res varchar(10);
begin
res := N::varchar(10);
while char_length(res) < L loop
  res := '0' || res;
end loop;  
return res;  
end;
$$;",pomanager.sq
"CREATE FUNCTION public.fn_id_diario_actual() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
  
BEGIN

	RETURN currval('public.venta_temporal_id_venta_temp_seq');
  
END;
$$;",backup_20200416_191058503.sql
"CREATE FUNCTION public.fn_split(parstring text, sep character varying, OUT nn integer, OUT id text) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
   str text[];  
   n int;
BEGIN
   str := regexp_split_to_array(ParString, Sep);
   n := array_length(str, 1);
   FOR i IN 1..n LOOP
      NN := i;
      ID := str[i];
      RETURN NEXT;
   END LOOP;
END;
$$;",pomanager.sq
"CREATE FUNCTION public.fn_verificar_caja_apertura() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	_existe VARCHAR;
BEGIN
        
SELECT 
  id_apertura 
  INTO _existe
FROM 
  public.caja_apertura 
  WHERE cerrado IS NOT TRUE
  LIMIT 1;
  
IF _existe IS NOT NULL THEN
	RETURN _existe; -- id_apertura
END IF;

RETURN '0'; -- no hay caja abierta
  
  
END;
$$;",backup_20200416_191058503.sql
"CREATE FUNCTION public.fn_verificar_caja_apertura(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	__id_apertura		ALIAS FOR $1;
	__existe VARCHAR;
BEGIN

IF (__id_apertura IS NULL) THEN
	RETURN '2'; -- id apertura nulo
END IF;
        
SELECT 
  id_apertura 
  INTO __existe
FROM 
  public.caja_apertura 
  WHERE cerrado IS NOT TRUE
  AND id_apertura = __id_apertura
  LIMIT 1;
  
IF __existe IS NOT NULL THEN
	RETURN '1'; -- HAY CAJA ABIERTA
END IF;

RETURN '0';


END;
$_$;",backup_20200416_191058503.sql
"CREATE FUNCTION public.foo() RETURNS void
    LANGUAGE plpgsql
    AS $$
	BEGIN
		FOR i IN 1..10 LOOP
			SELECT * FROM tb_usuario WHERE usu_codigo = i;
		END LOOP;
	END;
$$;",database_agdatabox-api.db
"CREATE FUNCTION public.fun_ejemplo_array(pcondicion character varying, OUT res character varying, OUT cod character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
 DECLARE
     condicion varchar [];
     cond varchar [];
 BEGIN
     condicion := string_to_array(pcondicion,'|');
      FOR i IN 1..(array_length(condicion, 1)) LOOP
	cond := string_to_array(condicion[i],';');
	res=cond[1];
	cod=cond[2];
        return query select res,cod;
      END LOOP;
	return;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.fun_ejemplo_array(pcondicion character varying[], OUT res character varying, OUT cod character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
 DECLARE
     condicion varchar [];
 BEGIN
     --condicion := string_to_array(pcondicion,'|');
      FOR i IN 1..(array_length(pcondicion, 1)) LOOP
	res=pcondicion[i];
	cod=pcondicion[i];
        return query select res,cod;
      END LOOP;
	return;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.fun_ordentipo(pnomenclatura character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
 DECLARE
     nome integer [];
     valor integer ;
     resul integer;
 BEGIN
      nome := string_to_array(pnomenclatura,'.');
      valor := 100000000;
      resul :=0;
      FOR i IN 1..(array_length(nome, 1)) LOOP
	resul:= resul + (nome[i]*valor);
        valor:=valor/100;
      END LOOP;
	return resul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_get_datos_documentos(pdatos character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
     vatributos character varying [];
     vdatos character varying [];
     vseparador character varying;
     vnombre_tipo character varying;
     vresul character varying;
 BEGIN
      vatributos := string_to_array(pdatos,'|');
      vseparador='';
      vresul :='';
      FOR i IN 1..(array_length(vatributos, 1)) LOOP
	vdatos= string_to_array(vatributos[i],';');
	select nombre into vnombre_tipo  from gd_atributos_documento where borrado='N'and codigo=vdatos[1];
	IF FOUND THEN
		vresul:= vresul || vseparador || vdatos[2];
		vseparador=';';
	END IF;
      END LOOP;
	return vresul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_get_datos_documentos_campos(pdatos character varying, ptipo_documento character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
     vatributos character varying [];
     vdatos character varying [];
     vseparador character varying;
     vnombre_tipo character varying;
     vresul character varying;
 BEGIN
      vatributos := string_to_array(pdatos,'|');
      vseparador='';
      vresul :='';
      if pdatos<>'' then
	      FOR i IN 1..(array_length(vatributos, 1)) LOOP
		vdatos= string_to_array(vatributos[i],';');
		select nombre into vnombre_tipo  from gd_atributos_documento where borrado='N' and tipo_documento=ptipo_documento and codigo=vdatos[1];
		IF FOUND THEN
			vresul:= vresul || vseparador || vnombre_tipo || ': ' || vdatos[2];
			vseparador='<br>';
		END IF;
	      END LOOP;
	end if;
	return vresul;
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.gd_valida_datos_doc_tp(pvalor text) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      vregistros varchar[];
      vdatos varchar[];
      vcodigo date;
      verror varchar;
 BEGIN
	BEGIN
		verror='';
		vregistros := string_to_array(pvalor,'|');
		FOR i IN 1..(array_length(vregistros, 1)) LOOP
			vdatos := string_to_array(vregistros[i],';');
			--1=codig atributo,2=valor, 3=tipo de dato
			if vdatos[3]='FE' then 
				if es_fecha(vdatos[2])=false then 
					verror=verror || 'Fecha invalida<br>'; 
				else --validar que la fecha no sea superior a la actual
					if cast(vdatos[2] as date) >= CURRENT_TIMESTAMP then
						verror=verror || 'Fecha invalida superior a la fecha actual del sistema<br>'; 
					end if;
				end if; 
			end if;			
			if vdatos[3]='NU' then if es_numero(vdatos[2])=false then verror=verror || 'Nuero incorrecto<br>'; end if; end if;
		        if vdatos[3]='DE' then if es_numero(vdatos[2])=false then verror=verror || 'Nuero incorrecto<br>'; end if; end if;
		        
		END LOOP;
				
	EXCEPTION WHEN OTHERS THEN
		verror=sqlerrm;		
	END;
	return verror;
	--select es_numero('9999999999999999999999');
	--'70;MUÑOS RAMOS MELANIE SOFIA ;TC|69;1312506528;TC|71;14/11/2024;FE|72;INTELECTUAL ;TC|73;87%;TC|74;MUY GRAVE;TC'
	--select case when cast('11/12/2024' as date) >= CURRENT_TIMESTAMP then 'SI' else 'NO' end
	--select gd_valida_datos_doc_tp('70;MUÑOS RAMOS MELANIE SOFIA ;TC|69;1312506528;TC|71;14/11/2024;FE|72;INTELECTUAL ;TC|73;87%;TC|74;MUY GRAVE;TC')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.generate_value(my_table text, my_column text) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
my_type text;
begin
select  /*case 
when data_type='character varying' 
then 'varchar('||character_maximum_length||')'
when data_type='numeric' then 'numeric('||numeric_precision||','||numeric_scale||')'
else*/ data_type
--end
from information_schema.columns
where table_schema='public' and table_name=my_table and column_name=my_column and is_updatable='YES' into my_type;

if (my_type like 'character varying') then return (select array_to_string(array(select chr((ascii('a')+round(random()*25))::integer) from generate_series(1,ceil(random()*20)::int)), ''));
elsif (my_type = 'integer') then return round(random()*1000)::integer;
elsif my_type = 'timestamp without time zone' then return current_timestamp::timestamp - random() * (current_timestamp - '1990-01-01 01:01:01'::timestamp);
elsif my_type = 'boolean' then return random() > 0.5;
else raise notice 'not supported';
end if;

end
$$;",testdb.dump
"CREATE FUNCTION public.get_carga_horaria_docente(cedula_docente text) RETURNS TABLE(horas_de_clase integer, horas_ci integer, horas_ic integer, horas_ase_aca integer, horas_ga integer, horas_oaa integer, total_hadmin integer, total_horas integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
	horas_de_clase := get_horas_de_clase( cedula_docente );
	horas_ci := get_horas_administrativas_por_tipo( cedula_docente , 'CI' );
	horas_ic := get_horas_administrativas_por_tipo( cedula_docente , 'IC' );
	horas_ase_aca := get_horas_administrativas_por_tipo( cedula_docente , 'AA' );
	horas_ga := get_horas_administrativas_por_tipo( cedula_docente , 'GA' );
	horas_oaa := get_horas_administrativas_por_tipo( cedula_docente , 'OAA' );
	total_hadmin := horas_ci + horas_ic + horas_ase_aca + horas_ga + horas_oaa;
	
	total_horas := horas_de_clase + total_hadmin;
	RETURN NEXT;
END;
$$;",horarios.sql
"CREATE FUNCTION public.get_carga_horaria_docente(cedula_docente text) RETURNS TABLE(horas_de_clase integer, horas_ci integer, horas_ic integer, horas_ase_aca integer, horas_ga integer, horas_oaa integer, total_hadmin integer, total_horas integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
	horas_de_clase := get_horas_de_clase( cedula_docente );
	horas_ci := get_horas_administrativas_por_tipo( cedula_docente , 'CI' );
	horas_ic := get_horas_administrativas_por_tipo( cedula_docente , 'IC' );
	horas_ase_aca := get_horas_administrativas_por_tipo( cedula_docente , 'AA' );
	horas_ga := get_horas_administrativas_por_tipo( cedula_docente , 'GA' );
	horas_oaa := get_horas_administrativas_por_tipo( cedula_docente , 'OAA' );
	total_hadmin := horas_ci + horas_ic + horas_ase_aca + horas_ga + horas_oaa;
	
	total_horas := horas_de_clase + total_hadmin;
	RETURN NEXT;
END;
$$;",horarios_07-01-2020.dump
"CREATE FUNCTION public.get_carga_horaria_docente(cedula_docente text) RETURNS TABLE(horas_de_clase integer, horas_ci integer, horas_ic integer, horas_ase_aca integer, horas_ga integer, horas_oaa integer, total_hadmin integer, total_horas integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
	horas_de_clase := get_horas_de_clase( cedula_docente );
	horas_ci := get_horas_administrativas_por_tipo( cedula_docente , 'CI' );
	horas_ic := get_horas_administrativas_por_tipo( cedula_docente , 'IC' );
	horas_ase_aca := get_horas_administrativas_por_tipo( cedula_docente , 'AA' );
	horas_ga := get_horas_administrativas_por_tipo( cedula_docente , 'GA' );
	horas_oaa := get_horas_administrativas_por_tipo( cedula_docente , 'OAA' );
	total_hadmin := horas_ci + horas_ic + horas_ase_aca + horas_ga + horas_oaa;
	
	total_horas := horas_de_clase + total_hadmin;
	RETURN NEXT;
END;
$$;",horarios_22-01-2020.dump
"CREATE FUNCTION public.get_carga_horaria_docente(cedula_docente text) RETURNS TABLE(horas_de_clase integer, horas_ci integer, horas_ic integer, horas_ase_aca integer, horas_ga integer, horas_oaa integer, total_hadmin integer, total_horas integer)
    LANGUAGE plpgsql
    AS $$
BEGIN
	horas_de_clase := get_horas_de_clase( cedula_docente );
	horas_ci := get_horas_administrativas_por_tipo( cedula_docente , 'CI' );
	horas_ic := get_horas_administrativas_por_tipo( cedula_docente , 'IC' );
	horas_ase_aca := get_horas_administrativas_por_tipo( cedula_docente , 'AA' );
	horas_ga := get_horas_administrativas_por_tipo( cedula_docente , 'GA' );
	horas_oaa := get_horas_administrativas_por_tipo( cedula_docente , 'OAA' );
	total_hadmin := horas_ci + horas_ic + horas_ase_aca + horas_ga + horas_oaa;
	
	total_horas := horas_de_clase + total_hadmin;
	RETURN NEXT;
END;
$$;",horarios_empty.dump
"CREATE FUNCTION public.get_child_groups(id integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $_$
declare ret integer[];
declare myrow record;
begin
FOR myrow IN SELECT p.id,p.type FROM project_groups p WHERE parent_id=$1 LOOP
	IF myrow.type = 0 THEN SELECT array_append(ret,myrow.id) INTO ret; 
	ELSIF myrow.type = 1 THEN SELECT array_cat(ret,get_child_groups(myrow.id)) INTO ret;
	END IF;
END LOOP;

return ret;
END;
$_$;",setup_v21.sql
"CREATE FUNCTION public.get_child_menus(id integer) RETURNS integer[]
    LANGUAGE plpgsql
    AS $_$
declare ret integer[];
declare myrow record;
begin
FOR myrow IN SELECT p.id,p.type FROM project_groups p WHERE parent_id=$1 LOOP
	IF myrow.type = 1 THEN 
		SELECT array_append(ret,myrow.id) INTO ret; 
		SELECT array_cat(ret,get_child_menus(myrow.id)) INTO ret;
	END IF;
END LOOP;

return ret;
END;
$_$;",setup_v21.sql
"CREATE FUNCTION public.get_contenido_directorio(pcodigo character varying, ptipo character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
 DECLARE
      mi_nombre varchar;
      mi_hijo varchar;
      fila RECORD;
      hijos RECORD;
      resul integer;
      vcantidad_tipo integer;
 BEGIN
	resul=0;
	select count(tipo) into vcantidad_tipo from gd_contenedor where activo='S' and contenedor_padre=pcodigo and tipo=ptipo;
	resul=vcantidad_tipo;
	FOR hijos IN SELECT codigo,tipo from gd_contenedor where activo='S' and contenedor_padre=pcodigo LOOP
		if hijos.tipo='FO' then
			if ptipo='DO' then
				select count(tipo) into vcantidad_tipo from gd_documento where borrado='N' and contenedor=hijos.codigo;
				resul=resul + vcantidad_tipo;
			end if;
			if ptipo='AN' then --anexos
				select count(codigo) into vcantidad_tipo from gd_documento_anexo where borrado='N' and documento in (select codigo from gd_documento where borrado='N' and contenedor=hijos.codigo);
				resul=resul + vcantidad_tipo;
			end if;
		else
			resul=resul + get_contenido_directorio(hijos.codigo,ptipo);
		end if;
	
	END LOOP;
	return resul;
	-- select * from get_contenido_directorio('10','DO')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_directorio(pcodigo character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      mi_nombre varchar;
     mi_padre varchar;
 BEGIN

	if pcodigo='-1' then
		return '/';
	else													          
		select contenedor_padre,nombre into mi_padre,mi_nombre from gd_contenedor where borrado='N' and  codigo=pcodigo and tipo in('ZO','CO','HO','DI','CS','DP','PO','AR','FO','ES','CA','AC');
		if mi_padre<>'-1' then
			return get_directorio(mi_padre) || '/' || mi_nombre;
		else
			return '/' || mi_nombre;
		end if;
	end if;
	-- select * from get_directorio('10')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_directorio_documento(pcodigo character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      mi_nombre varchar;
     mi_padre varchar;
 BEGIN

	select contenedor_padre,nombre into mi_padre,mi_nombre from gd_contenedor where codigo=pcodigo ;
	if mi_padre<>'-1' then
		return get_directorio_documento(mi_padre) || '/' || mi_nombre;
	else
		return mi_nombre;
	end if;
	-- select * from get_directorio_documento('1')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_directorio_padre(ppadre character varying, OUT codi character varying, OUT direc character varying, OUT rtipo character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
 DECLARE
       fila RECORD;
       hijos RECORD;
       
 BEGIN

	--select codigo,contenedor_padre,nombre into mi_padre,mi_nombre from gd_contenedor where codigo=pcodigo and tipo in('ZO','HO','DI','CS');
	IF ppadre='-1' then
		codi='-1';
		direc='/';
		rtipo='RZ';
		return query select codi,direc,rtipo;
	end if;
	
	FOR fila IN SELECT codigo,tipo from gd_contenedor where borrado='N' and contenedor_padre=ppadre and  tipo in('ZO','CO','HO','DI','CS','DP','PO','AR') order by nombre LOOP
		codi=fila.codigo;
		direc=get_directorio(fila.codigo);
		rtipo=fila.tipo;
		return query select codi,direc,rtipo;
		FOR hijos IN SELECT hi.codi as codi2,hi.direc as direc2, hi.rtipo as rtipo2 from get_directorio_padre(fila.codigo) hi LOOP
			codi=hijos.codi2;
			direc=hijos.direc2;
			rtipo=hijos.rtipo2;
			return query select codi,direc,rtipo;
		END LOOP;
	
	END LOOP;
	-- select * from get_directorio_padre('1')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_directorio_padre_all(ppadre character varying, OUT codi character varying, OUT direc character varying, OUT rtipo character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
 DECLARE
       fila RECORD;
       hijos RECORD;
       
 BEGIN

	--select codigo,contenedor_padre,nombre into mi_padre,mi_nombre from gd_contenedor where codigo=pcodigo and tipo in('ZO','HO','DI','CS');
	IF ppadre='-1' then
		codi='-1';
		direc='/';
		rtipo='RZ';
		return query select codi,direc,rtipo;
	end if;
	
	FOR fila IN SELECT codigo,tipo from gd_contenedor where borrado='N' and contenedor_padre=ppadre and  tipo in('ZO','CO','HO','DI','CS','DP','PO','AR','FO','ES','CA','AC') order by nombre LOOP
		codi=fila.codigo;
		direc=get_directorio(fila.codigo);
		rtipo=fila.tipo;
		return query select codi,direc,rtipo;
		FOR hijos IN SELECT hi.codi as codi2,hi.direc as direc2, hi.rtipo as rtipo2 from get_directorio_padre_all(fila.codigo) hi LOOP
			codi=hijos.codi2;
			direc=hijos.direc2;
			rtipo=hijos.rtipo2;
			return query select codi,direc,rtipo;
		END LOOP;
	
	END LOOP;
	-- select * from get_directorio_padre_all('-1')
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_groups(fortime timestamp with time zone, relaxdayslimit integer) RETURNS TABLE(d_start timestamp without time zone, d_end timestamp without time zone, g_id integer, s_number integer)
    LANGUAGE plpgsql
    AS $$
DECLARE 
    var_r record;
    buffer INTEGER[];
    elem INTEGER;
BEGIN
d_start := ForTime;
d_end := ForTime + INTERVAL '1 DAY';
 FOR var_r IN(
SELECT
	--serial_number,
	--rs_name,
	--range,
	--array_agg(gr_id ORDER BY gr_id ASC) as gr_ids
	gr_id,
	array_agg(serial_number ORDER BY serial_number ASC) as serial_numbers
FROM
	(SELECT
		serial_number,
		rs_name,
		range,
		gr_id,
		DENSE_RANK() OVER (PARTITION BY serial_number, rs_name ORDER BY range DESC, last_duty_rank DESC, equipment_last_duty_rank DESC, equipment_global_rank DESC) as priority
	FROM
		(SELECT 
			serial_number,
			rs_name,
			range,
			gr_id,
			MIN(since_last_duty_days) OVER (PARTITION BY gr_id) AS last_duty_days_for_group,
			DENSE_RANK() OVER (ORDER BY equipment_last_duty_days ASC) as equipment_global_rank,
			DENSE_RANK() OVER (PARTITION BY gr_id ORDER BY equipment_last_duty_days ASC) as equipment_last_duty_rank,
			DENSE_RANK() OVER (ORDER BY since_last_duty_days ASC) as last_duty_rank
		FROM
			(SELECT
				serial_number,
				rs_name,
				range,
				joined_with_log.gr_id,
				CASE WHEN equipment IS NULL THEN 1000 ELSE since_last_duty_days END as equipment_last_duty_days,
				CASE WHEN since_last_duty_days IS NULL THEN 1000 ELSE since_last_duty_days END as since_last_duty_days 
			FROM
				(SELECT 
					serial_number,
					rs_name,
					range,
					n_persons,
					x.gr_id,
					equipment,
					since_last_duty_days
				FROM
					(SELECT
						serial_number,
						rs_name,
						range,
						n_persons,
						gr_id
					FROM
						(SELECT 
							serial_number,
							rs_name,
							range,
							n_persons 
						FROM 
							inventory as a
							INNER JOIN
							radar_station as b
							ON  a.rs_name = b.name
						WHERE 
							active=TRUE) as rs

					INNER JOIN
						duty_groups
					ON rs.rs_name = duty_groups.for_station
					ORDER BY range DESC) as x

				LEFT OUTER JOIN

					(SELECT
						gr_id,
						equipment,
						MIN(DATE_PART('DAY', ForTime - duty_end)) OVER (PARTITION BY gr_id, equipment) as since_last_duty_days
					FROM
						duty_groups_log
					WHERE duty_end > ForTime - INTERVAL '7 DAY') as y

				ON x.gr_id = y.gr_id AND x.serial_number = y.equipment) as joined_with_log

			INNER JOIN

				(SELECT
					gr_id,
					COUNT(*) as onboard
				FROM
					groups_personnel
				GROUP BY 
					gr_id
				) as people_in_groups

			ON joined_with_log.gr_id = people_in_groups.gr_id
			WHERE n_persons - onboard = 0)as source) as dense
	WHERE last_duty_days_for_group >= RelaxDaysLimit
	) as pre_final
WHERE priority = 1
GROUP BY gr_id
 )  
 LOOP
        g_id := var_r.gr_id; 
	FOREACH elem IN ARRAY var_r.serial_numbers
	LOOP
		IF (NOT (buffer @> ARRAY[elem::int]) OR buffer IS NULL) THEN
			s_number := elem;
			EXIT;
		END IF;
	END LOOP;
	buffer := array_append(buffer, s_number);
        RETURN NEXT;
 END LOOP;
END; $$;",combat_duty_db.bak
"CREATE FUNCTION public.get_horas_administrativas_por_tipo(cedula_docente text, tipo_actividad text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN
	SELECT 
	   count( h.""codHor"" ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	INNER JOIN ""TActiAdmi"" aa ON aa.""codActAdm"" = h.""codActAdm""
	WHERE 
	  h.tipo = 2
	AND
	  d.""cedDoc"" = cedula_docente
	AND
	  aa.""tipActAdm"" = tipo_actividad
	GROUP BY d.""cedDoc""; 	

	
	
	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios.sql
"CREATE FUNCTION public.get_horas_administrativas_por_tipo(cedula_docente text, tipo_actividad text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN
	SELECT 
	   count( h.""codHor"" ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	INNER JOIN ""TActiAdmi"" aa ON aa.""codActAdm"" = h.""codActAdm""
	WHERE 
	  h.tipo = 2
	AND
	  d.""cedDoc"" = cedula_docente
	AND
	  aa.""tipActAdm"" = tipo_actividad
	GROUP BY d.""cedDoc""; 	

	
	
	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_07-01-2020.dump
"CREATE FUNCTION public.get_horas_administrativas_por_tipo(cedula_docente text, tipo_actividad text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN
	SELECT 
	   count( h.""codHor"" ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	INNER JOIN ""TActiAdmi"" aa ON aa.""codActAdm"" = h.""codActAdm""
	WHERE 
	  h.tipo = 2
	AND
	  d.""cedDoc"" = cedula_docente
	AND
	  aa.""tipActAdm"" = tipo_actividad
	GROUP BY d.""cedDoc""; 	

	
	
	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_22-01-2020.dump
"CREATE FUNCTION public.get_horas_administrativas_por_tipo(cedula_docente text, tipo_actividad text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN
	SELECT 
	   count( h.""codHor"" ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	INNER JOIN ""TActiAdmi"" aa ON aa.""codActAdm"" = h.""codActAdm""
	WHERE 
	  h.tipo = 2
	AND
	  d.""cedDoc"" = cedula_docente
	AND
	  aa.""tipActAdm"" = tipo_actividad
	GROUP BY d.""cedDoc""; 	

	
	
	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_empty.dump
"CREATE FUNCTION public.get_horas_de_clase(cedula_docente text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN

	SELECT 
	  count( h.* ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	WHERE 
	  h.tipo = 1
	AND
	d.""cedDoc"" = cedula_docente
	GROUP BY d.""cedDoc""; 	

	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios.sql
"CREATE FUNCTION public.get_horas_de_clase(cedula_docente text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN

	SELECT 
	  count( h.* ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	WHERE 
	  h.tipo = 1
	AND
	d.""cedDoc"" = cedula_docente
	GROUP BY d.""cedDoc""; 	

	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_07-01-2020.dump
"CREATE FUNCTION public.get_horas_de_clase(cedula_docente text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN

	SELECT 
	  count( h.* ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	WHERE 
	  h.tipo = 1
	AND
	d.""cedDoc"" = cedula_docente
	GROUP BY d.""cedDoc""; 	

	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_22-01-2020.dump
"CREATE FUNCTION public.get_horas_de_clase(cedula_docente text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	cantidad integer;
BEGIN

	SELECT 
	  count( h.* ) INTO cantidad
	FROM ""THorarios"" h 
	INNER JOIN ""TDocentes"" d ON d.""cedDoc"" = h.""cedDoc""
	WHERE 
	  h.tipo = 1
	AND
	d.""cedDoc"" = cedula_docente
	GROUP BY d.""cedDoc""; 	

	RETURN coalesce( cantidad  , 0 );
END;
$$;",horarios_empty.dump
"CREATE FUNCTION public.get_numero(pvalor character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
 DECLARE
      vresultado integer;
     mi_padre varchar;
 BEGIN
	BEGIN
		vresultado = to_number(pvalor,'999999999999999999');
	EXCEPTION WHEN OTHERS THEN
		vresultado=0;		
	END;
	return vresultado;
	--select get_numero('122112222222222');
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_phase_email(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec	RECORD;
	myemail	varchar(320);
BEGIN
	myemail := null;
	FOR myrec IN SELECT entitys.primary_email
		FROM entitys INNER JOIN entity_subscriptions ON entitys.entity_id = entity_subscriptions.entity_id
		WHERE (entity_subscriptions.entity_type_id = $1) LOOP

		IF (myemail is null) THEN
			IF (myrec.primary_email is not null) THEN
				myemail := myrec.primary_email;
			END IF;
		ELSE
			IF (myrec.primary_email is not null) THEN
				myemail := myemail || ', ' || myrec.primary_email;
			END IF;
		END IF;

	END LOOP;

	RETURN myemail;
END;
$_$;",hschool.sql
"CREATE FUNCTION public.get_phase_entitys(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec			RECORD;
	myentitys		varchar(320);
BEGIN
	myentitys := null;
	FOR myrec IN SELECT entitys.entity_name
		FROM entitys INNER JOIN entity_subscriptions ON entitys.entity_id = entity_subscriptions.entity_id
		WHERE (entity_subscriptions.entity_type_id = $1) LOOP

		IF (myentitys is null) THEN
			IF (myrec.entity_name is not null) THEN
				myentitys := myrec.entity_name;
			END IF;
		ELSE
			IF (myrec.entity_name is not null) THEN
				myentitys := myentitys || ', ' || myrec.entity_name;
			END IF;
		END IF;

	END LOOP;

	RETURN myentitys;
END;
$_$;",hschool.sql
"CREATE FUNCTION public.get_phase_status(boolean, boolean) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	ps		varchar(16);
BEGIN
	ps := 'Draft';
	IF ($1 = true) THEN
		ps := 'Approved';
	END IF;
	IF ($2 = true) THEN
		ps := 'Rejected';
	END IF;

	RETURN ps;
END;
$_$;",hschool.sql
"CREATE FUNCTION public.get_project_data(project text)
  RETURNS TABLE(client_id integer, client_name text, client_display_name text, client_url text, theme_name text, overview_layer json, base_layers json, extra_layers json, tables_onstart text[], is_public boolean, project_id integer, project_name text, project_display_name text, crs text, description text, restrict_to_start_extent boolean, geolocation boolean, feedback boolean, measurements boolean, print boolean, zoom_back_forward boolean, identify_mode boolean, permalink boolean, feedback_email text, project_path text, plugins text[], custom1 text, custom2 text)
LANGUAGE 'plpgsql'

COST 1
VOLATILE
ROWS 1000
AS $BODY$

declare base json;
declare overview json;
declare extra json;
declare plugins text[];
begin
  base:=null;
  overview:=null;

  SELECT json_agg(json_build_object('type',layers.type,'definition',layers.definition,'name',layers.name,'title',layers.display_name))
  FROM
    (SELECT layers.* FROM projects,layers,project_groups where projects.project_group_id = project_groups.id AND layers.id = ANY(project_groups.base_layers_ids) AND projects.name=$1 ORDER BY idx(project_groups.base_layers_ids, layers.id)) AS layers INTO base;

  SELECT json_agg(json_build_object('type',layers.type,'definition',layers.definition,'name',layers.name,'title',layers.display_name))
  FROM
    (SELECT layers.* FROM projects,layers,project_groups where projects.project_group_id = project_groups.id AND layers.id = ANY(project_groups.extra_layers_ids) AND projects.name=$1 ORDER BY idx(project_groups.extra_layers_ids, layers.id)) AS layers INTO extra;

  SELECT array_agg(plugins.name) from projects,plugins WHERE plugins.id = ANY(projects.plugin_ids) AND projects.name=$1 INTO plugins;

  SELECT json_agg(json_build_object('type',layers.type,'definition',layers.definition,'name',layers.name,'title',layers.display_name))
  FROM projects,layers where layers.id = projects.overview_layer_id and projects.name=$1 INTO overview;

 RETURN QUERY SELECT
                 clients.id,
                 clients.name,
                 clients.display_name,
                 clients.url,
                 themes.name,
                 overview,
                 base,
                 extra,
                 projects.tables_onstart,
                 projects.public,
                 projects.id,
                 projects.name,
                 projects.display_name,
                 projects.crs,
                 projects.description,
                 projects.restrict_to_start_extent,
                 projects.geolocation,
                 projects.feedback,
                 projects.measurements,
                 projects.print,
                 projects.zoom_back_forward,
                 projects.identify_mode,
                 projects.permalink,
                 projects.feedback_email,
                 projects.project_path,
                 plugins,
                 g.custom1,
                 g.custom2

     FROM projects,clients,themes,project_groups g WHERE clients.theme_id=themes.id AND projects.client_id = clients.id AND projects.project_group_id = g.id AND projects.name=$1;
end;

$BODY$;",setup_v21.sql
"CREATE FUNCTION public.get_puede_editar_contenido(pcontenedor character varying, pempresa character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      vtipo_empresa varchar;
      vempresa varchar;
      vexiste integer;
      vresul varchar;
 BEGIN

	select tipo_empresa into vtipo_empresa from gd_tipo_contenedor where codigo=(select tipo from gd_contenedor where codigo=pcontenedor) ;
	if vtipo_empresa = 'SI' then -- buscamos la empresa en gd_empresa
		--valirdar si existe la empresa caso contrario buscar la empresa en el contenedor
		select count(*) into vexiste from gd_empresa where borrado='N' and  directorio=pcontenedor;
		if vexiste = 1 then -- si existe la empresa
			select codigo into vempresa from gd_empresa where directorio=pcontenedor;
		else
			select empresa into vempresa from gd_contenedor where codigo=pcontenedor;
		end if;
	else
		select empresa into vempresa from gd_contenedor where codigo=pcontenedor;
	end if;
	--select codigo into vempresa2 from gd_empresa where directorio=pcontenedor; 
	if vempresa = pempresa then
		vresul='SI';
	else
		vresul='NO';
	end if;
	return vresul;
	-- select get_puede_editar_contenido('2340','29') 2340 EMPRESA=29
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.get_reporting_list(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
    myrec	RECORD;
	mylist	varchar(320);
BEGIN
	mylist := null;
	FOR myrec IN SELECT entitys.entity_name
		FROM reporting INNER JOIN entitys ON reporting.report_to_id = entitys.entity_id
		WHERE (reporting.primary_report = true) AND (reporting.entity_id = $1)
	LOOP

		IF (mylist is null) THEN
			mylist := myrec.entity_name;
		ELSE
			mylist := mylist || ', ' || myrec.entity_name;
		END IF;
	END LOOP;

	RETURN mylist;
END;
$_$;",hschool.sql
"CREATE FUNCTION public.get_status(id integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare stat varchar; 
begin
select ticket.status into stat from ticket
where ticket.ticket_id = id;
return stat;
end; $$;",plumbingdb_backup
"CREATE FUNCTION public.get_tech(id character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare name varchar;
begin
select employee.fname || ' ' || employee.lname
into name from invoice natural join ticket
natural join did_work natural join employee
where invoice.invoice_number = id;
return name; end; $$;",plumbingdb_backup
"CREATE FUNCTION public.get_ticket_from_invoice(id character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare result int;
begin
select invoice.ticket_id into result
from invoice 
where invoice.invoice_number = id;
return result;
end;$$;",plumbingdb_backup
"CREATE FUNCTION public.get_total_customers(businessid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE
	total INTEGER;

BEGIN
    SELECT INTO total COUNT(DISTINCT customer_id) as total_users
FROM get_business_coupons(2);

	RETURN total;
	
END; $$;",VBSchema.sql
"CREATE FUNCTION public.get_url_list(categoria integer, producto character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
    DECLARE
      urls refcursor;                       
    BEGIN
      OPEN urls FOR 
	  	SELECT url.did, url.nom_url, url.des_url, url.bol_activo
	  	FROM sia.TB_SIA_CATEGORIAS_EMPRESAS cat, sia.TB_SIA_EMPRESA emp, sia.TB_SIA_URLS url 
	  	WHERE cat.did = emp.id_categoria
		AND emp.did = url.id_empresa;
      RETURN urls;
    END;
  $$;",backup_sia_bbdd.sql
"CREATE FUNCTION public.getcurrentcycle() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    currentMonth integer;
    currentYear integer;
    quarterly integer;
    cicloid integer;
BEGIN
    SELECT extract(MONTH FROM now()) INTO currentMonth;
    SELECT extract(YEAR FROM now()) INTO currentYear;

    IF currentMonth IN (1,2,3,4) THEN
        quarterly := 1;
    ELSIF currentMonth IN (5,6,7,8) THEN
        quarterly := 2;
    ELSE
       quarterly := 3;
    END IF;

    SELECT c.id FROM public.cycles as c where c.sequence = quarterly AND c.year = currentYear INTO cicloid;

    RETURN cicloid;

END;
$$;",script.sql
"CREATE FUNCTION public.getcurrentquarterly() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    currentMonth integer;
BEGIN
    SELECT extract(MONTH FROM now()) INTO currentMonth;

    IF currentMonth IN (1,2,3,4) THEN
        return 1;
    ELSIF currentMonth IN (5,6,7,8) THEN
        RETURN 2;
    ELSE
       RETURN 3;
    END IF;

END;
$$;",script.sql
"CREATE FUNCTION public.getpass(rut_u integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE  

    PASS_U VARCHAR(100);      

BEGIN

    IF(CHECKUSER(RUT_U)=TRUE) THEN

        SELECT PASS INTO PASS_U FROM USUARIO WHERE RUT=RUT_U;

        RETURN PASS_U;

    ELSE

        RETURN 'FALSE';

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN 'FALSE';

        WHEN OTHERS THEN 

            RETURN 'FALSE';

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.getpassadmin(rut_u integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE  

    PASS_U VARCHAR(100);      

BEGIN

    IF(CHECKUSER(RUT_U)=TRUE) THEN

        SELECT PASS INTO PASS_U FROM ADMINISTRADOR WHERE RUT=RUT_U;

        RETURN PASS_U;

    ELSE

        RETURN 'FALSE';

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN 'FALSE';

        WHEN OTHERS THEN 

            RETURN 'FALSE';

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.getreceived(id integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare tmptime text;
begin
select to_char(received, 'HH12:MI AM MM/DD/YY'::text) into tmptime
from ticket
where ticket_id = id; return tmptime;
end; $$;",plumbingdb_backup
"CREATE FUNCTION public.getticketsuntiltoday(dt date) RETURNS TABLE(title text, totaltickets integer)
    LANGUAGE plpgsql
    AS $$
declare 
	recTick record;
	curTick cursor (dt date) for select tickets.title as tTitle, sum(ticket_num) as tTick
   								 from tickets inner join transactions on id = ticket_id
  								 where transactions.date >= dt and transactions.date <= CURRENT_DATE
 							     group by tickets.title;								 
begin
open curTick(dt);
loop
	fetch curTick into recTick;
	exit when not found;
	title := recTick.tTitle;
	totalTickets := recTick.tTick;
	return next;
end loop;
close curTick;
end; $$;",TicketService
"CREATE FUNCTION public.hostname_split(hostname text) RETURNS text[]
    LANGUAGE plpgsql
    AS $$
  declare
    res text[];
  begin
    res = regexp_split_to_array(hostname, '\.');

    return res;
  end;
$$;",pgdumpall.txt.sql
"CREATE FUNCTION public.increment(i integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
        BEGIN
                RETURN i + 1;
        END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION public.inicio_sesion(rut_u integer, pass_u character varying, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$ DECLARE

BEGIN

    IF VALIDACION(RUT_U)=TRUE THEN

        IF CHECKUSER(RUT_U)=TRUE THEN

            IF VALIDAR_LOGIN(RUT_U,PASS_U)=TRUE THEN

                BOOL := 'TRUE';

                MESSAGE := 'INICIO DE SESIÓN AUTORIZADO';

            ELSE

                BOOL := 'FALSE';

                MESSAGE := 'LOS DATOS INGRESADOS SON INCORRECTOS';

            END IF;

        ELSE 

            BOOL := 'FALSE';

            MESSAGE := 'EL USUARIO CON RUT: '||RUT_U||' NO EXISTE EN EL SISTEMA';

        END IF;

    ELSE        

        BOOL := 'FALSE';

        MESSAGE := 'EL RUT INGRESADO NO ES VÁLIDO';

    END IF;

    RETURN;

    EXCEPTION

        WHEN OTHERS THEN

            BOOL := 'FALSE';

            MESSAGE := 'HA OCURRIDO UN ERROR INTERNO';

            RETURN;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.inicio_sesion_admin(rut_u integer, pass_u character varying, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$ DECLARE

BEGIN

    IF VALIDACION(RUT_U)=TRUE THEN

        IF CHECKADMIN(RUT_U)=TRUE THEN

            IF VALIDAR_LOGIN_ADMIN(RUT_U,PASS_U)=TRUE THEN

                BOOL := 'TRUE';

                MESSAGE := 'INICIO DE SESIÓN AUTORIZADO';

            ELSE

                BOOL := 'FALSE';

                MESSAGE := 'LOS DATOS INGRESADOS SON INCORRECTOS';

            END IF;

        ELSE 

            BOOL := 'FALSE';

            MESSAGE := 'EL USUARIO CON RUT: '||RUT_U||' NO EXISTE EN EL SISTEMA';

        END IF;

    ELSE        

        BOOL := 'FALSE';

        MESSAGE := 'EL RUT INGRESADO NO ES VÁLIDO';

    END IF;

    RETURN;

    EXCEPTION

        WHEN insufficient_privilege THEN

            BOOL := 'FALSE';

            MESSAGE := 'NO TIENE PRIVILEGIOS PARA INICIAR SESION COMO ADMIN';

            RETURN;

        WHEN OTHERS THEN

            BOOL := 'FALSE';

            MESSAGE := 'HA OCURRIDO UN ERROR INTERNO';

            RETURN;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.invoice_in_date(id character varying, begin character varying, ending character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare exists integer;
begin
select count(""invoice_number"") into exists
from invoice natural join ticket natural join did_work
where invoice.invoice_number = id and
did_work.end_time between begin::timestamp and
ending::timestamp;
return exists; end; $$;",plumbingdb_backup
"CREATE FUNCTION public.isafter(start_date timestamp without time zone, end_date timestamp without time zone) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE   
   diffSeconds INT;
   
BEGIN
     -- get the rate based on film_id
     SELECT INTO diffSeconds *
	 FROM DATEDIFF('second', start_date::timestamp, end_date::timestamp);
	 
	 IF diffSeconds IS NOT NULL THEN
		 IF diffSeconds <= 0 THEN
			RAISE NOTICE 'start date is after end date';
			RETURN true;
		 ELSE 
			RAISE NOTICE 'start date is before end date';
			RETURN false;
		 END IF;
	ELSE 
		RAISE NOTICE 'diffSeconds is NULL';
		RETURN false;
	END IF;
END; $$;",VBSchema.sql
"CREATE FUNCTION public.isnumeric(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE 

    RETORNO BOOLEAN;

BEGIN

    SELECT '$1' ~ '^[0-9\.]+$' INTO RETORNO;

    RETURN RETORNO;

END;

$_$;",base_de_datos_completa.sql
"CREATE FUNCTION public.isnumeric(valor integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$

DECLARE 

    RETORNO BOOLEAN;

BEGIN

    SELECT valor = '^[0-9\.]+$' INTO RETORNO;

    RETURN RETORNO;

END;

$_$;",base_de_datos_completa.sql
"CREATE FUNCTION public.ispremium(character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
  return $1 in (select username from bdproject.users where uprivilege = 'premium');
END;
$_$;",pgbak.sql
"CREATE FUNCTION public.login(usu character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
	
	usu1 character varying;
	pass1 character varying;
	
	BEGIN
		
		usu1 := (SELECT usuario FROM usuario where usuario=usu AND password=pass);
		pass1 := (SELECT password FROM usuario where usuario=usu AND password=pass);

		IF usu = usu1 AND pass = pass1 THEN 
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
		END;
		$$;",06-11.sql
"CREATE FUNCTION public.login(usu character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
	
	usu1 character varying;
	pass1 character varying;
	
	BEGIN
		
		usu1 := (SELECT usuario FROM usuario where usuario=usu AND password=pass);
		pass1 := (SELECT password FROM usuario where usuario=usu AND password=pass);

		IF usu = usu1 AND pass = pass1 THEN 
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
		END;
		$$;",11junio.sql
"CREATE FUNCTION public.login(usu character varying, pass character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	DECLARE
	
	usu1 character varying;
	pass1 character varying;
	
	BEGIN
		
		usu1 := (SELECT usuario FROM usuario where usuario=usu AND password=pass);
		pass1 := (SELECT password FROM usuario where usuario=usu AND password=pass);

		IF usu = usu1 AND pass = pass1 THEN 
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
		END;
		$$;",12junio.sql
"CREATE FUNCTION public.makeusername(firstname text, lastname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN LOWER(SUBSTRING(firstname, 1,1) || lastname);
END;
$$;",all.sql
"CREATE FUNCTION public.makeusername(firstname text, lastname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN SUBSTRING(firstname, 1,1) || lastname;
END;
$$;",TechCertificate.sql
"CREATE FUNCTION public.makeusername(firstname text, lastname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
BEGIN
RETURN SUBSTRING(firstname, 1,1) || lastname;
END;
$$;",all.sql
"CREATE FUNCTION public.measure_exec_time(sql_txt character varying, OUT ""elapsed_time [ms]"" real) RETURNS real
    LANGUAGE plpgsql
    AS $$ 
declare
t0 timestamptz;
t1 timestamptz;

begin
CHECKPOINT; --DBCC DROPCLEANBUFFERS; DBCC FREEPROCCACHE; v sql 2016
t0 := clock_timestamp();
execute sql_txt;-- queries
t1 := clock_timestamp();
""elapsed_time [ms]"" := 1000*(extract(epoch from t1)-extract(epoch from t0));
end;

$$;",testdb.dump
"CREATE FUNCTION public.obtenerpass(rut_u integer, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$ 

DECLARE 

    PASS_U VARCHAR(100);

BEGIN

    IF ISNUMERIC(RUT_U) THEN

        PASS_U := GETPASS(RUT_U);

        IF(PASS_U!='FALSE') THEN

            BOOL := 'TRUE';

            MESSAGE := PASS_U;

        ELSE

            BOOL := 'FALSE';

            MESSAGE := 'EL USUARIO NO EXISTE';

        END IF;

    ELSE

        BOOL := 'FALSE';

        MESSAGE := 'EL VALOR DEL RUT DEBE SER NUMÉRICO';

    END IF;

    RETURN;

    EXCEPTION

        WHEN insufficient_privilege THEN

            BOOL := 'FALSE';

            MESSAGE := 'NO TIENE PRIVILEGIOS PARA OBTENER LA CONTRASEÑA';

            RETURN;

        WHEN OTHERS THEN

            BOOL := 'FALSE';

            MESSAGE := SQLERRM;

            RETURN;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.obtenerpassadmin(rut_u integer, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$ 

DECLARE 

    PASS_U VARCHAR(100);

BEGIN

    IF ISNUMERIC(RUT_U) THEN

        PASS_U := GETPASSADMIN(RUT_U);

        IF(PASS_U!='FALSE') THEN

            BOOL := 'TRUE';

            MESSAGE := PASS_U;

        ELSE

            BOOL := 'FALSE';

            MESSAGE := 'EL USUARIO NO EXISTE';

        END IF;

    ELSE

        BOOL := 'FALSE';

        MESSAGE := 'EL VALOR DEL RUT DEBE SER NUMÉRICO';

    END IF;

    RETURN;

    EXCEPTION

        WHEN insufficient_privilege THEN

            BOOL := 'FALSE';

            MESSAGE := 'NO TIENE PRIVILEGIOS PARA OBTENER LA CONTRASEÑA';

            RETURN;

        WHEN OTHERS THEN

            BOOL := 'FALSE';

            MESSAGE := SQLERRM;

            RETURN;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.password_validate(character varying, character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_entity_id			integer;
	v_entity_password	varchar(64);
BEGIN

	SELECT entity_id, entity_password INTO v_entity_id, v_entity_password
	FROM entitys WHERE (user_name = $1);

	IF(v_entity_id is null)THEN
		v_entity_id = -1;
	ELSIF(md5($2) != v_entity_password) THEN
		v_entity_id = -1;
	END IF;

	return v_entity_id;
END;
$_$;",hschool.sql
"CREATE FUNCTION public.predict_land(culture_name character varying, amount_of_planted_lands integer) RETURNS TABLE(culture character varying, amount_of_planted numeric, amount_of_necessary_products integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE 
am_of_zem Numeric[];
am_of_prdt Varchar[];
prod_koef Numeric[];
koef Numeric;
BEGIN

prod_koef = array(SElECT((SUM(inv.amount)::numeric)/(pc.amount_of_planted_lands_in_ha)::numeric) as division
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
GROUP by prplc.plant_culture_id, pc.amount_of_planted_lands_in_ha
ORDER BY prplc.plant_culture_id);

am_of_prdt = array(SElECT pc.culture_name
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
GROUP by pc.culture_name, pc.amount_of_planted_lands_in_ha
ORDER BY pc.culture_name);

For i in 1..array_length(prod_koef, 1) LOOP
	if(culture_name = am_of_prdt[i]) THEN koef = prod_koef[i]; END IF;
	
	
END LOOP;
amount_of_necessary_products = $2 * koef;
amount_of_planted = $2;
culture = $1;
RETURN NEXT;
end
$_$;",agromir2
"CREATE FUNCTION public.predict_land(culture_name character varying, amount_of_planted_lands integer) RETURNS TABLE(culture character varying, amount_of_planted numeric, amount_of_necessary_products integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE 
am_of_zem Numeric[];
am_of_prdt Varchar[];
prod_koef Numeric[];
koef Numeric;
BEGIN

prod_koef = array(SElECT((SUM(inv.amount)::numeric)/(pc.amount_of_planted_lands_in_ha)::numeric) as division
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
GROUP by prplc.plant_culture_id, pc.amount_of_planted_lands_in_ha
ORDER BY prplc.plant_culture_id);

am_of_prdt = array(SElECT pc.culture_name
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
GROUP by pc.culture_name, pc.amount_of_planted_lands_in_ha
ORDER BY pc.culture_name);

For i in 1..array_length(prod_koef, 1) LOOP
	if(culture_name = am_of_prdt[i]) THEN koef = prod_koef[i]; END IF;
	
	
END LOOP;
amount_of_necessary_products = $2 * koef;
amount_of_planted = $2;
culture = $1;
RETURN NEXT;
end
$_$;",agromir_11_06
"CREATE FUNCTION public.predict_land(culture_name character varying, amount_of_planted_lands integer) RETURNS TABLE(culture character varying, amount_of_planted numeric, amount_of_necessary_seeds integer, amount_of_necessary_fert integer, amount_of_necessary_plant integer)
    LANGUAGE plpgsql
    AS $_$
DECLARE 
am_of_zem Numeric[];
am_of_prdt Varchar[];
prod_koef_seeds Numeric[];
prod_koef_fert Numeric[];
prod_koef_plant Numeric[];
koef_seeds Numeric;
koef_fert Numeric;
koef_plant Numeric;
BEGIN

prod_koef_seeds = array(SElECT((SUM(inv.amount)::numeric)/(pc.amount_of_planted_lands_in_ha)::numeric) as division
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
Where pr.type = 'Seeds'
GROUP by prplc.plant_culture_id, pc.amount_of_planted_lands_in_ha
ORDER BY prplc.plant_culture_id);

prod_koef_fert = array(SElECT((SUM(inv.amount)::numeric)/(pc.amount_of_planted_lands_in_ha)::numeric) as division
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
Where pr.type = 'Fertilizers'
GROUP by prplc.plant_culture_id, pc.amount_of_planted_lands_in_ha
ORDER BY prplc.plant_culture_id);

prod_koef_plant = array(SElECT((SUM(inv.amount)::numeric)/(pc.amount_of_planted_lands_in_ha)::numeric) as division
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
Where pr.type = 'Plant Protectors'
GROUP by prplc.plant_culture_id, pc.amount_of_planted_lands_in_ha
ORDER BY prplc.plant_culture_id);

am_of_prdt = array(SElECT pc.culture_name
FROM (((plant__cultures as pc JOIN product__plant__cultures as prplc
ON pc.plant_culture_id = prplc.plant_culture_id) JOIN products as pr
ON prplc.product_id = pr.product_id)join invoice__products as inv
ON pr.product_id = inv.product)
GROUP by pc.culture_name, pc.amount_of_planted_lands_in_ha
ORDER BY pc.culture_name);

For i in 1..array_length(prod_koef_seeds, 1) LOOP
	if(culture_name = am_of_prdt[i]) THEN koef_seeds = prod_koef_seeds[i]; END IF;
END LOOP;
For i in 1..array_length(prod_koef_fert, 1) LOOP
	if(culture_name = am_of_prdt[i]) THEN koef_fert = prod_koef_fert[i]; END IF;
END LOOP;
For i in 1..array_length(prod_koef_plant, 1) LOOP
	if(culture_name = am_of_prdt[i]) THEN koef_plant = prod_koef_plant[i]; END IF;
END LOOP;
amount_of_necessary_seeds = $2 * koef_seeds;
amount_of_necessary_fert = $2 * koef_fert;
amount_of_necessary_plant = $2 * koef_plant;
amount_of_planted = $2;
culture = $1;
RETURN NEXT;
end
$_$;",Version%208.11.2018%20(mayaki_fields)
"CREATE FUNCTION public.proc_getstuffings(productorderid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
		BEGIN 
			Select *
		FROM Ingredients 

		WHERE IngredientID IN
			(SELECT Stuffings.IngredientID
			FROM ProductOrders, Stuffings
			Where ProductOrders.ProductOrderID = ProductOrderID
				and
				ProductOrders.ProductOrderID = Proc_GetStuffings.ProductOrderID);
		END;
		$$;",G3Systems_Alpha2.sql
"CREATE FUNCTION public.proc_openorders(buildingid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
		BEGIN 
			SELECT ProductOrderID, ProductName,PrepTime
	FROM (SELECT ProductOrderID, ProductID
		 FROM ProductOrders
		 WHERE LockedByStation IS NULL and
				Processed =0 and
				Activated=true and
				Visible=true and

		 OrderID in ( SELECT OrderID 
				FROM Orders
				WHERE Orders.Paid = true and
						Orders.Canceled=false and
						Orders.Activated=true and
						Orders.Visible=true and
						Orders.PickedUp=false and
						Orders.Returned=false and

						Orders.ByTerminal IN 
							(SELECT TerminalID
							FROM Terminals
							WHERE Terminals.BuildingID = BuildingID)
					 )) as POProds JOIN Products on Products.ProductID=POProds.ProductID;
		END;
		$$;",G3Systems_Alpha2.sql
"CREATE FUNCTION public.proc_polockedbystation(stationid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
		BEGIN 
			SELECT *
		FROM ProductOrders
		WHERE LockedByStation = StationID;
		END;
		$$;",G3Systems_Alpha2.sql
"CREATE FUNCTION public.pxgetean13(tmpcd character) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
  declare ProdCD char(13);
  declare CDigit char(1);
  declare i integer;
  declare step1 integer;
  declare step2 integer;
  declare sum integer;
  declare factor_ integer;
  BEGIN
    ProdCD = '';
    if len(tmpCD) <> 12 then
      ProdCD = tmpCD;
    else
      i = 12; --(len(tmpCD)
      sum = 0;
      factor_ = 3;
      while i >= 1 loop
        sum = sum+(cast(SUBSTRING(tmpCD,i,1) as integer)*factor_);
        i = i-1;
        factor_ = 4-factor_;
      end loop;
      CDigit = remainder((1000-sum),10);
      ProdCD = tmpCD+cast(CDigit as char(1));
    end if;
    return ProdCD;
  END;
$$;",V20190115.1.0.0__Skema_Awal.sql
"CREATE FUNCTION public.query_dati(pwd character, mail character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

BEGIN
IF (EXISTS (SELECT *
		   FROM utente
		   WHERE password_hash = pwd AND email = mail ))
THEN RETURN TRUE;
ELSE RETURN FALSE;
END IF;
END;

$$;",db8.sql
"CREATE FUNCTION public.random_between(low integer, high integer) RETURNS integer
    LANGUAGE plpgsql STRICT
    AS $$
BEGIN
   RETURN floor(random()* (high-low + 1) + low);
END;
$$;",createSchema.sql
"CREATE FUNCTION public.recuperar_schema_temp() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
			DECLARE
			   schemas varchar;
			   pos_inicial int4;
			   pos_final int4;
			   schema_temp varchar;
			BEGIN
			   schema_temp := '';
			   SELECT INTO schemas current_schemas(true);
			   SELECT INTO pos_inicial strpos(schemas, 'pg_temp');
			   IF (pos_inicial > 0) THEN
			      SELECT INTO pos_final strpos(schemas, ',');
			      SELECT INTO schema_temp substr(schemas, pos_inicial, pos_final - pos_inicial);
			   END IF;
			   RETURN schema_temp;
			END;
			$$;",sicd_public.sql
"CREATE FUNCTION public.refresh_data_sets_ts_data() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  did uuid;
  count INTEGER := 0;
begin
  FOR did IN SELECT id FROM source_data_sets LOOP
    PERFORM refresh_data_sets_ts_data(did);
    count := count + 1;
  END LOOP;
  RETURN count;
end
$$;",Clean-05-09-2020-plain-sql.backup
"CREATE FUNCTION public.refresh_des_ts_data() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	did uuid;
	count INTEGER := 0;
begin
	FOR did IN SELECT uuid FROM data_elements LOOP
		PERFORM refresh_de_ts_data(did);
		count := count + 1;
	END LOOP;
	RETURN count;
end
$$;",Clean-05-09-2020-plain-sql.backup
"CREATE FUNCTION public.refresh_external_des_ts_data() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	did INTEGER;
	count INTEGER := 0;
begin
	FOR did IN SELECT id FROM de_external_defs LOOP
		PERFORM refresh_external_de_ts_data(did);
		count := count + 1;
	END LOOP;
	RETURN count;
end
$$;",Clean-05-09-2020-plain-sql.backup
"CREATE FUNCTION public.refresh_translations_ts_data() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  did INTEGER;
  count INTEGER := 0;
begin
  FOR did IN SELECT id FROM translation_definitions LOOP
    PERFORM refresh_translations_ts_data(did);
    count := count + 1;
  END LOOP;
  RETURN count;
end
$$;",Clean-05-09-2020-plain-sql.backup
"CREATE FUNCTION public.reverse_hostname(hostname text) RETURNS text
    LANGUAGE plpgsql
    AS $$
  begin
    return array_to_string(array_reverse(hostname_split(hostname)), '.');
  end;
$$;",pgdumpall.txt.sql
"CREATE FUNCTION public.sameadminmatch(bigint, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(
		select * from bdproject.matches
		where id = $1 and admin = $2
		);
end;


$_$;",pgbak.sql
"CREATE FUNCTION public.sameadmintournaments(character varying, character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
begin
	return exists(
		select * from bdproject.tournaments
		where name = $1 and manager = $2
		);
end;


$_$;",pgbak.sql
"CREATE FUNCTION public.set_sequence_starts() RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE
    seq VARCHAR;
    next_val BIGINT;
    min_val BIGINT := 1000;
BEGIN
    RAISE NOTICE 'Setting values of sequences to minimum value...';

    FOR seq IN SELECT c.relname FROM pg_class c WHERE c.relkind = 'S' LOOP
        next_val := nextval(seq);
        RAISE NOTICE 'Found sequence % with next value = %', seq, next_val;
        IF next_val < min_val THEN
            RAISE NOTICE 'Increasing value of sequence % to %', seq, min_val;
            EXECUTE 'SELECT setval($1, $2)' USING seq, min_val;
        END IF;
    END LOOP;

    RAISE NOTICE 'Finished setting values of sequences to minimum value';
    RETURN;
END;
$_$;",orcid4.sql
"CREATE FUNCTION public.sis_accesos_rol_usuario(pusuario character varying, ptabla character varying, pmodulo character varying, OUT res character varying, OUT cod character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
 DECLARE
     vrol varchar; --almacenamos el roll del usuario
     vempresa varchar; --almacenamos la empresa a la que corresponde el usuario
     vfila RECORD;
	vtipo_rol varchar;
 BEGIN
 	select rol,empresa into vrol,vempresa from sis_usuario where codigo=pusuario;
 	select mostrar into vtipo_rol from sis_rol_usuario where codigo=vrol;
	-- si rol = 1 es administrador de debe acceder a todas la empresas
	-- si rol = 15 es un TICs ZONAL deben aparecer solo las empresas de la zona
	-- si rol = 16 es un TICs DISTRITAL solo debe aparece la empresa del distrito
	-- si no esta entre esos codigo no se debe poder acceder a nada
	res='SI';
	--res=vrol;
	--cod=vtipo_rol;
	--return query select  res, cod;
	if pmodulo ='gd_empresa' then-- es el caso de la modulo empresa
		if vrol= '1' then
			res='SI';cod='';
			return query select  res, cod;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;

	if ptabla ='gd_empresa' then-- es el caso de la tabla empresa
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM gd_empresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '15' then -- tics zonal select codigo from gd_empresa where empresa_padre=(select empresa_padre from gd_empresa where codigo=vempresa)
			FOR vfila IN SELECT codigo FROM gd_empresa where borrado='N' and empresa_padre=(select case tipo when 'ZO' then codigo else empresa_padre end as codi from gd_empresa where codigo=vempresa) or codigo=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '16' then -- tics distrittal
			FOR vfila IN SELECT codigo FROM gd_empresa where codigo=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;
	if ptabla ='gd_empresa_inf' then-- es el caso de la tabla empresa
		if vtipo_rol= 'N' then -- USUARIO NACIONAL
			FOR vfila IN SELECT codigo FROM gd_empresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vtipo_rol= 'Z' then -- tics zonal select codigo from gd_empresa where empresa_padre=(select empresa_padre from gd_empresa where codigo=vempresa)
			FOR vfila IN SELECT codigo FROM gd_empresa where borrado='N' and empresa_padre=(select case tipo when 'ZO' then codigo else empresa_padre end as codi from gd_empresa where codigo=vempresa) or codigo=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vtipo_rol= 'D' then -- tics distrittal U HOSPITAL
			FOR vfila IN SELECT codigo FROM gd_empresa where codigo=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;
	if ptabla ='gd_empresa_tipo' then-- es el caso de la tabla empresa - se utiliza en modulo de empresa en opcion de emprsa_padre
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM gd_empresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '15' then -- tics zonal
			FOR vfila IN SELECT codigo FROM gd_empresa where codigo=(select case tipo when 'ZO' then codigo else empresa_padre end as codi from gd_empresa where codigo=vempresa) LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '16' then -- tics distrittal
			FOR vfila IN SELECT codigo FROM gd_empresa where codigo=vempresa or empresa_padre=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;
	if ptabla ='sis_rol_usuario' then-- es el caso de la de roles solo se mostraran en caso de que el suaurio se tipo administrador
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM sis_rol_usuario LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;
	if ptabla ='gd_persona' then-- es el caso de la tabla gd_persona todos los roles de tipo administrador tendran acceso a todos los funcionarios
		if vrol= '1' or vrol= '15' or vrol = '16' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM gd_persona LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
		--if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;
	if ptabla ='sis_usuario' then-- es el caso de la tabla empresa
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM sis_usuario LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '15' then -- tics zonal
			FOR vfila IN SELECT codigo FROM sis_usuario where rol in(select codigo from sis_rol_usuario where mostrar in ('Z','D') ) 	AND ( empresa in (select codigo from gd_empresa where empresa_padre=(select case tipo when 'ZO' then codigo else empresa_padre end as codi from gd_empresa where codigo=vempresa)) or empresa=vempresa ) LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '16' then -- tics distrittal
			FOR vfila IN SELECT codigo FROM sis_usuario where (rol in(select codigo from sis_rol_usuario where mostrar in ('D') )) or  empresa=vempresa LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;
	if ptabla ='sis_rol_usuario_tipo' then-- es el caso de la tabla de roles - utiliza en el modulo de usuarios en la opcion de escoger roles
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM sis_rol_usuario LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '15' then -- tics zonal
			FOR vfila IN SELECT codigo FROM sis_rol_usuario where codigo not in('1') LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if vrol= '16' then -- tics distrittal
			FOR vfila IN SELECT codigo FROM sis_rol_usuario where codigo in('13','16','9') LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		end if;
		if res='SI' then res='NO';cod='';return query select  res, cod; end if;
	end if;

	if ptabla ='sis_modulos' or ptabla ='gd_modulos' then-- es el caso de la de roles solo se mostraran en caso de que el suaurio se tipo administrador
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM sis_modulos LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;
	
	if ptabla ='sis_configuracion' or ptabla='gd_sistema' then-- es el caso de la de roles solo se mostraran en caso de que el suaurio se tipo administrador
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM sis_configuracion LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;
	
	if ptabla ='gd_tipo_contenedor' then-- es el caso de la de roles solo se mostraran en caso de que el suaurio se tipo administrador
		if vrol= '1' then -- ADMINISTRADOR
			FOR vfila IN SELECT codigo FROM gd_tipo_contenedor LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;
	if ptabla ='gd_tipo_documento' then-- es el caso de la de roles solo se mostraran en caso de que el suaurio se tipo administrador
		if vrol= '1' or vrol= '8' or vrol= '12' then -- ADMINISTRADOR o RESPONSABLE ARCHIVO ZONAL o SECRETARIA GENERAL
			FOR vfila IN SELECT codigo FROM gd_tipo_documento LOOP
				res='';
				cod=vfila.codigo;
				return query select  res, cod;	
			END LOOP;
		else
			res='NO';
			cod='';
			return query select  res, cod;
		end if;
	end if;
	if res='SI' then res='';cod='';return query select  res, cod; end if;
	return; -- query select  res, cod;
	--select * from sis_accesos_rol_usuario('2','gd_empresa_inf','')
       
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.sis_genera_menu(pcodigo character varying, ppadre character varying, nivel integer, pdirec character varying, OUT res character varying, OUT codi character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE    
	fila RECORD;
	fila2 RECORD;
	fila3 RECORD;
BEGIN
	codi:='';
	IF nivel=0 THEN
		res:='<li data-options=""iconCls:''app_network'',state:''open''""><span>Sistema Inventario</span><ul>';
		return query select res,codi;
		FOR fila3 IN select mo3.res as res3 from sis_genera_menu(pcodigo,'-1',1,pdirec) AS mo3 LOOP
					res:=fila3.res3;
					return Query Select res,codi;
		END LOOP;
		res:='</ul></li>';
		return query select res,codi;
	
	ELSE		
		IF nivel=1 THEN --
			FOR fila IN SELECT codigo, nombre,dir_img from sis_modulos where padre='-1' and codigo<>'-1' and tipo='M' and codigo in(select distinct cod from sis_get_modulos_roll(pcodigo))  order by orden LOOP
				res:='<li data-options=""iconCls:''' || fila.dir_img ||''',state:''closed''""><span>'|| fila.nombre||'</span><ul>';
				--res:='<li class=""current"" > <a href=""javascript:void(0)"" ><img  src=''' || pdirec || fila.dir_img ||''' style="" position:absolute;  border:none; top:3px; left:4px; width: 20px; height:20;"">'|| fila.nombre||'</a><ul>';
				return query select res,codi;
				FOR fila2 IN select mo.res as res2 from sis_genera_menu(pcodigo,fila.codigo,2,pdirec) as mo LOOP
					res:=fila2.res2;
					return Query Select res,codi;
				END LOOP;
				res:='</ul></li>';
				return Query Select res,codi;
			END LOOP;
		ELSE --class=""current""
			FOR fila IN SELECT pagina, nombre,codigo,tipo,dir_img,referencia FROM sis_modulos where padre=ppadre and codigo in(select distinct cod from sis_get_modulos_roll(pcodigo)) order by orden  LOOP
				res:='<li data-options=""iconCls:''' || fila.dir_img ||''',state:''closed''""><span><a href=""javascript:void(0)""';
				IF fila.tipo='I' then
				 res:='<li data-options=""iconCls:''' || fila.dir_img ||'''""><span><a href=""javascript:void(0)""';
				 res:=res || 'onclick=""Muestrac_Contenido_principal(''' || fila.pagina ||''',''' || fila.referencia ||''')""';
				end if;
				res:=res || '>'||fila.nombre ||'</a></span>';
				return query select res,codi;
				if fila.tipo='M' then	
					res:='<ul>';
					return query select res,codi;
					FOR fila2 IN select mo.res as res2 from sis_genera_menu(pcodigo,fila.codigo,2,pdirec) AS mo LOOP
						res:=fila2.res2;
						return Query Select res,codi;
					END LOOP;
					res:='</ul>';
					return query select res,codi;
				end if;
				res:='</li>';
				return Query Select res,codi;
			END LOOP;
		END IF;
	END IF;
	RETURN;
	-- select * from genera_menu('1','-1',0,'archivo_virtual')
END;
$$;",esquemaDB.backup
"CREATE FUNCTION public.sis_mi_acendencia(pcodigo character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
 DECLARE
      mi_nombre varchar;
     mi_padre varchar;
 BEGIN

	select padre,nombre into mi_padre,mi_nombre from sis_modulos where codigo=pcodigo;
	if mi_padre<>'-1' then
		return sis_mi_acendencia(mi_padre) || '-->' || mi_nombre;
	else
		return mi_nombre;
	end if;
	
 END;
 $$;",esquemaDB.backup
"CREATE FUNCTION public.spdetsel(codp character, opc character) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE variable1 VARCHAR(4) default NULL;
DECLARE varbool BOOLEAN default false;
BEGIN
    variable1 = (SELECT id FROM public.opcxperfil WHERE codperfil = codp AND codopc = opc);
    IF (variable1 ISNULL) THEN
        varbool = false;
    ELSE
        varbool = true;
    END IF;
    RETURN varbool;
END; 
$$;",datos.sql
"CREATE FUNCTION public.spdetsel(codp character, opc character) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE variable1 VARCHAR(4) default NULL;
DECLARE varbool BOOLEAN default false;
BEGIN
    variable1 = (SELECT id FROM public.opcxperfil WHERE codperfil = codp AND codopc = opc);
    IF (variable1 ISNULL) THEN
        varbool = false;
    ELSE
        varbool = true;
    END IF;
    RETURN varbool;
END; 
$$;",sicfojy-24-10-2018.sql
"CREATE FUNCTION public.spgetproductingredients(productid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
	BEGIN
	SELECT * FROM Ingredients as I
			JOIN ProductHaveIngredients as PHI
			ON PHI.IngredientID = I.IngredientID
			WHERE PHI.ProductID = p_ProductID;
	END;
	$$;",G3Systems_Alpha2.sql
"CREATE FUNCTION public.spverifylogin(p_username character varying, p_password character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$

		begin
			SELECT EmployeeID, Username FROM Employees WHERE
			CAST(Username as bytea) = CAST(p_Username as bytea)
			AND CAST(Password as bytea) = CAST(p_Password as bytea)
			AND Username = p_Username 
			AND Password = p_Password;
		end;
$$;",G3Systems_Alpha2.sql
"CREATE FUNCTION public.sumar_dias_disponible_por_mes(character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_dias_disponible) FROM viatico
    WHERE mes = $1) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumar_dias_disponible_por_mes(character, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_dias_disponible) FROM viatico
    WHERE 
	mes = $1 and
	viatico.idpersona = $2
    ) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumar_dias_disponible_por_mes(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_dias_disponible) FROM viatico
    WHERE mes = $1) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumar_horas() RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		tipo = 'horas' and
  		activo =true and
  		historico = false) ;
    
    RETURN total;
END;
$$;",sicd_public.sql
"CREATE FUNCTION public.sumar_horas(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
	     
              WHERE
  		tipo ilike 'horas' and
  		activo =true and
  		historico = false and
  		idpersona = $1
  		group by
		bloque) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumar_horas(integer, character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
	     
              WHERE
  		tipo ilike 'horas' and
  		activo =true and
  		historico = false and
  		idpersona = $1 and
  		bloque= $2
  		) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumas_horas_segun_tipo(character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		cargo_por_persona.idtipo_hora  = $1 and
  		activo =true) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumas_horas_segun_tipo(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		cargo_por_persona.idtipo_hora is not null and
  		activo = true and 
  		historico = false and
  		cargo_por_persona.idpersona = $1) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumas_horas_segun_tipo(integer, character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		cargo_por_persona.idtipo_hora is not null and
  		activo = true and 
  		historico = false and
  		cargo_por_persona.idpersona = $1 and
  		bloque = $2) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumas_horas_segun_tipo(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		cargo_por_persona.idpersona  = $1 and
  		cargo_por_persona.idtipo_hora = $2 and
  		activo =true) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.sumas_horas_segun_tipo(integer, integer, character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	total numeric;
BEGIN
    total := (SELECT sum(cantidad_horas) as total_horas
	      FROM cargo_por_persona
              WHERE
  		cargo_por_persona.idpersona  = $1 and
  		cargo_por_persona.idtipo_hora = $2 and
  		activo =true and
  		bloque = $3) ;
    
    RETURN total;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.system_user_find_all() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select su.id,
  su.name,
  su.family,
  su.e_mail,
  su.password,
  b.id      as b_id,
  b.name    as b_name,
  b.address as b_address,
  s.id      as s_id,
  s.name    as s_name
from system_users su,
  branches b,
  subdivisions s
where su.branch_id = b.id
      and su.subdivision_id = s.id;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.system_user_findby_email(s_email character varying) RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select su.id,
  su.name,
  su.family,
  su.e_mail,
  su.password,
  b.id      as b_id,
  b.name    as b_name,
  b.address as b_address,
  s.id      as s_id,
  s.name    as s_name
from system_users su,
  branches b,
  subdivisions s
where su.branch_id = b.id
      and su.subdivision_id = s.id
      and su.e_mail = s_email;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.system_user_findbyid(p_id integer) RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select su.id,
  su.name,
  su.family,
  su.e_mail,
  su.password,
  b.id      as b_id,
  b.name    as b_name,
  b.address as b_address,
  s.id      as s_id,
  s.name    as s_name
from system_users su,
  branches b,
  subdivisions s
where su.branch_id = b.id
      and su.subdivision_id = s.id
      and su.id = p_id;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.tak_find_all_for_short_operator() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select
  t.id      as id_task,
  t.name    as t_name,
  su.name   as user_name,
  su.family as user_family,
  sd.name as subdivision,
  st.name as status
from tasks t, system_users su, subdivisions sd, status st
where t.system_user_id = su.id and t.status_id = st.id and   su.subdivision_id = sd.id  and operator_id = 294;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.task_find_all_for_operator() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select
  t.id      as t_id,
  t.name    as t_name,
  t.text,
  t.system_user_id,
  su.name   as su_name,
  su.family as su_family,
  su.subdivision_id,
  sd.name as sd_name,
  t.status_id,
  st.name as status,
  t.executor_id,
  t.operator_id

from tasks t, system_users su, subdivisions sd, status st
where t.system_user_id = su.id and t.status_id = st.id and su.subdivision_id = sd.id  and operator_id = 294;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.tasks_find_all() RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select t.id,
  t.name,
  t.text,
  l.id     as l_id,
  l.name   as l_name,
  s.id     as s_id,
  s.name   as s_name,
  s.family as s_family,
  s.e_mail as s_email,
  s.branch_id,
  s.subdivision_id,
  st.id    as st_status_id,
  st.name as st_name
from tasks t,
  listeners l,
  system_users s,
  status st
where t.listener_id = l.id
      and t.system_user_id = s.id
      and t.status_id = st.id;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.tasks_findbyid(p_id integer) RETURNS refcursor
  LANGUAGE plpgsql
AS $$
  DECLARE
  ref refcursor;
BEGIN
OPEN ref FOR
select t.id,
  t.name,
  t.text,
  l.id     as l_id,
  l.name   as l_name,
  s.id     as s_id,
  s.name   as s_name,
  s.family as s_family,
  s.e_mail as s_email,
  s.branch_id,
  s.subdivision_id,
  st.id    as st_status_id,
  st.name as st_name
from tasks t,
  listeners l,
  system_users s,
  status st
where t.listener_id = l.id
      and t.system_user_id = s.id
      and t.id = p_id
      and t.status_id = st.id;
RETURN ref;
END;
$$;",postgres_LK
"CREATE FUNCTION public.test_function(request character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

    DECLARE

        response varchar = '';

    begin

	   response = concat('recieved: ', request);

	   RETURN response;

    END;

$$;",dump-postgres.sql
"CREATE FUNCTION public.top_average(n integer) RETURNS real
    LANGUAGE plpgsql
    AS $$
DECLARE
avg real;
total real;
BEGIN
SELECT AVG(price) INTO avg FROM (SELECT price FROM menu_items ORDER BY price DESC LIMIT n) AS p;
RETURN avg;
END;
$$;",output
"CREATE FUNCTION public.traer_fuente_financiamiento(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	fuente text;
BEGIN
    fuente := (SELECT 	 
			 
			nombre
		FROM 
			public.fuente_financiamiento
		where 
			idfuente_financiamiento =$1) ;
    
    RETURN fuente;
END;
$_$;",sicd_public.sql
"CREATE FUNCTION public.truncate_tables(username character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
    statements CURSOR FOR
        SELECT tablename FROM pg_tables
        WHERE tableowner = username AND schemaname = 'public';
BEGIN
    FOR stmt IN statements LOOP
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(stmt.tablename) || ' CASCADE;';
    END LOOP;
END;
$$;",script.backup
"CREATE FUNCTION public.unique_ingred_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('ingredients_num_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM ingredients WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",ev4.sql
"CREATE FUNCTION public.unique_ingred_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('ingredients_num_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM ingredients WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",food.sql
"CREATE FUNCTION public.unique_ingred_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('ingredients_num_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM ingredients WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",new.sql
"CREATE FUNCTION public.unique_ingred_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('ingredients_num_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM ingredients WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",prod.sql
"CREATE FUNCTION public.unique_sku_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('sku_num_seq'::regclass) val 
   WHERE  NOT EXISTS (SELECT 1 FROM sku WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",ev4.sql
"CREATE FUNCTION public.unique_sku_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('sku_num_seq'::regclass) val 
   WHERE  NOT EXISTS (SELECT 1 FROM sku WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",food.sql
"CREATE FUNCTION public.unique_sku_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('sku_num_seq'::regclass) val 
   WHERE  NOT EXISTS (SELECT 1 FROM sku WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",new.sql
"CREATE FUNCTION public.unique_sku_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('sku_num_seq'::regclass) val 
   WHERE  NOT EXISTS (SELECT 1 FROM sku WHERE num = val);

   EXIT WHEN FOUND;
END LOOP; 
END
$$;",prod.sql
"CREATE FUNCTION public.unique_users_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('users_id_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM users WHERE id = val);
   EXIT WHEN FOUND;
END LOOP; 
END
$$;",ev4.sql
"CREATE FUNCTION public.unique_users_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('users_id_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM users WHERE id = val);
   EXIT WHEN FOUND;
END LOOP; 
END
$$;",food.sql
"CREATE FUNCTION public.unique_users_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('users_id_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM users WHERE id = val);
   EXIT WHEN FOUND;
END LOOP; 
END
$$;",new.sql
"CREATE FUNCTION public.unique_users_num_seq(OUT nextfree bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
LOOP
   SELECT INTO nextfree val
   FROM   nextval('users_id_seq'::regclass) val
   WHERE  NOT EXISTS (SELECT 1 FROM users WHERE id = val);
   EXIT WHEN FOUND;
END LOOP; 
END
$$;",prod.sql
"CREATE FUNCTION public.utilidadproducto(inpt integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
utilidad decimal(6,2);
BEGIN
SELECT p.precioVenta-p.precio_adquirido INTO utilidad
FROM producto p
WHERE p.codigoBarras = inpt;
RETURN utilidad;
END; $$;",dump(1).sql
"CREATE FUNCTION public.validacion(numerico character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    truerut VARCHAR(9);

    digito INT := 0;

    suma INT := 0;

    digitof INT :=0;

    largo INT;

BEGIN

    largo := LENGTH(NUMERICO);

    IF(largo=8) THEN

        TRUERUT := LPAD(NUMERICO,9,'0'); --agrega ceros al comienzo hasta alcanzar un lenght de 9

    ELSE

        TRUERUT := NUMERICO;

    END IF;

    digito := SUBSTR(TRUERUT,9,1);

    suma := SUBSTR(TRUERUT,1,1) * 3;

    suma := (suma + SUBSTR(TRUERUT,2,1) * 2);

    suma := (suma + SUBSTR(TRUERUT,3,1) * 7);

    suma := (suma + SUBSTR(TRUERUT,4,1) * 6);

    suma := (suma + SUBSTR(TRUERUT,5,1) * 5);

    suma := (suma + SUBSTR(TRUERUT,6,1) * 4);

    suma := (suma + SUBSTR(TRUERUT,7,1) * 3);

    suma := (suma + SUBSTR(TRUERUT,8,1) * 2);

    WHILE (suma > 11) LOOP 

      suma := suma - 11; 

    END LOOP; 

    digitof := (11 - suma);

    IF (digitof=10) THEN

      digitof:= 0;

    END IF;

    IF (digitof=digito) THEN

      RETURN TRUE;

    ELSE

      RETURN FALSE;

    END IF;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.validacion(numerico integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    truerut VARCHAR(9);

    digito INT := 0;

    suma INT := 0;

    digitof INT :=0;

    largo INT;

BEGIN

    largo := LENGTH(CAST(NUMERICO AS VARCHAR));

    IF(largo=8) THEN

        TRUERUT := LPAD(CAST(NUMERICO AS VARCHAR),9,'0'); --agrega ceros al comienzo hasta alcanzar un lenght de 9

    ELSE

        TRUERUT := NUMERICO;

    END IF;

    digito := SUBSTR(TRUERUT,9,1);

    suma := CAST(SUBSTR(TRUERUT,1,1) AS INT) * 3;

    suma := (suma + CAST(SUBSTR(TRUERUT,2,1) AS INT) * 2);

    suma := (suma + CAST(SUBSTR(TRUERUT,3,1) AS INT) * 7);

    suma := (suma + CAST(SUBSTR(TRUERUT,4,1) AS INT) * 6);

    suma := (suma + CAST(SUBSTR(TRUERUT,5,1) AS INT) * 5);

    suma := (suma + CAST(SUBSTR(TRUERUT,6,1) AS INT) * 4);

    suma := (suma + CAST(SUBSTR(TRUERUT,7,1) AS INT) * 3);

    suma := (suma + CAST(SUBSTR(TRUERUT,8,1) AS INT) * 2);

    WHILE (suma > 11) LOOP 

      suma := suma - 11; 

    END LOOP; 

    digitof := (11 - suma);

    IF (digitof=10) THEN

      digitof:= 0;

    END IF;

    IF (digitof=digito) THEN

      RETURN TRUE;

    ELSE

      RETURN FALSE;

    END IF;

END; 

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.validar_login(rut_c integer, pass_c character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    VERIFICADOR BOOLEAN;

BEGIN

    SELECT PASS = CRYPT(PASS_C, PASS) INTO VERIFICADOR FROM USUARIO WHERE RUT = RUT_C;

    IF VERIFICADOR = TRUE THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION 

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.validar_login(usuario character varying, pass_c character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    VERIFICADOR BOOLEAN;

BEGIN

    SELECT PASS = CRYPT(PASS_C, PASS) INTO VERIFICADOR FROM USUARIO WHERE RUT = USUARIO;

    IF VERIFICADOR = TRUE THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION 

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.validar_login_admin(rut_c integer, pass_c character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    VERIFICADOR BOOLEAN;

BEGIN

    SELECT PASS = CRYPT(PASS_C, PASS) INTO VERIFICADOR FROM ADMINISTRADOR WHERE RUT = RUT_C;

    IF VERIFICADOR = TRUE THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

    EXCEPTION 

        WHEN NO_DATA_FOUND THEN

            RETURN FALSE;

        WHEN OTHERS THEN

            RETURN FALSE;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.verifica_herramienta_sucursal(codigo integer, codigo_s integer, empresa_s integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

DECLARE

    CONTADOR INT;

BEGIN

    SELECT COUNT(*) INTO CONTADOR FROM SUCURSAL_HERRAMIENTA 

    WHERE COD_HERRAMIENTA = CODIGO 

    AND COD_SUCURSAL = CODIGO_S

    AND EMPRESA = EMPRESA_S;

    IF (CONTADOR>0) THEN

        RETURN TRUE;

    ELSE

        RETURN FALSE;

    END IF;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.verifica_iscrizione_studente(mtrcl integer, cod_corso integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

BEGIN
	IF (EXISTS (SELECT *
		   FROM iscritto_a
		   WHERE matricola = mtrcl AND codice_corso = cod_corso ))
THEN RETURN TRUE;
ELSE RETURN FALSE;

END IF;
END;

$$;",db8.sql
"CREATE FUNCTION public.verifica_iscrizione_studente(mtrcl integer, cod_corso smallint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$

BEGIN
	IF (EXISTS (SELECT *
		   FROM iscritto_a
		   WHERE matricola = mtrcl AND codice_corso = cod_corso ))
THEN RETURN TRUE;
ELSE RETURN FALSE;

END IF;
END;

$$;",db8.sql
"CREATE FUNCTION public.verificar_comuna(rut_u integer, region_d integer, comuna_d integer, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$

DECLARE

    COMUNA_CARRO SUCURSAL.COMUNA%TYPE;

    CONTADOR1 INT := 0;

    CONTADOR2 INT := 0;

BEGIN

    SELECT S.COMUNA INTO COMUNA_CARRO FROM CARRITO C JOIN SUCURSAL S

    ON C.COD_SUCURSAL = S.COD_SUCURSAL

    WHERE C.RUT = RUT_U;

    SELECT COUNT(*) INTO CONTADOR1 FROM REGION WHERE REGION_ID = REGION_D;

    SELECT COUNT(*) INTO CONTADOR2 FROM COMUNA WHERE COMUNA_ID = COMUNA_D;

    IF CONTADOR1!=0 THEN

        IF CONTADOR2!=0 THEN            

            IF COMUNA_D!=COMUNA_CARRO THEN

                BOOL := 'TRUE';

                MESSAGE := 'CAMBIO DE COMUNA AUTORIZADO';

            ELSE

                BOOL := 'NULL';

                MESSAGE := 'NULL';

            END IF;

        ELSE

            BOOL := 'FALSE';

            MESSAGE := 'LA COMUNA INGRESADA NO EXISTE';

        END IF;

    ELSE

        BOOL := 'FALSE';

        MESSAGE := 'LA REGION INGRESADA NO EXISTE';

    END IF;

    RETURN;

    EXCEPTION 

        WHEN OTHERS THEN    

            BOOL := 'FALSE';

            MESSAGE := SQLERRM;

            RETURN;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.verificar_descuento(codigo_h integer, codigo_e integer, codigo_s integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

    DESCUENTO_H INT;

BEGIN

    SELECT DESCUENTO INTO DESCUENTO_H

    FROM SUCURSAL_HERRAMIENTA

    WHERE COD_HERRAMIENTA = CODIGO_H 

    AND COD_SUCURSAL = CODIGO_S

    AND EMPRESA = CODIGO_E

    AND NOW() BETWEEN F_INICIO_D AND F_FINAL_D;

    IF DESCUENTO_H IS NULL THEN

        RETURN 0;

    ELSE

        RETURN DESCUENTO_H;

    END IF;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.verificar_producto_venta(fecha_i date, fecha_f date, cod_s integer, cod_he integer, empresa_h integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$

DECLARE

    CANTIDADES INT;

    VERIFICADOR INT;

BEGIN

    CANTIDADES := 0;

    SELECT COUNT(*) INTO VERIFICADOR

    FROM SUCURSAL_HERRAMIENTA

    WHERE COD_HERRAMIENTA = COD_HE

    AND COD_SUCURSAL = COD_S;

    IF VERIFICADOR > 0 THEN    

        SELECT * INTO CANTIDADES FROM

        (SELECT SH.STOCK - SUM(D.CANTIDAD)

        FROM HERRAMIENTA H JOIN CATEGORIA C 

        ON H.COD_CATEGORIA=C.COD_CATEGORIA

        JOIN SUCURSAL_HERRAMIENTA SH

        ON H.COD_HERRAMIENTA = SH.COD_HERRAMIENTA

        AND H.EMPRESA = SH.EMPRESA

        JOIN SUCURSAL SU

        ON SH.COD_SUCURSAL = SU.COD_SUCURSAL

        FULL OUTER JOIN DETALLE D 

        ON D.COD_H = SH.COD_HERRAMIENTA

        AND D.EMPRESA = SH.EMPRESA

        AND D.COD_SUCURSAL = SH.COD_SUCURSAL

        JOIN EMPRESA E

        ON E.COD_EMPRESA = SU.COD_EMPRESA

        WHERE D.ID_A IN (SELECT A.COD_ARRIENDO FROM ARRIENDO A JOIN DETALLE D 

                            ON A.COD_ARRIENDO = D.ID_A JOIN SUCURSAL_HERRAMIENTA H

                            ON D.COD_H = H.COD_HERRAMIENTA

                            AND D.EMPRESA = H.EMPRESA

                            AND D.COD_SUCURSAL = H.COD_SUCURSAL

                            WHERE A.FECHA_INICIO BETWEEN FECHA_I AND FECHA_F

                            OR A.FECHA_FINAL BETWEEN FECHA_I AND FECHA_F

                            GROUP BY A.COD_ARRIENDO)

        AND SH.COD_SUCURSAL = COD_S

        AND SH.COD_HERRAMIENTA = COD_HE

        AND SH.EMPRESA = EMPRESA_H

        GROUP BY H.COD_HERRAMIENTA, H.NOMBRE, H.DESCRIPCION, H.URL_FOTO, SH.PRECIO, C.NOMBRE, H.EMPRESA, E.NOMBRE, SU.COD_SUCURSAL, SU.NOMBRE, SH.STOCK

        UNION 

        SELECT SH.STOCK

        FROM HERRAMIENTA H JOIN CATEGORIA C 

        ON H.COD_CATEGORIA = C.COD_CATEGORIA

        JOIN SUCURSAL_HERRAMIENTA SH

        ON H.COD_HERRAMIENTA = SH.COD_HERRAMIENTA

        AND H.EMPRESA = SH.EMPRESA

        JOIN SUCURSAL SU

        ON SH.COD_SUCURSAL = SU.COD_SUCURSAL

        FULL OUTER JOIN DETALLE D 

        ON D.COD_H = SH.COD_HERRAMIENTA

        AND D.EMPRESA = SH.EMPRESA

        AND D.COD_SUCURSAL = SH.COD_SUCURSAL

        JOIN EMPRESA E

        ON E.COD_EMPRESA = SU.COD_EMPRESA

        WHERE (H.COD_HERRAMIENTA,SH.COD_SUCURSAL) NOT IN (SELECT H.COD_HERRAMIENTA,H.COD_SUCURSAL FROM ARRIENDO A JOIN DETALLE D 

                                    ON A.COD_ARRIENDO = D.ID_A JOIN SUCURSAL_HERRAMIENTA H

                                    ON D.COD_H = H.COD_HERRAMIENTA

                                    AND D.EMPRESA = H.EMPRESA

                                    AND D.COD_SUCURSAL = H.COD_SUCURSAL

                                    WHERE A.FECHA_INICIO BETWEEN FECHA_I AND FECHA_F

                                    OR A.FECHA_FINAL BETWEEN FECHA_I AND FECHA_F)

        AND SH.COD_SUCURSAL = COD_S

        AND SH.COD_HERRAMIENTA = COD_HE)

        AS TEMPORAL;

        RETURN CANTIDADES;

    ELSE

        RETURN -1;

    END IF;

    EXCEPTION

        WHEN NO_DATA_FOUND THEN

            RETURN -1;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.verificarut(rut_u integer, OUT bool character varying, OUT message character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$ 

DECLARE 

BEGIN

    IF(CHECKUSER(RUT_U)=TRUE) THEN

        BOOL := 'TRUE';

        MESSAGE := 'USUARIO VERIFICADO';

    ELSE

        BOOL:='FALSE';

        MESSAGE := 'USUARIO NO ENCONTRADO';

    END IF;

    RETURN;

    EXCEPTION

        WHEN OTHERS THEN

            BOOL := 'ERROR';

            MESSAGE := SQLERRM;

            RETURN;

END;

$$;",base_de_datos_completa.sql
"CREATE FUNCTION public.workinghours(cdate date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
  cmonth int:= extract('month' from cdate);
  cyear int:= extract('year' from cdate);
  daysnum int:= date_part('days', date_trunc('month', cdate) + '1 month'::interval - '1 day' :: interval)::integer;
BEGIN
  return (with days as
  (
      select dd, extract(DOW from dd) dw
      from generate_series((cyear :: text ||'-'|| cmonth :: text ||'-01') :: date,
                           (cyear :: text ||'-'|| cmonth :: text || '-' || daysnum :: text) :: date, '1 day' :: interval) dd
  )
  select count(*) from days where dw not in (6, 0)
  );
END;
$$;",pgbak.sql
"CREATE FUNCTION purge_phi(OUT success text) RETURNS text
    LANGUAGE plpgsql
    AS $$DECLARE
--------------------------------------
-- Purpose: purge all PHI
-- Caller: external or User
-------------------------------------------
	--local vars
	func text;
BEGIN
	func := 'ddw:purge_phi' ;

	-- assume it fails, change later if succeed
	success := 'false';
	-- use PERFORM instead of SELECT since we are throwing away the result
	PERFORM purger ('', 'test');
	perform purger ('', 'nuke-it');
	
	--perform purger ('', 'alerts');
	--PERFORM purger ('', 'patient');	
	--pERFORM purger ('', 'exam');
	--PERFORM purger ('', 'series');
	--PERFORM purger ('', 'acquisition');
	--pERFORM purger ('', 'instance');
	
	-- if we got all the way here we succeeded
	success := 'true';
	return ;
END
$$;",purged-ddw.sql
"CREATE FUNCTION pvcrequest_stamp() RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$    BEGIN
          -- Record the time the request is entered into the database
         RETURN current_timestamp;
    END;
$$;",dumpAll-RailsPostgres94.sql
"CREATE FUNCTION pvcrequest_stamp() RETURNS timestamp with time zone
    LANGUAGE plpgsql
    AS $$    BEGIN
          -- Record the time the request is entered into the database
         RETURN current_timestamp;
    END;
$$;",railsPostgresqlPVMMA.sql
"CREATE FUNCTION queue_peek(OUT id bigint, OUT path text) RETURNS record
    LANGUAGE plpgsql
    AS $_$begin
  select id, path from index_queue order by id limit 1 into $1, $2;
end;$_$;",AIST5.4.schema.sql
"CREATE FUNCTION raise_exception(text) RETURNS void
    LANGUAGE plpgsql
    AS $_$
BEGIN
RAISE EXCEPTION '%', $1;
END;
$_$;",tubesubmitter_critical_structure.sql
"CREATE FUNCTION random_datetime(start_date timestamp without time zone, end_date timestamp without time zone) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN start_date + random() * (end_date - start_date);
END
$$;",graphA.sql
"CREATE FUNCTION random_double(min real, max real) RETURNS real
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN random() * (max-min) + min;
END
$$;",graphA.sql
"CREATE FUNCTION random_int(min integer, max integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN floor(random() * max + min)::int;
END
$$;",graphA.sql
"CREATE FUNCTION random_string(
  IN string_length INTEGER,
  IN possible_chars TEXT DEFAULT 'abcdefghijklmnopqrstuvwxyz'
)
RETURNS text
LANGUAGE plpgsql
AS $$
  DECLARE
    output TEXT = '';
    i INT4;
    pos INT4;
  BEGIN
    FOR i IN 1..string_length LOOP
      pos := 1 + CAST( random() * ( LENGTH(possible_chars) - 1) AS INT4 );
      output := output || substr(possible_chars, pos, 1);
    END LOOP;
    RETURN output;
  END;
$$;",performance.md
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
BEGIN
  IF length < 0 THEN
    RAISE EXCEPTION 'Given length cannot be less than 0';
  END IF;
  FOR i in 1..length LOOP
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  END LOOP;
  RETURN result;
END;
$$;",graphA.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",chrs_employees_20160812.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",chrs_employees_20160825.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  	chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  	result text := '';
  	i integer := 0;
begin
  	if length < 0 then
    	raise exception 'Given length cannot be less than 0';
  	end if;
  	for i in 1..length loop
    	result := result || chars[1+random()*(array_length(chars, 1)-1)];
  	end loop;
  	return result;
end;
$$;",tblleave_timesheet
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2007-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2008-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",backup%2009-12.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",bubblers_dump.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160222%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160227%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160307%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160308%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160310%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160312%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160315%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160325%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160510%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160513%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160524%20karental.sql
"CREATE FUNCTION random_string(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
declare
  chars text[] := '{A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := '';
  i integer := 0;
begin
  if length < 0 then
    raise exception 'Given length cannot be less than 0';
  end if;
  for i in 1..length loop
    result := result || chars[1+random()*(array_length(chars, 1)-1)];
  end loop;
  return result;
end;
$$;",20160531%20karental.sql
"CREATE FUNCTION random_text_simple(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, get_random_number(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION random_text_simple_1(length integer) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
    possible_chars TEXT := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    output TEXT := '';
    i INT4;
BEGIN

    FOR i IN 1..length LOOP
        output := output || substr(possible_chars, random_range(1, length(possible_chars)), 1);
    END LOOP;

    RETURN output;
END;
$$;",libdb.backup.sql
"CREATE FUNCTION raport_iloscii() RETURNS text
    LANGUAGE plpgsql
    AS $$
declare 
result text := '';
begin
	select count(nazwa) from gra as gry;
	select count(nazwa) from producenci as producenci;
	select count(nazwa) from platforma as platformy;
	select count(nazwa) from wydawca as wydawcy;
	select avg(ocena) from gra as srednia;
	return result;
end;
$$;",bazadanych_dump.backup
"CREATE FUNCTION ratedate(integer, integer, date) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$DECLARE
 x1 DOUBLE PRECISION;
 x2 DOUBLE PRECISION;
BEGIN
 select value into x1 from currencyrate where value > 0 and currencyid = $1 and ratedate <= $3 order by ratedate desc limit 1;
 select value into x2 from currencyrate where value > 0 and currencyid = $2 and ratedate <= $3 order by ratedate desc limit 1;
 IF x1 is null THEN
  x1 = 1;
 END IF;
 IF x2 is null THEN
  x2 = 1;
 END IF;
 return x2/x1;
END;$_$;",hms.sql
"CREATE FUNCTION ready(n_verses integer, d_vars integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
			BEGIN
				IF n_verses = 0 THEN RETURN 0; ELSE RETURN d_vars::float / n_verses::float; END IF;
			END;
			$$;",init.sql
"CREATE FUNCTION realtime.radian2cardinal(real) RETURNS text
    LANGUAGE plpgsql
    AS $_$
declare
    degree numeric(5,2) := $1 / (2*pi()) *360;
    card text;
BEGIN
SELECT into card
    CASE
        WHEN degree BETWEEN  348.75 AND 360  THEN 'N'::text
	WHEN degree BETWEEN  0 AND 11.25  THEN 'N'::text
	WHEN degree BETWEEN  11.25 AND 33.75  THEN 'NNE'::text
	WHEN degree BETWEEN  33.75 AND 56.25  THEN 'NE'::text
	WHEN degree BETWEEN  56.25 AND 78.75   THEN 'ENE'::text
	WHEN degree BETWEEN  78.75 AND 101.25  THEN 'E'::text
	WHEN degree BETWEEN  101.25 AND 123.75  THEN 'ESE'::text
	WHEN degree BETWEEN  123.75 AND 146.25  THEN 'SE'::text
	WHEN degree BETWEEN  146.25 AND 168.75   THEN 'SSE'::text
	WHEN degree BETWEEN  168.75 AND 191.25  THEN 'S'::text
	WHEN degree BETWEEN  191.25 AND 213.75   THEN 'SSW'::text
	WHEN degree BETWEEN  213.75 AND 236.25   THEN 'SW'::text
	WHEN degree BETWEEN  236.25 AND 258.75   THEN 'WSW'::text
	WHEN degree BETWEEN  258.75 AND 281.25   THEN 'W'::text
	WHEN degree BETWEEN  281.25 AND 303.75   THEN 'WNW'::text
	WHEN degree BETWEEN  303.75 AND 326.25   THEN 'NW'::text
	WHEN degree BETWEEN  326.25 AND 348.75   THEN 'NNW'::text
            ELSE NULL::text
        END;
return card;
END;
$_$;",dump_db_iris_base_realtime-v40.sql
"CREATE FUNCTION receber_dados_cirurgiainternacao(verificar integer, tratamento integer, cirurgia integer, descricao character varying, datacirurgia character varying, horacirurgia character varying, valor character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	if(verificar = 0) then
		return (select inserir_cirurgiainternacao(tratamento, cirurgia, descricao,
		datacirurgia, horacirurgia, valor));
	else
		return (select atualizar_cirurgiainternacao(verificar, tratamento, cirurgia,
		descricao, datacirurgia, horacirurgia, valor));
	end if;
	if check_violation then
		raise exception 'violacao';
	end if;
	
end;

$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dados_cirurgiainternacao(verificar integer, tratamento integer, cirurgia integer, descricao text, datacirurgia date, horacirurgia time without time zone, valor numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	if(verificar = 0) then
		return (select inserir_cirurgiainternacao(tratamento, cirurgia, descricao,
		datacirurgia, horacirurgia, valor));
	else
		return (select atualizar_cirurgiainternacao(verificar, tratamento, cirurgia,
		descricao, datacirurgia, horacirurgia, valor));
	end if;
	if check_violation then
		raise exception 'violacao';
	end if;
	
end;

$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoscirurgia(nome character varying, medico integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_cirurgia(nome, medico));
		else 
			return (select atualizar_cirurgia(nome, medico, verificar));
	
		end if;

	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadoscirurgia(nome character varying, medico integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_cirurgia(nome, medico));
		else 
			return (select atualizar_cirurgia(nome, medico, verificar));
	
		end if;

	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoscliente(nomecliente character varying, datanascimentocliente date, enderecocliente character varying, rgcliente character varying, telefone character, expeditorrg character varying, municipiocliente character varying, cpfcliente character, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		
		
		if (verificar = 0) then
			return (select inserir_cliente(nomecliente, datanascimentocliente, enderecocliente, rgcliente, telefone, expeditorrg,
				municipiocliente, cpfcliente));
		        
		else 
			return (select atualizar_cliente(nomecliente, datanascimentocliente, enderecocliente, rgcliente, telefone, expeditorrg,
				municipiocliente, cpfcliente, verificar));
		end if;

		
		
	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadoscliente(nomecliente character varying, datanascimentocliente date, enderecocliente character varying, rgcliente character varying, telefone character, expeditorrg character varying, municipiocliente character varying, cpfcliente character, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		
		
		if (verificar = 0) then
			return (select inserir_cliente(nomecliente, datanascimentocliente, enderecocliente, rgcliente, telefone, expeditorrg,
				municipiocliente, cpfcliente));
		        
		else 
			return (select atualizar_cliente(nomecliente, datanascimentocliente, enderecocliente, rgcliente, telefone, expeditorrg,
				municipiocliente, cpfcliente, verificar));
		end if;

		
		
	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosconsulta(verificar integer, dataconsulta date, horaconsulta time without time zone, medicoveterinario integer, codigotipo integer, agendamento character, paciente integer, prontuario text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_consulta(dataconsulta, horaconsulta, medicoveterinario, codigotipo, agendamento, paciente, prontuario));
		else
			return (select atualizar_consulta(verificar, dataconsulta, horaconsulta, medicoveterinario, codigotipo, agendamento, paciente, prontuario));
		end if;

	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosconsulta(verificar integer, dataconsulta date, horaconsulta time without time zone, medicoveterinario integer, codigotipo integer, agendamento character, paciente integer, prontuario text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_consulta(dataconsulta, horaconsulta, medicoveterinario, codigotipo, agendamento, paciente, prontuario));
		else
			return (select atualizar_consulta(verificar, dataconsulta, horaconsulta, medicoveterinario, codigotipo, agendamento, paciente, prontuario));
		end if;

	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoscustos(verificar integer, codconsulta integer, codtipo integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	if (verificar = 0) then
		return (select inserir_custos(codconsulta, (select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	else
		return (select atualizar_custos(verificar, codconsulta, (select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	end if;	
end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadoscustos(verificar integer, codconsulta integer, codtipo integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	if (verificar = 0) then
		return (select inserir_custos(codconsulta, (select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	else
		return (select atualizar_custos(verificar, codconsulta, (select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	end if;	
end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoscustos(verificar integer, codconsulta integer, datapago date, codtipo integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	if (verificar = 0) then
		return (select inserir_custos(codconsulta,(select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	else
		return (select atualizar_custos(verificar, codconsulta, datapago,(select valor_consulta from tipo_consulta where cod_tipo_consulta = codtipo)));
	end if;	
end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoscustos(verificar integer, codconsulta integer, datapago date, valor numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
	if (verificar = 0) then
		return (select inserir_custos(codconsulta,(select valor_consulta from tipo_consulta where cod_tipo_consulta = codconsulta)));
	else
		return (select atualizar_custos(verificar, codconsulta, datapago,valor));
	end if;	
end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosexame(nome character varying, laboratorio integer, descricao character varying, valor numeric, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_exame(nome, laboratorio, descricao, valor));
		else 
			return (select atualizar_exame(nome, laboratorio, descricao, valor, verificar));
	
		end if;

	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosexame(nome character varying, laboratorio integer, descricao character varying, valor numeric, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_exame(nome, laboratorio, descricao, valor));
		else 
			return (select atualizar_exame(nome, laboratorio, descricao, valor, verificar));
	
		end if;

	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosexame(nome character varying, laboratorio integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_exame(nome, laboratorio));
		else 
			return (select atualizar_exame(nome, laboratorio, verificar));
	
		end if;

	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosexame(nome character varying, laboratorio integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_exame(nome, laboratorio));
		else 
			return (select atualizar_exame(nome, laboratorio, verificar));
	
		end if;

	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoslaboratoriais(verificar integer, tratamento integer, exame integer, descricao text, responsavel character varying, valor numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	if(verificar = 0) then
		return(select inserir_exame(tratamento, exame, descricao, responsavel, valor));
	else
		return(select atualizar_exame(verificar, tratamento, exame, descricao, responsavel, valor));
	end if;
end;

$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadoslaboratoriais(verificar integer, tratamento integer, exame integer, descricao text, responsavel character varying, valor numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$

begin
	if(verificar = 0) then
		return(select inserir_laboratoriais(tratamento, exame, descricao, responsavel, valor));
	else
		return(select atualizar_laboratoriais(verificar, tratamento, exame, descricao, responsavel, valor));
	end if;
end;

$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadoslaboratorio(nome character varying, telefone character varying, endereco character varying, municipio character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_laboratorio(nome, telefone, endereco, municipio));
		else 
			return (select atualizar_laboratorio(nome, telefone, endereco, municipio, verificar));
	
		end if;

	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadoslaboratorio(nome character varying, telefone character varying, endereco character varying, municipio character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_laboratorio(nome, telefone, endereco, municipio));
		else 
			return (select atualizar_laboratorio(nome, telefone, endereco, municipio, verificar));
	
		end if;

	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosmedicacao(cod_trat integer, cod_rem integer, qtd character varying, cod_resp character varying, valor_remedio numeric, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_medicacao(cod_trat, cod_rem, qtd, cod_resp, valor_remedio));
		else
			return (select atualizar_medicacao(cod_trat, cod_rem, qtd, cod_resp, valor_remedio, verificar));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosmedicacao(cod_trat integer, cod_rem integer, qtd character varying, cod_resp character varying, valor_remedio numeric, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_medicacao(cod_trat, cod_rem, qtd, cod_resp, valor_remedio));
		else
			return (select atualizar_medicacao(cod_trat, cod_rem, qtd, cod_resp, valor_remedio, verificar));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosmedicamento(nome_remedio character varying, valor_remedio numeric, qtd_estoque integer, categoria_remedio character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_med(nome_remedio, valor_remedio, qtd_estoque, categoria_remedio));
		else
			return (select atualizar_med(verificar, nome_remedio, valor_remedio, qtd_estoque, categoria_remedio));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosmedicamento(nome_remedio character varying, valor_remedio numeric, qtd_estoque integer, categoria_remedio character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_med(nome_remedio, valor_remedio, qtd_estoque, categoria_remedio));
		else
			return (select atualizar_med(verificar, nome_remedio, valor_remedio, qtd_estoque, categoria_remedio));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosmedico(nomemedico character varying, especialidade character varying, crmv character varying, telefone character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_medVet(nomemedico, especialidade, crmv, telefone));
		else
			return (select atualizar_medVet(verificar, nomemedico, especialidade, crmv, telefone));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosmedico(nomemedico character varying, especialidade character varying, crmv character varying, telefone character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_medVet(nomemedico, especialidade, crmv, telefone));
		else
			return (select atualizar_medVet(verificar, nomemedico, especialidade, crmv, telefone));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadospaciente(codclientefk integer, rghvpaciente character varying, especiepaciente character varying, racapaciente character varying, nascimentopaciente date, pelagempaciente character varying, sexopaciente character, pacientecadastrado character, nomepaciente character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_paciente(codclientefk, rghvpaciente, especiepaciente, racapaciente, nascimentopaciente,	pelagempaciente,
			sexopaciente, pacientecadastrado, nomepaciente));
		else
			return (select atualizar_paciente(codclientefk, rghvpaciente, especiepaciente, racapaciente, nascimentopaciente,	pelagempaciente,
			sexopaciente, pacientecadastrado, nomepaciente, verificar));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadospaciente(codclientefk integer, rghvpaciente character varying, especiepaciente character varying, racapaciente character varying, nascimentopaciente date, pelagempaciente character varying, sexopaciente character, pacientecadastrado character, nomepaciente character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_paciente(codclientefk, rghvpaciente, especiepaciente, racapaciente, nascimentopaciente,	pelagempaciente,
			sexopaciente, pacientecadastrado, nomepaciente));
		else
			return (select atualizar_paciente(codclientefk, rghvpaciente, especiepaciente, racapaciente, nascimentopaciente,	pelagempaciente,
			sexopaciente, pacientecadastrado, nomepaciente, verificar));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadosremedio(nome character varying, valor numeric, estoque integer, categoria character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if(verificar = 0) then
			return(select inserir_remedio(nome, valor, estoque, categoria));
		else
			return(select atualizar_remedio(nome, valor, estoque, categoria, verificar));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosremedio(nome character varying, valor numeric, estoque integer, categoria character varying, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if(verificar = 0) then
			return(select inserir_remedio(nome, valor, estoque, categoria));
		else
			return(select atualizar_remedio(nome, valor, estoque, categoria, verificar));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadostipoconsulta(verificar integer, valorconsulta numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_tipoConsulta(valorconsulta));
		else
			return (select atualizar_tipoConsulta(verificar, valorconsulta));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadostipoconsulta(verificar integer, valorconsulta numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_tipoConsulta(valorconsulta));
		else
			return (select atualizar_tipoConsulta(verificar, valorconsulta));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadostratamento(descricao character varying, codconsulta integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_tratamento(descricao, codconsulta));
		else 
			return (select atualizar_tratamento(descricao, codconsulta, verificar));
	
		end if;

	end;
 $$;",C.H.V.Final.backup
"CREATE FUNCTION receber_dadostratamento(nome character varying, pac integer, medico integer, verificar integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin		

		if (verificar = 0) then
			return (select inserir_tratamento(nome, pac, medico));
		else 
			return (select atualizar_tratamento(nome, pac, medico, verificar));
	
		end if;

	end;
 $$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosusuario(verificar integer, nomeusuario character varying, login character varying, senha character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_usuario(nomeusuario, login, senha));
		else
			return (select atualizar_usuario(verificar, nomeusuario, login, senha));
		end if;
	end;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION receber_dadosusuario(verificar integer, nomeusuario character varying, login character varying, senha character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
	begin
		if (verificar = 0) then
			return (select inserir_usuario(nomeusuario, login, senha));
		else
			return (select atualizar_usuario(verificar, nomeusuario, login, senha));
		end if;
	end;
$$;",C.H.V.Final.backup
"CREATE FUNCTION rechcli(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	declare f_pseudo alias for $1;
	declare f_mdp alias for $2;
	declare id integer;
	declare retour integer;
begin
	select into id id_client from client where pseudo=f_pseudo and mdp=f_mdp;
	if not found
	then
	  retour=0;
	else
	  retour=id;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION rechseance(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	declare f_id alias for $1;
	declare id integer;
	declare retour integer;
begin
	select into id id_seance from reservation where id_seance=CAST(f_id as integer);
	if not found
	then
	  retour=0;
	else
	  retour=1;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION rechsires(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
	declare f_seance alias for $1;
	declare f_client alias for $2;
	declare cli integer;
	declare se integer;
	declare id integer;
	declare retour integer;
begin
	cli=cast(f_client as integer);
	se=cast(f_seance as integer);
	select into id num_res from reservation where id_client=cli and id_seance=se;
	if not found
	then
	  retour=0;
	else
	  retour=id;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION recuperar_schema_temp() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
			DECLARE
			   schemas varchar;
			   pos_inicial int4;
			   pos_final int4;
			   schema_temp varchar;
			BEGIN
			   schema_temp := '';
			   SELECT INTO schemas current_schemas(true);
			   SELECT INTO pos_inicial strpos(schemas, 'pg_temp');
			   IF (pos_inicial > 0) THEN
			      SELECT INTO pos_final strpos(schemas, ',');
			      SELECT INTO schema_temp substr(schemas, pos_inicial, pos_final - pos_inicial);
			   END IF;
			   RETURN schema_temp;
			END;
			$$;",bkp_apunam.sql
"CREATE FUNCTION recycle_integer(_state integer) RETURNS TABLE(val integer)
    LANGUAGE plpgsql IMMUTABLE ROWS 1000000
    AS $$DECLARE 
	curr_state INTEGER; --current state
BEGIN
	SELECT ""current_state"".""state"" FROM ""current_state"" INTO ""curr_state""; --take the current state
	RETURN QUERY 
		SELECT DISTINCT trvlmaxamnt_1.""maxAmnt"" 
				FROM ""TrvlMaxAmnt"" AS trvlmaxamnt_1, ""TrvlMaxAmnt_state_log"" AS trvlmaxamnt_state_log_1
				WHERE trvlmaxamnt_state_log_1.""state""<""curr_state""
				AND trvlmaxamnt_state_log_1.""state"">1 
				AND trvlmaxamnt_1.""rid""=trvlmaxamnt_state_log_1.""rid""
				AND NOT EXISTS 
				(SELECT 1 
						FROM ""TrvlMaxAmnt"" AS trvlmaxamnt_2, ""TrvlMaxAmnt_state_log"" AS trvlmaxamnt_state_log_2
						WHERE trvlmaxamnt_state_log_2.""state""=""_state""
						AND trvlmaxamnt_2.rid=trvlmaxamnt_state_log_2.rid 
						AND trvlmaxamnt_2.""maxAmnt""=trvlmaxamnt_1.""maxAmnt"")
		UNION
		SELECT DISTINCT trvlcost_1.""cost""
				FROM ""TrvlCost"" AS trvlcost_1, ""TrvlCost_state_log"" AS trvlcost_state_log_1
				WHERE trvlcost_state_log_1.""state""<""curr_state""
				AND trvlcost_state_log_1.""state"">1 
				AND trvlcost_1.""rid""=trvlcost_state_log_1.""rid""
				AND NOT EXISTS 
				(SELECT 1 
						FROM ""TrvlCost"" AS trvlcost_2, ""TrvlCost_state_log"" AS trvlcost_state_log_2
						WHERE trvlcost_state_log_2.""state""=""_state""
						AND trvlcost_2.rid=trvlcost_state_log_2.rid 
						AND trvlcost_1.""cost""=trvlcost_2.""cost"")
		UNION
		SELECT DISTINCT accepted_1.""amount""
				FROM ""Accepted"" AS accepted_1, ""Accepted_state_log"" AS accepted_state_log_1
				WHERE accepted_state_log_1.""state""<""curr_state"" 
				AND accepted_state_log_1.""state"">1 
				AND accepted_1.""rid""=accepted_state_log_1.""rid""
				AND NOT EXISTS 
				(SELECT 1 
						FROM ""Accepted"" AS accepted_2, ""Accepted_state_log"" AS accepted_state_log_2
						WHERE accepted_state_log_2.""state""=""_state"" 
						AND accepted_2.rid=accepted_state_log_2.rid 
						AND accepted_1.""amount""=accepted_2.""amount"")
		--UNION
		--SELECT ""value"" FROM ""maxamnt_allowed_values""
		ORDER BY 1 ASC;
END$$;",dcds128.sql
"CREATE FUNCTION recycle_string(_state integer) RETURNS TABLE(val character varying)
    LANGUAGE plpgsql IMMUTABLE ROWS 1000000
    AS $$DECLARE 
	curr_state INTEGER; --current state
BEGIN
	SELECT ""current_state"".""state"" FROM ""current_state"" INTO ""curr_state""; --take the current state
	RETURN QUERY 
		SELECT DISTINCT pending_1.""empl""
				FROM ""Pending"" AS pending_1, ""Pending_state_log"" AS pending_state_log_1
				WHERE pending_state_log_1.""state""<""curr_state""
				AND pending_state_log_1.""state"">1
				AND pending_1.""rid"" = pending_state_log_1.""rid""
				AND NOT EXISTS
				(SELECT 1
						FROM ""Pending"" AS pending_2, ""Pending_state_log"" AS pending_state_log_2
						WHERE pending_state_log_2.""state""=""_state""
						AND pending_2.""rid"" = pending_state_log_2.""rid""
						AND pending_1.""empl""=pending_2.""empl"")
		UNION
		SELECT DISTINCT pending_1.""dest""
				FROM ""Pending"" AS pending_1, ""Pending_state_log"" AS pending_state_log_1
				WHERE pending_state_log_1.""state""<""curr_state""
				AND pending_state_log_1.""state"">1
				AND pending_1.""rid"" = pending_state_log_1.""rid""
				AND NOT EXISTS
				(SELECT 1
						FROM ""Pending"" AS pending_2, ""Pending_state_log"" AS pending_state_log_2
						WHERE pending_state_log_2.""state""=""_state""
						AND pending_2.""rid"" = pending_state_log_2.""rid""
						AND pending_1.""dest""=pending_2.""dest"")
		UNION
		SELECT DISTINCT currreq_1.""empl""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""<""curr_state""
				AND currreq_state_log_1.""state"">1
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
				AND NOT EXISTS
				(SELECT 1
						FROM ""CurrReq"" AS currreq_2, ""CurrReq_state_log"" AS currreq_state_log_2
						WHERE currreq_state_log_2.""state""=""_state""
						AND currreq_2.""rid"" = currreq_state_log_2.""rid""
						AND currreq_1.""empl""=currreq_2.""empl"")
		UNION
		SELECT DISTINCT currreq_1.""dest""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""<""curr_state""
				AND currreq_state_log_1.""state"">1
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
				AND NOT EXISTS
				(SELECT 1
						FROM ""CurrReq"" AS currreq_2, ""CurrReq_state_log"" AS currreq_state_log_2
						WHERE currreq_state_log_2.""state""=""_state""
						AND currreq_2.""rid"" = currreq_state_log_2.""rid""
						AND currreq_1.""dest""=currreq_2.""dest"")
		UNION
		SELECT DISTINCT currreq_1.""status""
				FROM ""CurrReq"" AS currreq_1, ""CurrReq_state_log"" AS currreq_state_log_1
				WHERE currreq_state_log_1.""state""<""curr_state""
				AND currreq_state_log_1.""state"">1
				AND currreq_1.""rid"" = currreq_state_log_1.""rid""
				AND NOT EXISTS
				(SELECT 1
						FROM ""CurrReq"" AS currreq_2, ""CurrReq_state_log"" AS currreq_state_log_2
						WHERE currreq_state_log_2.""state""=""_state""
						AND currreq_2.""rid"" = currreq_state_log_2.""rid""
						AND currreq_1.""status""=currreq_2.""status"")
		ORDER BY 1 ASC;
END$$;",dcds128.sql
"CREATE FUNCTION refcursorfunc() RETURNS refcursor
    AS $$
DECLARE 
mycurs refcursor; 
BEGIN

drop table if exists dphase;
drop table if exists optode_temp;
drop table if exists sbe16_temperature;
drop table if exists sbe16_pressure;
drop table if exists sbe16_conductivity;
drop table if exists set1;
drop table if exists set2;
drop table if exists set3;

create temp table dphase as
select distinct on (date_trunc('hour',data_timestamp)) 
date_trunc('hour',data_timestamp) as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and parameter_code = 'OPTODE_DPHASE'
;

create temp table optode_temp as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and parameter_code = 'OPTODE_TEMP'
;

create temp table sbe16_temperature as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'WATER_TEMP'
;


create temp table sbe16_pressure as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'WATER_PRESSURE'
;

create temp table sbe16_conductivity as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where mooring_id = 'PULSE_7'
and instrument_id = 4
and parameter_code = 'CONDUCTIVITY'
;

create temp table set1 as
select 
	dphase.obs_time,
	dphase.depth,
	dphase.parameter_value as optode_dphase,
	optode_temp.parameter_value as optode_temperature
from dphase full join optode_temp on 
(
dphase.obs_time = optode_temp.obs_time
AND
dphase.depth = optode_temp.depth
)
;

create temp table set2 as
select 
	set1.obs_time,
	set1.depth,
	set1.optode_dphase,
	set1.optode_temperature,
	sbe16_temperature.parameter_value as sbe16_temperature
from set1 full join sbe16_temperature on 
(
set1.obs_time = sbe16_temperature.obs_time
AND
set1.depth = sbe16_temperature.depth
)
;

create temp table set3 as
select 
	set2.obs_time,
	set2.depth,
	set2.optode_dphase,
	set2.optode_temperature,
        set2.sbe16_temperature,
	sbe16_pressure.parameter_value as sbe16_pressure
from set2 full join sbe16_pressure on 
(
set2.obs_time = sbe16_pressure.obs_time
AND
set2.depth = sbe16_pressure.depth
)
;

create temp table set4 as
select 
	set3.obs_time,
	set3.depth,
	set3.optode_dphase,
	set3.optode_temperature,
        set3.sbe16_temperature,
	set3.sbe16_pressure,
	sbe16_conductivity.parameter_value as sbe16_conductivity
from set3 full join sbe16_conductivity on 
(
set3.obs_time = sbe16_conductivity.obs_time
AND
set3.depth = sbe16_conductivity.depth
)
;

OPEN mycurs FOR  select * from set4 order by obs_time;
RETURN mycurs; 
END;
$$
    LANGUAGE plpgsql;",ABOS20110308.sql
"CREATE FUNCTION reference2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res xml;
  BEGIN

     res := xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                        xmlattributes('en' as ""xml:lang""), 
                        'Implemantation of ' ||item.item || '. Defined as: ' ||item.definition)),
          
             xmlelement(name ""complexContent"",
                xmlelement(name ""extension"",
                        xmlattributes('gcdml:litReferenceType' as base)))

              );

     return res;
  END;
$$;",test.sql
"CREATE FUNCTION refresh_session(p_session_id character varying) RETURNS void
    AS $$
BEGIN
    PERFORM
        s.session_id
    FROM
        app_session s
    WHERE
        s.session_id = p_session_id  AND
        s.session_end_ts IS NULL;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Invalid Login/Password';
    END IF;

    PERFORM save_session_id(p_session_id);
END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION refreshview() RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER
    AS $$
begin

  execute format('DROP VIEW metadata_view');
  execute format('CREATE OR REPLACE VIEW metadata_view AS SELECT *
FROM  (SELECT g.id, gs.external_id_prefix||''_''||g.id_at_source as genome, g.name as organism_name, g.description, u.username as username
      FROM genomes as g 
      LEFT JOIN genome_sources as gs ON gs.id=g.genome_source_id
      LEFT JOIN users as u ON u.id=g.owner_id) as temp
LEFT JOIN metadata_nucleotide as m1 USING (id)
LEFT JOIN metadata_genes as m2 USING (id)
LEFT JOIN metadata_taxonomy as m3 USING (id)
LEFT JOIN metadata_ncbi as m4 USING (id)
LEFT JOIN lpsn_genera as lpsn1 ON m3.gtdb_genus=lpsn1.lpsn_genus
LEFT JOIN lpsn_species as lpsn2 ON m3.gtdb_species=lpsn2.lpsn_species
LEFT JOIN lpsn_strains as lpsn3 ON m4.ncbi_organism_name=lpsn3.lpsn_strain');

  execute format('ALTER TABLE metadata_view
  OWNER TO gtdb');
end
$$;",gtdb_create.sql
"CREATE FUNCTION refurbsummsubass(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	_usrId INTEGER;

	_r RECORD;

  

BEGIN

	_usrID := (SELECT getusrid()); 

	PERFORM (SELECT checkpriv('refurbsummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, null, true));

	

	PERFORM (SELECT refurbpart(	pItemNumber,

					pRevision,

					pSerialNumber));

	

	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT refurbpart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber));

		END IF;

	END LOOP;

		  

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION regime2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql STABLE STRICT
    SET search_path TO gsc_db, public
    AS $$

  DECLARE
     res xml;
     groupElem xml := xmlelement(name ""group"", 
                                 xmlattributes('gcdml:RegimeTimesGroup' as ""ref"")
                                 );
    uomType text := 'token';

    restrictionPrefix text := CASE WHEN item.value_type = 'named regime' 
                                   THEN 'gcdml:NamedRegimeMeasurement' 
                                   ELSE 'gcdml:RegimeMeasurement' END; 
    
  BEGIN

  res := xmlconcat(
         xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                              xmlattributes('en' as ""xml:lang""), 
                              'Implemantation of ' ||item.item || '. Defined as: ' || item.definition)),
          xmlelement(name ""complexContent"", 
             xmlelement(name restriction, 
                        xmlattributes(restrictionPrefix || 'MIGSType' as base),
                groupElem,
                xmlelement(name attribute, xmlattributes('uom' as ""name"",
                                                         uomType as type,
                                                         'required' as use))
             )
          )
       ),
       -- now GCD version

        xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'Type' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", xmlattributes('en' as ""xml:lang""), 
                                                 'GCD implementation with additional attributes. ' || item.definition)),
          xmlelement(name ""complexContent"", 
             xmlelement(name restriction, 
                        xmlattributes(restrictionPrefix || 'Type' as base),
                 groupElem,
                xmlelement(name attribute, xmlattributes('uom' as ""name"",
                                                         uomType as type,
                                                         'required' as use))
             )
          )
       )-- end second xml
     ); -- end xmlconcat


     return res;
  END;
$$;",test.sql
"CREATE FUNCTION remove_diacritics(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
    _ret text;
BEGIN
    BEGIN
        SELECT to_ascii(convert_to($1, 'latin2'),'latin2') INTO _ret;
    EXCEPTION
        WHEN OTHERS THEN
            SELECT unaccent_string($1) INTO _ret;
    END;

    RETURN regexp_replace(_ret, '[\s]+', ' ', 'g');
END;
$_$;",full-scheme.sql
"CREATE FUNCTION remove_end_chars(p_text character varying, p_end_chars character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	counter integer;
	v_len integer;
   v_char varchar;
   v_text varchar = p_text;
   v_found boolean = true;
BEGIN
	v_len = Length(p_end_chars);
   WHILE v_found LOOP
   	v_found = false;
     	counter = 1;
   	WHILE counter <= v_len LOOP
   		v_char = Substring(p_end_chars FROM counter for 1);
        	IF Substring(v_text FROM Length(v_text) for 1) = v_char THEN
      		v_text = RTrim(v_text, v_char);
            v_found = true;
         END IF;
         counter = counter + 1;
   	END LOOP;
   END LOOP;
   Return v_text;
END;
$$;",utils.sql
"CREATE FUNCTION removeroleprivmodule(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pModule			ALIAS FOR $1;

	pRole 		ALIAS FOR $2;

	_r			RECORD;

	_moduleId 		INTEGER;

	_roleId			INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('removeroleprivmodule'));

	_moduleId := (SELECT getmoduleid(pModule));

	_roleId := (SELECT getroleid(pRole));



	FOR _r IN

		SELECT priv_name

		FROM priv

		WHERE priv_module_id = _moduleId

	LOOP

		IF _r.priv_name IS NOT NULL THEN

			PERFORM (SELECT removerolepriv(	_r.priv_name,

							pRole));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION removeusrprivmodule(text, text DEFAULT ""current_user""()) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pModule			ALIAS FOR $1;

	pUserName 		ALIAS FOR $2;

	_r			RECORD;

	_moduleId 		INTEGER;

	_usrId			INTEGER;

  

BEGIN

	PERFORM (SELECT getusrid());

	PERFORM (SELECT checkpriv('removeusrprivmodule'));

	_moduleId := (SELECT getmoduleid(pModule));

	_usrId := (SELECT getusrid(pUserName));



	FOR _r IN

		SELECT priv_name

		FROM priv

		WHERE priv_module_id = _moduleId

	LOOP

		IF _r.priv_name IS NOT NULL THEN

			PERFORM (SELECT removeusrpriv(	_r.priv_name,

							pUserName));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION replace_html_codes(p_text character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	v_inputstr varchar = p_text;
   v_chars varchar[][];
   i integer;
BEGIN
	v_chars = array[['&#32;',' '],['&#33;','!'],['&#34;','""""'],['&quot;','""""']]
 				|| array[['&#35;','#'],['&#36;','$'],['&#37;','%'],['&#38;','&']]
				|| array[['&amp;','&'],['&#39;',''''],['&40;','('],['&#41;',')']]
				|| array[['&#42;','*'],['&#43;','+'],['&44;',','],['&#45;','-']]
				|| array[['&#46;','.'],['&#47;','/'],['&58;',':'],['&#59;',';']]
				|| array[['&#60;','<'],['&#61;','='],['&62;','>'],['&#63;','?']]
				|| array[['&#64;','@'],['&#91;','['],['&92;','\\'],['&#93;',']']]
				|| array[['&#94;','^'],['&#95;','_'],['&96;',''''],['&#123;','{']]
				|| array[['&#124;','|'],['&#125;','}'],['&126;','~'],['&lt;','<']]
            || ARRAY[['&gt;','>'],['&amp;','&'],['&quot;','""'],['&apos;','''']];

   FOR i IN array_lower(v_chars, 1)..array_upper(v_chars, 1) LOOP
		v_inputstr = Replace(v_inputstr, v_chars[i][1], v_chars[i][2]);
   END LOOP;

   v_inputstr = regexp_replace(v_inputstr, '&#..;', '');
   v_inputstr = regexp_replace(v_inputstr, '&#...;', '');

   Return v_inputstr;
END;
$_$;",utils.sql
"CREATE FUNCTION requisicaovalortotal(p_requisicaoid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_total double precision;

BEGIN

    SELECT
           SUM(E.quantidade * E.valorunitario) INTO v_total
      FROM estoquemovimento E
INNER JOIN requisicao R
        ON R.requisicaoid = E.requisicaoid
       AND R.requisicaoid = p_requisicaoid
INNER JOIN produto P
        ON P.produtoid = E.produtoid;
    
RETURN v_total;

END;
$$;",almoxarifado.sql
"CREATE FUNCTION reset_sequence(tablename text, columnname text) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
DECLARE seqname character varying;
        c integer;
BEGIN
    select tablename || '_' || columnname || '_seq' into seqname;
    EXECUTE 'SELECT max(""' || columnname || '"") FROM ""' || tablename || '""' into c;
    if c is null then c = 0; end if;
    c = c+1; --because of substitution of setval with ""alter sequence""
    --EXECUTE 'SELECT setval( ""' || seqname || '"", ' || cast(c as character varying) || ', false)'; DOES NOT WORK!!!
    EXECUTE 'alter sequence ' || seqname ||' restart with ' || cast(c as character varying);
    RETURN nextval(seqname)-1;
END;
$$;",dkvdb.dump
"CREATE FUNCTION retornadados(cod integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

 DECLARE resultado refcursor;
 reg record;
BEGIN
		OPEN resultado FOR
			SELECT cod_consulta from consulta where cod_paciente_fk = (SELECT cod_paciente FROM paciente inner join cliente on cod_cliente = cod_cliente_fk where cod_cliente =96);
	FETCH resultado INTO reg;
	RETURN reg;
END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION retornadados(cod integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$

 DECLARE resultado refcursor;
 reg record;
BEGIN
		OPEN resultado FOR
			SELECT cod_consulta from consulta where cod_paciente_fk = (SELECT cod_paciente FROM paciente inner join cliente on cod_cliente = cod_cliente_fk where cod_cliente =96);
	FETCH resultado INTO reg;
	RETURN reg;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION retornaexamelabo() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
EXAME CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk;
 	--um_empregado laboratorios%ROWTYPE;
reg RECORD;
	BEGIN
	OPEN EXAME;
	LOOP
		--FETCH cs_empregados INTO um_empregado;
		FETCH EXAME INTO reg;
	--RETURN NEXT um_empregado;
	
		RETURN NEXT EXAME;
		END LOOP;
	END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION retornaexamelabo() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
EXAME CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk;
 	--um_empregado laboratorios%ROWTYPE;
reg RECORD;
	BEGIN
	OPEN EXAME;
	LOOP
		--FETCH cs_empregados INTO um_empregado;
		FETCH EXAME INTO reg;
	--RETURN NEXT um_empregado;
	
		RETURN NEXT EXAME;
		END LOOP;
	END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION retornaexamelabo(cod integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
EXAME CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join consulta c on p.cod_paciente = c.cod_paciente_fk inner join tratamento t on t.cod_consulta_fk = c.cod_consulta inner join laboratoriais l on l.cod_tratameto_fk = t.cod_tratamento_pk inner join exame e on e.cod_exame_pk = l.cod_exame_fk where p.cod_paciente =cod;
 	--um_empregado laboratorios%ROWTYPE;
reg RECORD;
	BEGIN
	OPEN EXAME;
	LOOP
		--FETCH cs_empregados INTO um_empregado;
		FETCH EXAME INTO reg;
	--RETURN NEXT um_empregado;
		RETURN NEXT EXAME;
		END LOOP;
	END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION retornaexamelabo(cod integer) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
EXAME CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk where p.cod_paciente =cod;
 	--um_empregado laboratorios%ROWTYPE;
reg RECORD;
	BEGIN
	OPEN EXAME;
	LOOP
		--FETCH cs_empregados INTO um_empregado;
		FETCH EXAME INTO reg;
	--RETURN NEXT um_empregado;
		RETURN NEXT EXAME;
		END LOOP;
	END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION retornaexamelabotext() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$

DECLARE
EXAME CURSOR FOR SELECT (cod_tratameto_fk , cod_exame_fk ), p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk;
 
reg RECORD;
	BEGIN
	OPEN EXAME;
	LOOP
		FETCH EXAME INTO reg;
		RETURN NEXT EXAME;
		END LOOP;
	END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION retornamedicacao(cod character varying, cod2 character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE RESU    RECORD; -- Variavel que armazenará o retorno da query
BEGIN

  -- Vamos criar o LOOP para retornar a execução da query na tabela cadastro
  FOR RESU IN SELECT descricao_tratamento,nome_remedio, qtd_aplicada, responsavel_medicacao, valor FROM  remedios INNER JOIN medicacao ON cod_remedio = cod_remedio_fk INNER JOIN tratamento on cod_tratamento_pk = cod_tratamento_fk where  descricao_tratamento = COD and nome_remedio = COD2
 LOOP
    -- O retorno de cada linha
    RETURN;
  END LOOP;
 
 
END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION retornapacconta(cod integer, dat date) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs CURSOR FOR SELECT p.cod_paciente, p.nome_paciente, p.nascimento_paciente, p.rghv_paciente, p.sexo_paciente  FROM paciente p inner join consulta co on p.cod_paciente = co.cod_paciente_fk inner join cliente cli on p.cod_cliente_fk = cli.cod_cliente WHERE  cli.cod_cliente = cod and co.data_consulta= dat;

reg RECORD;
BEGIN
OPEN cs;

FETCH cs INTO reg;

RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION retornar(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS character
    LANGUAGE plpgsql
    AS $$
declare tiempo character(25) ;


begin

	tiempo = (select sum(do_fecha_fin - do_fechaini) 
	from documento_flujo  
	join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	join proceso on(documento.proceso_id=proceso.id)
	where proceso.id=idproceso and documento_flujo.do_estado='F' and
	(documento_flujo.do_fechaini BETWEEN fechaini and fechafin) and
	(documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	
	return tiempo;
end;
$$;",VTz-8rcK_modelosigedoc
"CREATE FUNCTION retornar(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS character
    LANGUAGE plpgsql
    AS $$
declare tiempo character(25) ;


begin

	tiempo = (select sum(do_fecha_fin - do_fechaini) 
	from documento_flujo  
	join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	join proceso on(documento.proceso_id=proceso.id)
	where proceso.id=idproceso and documento_flujo.do_estado='F' and
	(documento_flujo.do_fechaini BETWEEN fechaini and fechafin) and
	(documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	
	return tiempo;
end;
$$;",VvBq-zuB_modelosigedoc
"CREATE FUNCTION retornarminutos(fechaini timestamp without time zone, fechafin timestamp without time zone) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare segundos decimal;
declare minutos decimal;

begin
	segundos =(extract(epoch from age(fechaFin, fechaIni)))::decimal;
	minutos=segundos/60;
	minutos=round(minutos, 2);
	return minutos;
end;
$$;",VTz-8rcK_modelosigedoc
"CREATE FUNCTION retornarminutos(fechaini timestamp without time zone, fechafin timestamp without time zone) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare segundos decimal;
declare minutos decimal;

begin
	segundos =(extract(epoch from age(fechaFin, fechaIni)))::decimal;
	minutos=segundos/60;
	minutos=round(minutos, 2);
	return minutos;
end;
$$;",VvBq-zuB_modelosigedoc
"CREATE FUNCTION retornarnumdocu(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS character
    LANGUAGE plpgsql
    AS $$
declare tiempo character(25) ;
declare ndocumentos integer;


begin

	ndocumentos = (select count (distinct documento_flujo.documento_iddocumento)
  
	  from documento_flujo  
	      
	  join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	  join proceso on(documento.proceso_id=proceso.id)
	  where proceso.id=idproceso and (documento_flujo.do_fechaini BETWEEN fechaini and fechafin)
	  and (documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	
	return ndocumentos;
end;
$$;",VTz-8rcK_modelosigedoc
"CREATE FUNCTION retornarnumdocu(fechaini timestamp without time zone, fechafin timestamp without time zone, idproceso integer) RETURNS character
    LANGUAGE plpgsql
    AS $$
declare tiempo character(25) ;
declare ndocumentos integer;


begin

	ndocumentos = (select count (distinct documento_flujo.documento_iddocumento)
  
	  from documento_flujo  
	      
	  join documento on(documento_flujo.documento_iddocumento=documento.iddocumento)
	  join proceso on(documento.proceso_id=proceso.id)
	  where proceso.id=idproceso and (documento_flujo.do_fechaini BETWEEN fechaini and fechafin)
	  and (documento_flujo.do_fecha_fin BETWEEN fechaini and fechafin));
	
	return ndocumentos;
end;
$$;",VvBq-zuB_modelosigedoc
"CREATE FUNCTION revdownpart(text, text, text, text, text, boolean DEFAULT false, text DEFAULT NULL::text, text DEFAULT NULL::text) RETURNS TABLE(_partnumber text, _revision text, _serialnumber text, _sequencenumber integer, _itemfreqcode text)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 		ALIAS FOR $1;

	pCurrentRevision 	ALIAS FOR $2;

	pSerialNumber 		ALIAS FOR $3;

	pDocNumber 		ALIAS FOR $4;

	pDocType 		ALIAS FOR $5;

	pNpi 			ALIAS FOR $6;

	pLine			ALIAS FOR $7;

	pStation		ALIAS FOR $8;

	_viewpart 		RECORD;

	_item 			RECORD;

	_docTypeId 		INTEGER;

	_locationId 		INTEGER;

	_partStateId 		INTEGER;

	_prefix 		TEXT;

	_serialPattern 		TEXT;

	_targetRevision 	TEXT;

	_npiRevision 		BOOLEAN;

	_r 			RECORD;

	_message 		TEXT;

	_changeRevPart 		RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('revdownpart'));

	PERFORM (SELECT validatepart(pItemNumber, pCurrentRevision, pSerialNumber));



	SELECT item_number, part_serialnumber, part_sequencenumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber AND part_serialnumber = pSerialNumber AND part_rev = pCurrentRevision;

	

	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'revdownpart: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	_docTypeId := (SELECT getdoctypeid(pDocType));

	_npiRevision := pNpi;

	

	IF _npiRevision = false THEN

		SELECT itemrev_npi

		INTO _npiRevision

		FROM itemrev

		WHERE itemrev_item_id = _item.item_id

			AND itemrev_rev = pCurrentRevision;

	END IF;

		

	SELECT itemrevflow_start_rev

	INTO _targetRevision

	FROM itemrevflow

	WHERE itemrevflow_item_id = _item.item_id

		AND itemrevflow_end_rev = pCurrentRevision

		AND itemrevflow_npi = _npiRevision;



	IF pCurrentRevision = '00' THEN

		RAISE EXCEPTION 'revdownpart: Cannot RevDown Part at Revision 00';

	ElSIF _targetRevision IS NULL THEN

		_targetRevision := lpad((pCurrentRevision::INTEGER - 1)::TEXT, 2, '0');

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev = _targetRevision) IS NULL THEN

		RAISE EXCEPTION 'revdownpart: Target Revision % of Selected Item % Not Found in AeryonMES', _targetRevision, pItemNumber;

	END IF;



	SELECT * 

	INTO _changeRevPart

	FROM changerevpart(	pItemNumber, 

				pCurrentRevision, 

				pSerialNumber, 

				pDocNumber, 

				pDocType, 

				_targetRevision,

				pLine,

				pStation);



	_message := 	pItemNumber || ' down reved from ' ||  

			pCurrentRevision || ' to ' || 

			_targetRevision || ' for ' ||

			pSerialNumber || ' on ' ||

			pDocType || ' ' ||

			pDocNumber || '.';



	PERFORM (SELECT enterpartlog(	'Manufacturing'::TEXT, 

					'Down Reved'::TEXT,

					pItemNumber,

					_targetRevision,

					pSerialNumber,

					'Revision History'::TEXT,

					_changeRevPart._partrevhistid,

					_message,

					pDocType,

					pDocNumber));

		  

	_partnumber := pItemNumber;

	_serialnumber := pSerialNumber;

	_revision := _targetRevision;

	_itemfreqcode := _item.itemfreqcode_freqcode;

	_sequencenumber := _viewpart.part_sequencenumber;

	

	RETURN NEXT;

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION revuppart(text, text, text, text, text, boolean DEFAULT false, text DEFAULT NULL::text, text DEFAULT NULL::text) RETURNS TABLE(_partnumber text, _revision text, _serialnumber text, _sequencenumber integer, _itemfreqcode text)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pCurrentRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	pDocNumber ALIAS FOR $4;

	pDocType ALIAS FOR $5;

	pNpi ALIAS FOR $6;

	pLine ALIAS FOR $7;

	pStation ALIAS FOR $8;

	_viewpart RECORD;

	_item RECORD;

	_docTypeId INTEGER;

	_locationId INTEGER;

	_partStateId INTEGER;

	_prefix TEXT;

	_serialPattern TEXT;

	_targetRevision TEXT;

	_npiRevision boolean;

	_changeRevPart RECORD;

	_message TEXT;

  

BEGIN

	PERFORM (SELECT checkpriv('revuppart'));

	PERFORM (SELECT validatepart(pItemNumber, pCurrentRevision, pSerialNumber));

	

	SELECT item_number, part_serialnumber, part_sequencenumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber AND part_serialnumber = pSerialNumber AND part_rev = pCurrentRevision;

	

	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'revuppart: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	_docTypeId := (SELECT getdoctypeid(pDocType));

	_npiRevision := pNpi;

	

	IF _npiRevision = false THEN

		SELECT itemrev_npi

		INTO _npiRevision

		FROM itemrev

		WHERE itemrev_item_id = _item.item_id

			AND itemrev_rev = pCurrentRevision;

	END IF;

		

	SELECT itemrevflow_end_rev

	INTO _targetRevision

	FROM itemrevflow

	WHERE itemrevflow_item_id = _item.item_id

		AND itemrevflow_start_rev = pCurrentRevision

		AND itemrevflow_npi = _npiRevision;



	IF _targetRevision IS NULL THEN

		_targetRevision := lpad((pCurrentRevision::INTEGER + 1)::TEXT, 2, '0');

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev = _targetRevision) IS NULL THEN

		RAISE EXCEPTION 'revuppart: Target Revision % of Selected Item % Not Found in AeryonMES', _targetRevision, pItemNumber;

	END IF;



	SELECT * 

	INTO _changeRevPart

	FROM changerevpart(	pItemNumber, 

				pCurrentRevision, 

				pSerialNumber, 

				pDocNumber, 

				pDocType, 

				_targetRevision,

				pLine,

				pStation);



	



	_message := 	pItemNumber || ' up reved from ' ||  

			pCurrentRevision || ' to ' || 

			_targetRevision || ' for ' ||

			pSerialNumber || ' on ' ||

			pDocType || ' ' ||

			pDocNumber || '.';



	PERFORM (SELECT enterpartlog(	'Manufacturing'::TEXT, 

					'Up Reved'::TEXT,

					pItemNumber,

					_targetRevision,

					pSerialNumber,

					'Revision History'::TEXT,

					_changeRevPart._partrevhistid,

					_message,

					pDocType,

					pDocNumber));

		  

	_partnumber := pItemNumber;

	_serialnumber := pSerialNumber;

	_revision := _targetRevision;

	_itemfreqcode := _item.itemfreqcode_freqcode;

	_sequencenumber := _viewpart.part_sequencenumber;

	

	RETURN NEXT;

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION role_exists(_role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
	retval boolean;
begin

select exists(
	select null from roles where lower(application_name) = lower(_application_name) and lower(role_name) = lower(_role_name))
into retval;

return retval;
end;
$$;",20151231%20karental_user.sql
"CREATE FUNCTION role_exists(_role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
	retval boolean;
begin

select exists(
	select null from roles where lower(application_name) = lower(_application_name) and lower(role_name) = lower(_role_name))
into retval;

return retval;
end;
$$;",20160222%20karental_user.sql
"CREATE FUNCTION role_exists(_role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare
	retval boolean;
begin

select exists(
	select null from roles where lower(application_name) = lower(_application_name) and lower(role_name) = lower(_role_name))
into retval;

return retval;
end;
$$;",20160325%20karental_user.sql
"CREATE FUNCTION rtrim(character) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  trim(trailing chr(32) from $1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION run_test(_sp character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  EXECUTE 'SELECT ' || _sp;
  RAISE EXCEPTION '#OK';
EXCEPTION
  WHEN others THEN
    RETURN SQLERRM;
END;
$$;",mdm.sql
"CREATE FUNCTION run_test(_sp character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  EXECUTE 'SELECT ' || _sp;
  RAISE EXCEPTION '#OK';
EXCEPTION
  WHEN others THEN
    RETURN SQLERRM;
END;
$$;",mes-idea.sql
"CREATE FUNCTION salas_globales(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR SELECT * FROM SALA WHERE SALA.TIPO == $1 ORDER BY ID;
	RETURN MYCURS;
END;
$_$;",todo.sql
"CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;",postgresql.txt
"CREATE FUNCTION scrapsummsubass(text, text, text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 		ALIAS FOR $1;

	pRevision 		ALIAS FOR $2;

	pSerialNumber 		ALIAS FOR $3;

	pPartScrapCode 		ALIAS FOR $4;

	pPartScrapDescription 	ALIAS FOR $5;

	_viewpart 		RECORD;

	_usrId 			INTEGER;

	_r			RECORD;

  

BEGIN

	_usrID := (SELECT getusrid());  

	PERFORM (SELECT checkpriv('scrapsummsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber));



	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_serialnumber, 

		part_sequencenumber,

		part_cust_id,

		loc_number

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;

	

	PERFORM (SELECT scrappart(	pItemNumber, 

					pRevision,

					pSerialNumber,

					pPartScrapCode,

					pPartScrapDescription));



	FOR _r IN

		SELECT *

		FROM summsubass(	pItemNumber,

					pRevision,

					pSerialNumber)

	LOOP

		IF _r.c_item_number IS NOT NULL THEN

			PERFORM (SELECT scrappart(	_r.c_item_number,

							_r.c_part_rev,

							_r.c_part_serialnumber,

							pPartScrapCode,

							pPartScrapDescription,

							false));

		END IF;

	END LOOP;

	

	RETURN true;

END;$_$;",ames_dev.backup
"CREATE FUNCTION searchemp(empno character varying) RETURNS hr.employee
    LANGUAGE plpgsql
    AS $$
declare
row hr.employee%ROWTYPE;
begin
select * into row from hr.employee where vemployee = empno;
return row;
end;
$$;",190718-dump-a.sql
"CREATE FUNCTION searchemp(empno character varying) RETURNS hr.employee
    LANGUAGE plpgsql
    AS $$
declare
row hr.employee%ROWTYPE;
begin
select * into row from hr.employee where vemployee = empno;
return row;
end;
$$;",alldb_dump.sql
"CREATE FUNCTION searchstudent(stno character varying) RETURNS ty_studentinfo
    LANGUAGE plpgsql
    AS $$
declare
row ty_studentinfo;
begin
select * into row from studentinfo_v where vstudent=stno;
return row;
end;
$$;",190718-dump-a.sql
"CREATE FUNCTION searchstudent(stno character varying) RETURNS ty_studentinfo
    LANGUAGE plpgsql
    AS $$
declare
row ty_studentinfo;
begin
select * into row from studentinfo_v where vstudent=stno;
return row;
end;
$$;",alldb_dump.sql
"CREATE FUNCTION sec_authentication_kind_by_code(p_code text) RETURNS sec_authentication_kind
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  -- поиск схемы аутентификации по её коду. возвращает строку, если такая найдена.
  -- если не найдена или найдено несколько с таким кодом, возбуждает исключение
  res  sec_authentication_kind;
begin
  select *
    into STRICT res
    from sec_authentication_kind
   where upper(code) = upper(trim(both from p_code));
   return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00033', 'authentication kind not found by code ""%s""'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00033', p_code);
  when TOO_MANY_ROWS then
    -- 'SEC00034', 'authentication kind not unique by code ""%s""'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00034', p_code);
end;
$$;",metadict.sql
"CREATE FUNCTION sec_authentication_kind_by_name(p_name text) RETURNS sec_authentication_kind
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  -- поиск схемы аутентификации по её имени. возвращает строку, если такая найдена.
  -- если не найдена или найдено несколько с таким именем, возбуждает исключение
  res  sec_authentication_kind;
begin
  select *
    into STRICT res
    from sec_authentication_kind
   where upper(u.name) = upper(trim(both from p_name));
   return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00031', 'authentication kind not found by name ""%s""'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00031', p_name);
  when TOO_MANY_ROWS then
    -- 'SEC00032', 'authentication kind not unique by name ""%s""'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00032', p_name);
end;
$$;",metadict.sql
"CREATE FUNCTION sec_authentication_path_by_id(p_auth_path_id integer) RETURNS sec_authentication_path
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  -- возвращает строку по идентификатору
  l_ap       sec_authentication_path;
begin
  select *
    into strict l_ap
    from sec_authentication_path ap
   where id = p_auth_path_id;
  return l_ap;
exception
  when NO_DATA_FOUND then
    -- 'SEC00011', 'authentication path id (%s) found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00011', p_auth_path_id::text);
  when TOO_MANY_ROWS then
    -- 'SEC00012', 'authentication path id (%s) not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00012', p_auth_path_id::text);
end;
$$;",metadict.sql
"CREATE FUNCTION sec_logout(p_tokenvalue text) RETURNS sec_token
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- завершает сессию с указанным токеном. возвращает строку токена, если сессия завершена успешно. в противном случае возвращает null
  l_token    sec_token; -- токен
  l_session  sec_session; -- сессия
  l_user     sec_user; -- учетная запись
begin
  -- проверка действительности токена
  select * into l_token from sec_token_valid(p_tokenvalue);
  if (found) then
    -- токен действителен, завершаем его
    l_token := sec_token_stale(l_token, true);
    -- проверка действительности сессии
    l_session := sec_session_valid(l_token.session_id);
    -- учетная запись сессии
    l_user := sec_user_by_id(l_session.user_id);
    -- сессия действительна, завершаем её
    l_session := sec_session_stale(l_session, true);
    -- регистрируем событие логаута
    perform sec_event_log_start(l_token.session_id, 'sec_session', 'logout_succeded', xmlforest(l_token), l_user.name, l_token.auth_path_id, p_tokenvalue);
    -- возвращаем строку токена
    return l_token;
  else 
    -- 'SEC00026', 'token ""%s"" not found'
    raise warning invalid_password using message = env_resource_text_format('SEC00026', p_tokenvalue);
    return null;
  end if;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_session_find_by_id(p_session_id integer) RETURNS sec_session
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- поиск сессии по её идентификатору. возвращает строку сессии, если такая найдена.
  -- если сессия не найдена, возбуждает исключение
  res  sec_session%rowtype;
begin
  select s.* 
    into strict res
    from sec_session s 
   where s.id = p_session_id;
  return res;
exception
  when NO_DATA_FOUND then
    raise exception 'session_id % not found', p_session_id::text;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_session_has_permission(p_session_id integer, p_permission_name text) RETURNS boolean
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- возвращает наличие указанного разрешения в указанной сессии
  l_session sec_session; -- текущая сессия
begin
  -- текущая сессия
  select * into l_session from sec_session_find_by_id(p_session_id);
  -- TODO заменить на осмысленную проверку наличия разрешения
  return true;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_session_has_role(p_session_id integer, p_role_name text) RETURNS boolean
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- возвращает наличие указанной роли в указанной сессии
  l_session sec_session; -- текущая сессия
begin
  -- текущая сессия
  select * into l_session from sec_session_find_by_id(p_session_id);
  -- TODO заменить на осмысленную проверку наличия роли
  return true;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_session_require_permission(p_session_id integer, p_permission_name text) RETURNS void
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- проверяет наличие указанного разрешения в указанной сессии. если разрешение отсутствует, генерирует исключение
begin
  -- текущая сессия
  if (not sec_session_has_permission(p_session_id, p_permission_name)) then
    -- 'SEC00004', 'access denied. has no permission (%s)'
    raise exception insufficient_privilege using message = env_resource_text_format('SEC00004', p_permission_name);
  end if;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_session_valid(p_session_id integer) RETURNS sec_session
    LANGUAGE plpgsql STABLE COST 10
    AS $$
declare
  -- проверки валидности сессии
  l_session  sec_session; -- текущая сессия
  now        timestamp with time zone;
begin
  -- текущая сессия
  select * into l_session from sec_session_find_by_id(p_session_id);
  if (found) then
    -- сессия найдена
    now := clock_timestamp();
    if (l_session.whenstarted > now) or (coalesce(l_session.whenended, now) < now) then
      -- период действия сессии ещё не наступил или уже окончен
      -- 'SEC00006', 'session %s expired'
      raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00006', p_session_id::text);
    end if;
    return l_session;
  else
    -- сессия не найдена
    -- 'SEC00005', 'session %s not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00005', p_session_id::text);
  end if;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_token_find_by_value(p_tokenvalue text) RETURNS sec_token
    LANGUAGE plpgsql STABLE COST 5
    AS $_$declare
  -- поиск токена по его локальному (уникальному) текстовому содержимому. возвращает строку токена, если такой найден.
  -- если токен не найден, возбуждает исключение
  res  sec_token;
begin
  select st.* 
    into strict res
    from sec_token st 
   where st.localvalue = p_tokenvalue;
     --and clock_timestamp() between validfrom and validtill
  return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00027', 'token value ""%1$s"" not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00027', p_tokenvalue);
  when TOO_MANY_ROWS then
    -- 'SEC00028', 'token value ""%1$s"" not unique'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00028', p_tokenvalue);
end;
$_$;",metadict.sql
"CREATE FUNCTION sec_token_localvalue(p_token sec_token) RETURNS sec_token
    LANGUAGE plpgsql COST 5
    AS $_$declare
  -- возвращает строку токена с заполненным локальным (уникальным) текстовым содержимым токена.
begin
  if (p_token.originvalue is not null) then
    if (p_token.id is null) then
      p_token.id = nextval('sec_token_id_seq');
    end if;
    p_token.localvalue := p_token.id || '#' || p_token.originvalue;
    return p_token;
  else
    -- 'SEC00035', 'value ""%2$s"" of ""%1$s"" must be not null'
    raise exception null_value_not_allowed using message = env_resource_text_format('SEC00035', 'token', 'originvalue');
  end if;
end;
$_$;",metadict.sql
"CREATE FUNCTION sec_token_valid(p_tokenvalue text) RETURNS sec_token
    LANGUAGE plpgsql STABLE COST 10
    AS $$
declare
  -- проверки валидности токена безопасности
  l_token  sec_token; -- токен
  now      timestamp with time zone;
begin
  -- ищем токен по его значению 
  select * into l_token from sec_token_find_by_value(p_tokenvalue);
  if (found) then
    -- токен найден
    now := clock_timestamp();
    if (l_token.validfrom > now) or (coalesce(l_token.validtill, now) < now) then
      -- период действия токена ещё не наступил или уже окончен
      -- 'SEC00025', 'token ""%s"" expired'
      raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00025', p_tokenvalue);
    end if;
    return l_token;
  else
    -- токен не найден
    -- 'SEC00026', 'token ""%s"" not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00026', p_tokenvalue);
  end if;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_accepted(p_user_name text, p_credential text, p_auth_path_id integer DEFAULT NULL::integer) RETURNS SETOF sec_user_authcred
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- проверка учетных данных. возвращает набор, для которых учетные данные приняты (подтверждены).
  -- если учетные данные не приняты, возвращает пустой набор
  l_user_id  integer;
begin
  select /* sec_0002 */ id into l_user_id from sec_user_by_name(p_user_name);
  return query select /* sec_0003 */ * from sec_user_authcred_accepted(l_user_id, p_credential, p_auth_path_id);
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_by_pk(p_user_id integer, p_auth_path_id integer) RETURNS sec_user_authcred
    LANGUAGE plpgsql STABLE COST 5
    AS $_$declare
  -- поиск учетных данных по идентификатору учетной записи и источнику аутентификации. возвращает строку учетных данных, если такая найдена.
  -- если не найдена или найдено несколько, возбуждает исключение
  res  sec_user_authcred;
begin
  select *
    into STRICT res
    from sec_user_authcred
   where user_id = p_user_id
     and auth_path_id = p_auth_path_id;
     --and (clock_timestamp() between valid_from and valid_till); --срок действия учетных данных
   return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00029', 'authentication credential not found for user id ""%1$s"" and authentication path id ""%2$s""'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00029', p_user_id::text, p_auth_path_id::text);
  when TOO_MANY_ROWS then
    -- 'SEC00030', 'authentication credential not unique for user id ""%1$s"" and authentication path id ""%2$s""'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00030', p_user_id::text, p_auth_path_id::text);
end;
$_$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_comply_policy(p_session_id integer, p_user_id integer, p_old_credential text, p_credential text, p_auth_path_id integer) RETURNS integer
    LANGUAGE plpgsql STABLE COST 30
    AS $_$declare
  -- проверка соответствия политике учетных данных.
  -- p_session_id - текущая сессия, p_user_id - учетная запись, для которой проверяются учетные данные на сответствие политике
  -- p_old_credential ""старые"" (текущие) учетные данные, p_credential - ""новые"" учетные данные, p_auth_path_id - способ аутентификации
  l_session  sec_session; -- текущая сессия
  l_uac      sec_user_authcred;
  ok         boolean;
  l_user     sec_user;
  moment     timestamp with time zone;
  res        integer;
  l_similarity  constant integer := 5; -- требуемая точность сходства
  l_min_length  constant integer := 8; -- минимальная длина учетных данных
  l_authcred_log_depth constant integer := 100; -- глубина просмотра журнала истории учетных данных
  l_digit    constant text := '[0-9]'; -- регулярное выражение для поиска цифр
  l_alpha_ci constant text := '[a-zа-яA-ZА-Я]'; -- регулярное выражение для поиска букв без учета регистра символов
  l_alpha_lc constant text := '[a-zа-я]'; -- регулярное выражение для поиска букв в нижнем регистре
  l_alpha_uc constant text := '[A-ZА-Я]'; -- регулярное выражение для поиска букв в верхнем регистре
  l_punctuation constant text := '[^a-zA-Zа-яА-Я0-9]'; -- регулярное выражение для поиска знаков препинания и спецсимволов
  l_min_cred_age constant interval := '1 day'; -- сколько дней нельзя менять учетные данные (минимальный срок жизни учетных данных)
  l_max_cred_age constant interval := '100 day'; -- сколько дней нельзя использовать такие-же учетные данные (максимальный срок жизни учетных данных)
  l_text_is_similar integer; -- результат, при котором тексты считаются похожими
begin
  -- текущая сессия
  select * into l_session from sec_session_valid(p_session_id);
  -- наличие полномочий на проверку чужих учетных данных или попытка проверить свои
  select (l_session.user_id = p_user_id) or sec_session_has_permission(p_session_id, 'sec_user_authcred.comply_policy') into ok;
  if (ok) then -- либо проверяем свои данные, либо есть полномочия на проверку чужих
    -- проверка ""старых"" (текущих) учетных данных для указанного пользователя
    select * into l_uac from sec_user_authcred_accepted(p_user_id, p_old_credential, p_auth_path_id) limit 1;
    if (found) then -- ""старые"" (текущие) учетные данные действительны
      l_user := sec_user_by_id(p_user_id);
      -- минимальная длина 'SEC00015', 'credential length (%1$s) less than minimum allowed (%2$s)'
      if (p_credential is null) or (char_length(p_credential) < l_min_length) then
        return env_resource_text_find_by_code('SEC00015', char_length(p_credential)::text, l_min_length::text);
      end if;
      -- сложность (большие, маленькие буквы, цифры, знаки)
      if regexp_matches(p_credential, l_digit) is null then -- не содержит цифр
        -- 'SEC00016', 'credential must contain at least one digit'
        return env_resource_text_find_by_code('SEC00016');
      end if;
      if regexp_matches(p_credential, l_alpha_ci) is null then -- не содержит букв
        -- 'SEC00017', 'credential must contain at least one letter'
        return env_resource_text_find_by_code('SEC00017');
      end if;
      if regexp_matches(p_credential, l_alpha_lc) is null then -- не содержит букв в нижнем регистре
        -- 'SEC00018', 'credential must contain at least one lower case letter'
        return env_resource_text_find_by_code('SEC00018');
      end if;
      if regexp_matches(p_credential, l_alpha_uc) is null then -- не содержит букв в верхнем регистре
        -- 'SEC00019', 'credential must contain at least one upper case letter'
        return env_resource_text_find_by_code('SEC00019');
      end if;
      if regexp_matches(p_credential, l_punctuation) is null then -- не содержит знаков препинания и спецсимволов
        -- 'SEC00020', 'credential must contain at least one punctuation character'
        return env_resource_text_find_by_code('SEC00020');
      end if;
      l_text_is_similar := env_resource_text_find_by_code('RES00003');
      -- если имя учетной записи и новые учетные данные похожи сточностью до 5 общих символов подряд
      if env_text_similar(l_user.name, p_credential, l_similarity) = l_text_is_similar then 
        -- 'SEC00021', 'credential must not be similar to user name'
        return env_resource_text_find_by_code('SEC00021');
      end if;
      -- если старые и новые учетные данные похожи сточностью до 5 общих символов подряд
      if env_text_similar(p_old_credential, p_credential, l_similarity) = l_text_is_similar then 
        -- 'SEC00022', 'credential must not be similar to previous one'
        return env_resource_text_find_by_code('SEC00022');
      end if;
      -- менялись ли учетные данные в течении послених N дней
      -- для исключения быстрой смены N паролей и возвращения к ранее использованным учетным данным
      select cl.when_logged
        into moment
        from sec_user_authcred_log cl
       where cl.user_id = p_user_id 
         and cl.auth_path_id = l_uac.auth_path_id
         and cl.credential_hash <> sec_user_authcred_hash(p_session_id, p_user_id, p_credential, l_uac.auth_path_id)
         and cl.when_logged > clock_timestamp() - l_min_cred_age -- сколько дней нельзя менять учетные данные
       order by cl.when_logged desc
       limit 1;
      if (found) then -- учетные данные менялись в течении послених N дней
        -- 'SEC00023', 'credential must not be changed ""%1$s"" after previos changes at ""%2$s""'
        return env_resource_text_find_by_code('SEC00023');
      end if;
      -- поиск совпадений новых учетных данных со старыми во всей истории из 
      -- журнала изменений учетных данных или с ограничением глубины анализа истории
      -- TODO: переделать. надо считать кол-во смен паролей, а не кол-во строк
      select count(1)
        into res
        from (
              select row_number() over (order by cl.when_logged desc) as rn
                from sec_user_authcred_log cl
               where cl.user_id = p_user_id 
                 and cl.auth_path_id = l_uac.auth_path_id
                 and cl.credential_hash = sec_user_authcred_hash(p_session_id, p_user_id, p_credential, l_uac.auth_path_id)
                 and cl.when_logged > clock_timestamp() - l_max_cred_age -- сколько дней нельзя использовать такие-же учетные данные
             ) s
       where rn < l_authcred_log_depth; -- глубина просмотра журнала истории
      if (res > 0) then -- совпадения найдены
        return env_resource_text_find_by_code('-----');
      end if;

      -- TODO: проверка на совпадение со словарным словом
      -- TODO: проверка на схожесть с одной из предсказуемых последовательностей символов

      -- ""ANY00001"", ""ok (no errors)""
      return env_resource_text_find_by_code('ANY00001');
    else 
      -- 'SEC00009', 'no valid credentials found for user (%s) and authentication path id (%s)'
      return env_resource_text_find_by_code('SEC00009');
    end if;
  else 
    -- код ошибки SEC00004, ""access denied. has no permission (%s)""
    return env_resource_text_find_by_code('SEC00004');
  end if;
  return res;
end;
$_$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_encrypt(p_session_id integer, p_user_id integer, p_credential text, p_auth_path_id integer) RETURNS text
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- возвращает учетные данные в форме, предназначенной для хранения. для паролей это обычно хеш пароля с солью
  l_session  sec_session; -- текущая сессия
  l_user     sec_user;
  ok         boolean;
  res  text;
begin
  -- текущая сессия
  select * into l_session from sec_session_valid(p_session_id);
  -- указанная учетная запись
  select * into l_user from sec_user_by_id(p_user_id);
  --наличие полномочий на операцию с чужими учетными данными или на свои
  select sec_session_has_permission(p_session_id, 'sec_user_authcred.encrypt') or (l_session.user_id = l_user.id) into ok;
  if (not ok) then
    -- 'SEC00004', 'access denied. has no permission (%s)'
    raise exception insufficient_privilege using message = env_resource_text_format('SEC00004', 'sec_user_authcred.encrypt');
  end if;
  select case -- обработка разных типов аутентификации и разновидностей учетных данных.
           -- при добавлении новых видов аутентификации их обработку надо добавить сюда
           when (ak.code = 'pg_crypt') then crypt(p_credential, gen_salt(ap.credential_kind))
           else null
         end
    into strict res
    from sec_user_authcred acr,
         sec_authentication_path ap,
         sec_authentication_kind ak
   where (acr.user_id = p_user_id)
     and (acr.auth_path_id = p_auth_path_id)
     and (ap.id = acr.auth_path_id)
     and (ak.id = ap.authentication_kind_id);
  return res;
exception
  when NO_DATA_FOUND then
    raise exception 'user_id (%) and/or auth_path_id (%) not found', p_user_id, p_auth_path_id;
  when TOO_MANY_ROWS then
    raise exception 'user_id (%) and auth_path_id (%) are not unique', p_user_id, p_auth_path_id;
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_hash(p_session_id integer, p_user_id integer, p_credential text, p_auth_path_id integer) RETURNS text
    LANGUAGE plpgsql STABLE COST 30
    AS $$declare
  -- возвращает хеш учетных данных
  l_session  sec_session; -- текущая сессия
  l_user     sec_user;
  ok         boolean;
  l_ap       sec_authentication_path;
begin
  -- текущая сессия
  select * into l_session from sec_session_valid(p_session_id);
  -- указанная учетная запись
  select * into l_user from sec_user_by_id(p_user_id);
  --наличие полномочий на операцию с чужими учетными данными или на свои
  select sec_session_has_permission(p_session_id, 'sec_user_authcred.hash') or (l_session.user_id = l_user.id) into ok;
  if (not ok) then
    -- 'SEC00004', 'access denied. has no permission (%s)'
    raise exception insufficient_privilege using message = env_resource_text_format('SEC00004', 'sec_user_authcred.hash');
  end if;
  l_ap := sec_authentication_path_by_id(p_auth_path_id);
  return encode(digest(l_user.name||p_credential, l_ap.credential_hash_kind), 'hex');
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_authcred_is_valid(p_session_id integer, p_uac sec_user_authcred) RETURNS boolean
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  -- проверка периода действия учетных данных
  l_session  sec_session; -- текущая сессия
  l_user     sec_user;
  ok         boolean;
begin
  -- текущая сессия
  select * into l_session from sec_session_valid(p_session_id);
  --наличие полномочий на операцию с чужими учетными данными или на свои
  select sec_session_has_permission(p_session_id, 'sec_user_authcred.is_valid') or (l_session.user_id = p_uac.user_id) into ok;
  if (not ok) then
    -- 'SEC00004', 'access denied. has no permission (%s)'
    raise exception insufficient_privilege using message = env_resource_text_format('SEC00004', 'sec_user_authcred.is_valid');
  end if;
  return (clock_timestamp() between p_uac.valid_from and p_uac.valid_till); --срок действия учетных данных
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_by_id(p_id integer) RETURNS sec_user
    LANGUAGE plpgsql STABLE COST 5
    AS $$declare
  -- поиск учетной записи по её идентификатору. возвращает строку учетной записи, если такая найдена.
  -- если учетная запись не найдена или найдено несколько учетных записей с таким идентификатором, возбуждает исключение
  res  sec_user;
begin
  select u.*
    into STRICT res
    from sec_user u
   where id = p_id;
   return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00013', 'user id %s not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00013', p_id::text);
  when TOO_MANY_ROWS then
    -- 'SEC00014', 'user id %s not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00014', p_id::text);
end;
$$;",metadict.sql
"CREATE FUNCTION sec_user_by_name(p_user_name text) RETURNS sec_user
    LANGUAGE plpgsql STABLE COST 10
    AS $_$declare
  -- поиск учетной записи по её имени. возвращает строку учетной записи, если такая найдена.
  -- если учетная запись не найдена или найдено несколько учетных записей с таким именем, возбуждает исключение
  res  sec_user%rowtype;
begin
  select u.*
    into STRICT res
    from sec_user u
   where upper(u.name) = upper($1);
   return res;
exception
  when NO_DATA_FOUND then
    -- 'SEC00001', 'user %s not found'
    raise exception NO_DATA_FOUND using message = env_resource_text_format('SEC00001', p_user_name);
    --execute env_raise_exception('P0002', 'SEC00001', p_user_name);
  when TOO_MANY_ROWS then
    -- 'SEC00002', 'user %s not unique'
    raise exception TOO_MANY_ROWS using message = env_resource_text_format('SEC00002', p_user_name);
    --execute env_raise_exception('23505', 'SEC00002', p_user_name);
end;
$_$;",metadict.sql
"CREATE FUNCTION sec_user_create(p_session_id integer, p_name text, p_auth_path_id integer, p_credential text) RETURNS sec_user
    LANGUAGE plpgsql COST 10
    AS $$declare
  -- создание учетной записи
  l_person  prs_person;
  l_user    sec_user;
begin
  select * into l_person from prs_person_create(p_session_id, p_name, (prs_person_kind()).""INDIVIDUAL"", null, null);
  select * into l_user from sec_user_create(p_session_id, l_person.id, p_name, p_auth_path_id, p_credential);
  return l_user;
end;
$$;",metadict.sql
"CREATE FUNCTION secondsworked(timestamp with time zone[]) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
declare
/*	times timestamp with time zone[] := ARRAY[];*/
	times timestamp with time zone[];
	count integer := 1;
	span numeric := 0;
	mag integer := 0;
begin
	times := $1;
	if array_upper(times, 1) % 2 = 1 then
		times := times || 'now'::timestamp with time zone;
	end if;

	mag := array_upper(times,1);

	while count <= mag loop
		span := span + extract(epoch from times[count + 1] - times[count]);
		count := count + 2;
	end loop;
	return span;
end;
$_$;",db.sql
"CREATE FUNCTION secondsworkedcompleted(timestamp with time zone[]) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
declare
/*	times timestamp with time zone[] := ARRAY[];*/
	times timestamp with time zone[];
	count integer := 1;
	span numeric := 0;
	mag integer := 0;
begin
	times := $1;

	mag := array_upper(times,1);

	if mag % 2 = 1 then
           --remove the last time from the calculation -- only show completed ones
	   mag := mag - 1;
	end if;

	while count <= mag loop
		span := span + extract(epoch from times[count + 1] - times[count]);
		count := count + 2;
	end loop;
	return span;
end;
$_$;",db.sql
"CREATE FUNCTION secondsworkedestimated(timestamp with time zone[]) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
declare
/*	times timestamp with time zone[] := ARRAY[];*/
	times timestamp with time zone[];
begin
	times := $1;
	if array_upper(times, 1) % 2 = 1 then
		times := times || current_timestamp;
	end if;
	return secondsWorkedCompleted(times);
end;
$_$;",db.sql
"CREATE FUNCTION select_all_links() RETURNS TABLE(obj text, attr text, type text, attr_value text)
    LANGUAGE plpgsql
    AS $$
DECLARE
  link_record RECORD;
BEGIN
  FOR link_record IN SELECT link.link_id, object1.name AS obj1_name, object2.name AS obj2_name, link.type FROM ""nir-link"" link
    JOIN ""nir-object"" object1 ON link.obj1 = object1.id
    JOIN ""nir-object"" object2 ON link.obj2 = object2.id

    LOOP
      obj := link_record.obj1_name;
      attr := link_record.obj2_name;
      type := link_record.type;

      IF type = 'int' THEN
        SELECT value::text INTO attr_value  FROM ""int"" int_table WHERE int_table.link_id = link_record.link_id LIMIT 1;
      END IF;
      IF type = 'string' THEN
        SELECT value INTO attr_value FROM ""string"" string_table WHERE string_table.link_id = link_record.link_id LIMIT 1;
      END IF;
      IF type = 'double' THEN
        SELECT value::text INTO attr_value FROM ""real"" real_table WHERE real_table.link_id = link_record.link_id LIMIT 1;
      END IF;
      IF type = 'binary' THEN
        SELECT value::text INTO attr_value FROM ""binary"" binary_table WHERE binary_table.link_id = link_record.link_id LIMIT 1;
      END IF;
      IF type = 'datetime' THEN
        SELECT value INTO attr_value FROM ""date-time"" datetime_table WHERE datetime_table.link_id = link_record.link_id LIMIT 1;
      END IF;
      RETURN NEXT;
  END LOOP;
END;
$$;",graphA.sql
"CREATE FUNCTION select_donors_data(integer) RETURNS SETOF integer
    LANGUAGE plpgsql STABLE STRICT
    AS $_$
declare
batch int := (
	select data_serial from datas
	where have_data and
		data >= (select max(data) from datas)
			- (($1::text || ' week')::interval)
	order by data asc limit 1
);
begin
return query execute '
select usuario
from usuarios
where data = $1
' using batch;
return;
end
;$_$;


ALTER FUNCTION public.select_donors_data(integer) OWNER TO folding;

--
-- TOC entry 179 (class 1259 OID 1604111)
-- Name: donor_first_wu; Type: TABLE; Schema: public; Owner: folding; Tablespace: 
--

CREATE TABLE donor_first_wu (
    donor integer NOT NULL,
    data timestamp with time zone
);


ALTER TABLE donor_first_wu OWNER TO folding;

--
-- TOC entry 294 (class 1255 OID 1604114)
-- Name: select_new_members(integer, integer); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION select_new_members(integer, integer) RETURNS SETOF donor_first_wu
    LANGUAGE sql STABLE STRICT
    AS $_$select count(donor)::integer, date_trunc('day', d.data) as data_day
from donor_first_wu as dfw
inner join usuarios_indice as ui on
  dfw.donor = ui.usuario_serial and ui.n_time = $1
right outer join datas as d on dfw.data = d.data
where
  date_trunc('day', d.data) > (
    select date_trunc('day', data)
    from datas
    order by data desc limit 1
    ) - (($2::text || ' week')::interval)
group by data_day
$_$;


ALTER FUNCTION public.select_new_members(integer, integer) OWNER TO folding;

--
-- TOC entry 295 (class 1255 OID 1604115)
-- Name: select_team_size_table(integer, integer); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION select_team_size_table(integer, integer) RETURNS SETOF type_select_team_size_table
    LANGUAGE sql STABLE STRICT
    AS $_$select
  donor::smallInt as new_members,
  active_members,
  d.data::date as day,
  isodow(d.data::date)::smallInt as dow
from
  team_active_members_history as tam
  inner join
  datas as d on d.data_serial = tam.serial_date
  inner join
  select_new_members($1, $2) as nm on nm.data::date = d.data::date
where
  team_number = $1
  and
  d.data_serial = (
    select data_serial
    from datas
    where date_trunc('day', data) = date_trunc('day', d.data)
    order by data desc
    limit 1
    )
;
$_$;


ALTER FUNCTION public.select_team_size_table(integer, integer) OWNER TO folding;

--
-- TOC entry 296 (class 1255 OID 1604116)
-- Name: select_two_consecutive_serial_dates(); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION select_two_consecutive_serial_dates() RETURNS SETOF type_two_serial_dates_x_days
    LANGUAGE sql STABLE STRICT
    AS $$
select
  data_serial as d1_serial,
  (
  select data_serial
  from datas
  where data < de.data
  order by data desc
  limit 1
  ) as d0_serial
from datas as de
where data <> (select data from datas order by data limit 1)
order by data desc
;
$$;


ALTER FUNCTION public.select_two_consecutive_serial_dates() OWNER TO folding;

--
-- TOC entry 297 (class 1255 OID 1604117)
-- Name: select_two_serial_dates_x_days(integer); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION select_two_serial_dates_x_days(integer) RETURNS SETOF type_two_serial_dates_x_days
    LANGUAGE sql STABLE STRICT
    AS $_$select data_serial as d1_serial,
  coalesce((
    select data_serial
    from (select data, data_serial from datas where have_data) as dhd
    where
      date_trunc('day', de.data - ($1::text ||' days')::interval) =
      date_trunc('day', dhd.data)
      and
      in_day_batch_number(dhd.data_serial) =
      in_day_batch_number(de.data_serial)
    ), (
    select data_serial
    from (select data, data_serial from datas where have_data) as dhd
    where
      de.data - ($1::text ||' days')::interval >=
      dhd.data
    order by data desc
    limit 1
    )) as d0_serial
from datas as de
where have_data and
  data <> (select data from datas order by data limit 1)
order by data desc
;
$_$;


ALTER FUNCTION public.select_two_serial_dates_x_days(integer) OWNER TO folding;

--
-- TOC entry 298 (class 1255 OID 1604118)
-- Name: select_two_serial_dates_x_days_last_batch(integer); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION select_two_serial_dates_x_days_last_batch(integer) RETURNS SETOF type_two_serial_dates_x_days
    LANGUAGE sql STABLE STRICT
    AS $_$select d1_serial, d0_serial
from select_two_serial_dates_x_days($1) as tsd
inner join datas as d
on d.data_serial = tsd.d1_serial
where d.data_serial = (
  select data_serial
  from datas
  where have_data and
    date_trunc('day', data) = date_trunc('day', d.data)
  order by data desc
  limit 1
  )
;
$_$;


ALTER FUNCTION public.select_two_serial_dates_x_days_last_batch(integer) OWNER TO folding;

--
-- TOC entry 299 (class 1255 OID 1604119)
-- Name: subteam_group_name(text, text); Type: FUNCTION; Schema: public; Owner: folding
--

CREATE FUNCTION subteam_group_name(name text, pattern text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
begin
if name ~ pattern then
  return substring(upper(name) from pattern);
else
  return name;
end if;
end;
$$;",ks2.schema
"CREATE FUNCTION selection() RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
 
 IF (SELECT type_instr FROM instrument WHERE isin IN (SELECT isin FROM trade ORDER BY trade_id DESC LIMIT 1))='bond' THEN
  PERFORM add_acc_na_nc();
  ELSE PERFORM add_acc_nj();
  END IF;
  END;$$;",DBinit.sql
"CREATE FUNCTION serialbom(text, text) RETURNS TABLE(t_item_number text, t_bom_itemrev text, t_bom_qtyper numeric, p_item_number text, p_bom_itemrev text, p_bom_qtyper numeric, c_item_number text, c_bom_itemrev text, c_bom_qtyper numeric)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	_item RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('serialbom'));



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'serialbom: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev = pRevision) IS NULL THEN

		RAISE EXCEPTION 'serialbom: Revision % of Selected Item % Not Found in AeryonMES', pRevision, pItemNumber;

	END IF;



	RETURN QUERY (WITH RECURSIVE b(	t_bom_item_id, 

					t_bom_itemrev,

					t_bom_qtyper,

					p_bom_item_id, 

					p_bom_itemrev, 

					p_bom_qtyper,

					p_item_phantom,

					c_bom_item_id, 

					c_bom_itemrev,

					c_bom_qtyper,

					c_item_phantom) 

			AS(	SELECT	p.bom_parent_item_id 	AS t_bom_item_id,

					p.bom_parent_itemrev 	AS t_bom_itemrev,

					1::NUMERIC(20, 8)	AS t_bom_qtyper,

					p.bom_parent_item_id 	AS p_bom_item_id,

					p.bom_parent_itemrev 	AS p_bom_itemrev,

					1::NUMERIC(20, 8)	AS p_bom_qtyper,

					i2.item_phantom		AS p_item_phantom,

					p.bom_item_id		AS c_bom_item_id,

					p.bom_itemrev		AS c_bom_itemrev,

					p.bom_qtyper		AS c_bom_qtyper,

					i3.item_phantom		AS c_item_phantom

				FROM	bom p

				LEFT OUTER JOIN item i2

					ON i2.item_id = bom_parent_item_id

				LEFT OUTER JOIN item i3

					ON i3.item_id = p.bom_item_id

				WHERE 	p.bom_parent_item_id = _item.item_id

				AND 	p.bom_parent_itemrev = pRevision

				AND 	COALESCE(p.bom_effective, now()) <= now()

				AND 	COALESCE(p.bom_expires, now()) >= now()

			UNION ALL

				SELECT 	b.t_bom_item_id 	AS t_bom_item_id,

					b.t_bom_itemrev 	AS t_bom_itemrev,

					b.t_bom_qtyper		AS t_bom_qtyper,

					b.c_bom_item_id 	AS p_bom_item_id,

					b.c_bom_itemrev 	AS p_bom_itemrev,

					b.c_bom_qtyper 		AS p_bom_qtyper,

					b.c_item_phantom	AS p_item_phantom,

					c.bom_item_id		AS c_bom_item_id,

					c.bom_itemrev		AS c_bom_itemrev,

					(c.bom_qtyper * b.c_bom_qtyper)::NUMERIC(20, 8)

								AS c_bom_qtyper,

					i3.item_phantom		AS c_item_phantom

				FROM 	b

				LEFT OUTER JOIN bom c

					ON c.bom_parent_item_id = b.c_bom_item_id

				LEFT OUTER JOIN item i3

					ON i3.item_id = c.bom_item_id

				WHERE 	c.bom_parent_item_id = b.c_bom_item_id

				AND 	c.bom_parent_itemrev = b.c_bom_itemrev

				AND 	COALESCE(c.bom_effective, now()) <= now()

				AND 	COALESCE(c.bom_expires, now()) >= now()

				AND	b.c_item_phantom = true

			)

		SELECT 	i1.item_number AS t_item_number, 

			b.t_bom_itemrev, 

			b.t_bom_qtyper, 

			i2.item_number AS p_item_number, 

			b.p_bom_itemrev, 

			b.p_bom_qtyper, 

			i3.item_number AS c_item_number, 

			b.c_bom_itemrev, 

			b.c_bom_qtyper

		FROM 	b

		LEFT OUTER JOIN item i1

			ON b.t_bom_item_id = i1.item_id

		LEFT OUTER JOIN item i2

			ON b.p_bom_item_id = i2.item_id

		LEFT OUTER JOIN item i3

			ON b.c_bom_item_id = i3.item_id

		WHERE i3.item_serialized = true

		AND b.c_item_phantom = false);

		  

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",AuroraOld.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-07-31.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-08-01.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-09-25.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-10-07.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-10-14.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-14-11-24-versao-1.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-15-03-03.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-15-03-10.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-15-04-28.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-15-04-30-oficial.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-16-11-09-2.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-16-11-09.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-16-11-25.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump-16-11-28.sql
"CREATE FUNCTION serialize_array(text[], separador character varying) RETURNS text
    LANGUAGE plpgsql
    AS $_$
	DECLARE
		v_array ALIAS FOR $1;
		v_separador ALIAS FOR $2;
		v_serialize_array text := '';
	BEGIN
		FOR i IN array_lower(v_array, 1) .. array_upper(v_array, 1) LOOP
			IF v_serialize_array = '' THEN
				v_serialize_array := v_array[i];
			ELSE
				IF v_separador = '' THEN
					v_serialize_array := v_serialize_array||','||v_array[i];
				ELSE
					v_serialize_array := v_serialize_array||v_separador||v_array[i];
				END IF;
			END IF;
		END LOOP;

		RETURN v_serialize_array;
	END
$_$;",liverpool_dump_14-09-20.sql
"CREATE FUNCTION serialsubass(text, text, text) RETURNS TABLE(t_item_number text, t_part_rev text, t_part_serialnumber text, t_part_sequencenumber integer, t_part_parent_allocorder integer, p_item_number text, p_part_rev text, p_part_serialnumber text, p_part_sequencenumber integer, p_part_parent_allocorder integer, c_item_number text, c_part_rev text, c_part_serialnumber text, c_part_sequencenumber integer, c_part_parent_allocorder integer)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	_viewpart RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('serialsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber));



	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_serialnumber, 

		part_sequencenumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;



	RETURN QUERY (WITH a(		t_part_id,

					t_part_item_id,

					t_part_rev,

					t_part_serialnumber,

					t_part_sequencenumber,

					t_part_parent_part_id,

					t_part_allocpos,

					p_part_id,

					p_part_item_id,

					p_part_rev,

					p_part_serialnumber,

					p_part_sequencenumber,

					p_part_parent_part_id,

					p_part_allocpos,

					p_item_phantom,

					c_part_id,

					c_part_item_id,

					c_part_rev,

					c_part_serialnumber,

					c_part_sequencenumber,

					c_part_parent_part_id,

					c_part_allocpos,

					c_item_phantom) 

			AS(	SELECT	p.part_id			AS t_part_id,

					p.part_item_id			AS t_part_item_id,

					p.part_rev			AS t_part_rev,

					p.part_serialnumber		AS t_part_serialnumber,

					p.part_sequencenumber		AS t_part_sequencenumber,

					p.part_parent_part_id		AS t_part_parent_part_id,

					p.part_allocpos			AS t_part_allocpos,

					p.part_id			AS p_part_id,

					p.part_item_id			AS p_part_item_id,

					p.part_rev			AS p_part_rev,

					p.part_serialnumber		AS p_part_serialnumber,

					p.part_sequencenumber		AS p_part_sequencenumber,

					p.part_parent_part_id		AS p_part_parent_part_id,

					p.part_allocpos			AS p_part_allocpos,

					i2.item_phantom			AS p_item_phantom,

					c.part_id			AS c_part_id,

					c.part_item_id			AS c_part_item_id,

					c.part_rev			AS c_part_rev,

					c.part_serialnumber		AS c_part_serialnumber,

					c.part_sequencenumber		AS c_part_sequencenumber,

					c.part_parent_part_id		AS c_part_parent_part_id,

					c.part_allocpos			AS c_part_allocpos,

					i3.item_phantom			AS c_item_phantom

				FROM	part p

				LEFT OUTER JOIN part c

					ON p.part_id = c.part_parent_part_id

				LEFT OUTER JOIN item i2

					ON i2.item_id = p.part_item_id

				LEFT OUTER JOIN item i3

					ON i3.item_id = c.part_item_id

				WHERE 	p.part_id = _viewpart.part_id

			-- UNION ALL

-- 				SELECT	p.part_id			AS t_part_id,

-- 					p.part_item_id			AS t_part_item_id,

-- 					p.part_rev			AS t_part_rev,

-- 					p.part_serialnumber		AS t_part_serialnumber,

-- 					p.part_sequencenumber		AS t_part_sequencenumber,

-- 					p.part_parent_part_id		AS t_part_parent_part_id,

-- 					p.part_allocpos			AS t_part_allocpos,

-- 					p.part_id			AS p_part_id,

-- 					p.part_item_id			AS p_part_item_id,

-- 					p.part_rev			AS p_part_rev,

-- 					p.part_serialnumber		AS p_part_serialnumber,

-- 					p.part_sequencenumber		AS p_part_sequencenumber,

-- 					p.part_parent_part_id		AS p_part_parent_part_id,

-- 					p.part_allocpos			AS p_part_allocpos,

-- 					i2.item_phantom			AS p_item_phantom,

-- 					c.part_id			AS c_part_id,

-- 					c.part_item_id			AS c_part_item_id,

-- 					c.part_rev			AS c_part_rev,

-- 					c.part_serialnumber		AS c_part_serialnumber,

-- 					c.part_sequencenumber		AS c_part_sequencenumber,

-- 					c.part_parent_part_id		AS c_part_parent_part_id,

-- 					c.part_allocpos			AS c_part_allocpos,

-- 					i3.item_phantom			AS c_item_phantom

-- 				FROM	part p

-- 				LEFT OUTER JOIN part c

-- 					ON p.part_id = c.part_parent_part_id

-- 				LEFT OUTER JOIN item i2

-- 					ON i2.item_id = a.p_part_item_id

-- 				LEFT OUTER JOIN item i3

-- 					ON i3.item_id = c.part_item_id

-- 				WHERE 	p.part_id = _viewpart.part_id

-- 				AND	a.c_item_phantom = true

			)

		SELECT 	i1.item_number AS t_item_number, 

			a.t_part_rev,

			a.t_part_serialnumber,

			a.t_part_sequencenumber,

			a.t_part_allocpos,

			i2.item_number AS p_item_number, 

			a.p_part_rev,

			a.p_part_serialnumber,

			a.p_part_sequencenumber,

			a.p_part_allocpos,

			i3.item_number AS c_item_number, 

			a.c_part_rev,

			a.c_part_serialnumber,

			a.c_part_sequencenumber,

			a.c_part_allocpos 

		FROM 	a

		LEFT OUTER JOIN item i1

			ON a.t_part_item_id = i1.item_id

		LEFT OUTER JOIN item i2

			ON a.p_part_item_id = i2.item_id

		LEFT OUTER JOIN item i3

			ON a.c_part_item_id = i3.item_id);

		  

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION session_is_superuser() RETURNS boolean
    AS $$
BEGIN
    PERFORM login from app_session where session_id = 
        (SELECT current_sess_id()) and login is null;

    RETURN FOUND;
END;
$$
    LANGUAGE plpgsql;",bahai02.dump
"CREATE FUNCTION sha1(bytea) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
RETURN ENCODE(DIGEST($1, 'sha1'), 'hex');
END;
$_$;",ddl.sql
"CREATE FUNCTION sha1(bytea) RETURNS text
    LANGUAGE plpgsql
    AS $_$
BEGIN
    RETURN ENCODE(DIGEST($1, 'sha1'), 'hex');
END;
$_$;",baza.sql
"CREATE FUNCTION sha256(bytea) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
BEGIN
RETURN ENCODE(DIGEST($1, 'sha256'), 'hex');
END;
$_$;",ddl.sql
"CREATE FUNCTION show_column(column_name name, table_name oid) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE
	result boolean := true;
	col_comment text;
	str RECORD;
BEGIN
	col_comment := html.get_column_comment(column_name, table_name);
	FOR str IN SELECT foo FROM regexp_split_to_table(col_comment, E'\n') AS foo LOOP
		IF str.foo ~* E'^show="".*""$' THEN
			IF lower(trim(both '""' from substring(str.foo from '"".*""'))) = 'false' THEN
				RETURN false;
			END IF;
		END IF;
	END LOOP;
	RETURN result;
END;
$_$;",schema-html.sql
"CREATE FUNCTION show_timestamp(created bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	timestamp_converted VARCHAR;
BEGIN
  SELECT TIMESTAMP WITH TIME ZONE 'epoch' + created * INTERVAL '1 second' INTO timestamp_converted;
  RETURN timestamp_converted;
END;
$$;",backup.sql
"CREATE FUNCTION slot2interval(slotnumber bigint) RETURNS interval
    LANGUAGE plpgsql
    AS $$declare
  Minutes interval;
  xD bigint;
  xH bigint;
  xM bigint;
  xMin bigint;
begin
  xM = mod(slotnumber,100);
  xH = mod((slotnumber/100),100);
  xD = mod((slotnumber/10000),100);
  xMin = xM + (xH * 60) + (xD * 24 * 60);
  Minutes = xMin * '1 minutes'::interval;

  return Minutes;
end;
$$;",TBDB.bck
"CREATE FUNCTION soma(p1 integer, p2 integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  begin
     return p1 + p2 ;
  end;
$$;",aula.sql
"CREATE FUNCTION soma5(p1 anyelement, p2 anyelement) RETURNS anyelement
    LANGUAGE plpgsql
    AS $$
  begin
    return p1 + p2;
  end;
$$;",aula.sql
"CREATE FUNCTION somefunc() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    quantity integer := 30;
BEGIN
    --RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30
    quantity := 50;
    --
    -- Create a subblock
    --
   
    BEGIN
	quantity :=(SELECT COUNT(*) FROM ""USERS"");
	quantity :=quantity+1;
        --RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80
        --RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50
    END;

    --RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50

    RETURN quantity;
END;
$$;",server.sql
"CREATE FUNCTION soundex(input text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT COST 500
    AS $$
DECLARE
  soundex text = '';
  char text;
  symbol text;
  last_symbol text = '';
  pos int = 1;
BEGIN
  WHILE length(soundex) < 4 LOOP
    char = upper(substr(input, pos, 1));
    pos = pos + 1;
    CASE char
    WHEN '' THEN
      -- End of input string
      IF soundex = '' THEN
        RETURN '';
      ELSE
        RETURN rpad(soundex, 4, '0');
      END IF;
    WHEN 'B', 'F', 'P', 'V' THEN
      symbol = '1';
    WHEN 'C', 'G', 'J', 'K', 'Q', 'S', 'X', 'Z' THEN
      symbol = '2';
    WHEN 'D', 'T' THEN
      symbol = '3';
    WHEN 'L' THEN
      symbol = '4';
    WHEN 'M', 'N' THEN
      symbol = '5';
    WHEN 'R' THEN
      symbol = '6';
    ELSE
      -- Not a consonant; no output, but next similar consonant will be re-recorded
      symbol = '';
    END CASE;

    IF soundex = '' THEN
      -- First character; only accept strictly English ASCII characters
      IF char ~>=~ 'A' AND char ~<=~ 'Z' THEN
        soundex = char;
        last_symbol = symbol;
      END IF;
    ELSIF last_symbol != symbol THEN
      soundex = soundex || symbol;
      last_symbol = symbol;
    END IF;
  END LOOP;

  RETURN soundex;
END;
$$;",xo.txt
"CREATE FUNCTION sp_campeonato_buscar_por_sequencial(OUT ""P_CS_GERAL"" refcursor, ""P_SEQ_CAMPEONATO"" integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM campeonato WHERE SEQ_CAMPEONATO = $2;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_campeonato_buscar_todos(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM campeonato;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_configuracao_cambista_buscar_todos(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR EXECUTE
 'SELECT U.*, CC.* FROM USUARIO U, TIPO_USUARIO TU, CONFIGURACAO_CAMBISTA CC
 WHERE U.COD_TIPO_USUARIO = TU.SEQ_TIPO_USUARIO
 AND CC.COD_USUARIO = U.SEQ_USUARIO
 ORDER BY CC.SEQ_CAMBISTA';
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_configuracao_jogo_buscar_por_seq_jogo(OUT ""P_CS_GERAL"" refcursor, ""P_SEQ_JOGO"" integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM configuracao_jogo WHERE COD_JOGO = $2;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_esporte_buscar_por_sequencial(OUT ""P_CS_GERAL"" refcursor, ""P_SEQ_ESPORTE"" integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM esporte WHERE SEQ_ESPORTE = $2;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_esporte_buscar_todos(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM esporte;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_generic_return_ref(text) RETURNS refcursor
    LANGUAGE plpgsql IMMUTABLE
    AS $_$      
	DECLARE
		sql ALIAS for $1;
		ref refcursor;                                         
	BEGIN
		OPEN ref FOR EXECUTE sql;

	RETURN ref; 
	                                                      
	END;
	
	$_$;",SQL.DACB2.TMS-DB-Cleaned-with-Fields.sql
"CREATE FUNCTION sp_jogo_buscar_todos(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM jogo;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_jogo_retornar_ultimo_sequencial(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR SELECT MAX(seq_jogo) AS seq_jogo FROM jogo; 
 
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_limite_aposta_buscar_por_seq_jogo(OUT ""P_CS_GERAL"" refcursor, ""P_SEQ_JOGO"" integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR 
  SELECT * FROM limite_aposta WHERE COD_JOGO = $2;
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_process_address1(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_process_address2(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_process_address3(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := data_cleaning.sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_process_address4(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(data_cleaning.sp_replace_vietnamese_char($1))),'');
	var_result := data_cleaning.sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := data_cleaning.sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_process_data_char_after_number(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_replace_common_phrase(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_20160106.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_20160107.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_20160111.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_20160113.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_latest.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_production.backup
"CREATE FUNCTION sp_replace_vietnamese_char(character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$_$;",data-cleaning_production_20160118.backup
"CREATE FUNCTION sp_usuario_buscar_todos(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;

BEGIN

OPEN $1 FOR EXECUTE
  'SELECT U.*, CC.* FROM USUARIO U, TIPO_USUARIO TU, CONFIGURACAO_CAMBISTA CC
 WHERE U.COD_TIPO_USUARIO = TU.SEQ_TIPO_USUARIO
 AND CC.COD_USUARIO = U.SEQ_USUARIO
 ORDER BY U.NOME_USUARIO';
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION sp_usuario_consultar_por_parametros(OUT ""P_CS_GERAL"" refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
 P_CS_GERAL REFCURSOR;
BEGIN
	
 OPEN $1 FOR EXECUTE 
 'SELECT U.*, CC.* FROM USUARIO U, TIPO_USUARIO TU, CONFIGURACAO_CAMBISTA CC
 WHERE U.COD_TIPO_USUARIO = TU.SEQ_TIPO_USUARIO
 AND CC.COD_USUARIO = U.SEQ_USUARIO
 ' || SCRIPT || ' ORDER BY U.NOME_USUARIO';
 
END;
$_$;",system_games_schema.sql
"CREATE FUNCTION space(integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  lpad(chr(32),$1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION sqr(INOUT a integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
a=a*a;
end;
$$;",file(21Aprl).pgsql
"CREATE FUNCTION sqr(INOUT a integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin
a=a*a;
end;
$$;",mydb_dump(20th_April).pgsql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(BuildArea(mline));

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",database.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",schema.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION st_bdmpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := multi(ST_BuildArea(mline));

	RETURN geom;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",database.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",schema.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION st_bdpolyfromtext(text, integer) RETURNS geometry
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	geomtext alias for $1;
	srid alias for $2;
	mline geometry;
	geom geometry;
BEGIN
	mline := ST_MultiLineStringFromText(geomtext, srid);

	IF mline IS NULL
	THEN
		RAISE EXCEPTION 'Input is not a MultiLinestring';
	END IF;

	geom := ST_BuildArea(mline);

	IF GeometryType(geom) != 'POLYGON'
	THEN
		RAISE EXCEPTION 'Input returns more then a single polygon, try using BdMPolyFromText instead';
	END IF;

	RETURN geom;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION st_build_histogram2d(histogram2d, text, text, text) RETURNS histogram2d
    AS $_$
BEGIN
	EXECUTE 'SET local search_path = '||$2||',public';
	RETURN public.build_histogram2d($1,$3,$4);
END
$_$
    LANGUAGE plpgsql STABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_build_histogram2d(histogram2d, text, text, text) RETURNS histogram2d
    AS $_$
BEGIN
	EXECUTE 'SET local search_path = '||$2||',public';
	RETURN public.build_histogram2d($1,$3,$4);
END
$_$
    LANGUAGE plpgsql STABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",database.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",schema.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION st_find_extent(text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	tablename alias for $1;
	columnname alias for $2;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||schemaname||'"".""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""'||columnname||'"") FROM ""'||schemaname||'"".""'||tablename||'""' LOOP
		return myrec.extent;
	END LOOP; 
END;
$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",database.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",fearth_db.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",postgres.sql.txt
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",schema.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",snow_db_postgres.sql
"CREATE FUNCTION st_find_extent(text, text, text) RETURNS box2d
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
DECLARE
	schemaname alias for $1;
	tablename alias for $2;
	columnname alias for $3;
	myrec RECORD;

BEGIN
	FOR myrec IN EXECUTE 'SELECT extent(""' || columnname || '"") FROM ""' || schemaname || '"".""' || tablename || '""' LOOP
		return myrec.extent;
	END LOOP;
END;
$_$;",vkdb-schema.sql
"CREATE FUNCTION st_geometrytype(geometry) RETURNS text
    AS $_$
    DECLARE
        gtype text := geometrytype($1);
    BEGIN
        IF (gtype IN ('POINT', 'POINTM')) THEN
            gtype := 'Point';
        ELSIF (gtype IN ('LINESTRING', 'LINESTRINGM')) THEN
            gtype := 'LineString';
        ELSIF (gtype IN ('POLYGON', 'POLYGONM')) THEN
            gtype := 'Polygon';
        ELSIF (gtype IN ('MULTIPOINT', 'MULTIPOINTM')) THEN
            gtype := 'MultiPoint';
        ELSIF (gtype IN ('MULTILINESTRING', 'MULTILINESTRINGM')) THEN
            gtype := 'MultiLineString';
        ELSIF (gtype IN ('MULTIPOLYGON', 'MULTIPOLYGONM')) THEN
            gtype := 'MultiPolygon';
        ELSE
            gtype := 'Geometry';
        END IF;
        RETURN 'ST_' || gtype;
    END
	$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",dbsetup.sql
"CREATE FUNCTION st_geometrytype(geometry) RETURNS text
    AS $_$
    DECLARE
        gtype text := geometrytype($1);
    BEGIN
        IF (gtype IN ('POINT', 'POINTM')) THEN
            gtype := 'Point';
        ELSIF (gtype IN ('LINESTRING', 'LINESTRINGM')) THEN
            gtype := 'LineString';
        ELSIF (gtype IN ('POLYGON', 'POLYGONM')) THEN
            gtype := 'Polygon';
        ELSIF (gtype IN ('MULTIPOINT', 'MULTIPOINTM')) THEN
            gtype := 'MultiPoint';
        ELSIF (gtype IN ('MULTILINESTRING', 'MULTILINESTRINGM')) THEN
            gtype := 'MultiLineString';
        ELSIF (gtype IN ('MULTIPOLYGON', 'MULTIPOLYGONM')) THEN
            gtype := 'MultiPolygon';
        ELSE
            gtype := 'Geometry';
        END IF;
        RETURN 'ST_' || gtype;
    END
	$_$
    LANGUAGE plpgsql IMMUTABLE STRICT;",xenia_all.sql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_max4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        max float;
    BEGIN
        _matrix := matrix;
        max := '-Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF max < _matrix[x][y] THEN
                    max := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN max;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_mean4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
        count float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        count := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                        count := count + 1;
                    END IF;
                ELSE
                    count := count + 1;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        IF count = 0 THEN
            RETURN NULL;
        END IF;
        RETURN sum / count;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_min4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        FOR x in array_lower(_matrix, 1)..array_upper(_matrix, 1) LOOP
            FOR y in array_lower(_matrix, 2)..array_upper(_matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min := _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        RETURN min;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_range4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        min float;
        max float;
    BEGIN
        _matrix := matrix;
        min := 'Infinity'::float;
        max := '-Infinity'::float;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF NOT nodatamode = 'ignore' THEN
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                IF min > _matrix[x][y] THEN
                    min = _matrix[x][y];
                END IF;
                IF max < _matrix[x][y] THEN
                    max = _matrix[x][y];
                END IF;
            END LOOP;
        END LOOP;
        IF max = '-Infinity'::float OR min = 'Infinity'::float THEN
            RETURN NULL;
        END IF;
        RETURN max - min;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",hr_database.pgsql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",pgex_backup.sql
"CREATE FUNCTION st_sum4ma(matrix double precision[], nodatamode text, VARIADIC args text[]) RETURNS double precision
    LANGUAGE plpgsql IMMUTABLE
    AS $$
    DECLARE
        _matrix float[][];
        sum float;
    BEGIN
        _matrix := matrix;
        sum := 0;
        FOR x in array_lower(matrix, 1)..array_upper(matrix, 1) LOOP
            FOR y in array_lower(matrix, 2)..array_upper(matrix, 2) LOOP
                IF _matrix[x][y] IS NULL THEN
                    IF nodatamode = 'ignore' THEN
                        _matrix[x][y] := 0;
                    ELSE
                        _matrix[x][y] := nodatamode::float;
                    END IF;
                END IF;
                sum := sum + _matrix[x][y];
            END LOOP;
        END LOOP;
        RETURN sum;
    END;
    $$;",sqlex_backup.pgsql
"CREATE FUNCTION stn_in_reg(latgradbeg double precision, latminbeg double precision, longradbeg double precision, lonminbeg double precision, fi_min double precision, lamb_min double precision, fi_max double precision, lamb_max double precision) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE Fi double precision;
DECLARE Lamb double precision;

BEGIN
   
    Fi=grad(latgradbeg,latminbeg);
    Lamb=grad(longradbeg,lonminbeg);

    IF (lamb_min>180 or lamb_max>180) and Lamb<0 THEN
      Lamb=Lamb+360; 
    END IF;
    
    IF Fi>=fi_min and Fi<=fi_max and Lamb>=lamb_min and Lamb<=lamb_max  
      THEN
        RETURN true;
      ELSE
        RETURN false; 
    END IF;  
     
END;   
$$;",dump.sql
"CREATE FUNCTION stn_in_regxy(latgradbeg double precision, latminbeg double precision, longradbeg double precision, lonminbeg double precision, fi_min double precision, lamb_min double precision, fi_max double precision, lamb_max double precision, xmax double precision, ymax double precision, type_proj integer, fi0_region double precision, x0_off double precision, y0_off double precision, dfi_map double precision, type_map integer, lambusermin integer, lambusermax integer, num_reg integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE Fi double precision;
DECLARE Lamb double precision;
DECLARE R0 double precision;
DECLARE alf double precision;
DECLARE C double precision;
DECLARE U double precision;
DECLARE r double precision;
DECLARE delt double precision;
DECLARE x double precision;
DECLARE y double precision;
DECLARE fi0_map double precision;
DECLARE Lamb0 double precision;
DECLARE fk double precision;

BEGIN
   
    Fi=grad(latgradbeg,latminbeg);
    Lamb=grad(longradbeg,lonminbeg);

    IF (lamb_min>180 OR lamb_max>180) AND Lamb<0 THEN
      Lamb=Lamb+360; 
    END IF;
    
    IF Fi>=fi_min AND Fi<=fi_max AND Lamb>=lamb_min AND Lamb<=lamb_max  
    THEN
         BEGIN

           IF type_proj=4 OR type_proj=5 THEN
             RETURN true;
           END IF;  
         
           R0=6371.116;
           alf=0.5;
           C=14523.0039;

           Lamb=Lamb*pi()/180;
           Fi=Fi*pi()/180;

           IF type_proj!=4 AND type_proj!=5 THEN
             BEGIN
               IF Lamb>0 THEN
                 IF Lamb>pi() THEN
                   Lamb=-(2*pi()-Lamb);
                 END IF;   
               ELSE 
                 BEGIN
                   Lamb=2*pi() + Lamb;
                   IF Lamb>pi() THEN 
                     Lamb=-(2*pi()-Lamb);
                   END IF;  
                 END;
               END IF;
             
               IF Lamb<-pi() THEN 
                 Lamb=2*pi() + Lamb;
               END IF;
             END;   
           END IF;

          IF type_proj=1 THEN
            BEGIN
              fi0_map=pi()/2-fi0_region;      
              IF type_map=2 THEN
                fi=-fi;
              END IF;  

              x= -2.*R0*cos(fi)*cos(lamb+fi0_map+dfi_map)/(1+sin(fi))-x0_off;

              IF type_map!=2 THEN
                y= -2.*R0*cos(fi)*sin(lamb+fi0_map+dfi_map)/(1+sin(fi))-y0_off;
              ELSE
                y= -2.*R0*cos(fi)*sin(lamb+fi0_map+dfi_map)/(1+sin(fi))+y0_off;
              END IF; 
              
              IF type_map=2 THEN
                y=-y;
              END IF;  
            END;
          END IF;

    
          IF type_proj=2 THEN
            BEGIN
              fi0_map=(pi()-fi0_region)*alf;          
              IF type_map=2 THEN
                Fi=-Fi;
              END IF;  

              IF Lamb<0 THEN
                BEGIN
                  IF (num_reg>=0 OR num_reg=-1) AND LambUserMax<0 AND LambUserMin>0  THEN
                     Lamb=2*pi() + Lamb;
                  END IF;   
                END;
              END IF;

              U=tan(pi()/4.+Fi/2.);
              r=C/power(U,alf);
              delt=alf*Lamb;
              x=-r*cos(delt+fi0_map+dfi_map)-x0_off;

              IF type_map!=2 THEN
                y=-r*sin(delt+fi0_map+dfi_map)-y0_off;
              ELSE
                y=-r*sin(delt+fi0_map+dfi_map)+y0_off;
              END IF;  

              IF type_map=2 THEN
                y=-y;
              END IF;  
            END;
          END IF;


          IF type_proj=3 THEN
            BEGIN
              fk=0.866025404;  /* cos(30) */

              IF num_reg<0 THEN
                BEGIN
                  IF LambUserMax>0 THEN
                    Lamb0=-179.5;
                  ELSE
                    BEGIN
                      IF LambUserMin<0 THEN
                        Lamb0=179.5;
                      ELSE
                        Lamb0=LambUserMax+0.5;
                      END IF;  
                    END;  
                  END IF;
                END;
              ELSE
                 IF num_reg=10 THEN
                   Lamb0=-110.0;
                 ELSE
                   Lamb0=-168.0;
                 END IF;  
              END IF;
              
              IF Lamb<Lamb0*pi()/180. THEN
                Lamb=2*pi()+Lamb;
              END IF;        
              fi0_map=0;

              x=R0*fk*(lamb+fi0_map)-x0_off;    
              y=(1+fk)*R0*tan(fi/2.)-y0_off;    
            END;  
          END IF;

          IF 0<=x AND x<=Xmax AND 0<=y AND y<=Ymax THEN 
            RETURN true;
          ELSE
            RETURN false;
          END IF;     
         END;  
      ELSE
        RETURN false; 
    END IF;  
     
END;   
$$;",dump.sql
"CREATE FUNCTION str(integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  to_char($1);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION str(integer, integer) RETURNS character
    LANGUAGE plpgsql
    AS $_$
begin
         return  left(ltrim(rtrim(cast($1 as bpchar))),$2);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION str2flt(""in"" text, exponent text) RETURNS double precision
    LANGUAGE plpgsql
    AS $_$declare
------------------------------------------
-- Author: SG Langer, March 2014
-- Purpose: Take any numeric looking string as input
-- 	and isolate the parts left and right of decimal
-- 	and convert to numbers
-- Args: $1 = the numeric string
--	$2 = an exponent if scientific notation (not implemented yet)
-- Caller: numerous
-----------------------------------------
	func text := 'ddw: str2flt';
	leftval text;
	rightval text ;
	sum double precision := 0;
	sign int := 1;
	exp int := 0;
	digit text;
	asc_val int;
begin
	-- check if a decimal,and slice off everything to the right of it
	if (strpos($1, '.') < 1) then
		-- casting does not work. CAST thinks $1 is ''
		--val := cast ($1 as int);
		leftval := $1;
		rightval := '0';
	else
		leftval := substr($1, 0, strpos($1, '.'));
		rightval := substr($1, strpos($1, '.'), char_length($1)); 
	end if;
	
	-- check if it is negative
	if (strpos(leftval, '-') =1) then
		sign := -1;
		leftval := substr(leftval, 2, char_length(leftval));
	end if;

	-- now, build up the Float part of the leftVal
	while char_length(leftval)> 0 loop
		-- need to handle ""invalid input"" when substr hits a ',' or ' '
		digit := substr(leftval, char_length(leftval)) ;
		-- now check that digit is Numeric else ignore
		select into asc_val ascii(digit);
		--perform logger (func, 'leftval digit and asc: ' || digit  || ' ' || asc_val);
		if (asc_val > 47 AND asc_val < 58) then
			sum := sum + 10^exp * cast (digit as int) ;	
			exp := exp + 1 ;
		end if;
		leftval := substr(leftval, 0, char_length(leftval) );
	end loop ;

	-- now, build up the Float part of the rightVal
	exp := -1 * char_length(rightval) + 1 ;
	while char_length(rightval)> 0 loop
		digit := substr(rightval, char_length(rightval));
		-- now check that digit is Numeric else ignore
		select into asc_val ascii(digit);
		if (asc_val > 47 AND asc_val < 58) then
			sum := sum + 10^exp * cast (digit as int) ;	
			exp := exp + 1 ;
		end if;
		rightval := substr(rightval, 0, char_length(rightval) );
		--perform logger (func, 'right val: ' || rightval || ' ' || sum);
	end loop;

	return sign * sum;
end$_$;",purged-ddw.sql
"CREATE FUNCTION str2int(str text, exponent text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$declare
------------------------------------------
-- Author: SG Langer, March 2014
-- Purpose: Take any numeric looking string as input
--	Trim off the float part (if one), then
--	create an int and return. This was necessary 
--	because neither Cast nor to_number() in pgSQL work. 
--	Oh, they work when I called them directly like
--	CAST ('123.45' as int)
-- 	but failed when I did this
--	CAST (table.textField as int)
-- 	I kept getting ""Wrong input syntax for int: '' ""
--	That is to say both CAST and to_number see the textField as NULL
--	As the URL's below show, I was not the first to see this
-- Args: $1 = the numeric string
--	$2 = an exponent if scientific notation (not implemented yet)
-- Caller: numerous
-----------------------------------------
	func text;
	val text;
	sum int;
	exp int;
	digit text;
	sign int;
	asc_val int;
begin
	func :='ddw:str2int';
	exp :=0;
	sum :=0;
	sign := 1;

	-- check if a decimal,and slice off everything to the right of it
	if (strpos($1, '.') < 1) then
		-- casting does not work. CAST thinks $1 is ''
		--val := cast ($1 as int);
		val := $1;
	else
		val := substr($1, 0, strpos($1, '.'));
	end if;
	
	-- check if it is negative
	if (strpos(val, '-') =1) then
		sign := -1;
		val := substr(val, 2, char_length(val));
	end if;

	while char_length(val)> 0 loop
		-- need to handle ""invalid input"" when substr hits a ',' or ' '
		BEGIN
			digit := substr(val, char_length(val));
			-- now check that digit is Numeric else ignore
			select into asc_val ascii(digit);
			if (asc_val > 47 AND asc_val < 58) then
				sum := sum + 10^exp * cast (digit as int) ; 
				exp := exp + 1 ;
				perform logger (func, 'digit and exp ' || digit || ' ' || exp); 
			end if;
		EXCEPTION WHEN others then
			-- do nothing, just log error
			perform logger (func, 'exception =' || others);
		END; 
		--perform logger (func, val || ' ' || sum);
		val := substr(val, 0, char_length(val) );
	end loop ;
	
	-- THESE all have SAME problem, think $1 is NULL
	-- http://forums.codeguru.com/showthread.php?527147-PL-pgsql-Convert-character-varying-to-an-integer
	--select into val to_number(quote_literal($1), quote_literal(99999999));

	--http://grokbase.com/t/postgresql/pgsql-general/01bv71dv92/casting-varchar-to-numeric
	--select into val $1::double precision::numeric ;
	return sign * sum;
end
$_$;",purged-ddw.sql
"CREATE FUNCTION str_status(num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare status_out character varying;
begin

 --irul
 --status: sudah/belum

select case when num=0 then 'BELUM' when num=1 then 'SUDAH' else 'Unknown' end into status_out;
return status_out;
   
end
$$;",db_bphtb.sql
"CREATE FUNCTION str_status_daftar(num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare status_out character varying;
begin

-- irul
/*
STATUS DAFTAR:
0 = 'Draft';
1 = 'Bayar';
2 = 'Approval';
3 = 'Penelitian';
4 = 'SKPD-KB';
5 = 'SKPD-LB';
6 = 'BPN';
7 = 'Selesai';    
*/

select case 
  when num=0 then 'Draft' 
  when num=2 then 'Bayar' 
  when num=3 then 'Approval' 
  when num=4 then 'Penelitian' 
  when num=5 then 'SKPD-KB' 
  when num=6 then 'SKPD-LB' 
  when num=7 then 'Selesai' 
  else 'Unknown' end 
into status_out;

return status_out;
   
end
$$;",db_bphtb.sql
"CREATE FUNCTION str_status_validasi(num integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare status_out character varying;
begin

-- aagusti
/*
STATUS VALIDASI:
0 = 'Draft';
1 = 'Validated';
2 = 'Approved';   
*/

select case 
  when num=0 then 'Draft' 
  when num=1 then 'On Validated' 
  when num=2 then 'Approved'
  else 'Unknown' end 
into status_out;

return status_out;
   
end
$$;",db_bphtb.sql
"CREATE FUNCTION string_to_hex(p character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	elems text[]; 
BEGIN
	elems := string_to_array($1, '/');
    RETURN substr(elems[2], 3, char_length(elems[2]));
END;
$_$;",backup.sql
"CREATE FUNCTION subteam_group_name(name text, pattern text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
begin
if name ~ pattern then
  return substring(upper(name) from pattern);
else
  return name;
end if;
end;
$$;",fahstats.schema
"CREATE FUNCTION subteam_group_name(name text, pattern text, case_sensitive boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
name_cs text;
begin
if name ~ pattern then
  if case_sensitive then
    name_cs := name;
  else name_cs := upper(name);
  end if;
  return substring(name_cs from pattern);
else
  return name;
end if;
end;
$$;",fahstats.schema
"CREATE FUNCTION subteam_group_name(name text, pattern text, case_sensitive boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $$
declare
name_cs text;
begin
if name ~ pattern then
  if case_sensitive then
    name_cs := name;
  else name_cs := upper(name);
  end if;
  return substring(name_cs from pattern);
else
  return name;
end if;
end;
$$;",ks2.schema
"CREATE FUNCTION sum_interval(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
x interval;
result integer := 0;
begin

for x in select * from timetable($1, $2)
loop
	result = result + (SELECT EXTRACT(EPOCH FROM x))/3600;
end loop;
return result;

end
$_$;",MovieStore_script.sql
"CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
sum := x + y;
prod := x * y;
END;
$$ LANGUAGE plpgsql;",postgresql.txt
"CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) returns records AS $$
BEGIN
sum := x + y;
prod := x * y;
END;
$$ LANGUAGE plpgsql;",postgresql.txt
"CREATE FUNCTION sum_order(oid bigint) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE sum Decimal;
BEGIN
    SELECT SUM(price * quantity) INTO sum FROM order_products WHERE order_id=oid;
    RETURN sum;
END;
$$;",db.sql
"CREATE FUNCTION sumar1(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
	RETURN $1 + 1;
END;
$_$;",lab_clinic.sql
"CREATE FUNCTION summbom(text, text) RETURNS TABLE(t_item_number text, t_bom_itemrev text, t_bom_qtyper numeric, p_item_number text, p_bom_itemrev text, p_bom_qtyper numeric, c_item_number text, c_bom_itemrev text, c_bom_qtyper numeric)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	_item RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('summbom'));



	SELECT item_id, item_serialstream_id, serialprefix_prefix, serialpattern_pattern, itemfreqcode_freqcode

	INTO _item

	FROM item 

	LEFT OUTER JOIN serialstream ON item_serialstream_id = serialstream_id

	LEFT OUTER JOIN serialprefix ON item_serialprefix_id = serialprefix_id

	LEFT OUTER JOIN serialpattern ON serialprefix_serialpattern_id = serialpattern_id

	LEFT OUTER JOIN itemfreqcode ON item_itemfreqcode_id = itemfreqcode_id

	WHERE item_number = pItemNumber 

	AND item_active = true;



	IF _item.item_id IS NULL THEN

		RAISE EXCEPTION 'summbom: Item Number % not found in AeryonMES', pItemNumber;

	END IF;



	IF (SELECT itemrev_id

	    FROM itemrev

	    WHERE itemrev_item_id = _item.item_id

	    AND itemrev_rev = pRevision) IS NULL THEN

		RAISE EXCEPTION 'summbom: Revision % of Selected Item % Not Found in AeryonMES', pRevision, pItemNumber;

	END IF;



	RETURN QUERY (WITH RECURSIVE b(	t_bom_item_id, 

					t_bom_itemrev,

					t_bom_qtyper,

					p_bom_item_id, 

					p_bom_itemrev, 

					p_bom_qtyper,

					c_bom_item_id, 

					c_bom_itemrev,

					c_bom_qtyper) 

			AS(	SELECT	p.bom_parent_item_id 	AS t_bom_item_id,

					p.bom_parent_itemrev 	AS t_bom_itemrev,

					1::NUMERIC(20, 8)	AS t_bom_qtyper,

					p.bom_parent_item_id 	AS p_bom_item_id,

					p.bom_parent_itemrev 	AS p_bom_itemrev,

					1::NUMERIC(20, 8)	AS p_bom_qtyper,

					p.bom_item_id		AS c_bom_item_id,

					p.bom_itemrev		AS c_bom_itemrev,

					p.bom_qtyper		AS c_bom_qtyper

				FROM	bom p

				WHERE 	p.bom_parent_item_id = _item.item_id

				AND 	p.bom_parent_itemrev = pRevision

				AND 	COALESCE(p.bom_effective, now()) <= now()

				AND 	COALESCE(p.bom_expires, now()) >= now()

			UNION ALL

				SELECT 	b.t_bom_item_id 	AS t_bom_item_id,

					b.t_bom_itemrev 	AS t_bom_itemrev,

					b.t_bom_qtyper		AS t_bom_qtyper,

					b.c_bom_item_id 	AS p_bom_item_id,

					b.c_bom_itemrev 	AS p_bom_itemrev,

					b.c_bom_qtyper 		AS p_bom_qtyper,

					c.bom_item_id		AS c_bom_item_id,

					c.bom_itemrev		AS c_bom_itemrev,

					(c.bom_qtyper * b.c_bom_qtyper)::NUMERIC(20, 8)

								AS c_bom_qtyper

				FROM 	b

				LEFT OUTER JOIN bom c

					ON c.bom_parent_item_id = b.c_bom_item_id

				WHERE 	c.bom_parent_item_id = b.c_bom_item_id

				AND 	c.bom_parent_itemrev = b.c_bom_itemrev

				AND 	COALESCE(c.bom_effective, now()) <= now()

				AND 	COALESCE(c.bom_expires, now()) >= now()

			)

		SELECT 	i1.item_number AS t_item_number, 

			b.t_bom_itemrev, 

			b.t_bom_qtyper, 

			i2.item_number AS p_item_number, 

			b.p_bom_itemrev, 

			b.p_bom_qtyper, 

			i3.item_number AS c_item_number, 

			b.c_bom_itemrev, 

			b.c_bom_qtyper

		FROM 	b

		LEFT OUTER JOIN item i1

			ON b.t_bom_item_id = i1.item_id

		LEFT OUTER JOIN item i2

			ON b.p_bom_item_id = i2.item_id

		LEFT OUTER JOIN item i3

			ON b.c_bom_item_id = i3.item_id);

		  

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION summsubass(text, text, text) RETURNS TABLE(t_item_number text, t_part_rev text, t_part_serialnumber text, t_part_sequencenumber integer, t_part_parent_allocorder integer, p_item_number text, p_part_rev text, p_part_serialnumber text, p_part_sequencenumber integer, p_part_parent_allocorder integer, c_item_number text, c_part_rev text, c_part_serialnumber text, c_part_sequencenumber integer, c_part_parent_allocorder integer)
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber ALIAS FOR $1;

	pRevision ALIAS FOR $2;

	pSerialNumber ALIAS FOR $3;

	_viewpart RECORD;

  

BEGIN

	PERFORM (SELECT checkpriv('summsubass'));

	PERFORM (SELECT validatepart(pItemNumber, pRevision, pSerialNumber, null, true));



	SELECT 	part_id, 

		item_id, 

		item_number, 

		part_serialnumber, 

		part_sequencenumber

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;



	RETURN QUERY (WITH RECURSIVE a(	t_part_id,

					t_part_item_id,

					t_part_rev,

					t_part_serialnumber,

					t_part_sequencenumber,

					t_part_parent_part_id,

					t_part_allocpos,

					p_part_id,

					p_part_item_id,

					p_part_rev,

					p_part_serialnumber,

					p_part_sequencenumber,

					p_part_parent_part_id,

					p_part_allocpos,

					c_part_id,

					c_part_item_id,

					c_part_rev,

					c_part_serialnumber,

					c_part_sequencenumber,

					c_part_parent_part_id,

					c_part_allocpos) 

			AS(	SELECT	p.part_id			AS t_part_id,

					p.part_item_id			AS t_part_item_id,

					p.part_rev			AS t_part_rev,

					p.part_serialnumber		AS t_part_serialnumber,

					p.part_sequencenumber		AS t_part_sequencenumber,

					p.part_parent_part_id		AS t_part_parent_part_id,

					p.part_allocpos	AS t_part_allocpos,

					p.part_id			AS p_part_id,

					p.part_item_id			AS p_part_item_id,

					p.part_rev			AS p_part_rev,

					p.part_serialnumber		AS p_part_serialnumber,

					p.part_sequencenumber		AS p_part_sequencenumber,

					p.part_parent_part_id		AS p_part_parent_part_id,

					p.part_allocpos	AS p_part_allocpos,

					c.part_id			AS c_part_id,

					c.part_item_id			AS c_part_item_id,

					c.part_rev			AS c_part_rev,

					c.part_serialnumber		AS c_part_serialnumber,

					c.part_sequencenumber		AS c_part_sequencenumber,

					c.part_parent_part_id		AS c_part_parent_part_id,

					c.part_allocpos	AS c_part_allocpos

				FROM	part p

				LEFT OUTER JOIN part c

					ON p.part_id = c.part_parent_part_id

				WHERE 	p.part_id = _viewpart.part_id

			UNION ALL

				SELECT 	a.t_part_id			AS t_part_id,

					a.t_part_item_id		AS t_part_item_id,

					a.t_part_rev			AS t_part_rev,

					a.t_part_serialnumber		AS t_part_serialnumber,

					a.t_part_sequencenumber		AS t_part_sequencenumber,

					a.t_part_parent_part_id		AS t_part_parent_part_id,

					a.t_part_allocpos	AS t_part_allocpos,

					a.c_part_id			AS p_part_id,

					a.c_part_item_id		AS p_part_item_id,

					a.c_part_rev			AS p_part_rev,

					a.c_part_serialnumber		AS p_part_serialnumber,

					a.c_part_sequencenumber		AS p_part_sequencenumber,

					a.c_part_parent_part_id		AS p_part_parent_part_id,

					a.c_part_allocpos	AS p_part_allocpos,

					c.part_id			AS c_part_id,

					c.part_item_id			AS c_part_item_id,

					c.part_rev			AS c_part_rev,

					c.part_serialnumber		AS c_part_serialnumber,

					c.part_sequencenumber		AS c_part_sequencenumber,

					c.part_parent_part_id		AS c_part_parent_part_id,

					c.part_allocpos	AS c_part_allocpos

				FROM 	a

				LEFT OUTER JOIN part c

					ON a.c_part_id = c.part_parent_part_id

				WHERE 	a.c_part_id = c.part_parent_part_id

			)

		SELECT 	i1.item_number AS t_item_number, 

			a.t_part_rev,

			a.t_part_serialnumber,

			a.t_part_sequencenumber,

			a.t_part_allocpos,

			i2.item_number AS p_item_number, 

			a.p_part_rev,

			a.p_part_serialnumber,

			a.p_part_sequencenumber,

			a.p_part_allocpos,

			i3.item_number AS c_item_number, 

			a.c_part_rev,

			a.c_part_serialnumber,

			a.c_part_sequencenumber,

			a.c_part_allocpos 

		FROM 	a

		LEFT OUTER JOIN item i1

			ON a.t_part_item_id = i1.item_id

		LEFT OUTER JOIN item i2

			ON a.p_part_item_id = i2.item_id

		LEFT OUTER JOIN item i3

			ON a.c_part_item_id = i3.item_id);

		  

	RETURN;

END;$_$;",ames_dev.backup
"CREATE FUNCTION sys_generate_constraints_for_tables() RETURNS numeric
    LANGUAGE plpgsql
    AS $$
 DECLARE
  v_cursor cursor for select table_name from information_schema.tables where table_type='BASE TABLE' and table_name in('tt_combination','tt_cube_common','tt_cube_ages');
 BEGIN  
 for rec in v_cursor loop
	perform sys_generate_constraints_for_table(rec.table_name::varchar);
 end loop;
 return 0;
END
$$;",1_first7_functions.sql
"CREATE FUNCTION sys_generate_constraints_for_tables() RETURNS numeric
LANGUAGE plpgsql
AS $$
 DECLARE
  v_cursor cursor for select table_name from information_schema.tables where table_type='BASE TABLE' and table_name in('tt_combination','tt_cube_common','tt_cube_ages');
 BEGIN
 for rec in v_cursor loop
	perform sys_generate_constraints_for_table(rec.table_name::varchar);
 end loop;
 return 0;
END
$$;",functions.sql
"CREATE FUNCTION sys_generate_indexes_for_materialized_view(v_view character varying) RETURNS numeric
LANGUAGE plpgsql
AS $_$
 DECLARE
 v_sql   varchar(1024);
 v_table varchar(100);
 v_count integer;
 --
 v_views cursor for
  select matviewname
  from pg_matviews
  where matviewname=$1;
 --
 v_columns cursor for
  select field_name
  from ( select 'canton_id' as field_name
	  union
         select 'state_id'
          union
         select 'municipality_id'
          union
         select 'organization_id'
          union
         select 'time_id'
          union
         select 'year_'
          union
         select 'month_'
          union
         select 'up_level_municipality_id'
        ) tt;
 BEGIN
  --
  for rec1 in v_views loop
   for rec2 in v_columns loop
    v_count = 0;
    select count(*) into v_count from pg_matviews where definition like '%'||rec2.field_name||'%' and matviewname = rec1.matviewname;
    if (v_count>0) then
     begin
      execute  'CREATE INDEX idx_'||rec2.field_name||'_'|| rec1.matviewname ||' ON '|| rec1.matviewname ||' USING btree ('||rec2.field_name||')';
     exception when others then
      perform sys_log('Ошибка создания индекса для '||rec1.matviewname||' '||rec2.field_name);
     end;
    end if;
   end loop;
  end loop;
 --
 return 0;
 END
 $_$;",functions.sql
"CREATE FUNCTION sys_generate_indexes_for_materialized_views() RETURNS numeric
LANGUAGE plpgsql
AS $$
 DECLARE
 v_sql   varchar(1024);
 v_table varchar(100);
 v_count integer;
 --
 v_views cursor for
  select matviewname
  from pg_matviews
  where matviewname like 'v\_%' or matviewname like 'vt\_%';
 --
 v_columns cursor for
  select field_name
  from ( select 'canton_id' as field_name
	  union
         select 'state_id'
          union
         select 'municipality_id'
          union
         select 'organization_id'
          union
         select 'time_id'
          union
         select 'year_'
          union
         select 'month_'
          union
         select 'up_level_municipality_id'
        ) tt;
 BEGIN
  --
  for rec1 in v_views loop
   for rec2 in v_columns loop
    v_count = 0;
    select count(*) into v_count from pg_matviews where definition like '%'||rec2.field_name||'%' and matviewname = rec1.matviewname;
    if (v_count>0) then
     begin
      execute  'CREATE INDEX idx_'||rec2.field_name||'_'|| rec1.matviewname ||' ON '|| rec1.matviewname ||' USING btree ('||rec2.field_name||')';
     exception when others then
      perform sys_log('Ошибка создания индекса для '||rec1.matviewname||' '||rec2.field_name);
     end;
    end if;
   end loop;
  end loop;
 --
 return 0;
 END
 $$;",functions.sql
"CREATE FUNCTION sys_generate_indexes_for_table(v_table character varying) RETURNS numeric
LANGUAGE plpgsql
AS $_$
 DECLARE
         v_sql 	 varchar(1024);
         v_table varchar(100);
	 v_count integer;
	 v_check integer;
 BEGIN
 --
 --ver. 1.0.0.0
 --
 v_table = $1;
 --0. value_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'value_id';
 if (v_count = 1) then
	select count(*) into v_check from pg_indexes where schemaname='public' and indexname = v_table||'_pk';
	if (v_check=0) then
	 v_sql = 'CREATE UNIQUE INDEX '||v_table||'_pk ON '||v_table||' USING btree (value_id)';
	 execute v_sql;
	end if;
 end if;
 --0. time_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'time_id';
 if (v_count = 1) then
	v_sql = 'CREATE INDEX '||v_table||'_time_id_fk ON '||v_table||' USING btree (time_id)';
	execute v_sql;
 end if;
 --7. Проверяем наличие столбца organization_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'organization_id';
 if (v_count = 1) then
	 v_sql = 'CREATE INDEX '||v_table||'_org_id_fk ON '||v_table||' USING btree (organization_id)';
	 execute v_sql;
 end if;
 --7. Проверяем наличие столбца state_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'canton_id';
 if (v_count = 1) then
	 v_sql = 'CREATE INDEX '||v_table||'_canton_id_fk ON '||v_table||' USING btree (canton_id)';
	 execute v_sql;
 end if;
 --7. Проверяем наличие столбца state_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'state_id';
 if (v_count = 1) then
	 v_sql = 'CREATE INDEX '||v_table||'_state_id_fk ON '||v_table||' USING btree (state_id)';
	 execute v_sql;
 end if;
 --7. Проверяем наличие столбца municipality_id
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and column_name = 'municipality_id';
 if (v_count = 1) then
	 v_sql = 'CREATE INDEX '||v_table||'_mun_id_fk ON '||v_table||' USING btree (municipality_id)';
	 execute v_sql;
 end if;
 --8. Проверяем наличие столбца time_id и organization_id одновременно
 v_count=0;
 select count(column_name) into v_count from information_schema.columns where table_name = v_table and (column_name = 'time_id' or column_name = 'organization_id');
 if (v_count = 2) then
	select count(*) into v_check from pg_indexes where schemaname='public' and indexname = v_table||'_uk';
	if (v_check = 0) then
	 v_sql = 'CREATE UNIQUE INDEX '||v_table||'_uk ON '||v_table||' USING btree (organization_id, time_id)';
	 execute v_sql;
	end if;
 end if;
 --
 return 0;
END
$_$;",functions.sql
"CREATE FUNCTION sys_generate_tables_for_views() RETURNS numeric
    LANGUAGE plpgsql
    AS $$
 DECLARE
  v_cursor cursor for select table_name from information_schema.tables where table_type='VIEW' and table_name in('v_combination','v_cube_common','v_cube_ages');
 BEGIN  
 for rec in v_cursor loop
	perform sys_generate_table_for_view(rec.table_name::varchar);
 end loop;
 return 0;
END
$$;",1_first7_functions.sql
"CREATE FUNCTION sys_generate_tables_for_views() RETURNS numeric
LANGUAGE plpgsql
AS $$
 DECLARE
  v_cursor cursor for select table_name from information_schema.tables where table_type='VIEW' and table_name in('v_combination','v_cube_common','v_cube_ages','v_income');
 BEGIN
 for rec in v_cursor loop
	perform sys_generate_table_for_view(rec.table_name::varchar);
 end loop;
 return 0;
END
$$;",functions.sql
"CREATE FUNCTION sys_get_ddl_for_table_by_view(v_view character varying) RETURNS character varying
LANGUAGE plpgsql
AS $_$
 DECLARE
         v_sql 	 varchar(9128);
         v_table varchar(100);
	 v_count integer;
	 v_fields cursor for select table_name, column_name, data_type, character_maximum_length from information_schema.columns where table_name = $1 order by ordinal_position;
 BEGIN
 --1. Делаем имя table из имени view
 select replace($1,'v_','tt_') into v_table;
 --2. Создаем таблицу
 v_sql = 'create table ' || v_table || ' ( ';
 for rec in v_fields loop
	v_sql = v_sql || rec.column_name || ' ' || rec.data_type;
	if (rec.character_maximum_length is not null) then
	 v_sql = v_sql || '(' || rec.character_maximum_length || ')';
	end if;
	v_sql = v_sql || ',';
 end loop;
 v_sql = substr(v_sql,0,length(v_sql));
 v_sql = v_sql || ')';
 --
 return v_sql;
END
$_$;",functions.sql
"CREATE FUNCTION sys_switch_view(v_view character varying) RETURNS numeric
LANGUAGE plpgsql
AS $_$
 DECLARE v_table varchar(100);
         vt_view varchar(100);
         v_count integer;
         v_first boolean;
 BEGIN
 v_count = 0;
 v_first = false;
 --0. Получаем имя таблицы
 select replace($1,'v_','tt_') into v_table;
 select replace($1,'v_','vt_') into vt_view;
 --1. Если таблицы для кеша еще не созданы, то создаем их
 select count(*) into v_count from information_schema.tables where table_name = v_table;
 if v_count = 0 then
 perform sys_generate_table_for_view(v_view);
 v_first = true;
 end if;
 --2. Если запускаем процедуру первый раз, то переключаем сразу на кеш
 if (v_first) then
  execute 'create or replace view '|| $1 ||' AS select * from ' || v_table;
 else
--2. Если на данный момент переключены на view, переключаем на таблицы, иначе на view
 select count(*) into v_count from information_schema.views where table_name = $1 and view_definition like '%vt_%.%';
 if (v_count = 1) then
  execute 'create or replace view '|| $1 ||' AS select * from ' || v_table;
 else
  execute 'create or replace view '|| $1 ||' AS select * from ' || vt_view;
 end if;
 end if;
 return 0;
END
$_$;",functions.sql
"CREATE FUNCTION sys_switch_views() RETURNS numeric
    LANGUAGE plpgsql
    AS $$
 DECLARE v_count integer;
         v_first boolean;
 BEGIN
 v_count = 0;
 v_first = false; 
 --1. ���� ������� ��� ���� ��� �� �������, �� ������� ��
 select count(*) into v_count from information_schema.tables where table_name = 'tt_cube_common';
 if v_count = 0 then
	 perform sys_generate_tables_for_views();
	 v_first = true;
 end if;
 --2. ���� ��������� ��������� ������ ���, �� ����������� ����� �� ���
 if (v_first) then
	  create or replace view v_combination AS select * from tt_combination;
	  create or replace view v_cube_common AS select * from tt_cube_common;
	  create or replace view v_cube_ages AS select * from tt_cube_ages;  
 else
	--2. ���� �� ������ ������ ����������� �� view, ����������� �� �������, ����� �� view
	 select count(*) into v_count from information_schema.views where table_name = 'v_cube_common' and view_definition like '%vt_cube_common.%';
	 if (v_count = 1) then
	  create or replace view v_combination AS select * from tt_combination;
	  create or replace view v_cube_common AS select * from tt_cube_common;
	  create or replace view v_cube_ages AS select * from tt_cube_ages;  
	 else
	  create or replace view v_combination AS select * from vt_combination;
	  create or replace view v_cube_common AS select * from vt_cube_common;
	  create or replace view v_cube_ages AS select * from vt_cube_ages;
	 end if; 
 end if;
 return 0;
END
$$;",1_first7_functions.sql
"CREATE FUNCTION sys_switch_views() RETURNS numeric
LANGUAGE plpgsql
AS $$
 DECLARE v_count integer;
         v_first boolean;
 BEGIN
 --
 --ver. 1.0.0.1
 --
 v_count = 0;
 v_first = false;
 --1. Если таблицы для кеша еще не созданы, то создаем их
 select count(*) into v_count from information_schema.tables where table_name = 'tt_cube_common';
 if v_count = 0 then
	 perform sys_generate_tables_for_views();
	 v_first = true;
 end if;
 --2. Если запускаем процедуру первый раз, то переключаем сразу на кеш
 if (v_first) then
	  create or replace view v_combination AS select * from tt_combination;
	  create or replace view v_cube_common AS select * from tt_cube_common;
	  create or replace view v_cube_ages AS select * from tt_cube_ages;
	  create or replace view v_audit_1 AS select * from tt_audit_1;
	  create or replace view v_audit_2 AS select * from tt_audit_2;
 else
	--2. Если на данный момент переключены на view, переключаем на таблицы, иначе на view
	 select count(*) into v_count from information_schema.views where table_name = 'v_cube_common' and view_definition like '%vt_cube_common.%';
	 if (v_count = 1) then
	  create or replace view v_combination AS select * from tt_combination;
	  create or replace view v_cube_common AS select * from tt_cube_common;
	  create or replace view v_cube_ages AS select * from tt_cube_ages;
	  create or replace view v_audit_1 AS select * from tt_audit_1;
	  create or replace view v_audit_2 AS select * from tt_audit_2;
	 else
	  create or replace view v_combination AS select * from vt_combination;
	  create or replace view v_cube_common AS select * from vt_cube_common;
	  create or replace view v_cube_ages AS select * from vt_cube_ages;
	  create or replace view v_audit_1 AS select * from vt_audit_1;
	  create or replace view v_audit_2 AS select * from vt_audit_2;
	 end if;
 end if;
 return 0;
END
$$;",functions.sql
"CREATE FUNCTION system_application_isdenied(text, text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
pType  ALIAS FOR $1;
pMask  ALIAS FOR $2;
BEGIN

IF(SELECT true FROM ""access"" WHERE( LOWER(pType) = ""Type""  AND LOWER(pMask) LIKE LOWER(""Mask"") AND ""Status"" = 1) LIMIT 1 OFFSET 0) THEN
	RETURN false;
END IF;

IF(SELECT true FROM ""access"" WHERE( LOWER(pType) = ""Type""  AND LOWER(pMask) LIKE LOWER(""Mask"") AND ""Status"" = 0) LIMIT 1 OFFSET 0) THEN
	RETURN true;
END IF;

RETURN false;

END;
$_$;",sql.backup
"CREATE FUNCTION system_config_get(text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
configName  ALIAS FOR $1;
BEGIN

RETURN (SELECT ""Value"" FROM config WHERE( ""Name"" = configName ) LIMIT 1 OFFSET 0);

END;
$_$;",sql.backup
"CREATE FUNCTION system_session_count(integer, OUT guest bigint, OUT registered bigint) RETURNS record
    LANGUAGE plpgsql
    AS $_$
DECLARE
tStamp  timestamp without time zone;
BEGIN

tStamp := now() - ($1 * interval '1 seconds');

SELECT COUNT(""Id"") INTO guest FROM sessions WHERE(""UsersId"" = 0 AND ""TimeStamp"" > tStamp);
SELECT COUNT(""Id"") INTO registered FROM sessions WHERE(""UsersId"" > 0 AND ""TimeStamp"" > tStamp);

END;
$_$;",sql.backup
"CREATE FUNCTION tahap_now(id numeric, date timestamp without time zone) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
	tahap character varying;
	awal timestamp without time zone;
	akhir timestamp without time zone;
BEGIN
   SELECT array_to_string(array_agg(a.akt_jenis), ',') INTO tahap FROM jadwal j, aktivitas a WHERE j.akt_id=a.akt_id AND j.lls_id= $1 AND dtj_tglawal <= $2 AND dtj_tglakhir >= $2;
   IF tahap IS NULL THEN
	SELECT dtj_tglawal INTO awal FROM jadwal WHERE lls_id=$1 ORDER BY dtj_tglawal ASC LIMIT 1;
	SELECT dtj_tglakhir INTO akhir FROM jadwal WHERE lls_id=$1 ORDER BY dtj_tglakhir DESC LIMIT 1;
	IF awal IS NOT NULL AND awal > $2 THEN
		tahap := 'BELUM_DILAKSANAKAN';
	ELSIF akhir IS NOT NULL AND akhir < $2 THEN	
		tahap := 'SUDAH_SELESAI';
	ELSE
		tahap := 'TIDAK_ADA_JADWAL';
	END IF;
   END IF;
   RETURN tahap;
END;
$_$;",spse-4.x-base.sql
"CREATE FUNCTION task_priorityes_to_name(priority task_priorityes) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
begin
	case priority
		when 'high'     then return 'Высокий';
		when 'default'  then return 'Обычный';
		when 'low'      then return 'Низкий';
	end case;
	return concat('Функция task_priorityes_to_name требует исправлений. Тип: ', priority);
end
$$;",shema.sql
"CREATE FUNCTION taxi_per_line (numeric, numeric)  
RETURNS numeric AS  $$ 
BEGIN
RAISE NOTICE 'intermediate: %, per row: %', $1, $2;                                                                                                                                                                          RETURN $1 + $2*2.2;                                                                                                                                                                                           END;                                                                                                                                                                                                       $$ LANGUAGE 'plpgsql';",vari_comandi_sql_admin.sql
"CREATE FUNCTION team_production(integer) RETURNS SETOF type_team_production
    LANGUAGE plpgsql STABLE STRICT
    AS $_$declare
  team_production type_team_production;
  linha record;
  points0 real;
  points1 real;
  wus0 integer;
  wus1 integer;
  cur_batch_date timestamp;
begin

cur_batch_date := (select data from datas order by data desc limit 1);
points0 := coalesce((
  select pontos
  from times inner join datas on times.data = datas.data_serial
  where n_time = $1 and datas.data in (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (select cur_batch_date - interval '55 days 23 hour')
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
  ), 0);

wus0 := coalesce((
  select wus
  from times inner join datas on times.data = datas.data_serial
  where n_time = $1 and datas.data in (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (select cur_batch_date - interval '55 days 23 hour')
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
  ), 0);

for linha in
-- -----------------------------------
select pontos , wus, 'day', datas.data as d0
from times inner join datas on times.data = datas.data_serial
where n_time = $1 and datas.data in (
  select ymdhm from (
    select date_trunc('day', datas.data)::date as ymd, max (data) as ymdhm
    from datas
    where data >= (select cur_batch_date - interval '55 days 1 hour')
    group by ymd
    ) as max
)
order by datas.data
-- -----------------------------------
loop
points1 := linha.pontos - points0;
points0 := linha.pontos;
wus1 := linha.wus - wus0;
wus0 := linha.wus;
  select f.points1, f.wus1, ""date"" into team_production
  from (select points1, wus1, linha.d0 as ""date"") as f;
  return next team_production;
end loop;
return;
end;$_$;",fahstats.schema
"CREATE FUNCTION team_production(integer) RETURNS SETOF type_team_production
    LANGUAGE plpgsql STABLE STRICT
    AS $_$declare
  team_production type_team_production;
  linha record;
  points0 real;
  points1 real;
  wus0 integer;
  wus1 integer;
  cur_batch_date timestamp;
begin

cur_batch_date := (select data from datas order by data desc limit 1);
points0 := coalesce((
  select pontos
  from times inner join datas on times.data = datas.data_serial
  where n_time = $1 and datas.data in (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (select cur_batch_date - interval '55 days 23 hour')
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
  ), 0);

wus0 := coalesce((
  select wus
  from times inner join datas on times.data = datas.data_serial
  where n_time = $1 and datas.data in (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (select cur_batch_date - interval '55 days 23 hour')
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
  ), 0);

for linha in
-- -----------------------------------
select pontos , wus, 'day', datas.data as d0
from times inner join datas on times.data = datas.data_serial
where n_time = $1 and datas.data in (
  select ymdhm from (
    select date_trunc('day', datas.data)::date as ymd, max (data) as ymdhm
    from datas
    where data >= (select cur_batch_date - interval '55 days 1 hour')
    group by ymd
    ) as max
)
order by datas.data
-- -----------------------------------
loop
points1 := linha.pontos - points0;
points0 := linha.pontos;
wus1 := linha.wus - wus0;
wus0 := linha.wus;
  select f.points1, f.wus1, ""date"" into team_production
  from (select points1, wus1, linha.d0 as ""date"") as f;
  return next team_production;
end loop;
return;
end;$_$;",ks2.schema
"CREATE FUNCTION term(varterm character varying, OUT conceptid numeric, OUT id numeric, OUT term character varying) RETURNS SETOF record
    LANGUAGE plpgsql
    AS $$
DECLARE
    reg RECORD;
BEGIN
    FOR REG IN  SELECT  d.conceptid, d.id, d.term
		FROM 
		snomed.descriptions d 
		Inner join snomed.languages l on d.id = l.referencedcomponentid
		Inner join snomed.concepts c on c.id = d.conceptid
		WHERE 
			c.active = True
			and d.active = True 
			and l.active = True			 
			and l.refsetId =  450828004 --conjunto de referencias de lenguaje castellano para América Latina (metadato fundacional)
			AND to_tsquery(varterm) @@ textsearchable_index_col
		Order by char_length(d.term),d.term LIMIT 50 LOOP
		conceptid := reg.conceptid;
		id := reg.id;
		term := reg.term;
       RETURN NEXT;
    END LOOP;
    RETURN;
END
$$;",simulador.txt
"CREATE FUNCTION test() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
    i integer;
BEGIN
  select 1 into i;
  return i;
END;
$$;",beach_ranks_backup.sql
"CREATE FUNCTION test(p1 integer, p2 integer) 
	RETURNS integer AS $$
BEGIN
		RETURN p1 + p2;
END; $$
LANGUAGE plpgsql;",postgres.md
"CREATE FUNCTION test_account(account integer[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
   k integer[] := '{ 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1, 3, 7, 1 }';
   sum integer;
begin
   if (array_length(account, 1) != 23) then
      return false;
   end if;

   sum := get_control_sum(account, k);
   return sum % 10 = 0;
end;$$;",create.sql
"CREATE FUNCTION test_assert_array_equals() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- EMPTY ARRAYS

  PERFORM pgunit.assert_array_equals('{}'::varchar[], '{}'::varchar[], _message);

  BEGIN
    PERFORM pgunit.assert_array_equals('{}'::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1']::varchar[], '{}'::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 28';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1']::varchar[], NULL::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 38';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals('{}'::varchar[], NULL::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 48';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(NULL::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 58';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#incorrect_expected_value %' THEN
        RAISE;
      END IF;
  END;

  -- UNARY ARRAY

  PERFORM pgunit.assert_array_equals(array['1']::varchar[], array['1']::varchar[], _message);

  BEGIN
    PERFORM pgunit.assert_array_equals(array['2']::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 72';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- ARRAYS

  PERFORM pgunit.assert_array_equals(array['1', '2']::varchar[], array['1', '2']::varchar[], _message);
  PERFORM pgunit.assert_array_equals(array['2', '1']::varchar[], array['1', '2']::varchar[], _message);
  PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '3', '2']::varchar[], _message);


  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '3', '2', '2']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 77';
  EXCEPTION
  WHEN others THEN
    IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
      RAISE;
    END IF;
  END;


  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '2', '2']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 89';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['4', '5', '6']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 99';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_array_equals() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- EMPTY ARRAYS

  PERFORM pgunit.assert_array_equals('{}'::varchar[], '{}'::varchar[], _message);

  BEGIN
    PERFORM pgunit.assert_array_equals('{}'::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1']::varchar[], '{}'::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 28';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1']::varchar[], NULL::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 38';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals('{}'::varchar[], NULL::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 48';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(NULL::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 58';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#incorrect_expected_value %' THEN
        RAISE;
      END IF;
  END;

  -- UNARY ARRAY

  PERFORM pgunit.assert_array_equals(array['1']::varchar[], array['1']::varchar[], _message);

  BEGIN
    PERFORM pgunit.assert_array_equals(array['2']::varchar[], array['1']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 72';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- ARRAYS

  PERFORM pgunit.assert_array_equals(array['1', '2']::varchar[], array['1', '2']::varchar[], _message);
  PERFORM pgunit.assert_array_equals(array['2', '1']::varchar[], array['1', '2']::varchar[], _message);
  PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '3', '2']::varchar[], _message);


  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '3', '2', '2']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 77';
  EXCEPTION
  WHEN others THEN
    IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
      RAISE;
    END IF;
  END;


  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['1', '2', '2']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 89';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_array_equals(array['1', '2', '3']::varchar[], array['4', '5', '6']::varchar[], _message);
    RAISE EXCEPTION 'Epic fail. Line: 99';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_array_equals\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_assert_equals() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT

  PERFORM pgunit.assert_equals(1::int, 1::int, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1::int, 2::int, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_equals(1::int, NULL::int, _message);
    RAISE EXCEPTION 'Epic fail. Line: 28';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_equals(1::int8, 1::int8, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1::int8, 2::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 42';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_equals(1.1::numeric, 1.1::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1.1::numeric, 1.2::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 56';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_equals('1.1'::varchar, '1.1'::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_equals('1.1'::varchar, '1.1 '::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 70';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_equals('1.1'::text, '1.1'::text, _message);

  BEGIN
    PERFORM pgunit.assert_equals('1.1'::text, '1.1 '::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 84';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_equals() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT

  PERFORM pgunit.assert_equals(1::int, 1::int, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1::int, 2::int, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_equals(1::int, NULL::int, _message);
    RAISE EXCEPTION 'Epic fail. Line: 28';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_equals(1::int8, 1::int8, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1::int8, 2::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 42';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_equals(1.1::numeric, 1.1::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_equals(1.1::numeric, 1.2::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 56';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_equals('1.1'::varchar, '1.1'::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_equals('1.1'::varchar, '1.1 '::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 70';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_equals('1.1'::text, '1.1'::text, _message);

  BEGIN
    PERFORM pgunit.assert_equals('1.1'::text, '1.1 '::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 84';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_equals\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_assert_false() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  PERFORM pgunit.assert_false(False, _message);

  BEGIN
    PERFORM pgunit.assert_false(True, _message);
    RAISE EXCEPTION 'Epic fail. Line: 16';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_false\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_false(NULL::boolean, _message);
    RAISE EXCEPTION 'Epic fail. Line: 26';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_false\n%' THEN
        RAISE;
      END IF;
  END;

END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_false() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  PERFORM pgunit.assert_false(False, _message);

  BEGIN
    PERFORM pgunit.assert_false(True, _message);
    RAISE EXCEPTION 'Epic fail. Line: 16';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_false\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_false(NULL::boolean, _message);
    RAISE EXCEPTION 'Epic fail. Line: 26';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_false\n%' THEN
        RAISE;
      END IF;
  END;

END;
$$;",mes-idea.sql
"CREATE FUNCTION test_assert_not_null() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT4

  PERFORM pgunit.assert_not_null(1::int4, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::int4, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_not_null(1::int8, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 32';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_not_null(1.1::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 46';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_not_null('1.1'::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 60';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_not_null('1.1'::text, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 74';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_not_null() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT4

  PERFORM pgunit.assert_not_null(1::int4, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::int4, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_not_null(1::int8, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 32';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_not_null(1.1::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 46';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_not_null('1.1'::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 60';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_not_null('1.1'::text, _message);

  BEGIN
    PERFORM pgunit.assert_not_null(NULL::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 74';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_not_null\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_assert_null() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT4

  PERFORM pgunit.assert_null(NULL::int4, _message);

  BEGIN
    PERFORM pgunit.assert_null(1::int4, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_null(NULL::int8, _message);


  BEGIN
    PERFORM pgunit.assert_null(1::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 33';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_null(NULL::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_null(1.1::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 47';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_null(NULL::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_null('1.1'::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 61';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_null(NULL::text, _message);

  BEGIN
    PERFORM pgunit.assert_null('1.1'::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 75';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_null() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  -- INT4

  PERFORM pgunit.assert_null(NULL::int4, _message);

  BEGIN
    PERFORM pgunit.assert_null(1::int4, _message);
    RAISE EXCEPTION 'Epic fail. Line: 18';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- INT8

  PERFORM pgunit.assert_null(NULL::int8, _message);


  BEGIN
    PERFORM pgunit.assert_null(1::int8, _message);
    RAISE EXCEPTION 'Epic fail. Line: 33';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- NUMERIC

  PERFORM pgunit.assert_null(NULL::numeric, _message);

  BEGIN
    PERFORM pgunit.assert_null(1.1::numeric, _message);
    RAISE EXCEPTION 'Epic fail. Line: 47';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- VARCHAR

  PERFORM pgunit.assert_null(NULL::varchar, _message);

  BEGIN
    PERFORM pgunit.assert_null('1.1'::varchar, _message);
    RAISE EXCEPTION 'Epic fail. Line: 61';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;

  -- TEXT

  PERFORM pgunit.assert_null(NULL::text, _message);

  BEGIN
    PERFORM pgunit.assert_null('1.1'::text, _message);
    RAISE EXCEPTION 'Epic fail. Line: 75';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_null\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_assert_true() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  PERFORM pgunit.assert_true(True, _message);

  BEGIN
    PERFORM pgunit.assert_true(False, _message);
    RAISE EXCEPTION 'Epic fail. Line: 16';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_true\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_true(NULL::boolean, _message);
    RAISE EXCEPTION 'Epic fail. Line: 26';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_true\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_assert_true() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  varchar;
BEGIN
  _message := 'qazwsxedc';

  PERFORM pgunit.assert_true(True, _message);

  BEGIN
    PERFORM pgunit.assert_true(False, _message);
    RAISE EXCEPTION 'Epic fail. Line: 16';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_true\n%' THEN
        RAISE;
      END IF;
  END;

  BEGIN
    PERFORM pgunit.assert_true(NULL::boolean, _message);
    RAISE EXCEPTION 'Epic fail. Line: 26';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#assert_true\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_bank_account(account numeric, bik numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
   bik_a integer[];
   account_a integer[];
begin
   bik_a = string_to_array('0' || substring(lpad(bik::character varying, 9, '0') from 5 for 2), NULL)::integer[];
   account_a = string_to_array(account::character varying, NULL)::integer[];
   return test_account(bik_a || account_a);
end;$$;",create.sql
"CREATE FUNCTION test_current_account(account numeric, bik numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
   bik_a integer[];
   account_a integer[];
begin
   bik_a = string_to_array((bik % 1000)::character varying, NULL)::integer[];
   account_a = string_to_array(account::character varying, NULL)::integer[];
   return test_account(bik_a || account_a);
end;$$;",create.sql
"CREATE FUNCTION test_env() RETURNS boolean
    LANGUAGE plpgsql COST 10
    AS $$
declare
  -- модульные тесты проверки функций окружения 
  l_text  env_resource_text.content%type;
begin
  select env_resource_text_format('I1800001', 'zz') into l_text;
  if (l_text is null) then
    raise exception NO_DATA_FOUND using message = 'failed to format message with code I1800001';
  end if;
  return true;
end;
$$;",metadict.sql
"CREATE FUNCTION test_fail() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  text;
BEGIN
  _message := 'qazwxedc';
  BEGIN
    PERFORM pgunit.fail(_message);
    RAISE EXCEPTION 'Epic fail. Line: 14';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#fail\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mdm.sql
"CREATE FUNCTION test_fail() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  _message  text;
BEGIN
  _message := 'qazwxedc';
  BEGIN
    PERFORM pgunit.fail(_message);
    RAISE EXCEPTION 'Epic fail. Line: 14';
  EXCEPTION
    WHEN others THEN
      IF SQLERRM NOT ILIKE E'#fail\n%' THEN
        RAISE;
      END IF;
  END;
END;
$$;",mes-idea.sql
"CREATE FUNCTION test_future_xid_status(bigint)
RETURNS void
LANGUAGE plpgsql
AS
$$
BEGIN
  PERFORM txid_status($1);
  RAISE EXCEPTION 'didn''t ERROR at xid in the future as expected';
EXCEPTION
  WHEN invalid_parameter_value THEN
    RAISE NOTICE 'Got expected error for xid in the future';
END;
$$;",txid.out
"CREATE FUNCTION test_inn(inn_value numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
   inn_arr integer[];
   k integer[] := '{ 2, 4, 10, 3, 5, 9, 4, 6, 8 }';
   k1 integer[] := '{ 7, 2, 4, 10, 3, 5, 9, 4, 6, 8 }';
   k2 integer[] := '{3, 7, 2, 4, 10, 3, 5, 9, 4, 6, 8 }';
begin
   inn_arr := string_to_array(inn_value::character varying, NULL)::integer[];

   if (array_length(inn_arr, 1) != 10 and array_length(inn_arr, 1) != 12) then
      return false;
   end if;

   if (get_control_value(inn_arr, k, 11) = inn_arr[10]) then
      if (array_length(inn_arr, 1) = 12) then
         return get_control_value(inn_arr, k1, 11) == inn_arr[11] && get_control_value(inn_arr, k2, 11) == inn_arr[12];
      end if;
		
      return true;
   end if;

   return false;
end;$$;",create.sql
"CREATE FUNCTION test_okpo(okpo_value numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $$declare
   okpo_arr integer[];
   k1 integer[] := '{ 1, 2, 3, 4, 5, 6, 7 }';
   k2 integer[] := '{ 3, 4, 5, 6, 7, 8, 9 }';
   c integer;
begin
   okpo_arr := string_to_array(okpo_value::character varying, NULL)::integer[];
   if (array_length(okpo_arr, 1) < 8) then
      return false;
   end if;
	
   c := get_control_value(okpo_arr, k1, 11, false);
   if (c > 9) then
      c := get_control_value(okpo_arr, k2, 11);
   end if;

   return c = okpo_arr[8];
end;$$;",create.sql
"CREATE FUNCTION test_sec() RETURNS boolean
    LANGUAGE plpgsql COST 10
    AS $_$declare
  -- модульные тесты проверки операций над учетными записями и учетными данными
  c_auth_path_id  constant integer := 1; -- источник аутентификации админа (подойдет код любого существующего источника)
  l_root_token    sec_token;
  l_root_session  sec_session;
  c_auth_kind     constant text := 'pg_crypt';
  l_ak            sec_authentication_kind;
  l_ap            sec_authentication_path;
  c_user_name     constant text := 'test-001';
  c_credential    constant text := 'te$t-creDential#001';
  l_user          sec_user;
  l_token         sec_token;
  l_session       sec_session;
  l_cnt           integer;
  l_ok            integer;
  l_res           integer;
  l_uac           sec_user_authcred;
begin
  -- создаем сессию админа
  l_root_token := sec_login(uuid_generate()::text, c_auth_path_id, 'root');
  -- проверяем валидность созданной сессии
  l_root_session := sec_session_valid(l_root_token.session_id);
  -- поиск сессии
  select * into l_session from sec_session_find_by_id(l_root_token.session_id);
  -- схемы, виды аутентификации
  begin
    l_ak := sec_authentication_kind_by_code(c_auth_kind);
  exception
    when NO_DATA_FOUND then 
      l_ak := sec_authentication_kind_add(l_root_token.session_id, row(null, c_auth_kind, c_auth_kind));
  end;
  -- методы, способы и источники проверки аутентификации
  select * into l_ap
    from sec_authentication_path
   where authentication_kind_id = l_ak.id;
  -- поиск пользователя
  begin
    select * into l_user from sec_user_by_name(c_user_name);
  exception
    when NO_DATA_FOUND then
      l_user := sec_user_create(l_root_session.id, c_user_name, l_ap.id, c_credential);
  end;
  -- создаем сессию юзера
  l_token := sec_login(c_user_name, c_credential, l_ap.id);
  if (l_token is null) then
    raise warning NO_DATA_FOUND using message = 'sec_login failed. resulted token is NULL';
    -- сброс своего пароля
    if (not sec_user_authcred_reset_any(l_root_session.id, c_user_name, c_credential, l_ap.id)) then
      raise exception NO_DATA_FOUND using message = 'authcred NOT reseted';
    end if;
    l_token := sec_login(c_user_name, c_credential, l_ap.id);
  end if;
  if (l_token is null) then
    raise notice 'sec_login failed. resulted token is NULL';
  else
    raise notice using message = 'sec_login succeded. resulted token is NOT NULL. l_token.id='||l_token.id;
  end if;
  -- проверяем валидность созданной сессии
  l_session := sec_session_valid(l_token.session_id);
  -- проверка наличия валидных учетных данных для аутентификации
  select * into l_uac from sec_user_authcred_by_pk(l_session.user_id, l_token.auth_path_id);
  -- проверка учетных данных при аутентификации
  select count(*) into l_cnt from sec_user_authcred_accepted(l_session.user_id, c_credential, l_token.auth_path_id);
  if (l_cnt = 0) then
    raise exception NO_DATA_FOUND using message = 'authcred NOT accepted';
  end if;
  -- проверка учетных данных при аутентификации
  select count(*) into l_cnt from sec_user_authcred_accepted(c_user_name, c_credential, l_token.auth_path_id);
  if (l_cnt = 0) then
    raise exception NO_DATA_FOUND using message = 'authcred NOT accepted';
  end if;
  select * into l_ok from env_resource_text_find_by_code('ANY00001');
  if (l_ok is null) then
    raise exception NO_DATA_FOUND using message = 'env_resource_text_find_by_code failed to find resource with code ""ANY00001""';
  end if;
  -- проверка на некорректные учетные данные
  select count(*) into l_cnt from sec_user_authcred_accepted(c_user_name, '-'||c_credential||'+', l_token.auth_path_id);
  if (l_cnt = 0) then
    raise notice 'wrong user_authcred not accepted';
  else 
    raise exception 'wrong user_authcred ACCEPTED';
  end if;

  -- период действия учетных данных - до сегодняшней полуночи
  select * into l_uac from sec_user_authcred_set_valid_period(l_root_session.id, l_uac.user_id, l_uac.auth_path_id, 'yesterday', 'today');
  -- проверка учетных данных при аутентификации
  select count(*) into l_cnt from sec_user_authcred_accepted(c_user_name, c_credential, l_token.auth_path_id);
  if (l_cnt = 0) then
    raise notice 'block out user_authcred. authcred not accepted';
  end if;
  -- период действия учетных данных - c сегодняшней полуночи до бексонечности
  select * into l_uac from sec_user_authcred_set_valid_period(l_root_session.id, l_uac.user_id, l_uac.auth_path_id, 'today', 'infinity');
  -- проверка учетных данных при аутентификации
  select count(*) into l_cnt from sec_user_authcred_accepted(c_user_name, c_credential, l_token.auth_path_id);
  if (l_cnt = 0) then
    raise exception 'unblock user_authcred. authcred NOT accepted';
  end if;
    -- завершаем сессию юзера
  l_token := sec_logout(l_token.localvalue);
  -- завершаем сессию админа
  l_root_token := sec_logout(l_root_token.localvalue);
  return true;
end;
$_$;",metadict.sql
"CREATE FUNCTION test_signature() RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE lv_hash text;
	lv_to_hash bytea;
	lv_signed_hash bytea;
	lv_patient_id integer;
	lv_execute BOOLEAN;
	lv_start date;
	lv_end date;
	lv_nonce bigint;
	lv_temp_signature bytea;
	lv_private_key text;
BEGIN
	lv_patient_id := 1;
	lv_start := '2001-10-05';
	lv_end := '2015-10-05';
	lv_nonce := nonce FROM ""Patient"" WHERE id = lv_patient_id;
	lv_execute := false;
	--lv_to_hash := 'browse_my_prescriptions_history' || lv_patient_id || lv_execute || (SELECT to_char(lv_start, 'HH12:MI:SS')) || (select to_char(lv_end, 'HH12:MI:SS')) || lv_nonce;--- || lv_end::text || lv_nonce;

	lv_to_hash := 'browse_my_prescriptions_history' || lv_patient_id || lv_execute || lv_start || lv_end || lv_nonce;--- || lv_end::text || lv_nonce;
	
	lv_hash := sha1(lv_to_hash);
	PERFORM dump_hash(lv_hash);
	lv_private_key := private_key FROM ""Patient"" WHERE id = lv_patient_id;
	PERFORM dump_key(lv_private_key);
	PERFORM system('bash /fixkey.sh');
	PERFORM system('openssl rsautl -sign -in /tmp/tosign -inkey /tmp/key -out /tmp/sig');
	--lv_temp_signature := (SELECT system('openssl rsautl -sign -in /tmp/tosign -inkey /tmp/key -out /tmp/sig'));
	lv_temp_signature := (SELECT system('cat /tmp/sig'));
	--PERFORM dump_sig(lv_temp_signature);
	PERFORM browse_my_prescriptions_history(lv_patient_id, lv_execute, lv_start, lv_end, lv_temp_signature);
END;$$;",baza.sql
"CREATE FUNCTION testa_cursor() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs_empregados CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk;
 	
--um_empregado laboratorios%ROWTYPE;
reg RECORD;
BEGIN
OPEN cs_empregados;
--FETCH cs_empregados INTO um_empregado;
FETCH cs_empregados INTO reg;

--RETURN NEXT um_empregado;
RETURN NEXT reg;
RETURN;
END;
$$;",C.%20H.%20V.%20BANCO%20DE%20DADOS%20Final.sql
"CREATE FUNCTION testa_cursor() RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
cs_empregados CURSOR FOR SELECT p.nome_paciente, e.tipo_exame, l.descricao_exame, l.responsavel_exame, l.valor from paciente p inner join tratamento t on p.cod_paciente = t.cod_paciente_fk inner join laboratoriais l on t.cod_tratamento_pk = l.cod_tratameto_fk inner join exame e on e.cod_exame_pk = l.cod_exame_fk;
 	
--um_empregado laboratorios%ROWTYPE;
reg RECORD;
BEGIN
OPEN cs_empregados;
--FETCH cs_empregados INTO um_empregado;
FETCH cs_empregados INTO reg;

--RETURN NEXT um_empregado;
RETURN NEXT reg;
RETURN;
END;
$$;",C.H.V.Final.backup
"CREATE FUNCTION teste(pnome character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
  declare
    retorno integer;
    d1 integer;
  begin
       select count(id) into retorno from pessoas where nome = pnome;
       GET DIAGNOSTICS d1 = ROW_COUNT;
       raise notice ' o valor contado no diagnostico eh: % ', d1;
       return retorno;  
  end;
$$;",aula.sql
"CREATE FUNCTION teste_pessoas() RETURNS SETOF pessoas
    LANGUAGE plpgsql
    AS $$
  declare
    reg record;
  begin
     for reg in (select * from pessoas) loop
        reg.nome := upper(reg.nome);
        return next reg;
     end loop;
     return;
  end;
$$;",aula.sql
"CREATE FUNCTION text2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$

  DECLARE
     res xml;
  BEGIN
     res := xmlelement(name ""simpleType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", xmlattributes('en' as ""xml:lang""), item.definition)),
          
             xmlelement(name restriction, 
                        xmlattributes('normalizedString' as base)));

     return res;
  END;
$$;",test.sql
"CREATE FUNCTION three(study_uid text) RETURNS text
    LANGUAGE plpgsql
    AS $$declare
------------------------------------------
-- Purpose: Fuji CR header processor
-- 	After successful run clears entry from
--	""exams-to-process"" table
-- Caller: Dispatcher
-----------------------------------------
	func text :='ddw:three';
	status text :='failed';

begin
	status :='ok';
	-- right now this is just a stub to clear the ""exams-to-process"" table
	-- and avoid errors in the Log table
	return status ;
end;$$;",purged-ddw.sql
"CREATE FUNCTION time_add_hours(time without time zone, integer) RETURNS time without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pHours || ' hours')::interval)::time;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_hours(time without time zone, integer) RETURNS time without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pHours || ' hours')::interval)::time;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_add_hours(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pHours || ' hours')::interval)::timestamp ;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_hours(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pHours || ' hours')::interval)::timestamp ;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_add_hours(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN time_add_hours(pTime::timestamp with time zone, pHours);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_hours(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime  ALIAS FOR $1;
  pHours ALIAS FOR $2;
BEGIN
  RETURN time_add_hours(pTime::timestamp with time zone, pHours);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_add_minutes(time without time zone, integer) RETURNS time without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pMinutes || ' minutes')::interval)::time;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_minutes(time without time zone, integer) RETURNS time without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pMinutes || ' minutes')::interval)::time;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_add_minutes(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pMinutes || ' minutes')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_minutes(timestamp with time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN (pTime + (pMinutes || ' minutes')::interval)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_add_minutes(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN time_add_minutes(pTime::timestamp with time zone, pMinutes)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_add_minutes(timestamp without time zone, integer) RETURNS timestamp without time zone
    AS $_$
DECLARE
  pTime    ALIAS FOR $1;
  pMinutes ALIAS FOR $2;
BEGIN
  RETURN time_add_minutes(pTime::timestamp with time zone, pMinutes)::timestamp;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_hours(time without time zone, time without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN EXTRACT('hour' FROM (pEndTime - pStartTime));
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_hours(time without time zone, time without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN EXTRACT('hour' FROM (pEndTime - pStartTime));
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_hours(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vDays      integer;
  vHours     integer;
BEGIN
  vDays  := EXTRACT('day'  FROM (DATE_TRUNC('day', pEndTime) - DATE_TRUNC('day', pStartTime)));
  vHours := EXTRACT('hour' FROM (pEndTime - pStartTime));
  RETURN (vDays * 24) + vHours;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_hours(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vDays      integer;
  vHours     integer;
BEGIN
  vDays  := EXTRACT('day'  FROM (DATE_TRUNC('day', pEndTime) - DATE_TRUNC('day', pStartTime)));
  vHours := EXTRACT('hour' FROM (pEndTime - pStartTime));
  RETURN (vDays * 24) + vHours;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_hours(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN time_diff_hours(pStartTime::timestamp with time zone, pEndTime::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_hours(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN time_diff_hours(pStartTime::timestamp with time zone, pEndTime::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_minutes(time without time zone, time without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vHours     integer;
  vMinutes   integer;
BEGIN
  vHours   := EXTRACT('hour' FROM (pEndTime - pStartTime));
  vMinutes := EXTRACT('minute' FROM (pEndTime - pStartTime));
  RETURN (vHours * 60) + vMinutes;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_minutes(time without time zone, time without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vHours     integer;
  vMinutes   integer;
BEGIN
  vHours   := EXTRACT('hour' FROM (pEndTime - pStartTime));
  vMinutes := EXTRACT('minute' FROM (pEndTime - pStartTime));
  RETURN (vHours * 60) + vMinutes;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_minutes(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vHours     integer;
  vMinutes   integer;
BEGIN
  vHours   := time_diff_hours(pStartTime, pEndTime);
  vMinutes := EXTRACT('minute' FROM AGE(pEndTime, pStartTime));
  RETURN (vHours * 60) + vMinutes;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_minutes(timestamp with time zone, timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
  vHours     integer;
  vMinutes   integer;
BEGIN
  vHours   := time_diff_hours(pStartTime, pEndTime);
  vMinutes := EXTRACT('minute' FROM AGE(pEndTime, pStartTime));
  RETURN (vHours * 60) + vMinutes;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION time_diff_minutes(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN time_diff_minutes(pStartTime::timestamp with time zone, pEndTime::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION time_diff_minutes(timestamp without time zone, timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pStartTime ALIAS FOR $1;
  pEndTime   ALIAS FOR $2;
BEGIN
  RETURN time_diff_minutes(pStartTime::timestamp with time zone, pEndTime::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION timestamp2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql
    AS $$
  DECLARE
     res xml;
  BEGIN
     res := xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                        xmlattributes('en' as ""xml:lang""), 
                        'Implementation of ' ||item.item || '. Defined as: ' || item.definition)),
          
             xmlelement(name ""attribute"", 
                        xmlattributes('time' as name, 
                                      'gcdml:FuzzyTimePositionUnion' as type,
                                       'required' as use)
                       )
              );


     return res;
  END;
$$;",test.sql
"CREATE FUNCTION to_days(date) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN to_days(pDate::timestamp);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION to_days(date) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN to_days(pDate::timestamp);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION to_days(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  vDays interval;
  vResult integer;
BEGIN
  vDays := (DATE_TRUNC('day', pDate) - DATE_TRUNC('day', '0000-01-01'::timestamp));
  vResult := EXTRACT('day' FROM vDays);
  RETURN vResult;
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION to_days(timestamp with time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
  vDays interval;
  vResult integer;
BEGIN
  vDays := (DATE_TRUNC('day', pDate) - DATE_TRUNC('day', '0000-01-01'::timestamp));
  vResult := EXTRACT('day' FROM vDays);
  RETURN vResult;
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION to_days(timestamp with time zone) RETURNS integer     AS $_$ BEGIN  RETURN round(date_part('epoch', $1::date) / 86400)::int4 + 719528; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION to_days(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN to_days(pDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-demo.psql
"CREATE FUNCTION to_days(timestamp without time zone) RETURNS integer
    AS $_$
DECLARE
  pDate ALIAS FOR $1;
BEGIN
  RETURN to_days(pDate::timestamp with time zone);
END;
$_$
    LANGUAGE plpgsql;",weberp-new.psql
"CREATE FUNCTION to_int(p_val character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Cast value to int; on failure return 0
   BEGIN
      RETURN Cast(p_val As integer);
    EXCEPTION WHEN Others THEN
      RETURN 0;
   END;

END
$$;",utils.sql
"CREATE FUNCTION to_varchar(p_val xml) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
  -- Cast value to int; on failure return null
   BEGIN
      RETURN Cast(p_val As varchar);
    EXCEPTION WHEN Others THEN
      RETURN null;
   END;

END
$$;",utils.sql
"CREATE FUNCTION todas_participantes(integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR SELECT * from participantes where participantes.IDROM=$1 ORDER BY participantes.PARTICIPANTE;
	RETURN MYCURS;
END;
$_$;",todo.sql
"CREATE FUNCTION todas_salas() RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR SELECT * FROM SALA ORDER BY ID;
	RETURN MYCURS;
END;
$$;",todo.sql
"CREATE FUNCTION todas_salas_grupales(integer, integer) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE
	MYCURS REFCURSOR;
BEGIN
	OPEN MYCURS FOR SELECT * from rom inner join participantes on rom.id = participantes.idrom where (rom.idusuario=$1 or participantes.participante=$1) and rom.tipo=$2 ORDER BY rom.ID;
	RETURN MYCURS;
END;
$_$;",todo.sql
"CREATE FUNCTION total() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
total integer;
begin
select count(*) into total from company;
return total;
end;
$$;",file(21Aprl).pgsql
"CREATE FUNCTION total() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare
total integer;
begin
select count(*) into total from company;
return total;
end;
$$;",mydb_dump(20th_April).pgsql
"CREATE FUNCTION total_cost(id_attachment integer) RETURNS money
    LANGUAGE plpgsql STABLE SECURITY DEFINER LEAKPROOF
    AS $$
DECLARE cost money;
BEGIN
cost = (SELECT SUM(""Ценность"" * ""Количество"")
	FROM public.""Предмет""
	WHERE ""ИД_Вложение"" = id_attachment);
RETURN COALESCE(cost,0::money);
END
$$;",post_office.backup
"CREATE FUNCTION total_dias_alquilado_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
aux int;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_i) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo;
RETURN total; 
END
$$;",backup%2027-jul-2017(1).sql
"CREATE FUNCTION total_dias_alquilado_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
aux int;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_i) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo;
RETURN total; 
END
$$;",backup%2027-jul-2017(2).sql
"CREATE FUNCTION total_dias_alquilado_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
aux int;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_i) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo;
RETURN total; 
END
$$;",backup%2027-jul-2017(3).sql
"CREATE FUNCTION total_dias_alquilado_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
aux int;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_i) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo;
RETURN total; 
END
$$;",backup%2027-jul-2017(4).sql
"CREATE FUNCTION total_dias_alquilado_marca_modelo(model character varying, marc character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
total INT;
aux int;
id_mar int;
id_m int;
BEGIN
total=0;
SELECT marcas.id_marca INTO id_mar FROM marcas WHERE marcas.nombre_marca=marc;
SELECT modelos.id_modelo INTO id_m FROM modelos WHERE modelos.nombre_modelo=model AND modelos.modelo_id_marca=id_mar;

SELECT sum(fecha_entrega-fecha_i) into total
from contratos JOIN autos on contratos.cont_id_auto=autos.id_auto
JOIN modelos ON modelos.id_modelo=autos.id_modelo_auto JOIN marcas ON marcas.id_marca=modelos.modelo_id_marca
WHERE marcas.id_marca=id_mar and id_m=modelos.id_modelo;
RETURN total; 
END
$$;",backup1.sql
"CREATE FUNCTION total_network_speed(c_device_id integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$DECLARE result double precision;
BEGIN
	result = SUM(networkadapter.max_speed) FROM networkadapter JOIN 
	(SELECT hardware_component_id FROM devicehardwarecomponent 
	WHERE device_id = c_device_id) AS devicescomponents 
	ON networkadapter.hardware_component_id = devicescomponents.hardware_component_id;
	RETURN result;
END;$$;",database
"CREATE FUNCTION total_record() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE total INTEGER;
BEGIN
	SELECT count(*) INTO total FROM tbarticle;
	RETURN total;
END;
$$;",05072015235607.sql
"CREATE FUNCTION total_weight(id_attachment integer) RETURNS real
    LANGUAGE plpgsql STABLE SECURITY DEFINER LEAKPROOF
    AS $$
DECLARE weight real;
BEGIN
weight = (SELECT SUM(""Вес"" * ""Количество"")
	FROM public.""Предмет""
	WHERE ""ИД_Вложение"" = id_attachment);
RETURN COALESCE(weight,0);
END
$$;",post_office.backup
"CREATE FUNCTION translate(att_val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF CHAR_LENGTH(TRIM(att_val)) = 0 THEN
	
		RETURN null::VARCHAR;
	END IF;

	RETURN TRANSLATE(att_val, massoftware.translate_from (), massoftware.translate_to())::VARCHAR;
		
END;
$$;",back.sql
"CREATE FUNCTION translate_from() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	
	RETURN '/\""'';,_-.âãäåāăąàáÁÂÃÄÅĀĂĄÀèééêëēĕėęěĒĔĖĘĚÉÈËÊìíîïìĩīĭÌÍÎÏÌĨĪĬóôõöōŏőòÒÓÔÕÖŌŎŐùúûüũūŭůÙÚÛÜŨŪŬŮçÇñÑ'::VARCHAR;
		
END;
$$;",back.sql
"CREATE FUNCTION translate_to() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	
	RETURN '         aaaaaaaaaAAAAAAAAAeeeeeeeeeeEEEEEEEEEiiiiiiiiIIIIIIIIooooooooOOOOOOOOuuuuuuuuUUUUUUUUcCnN'::VARCHAR;
		
END;
$$;",back.sql
"CREATE FUNCTION treatment2gcdmltype(item clist_item_details) RETURNS xml
    LANGUAGE plpgsql STABLE STRICT
    SET search_path TO gsc_db, public
    AS $$

  DECLARE
     res xml;

  BEGIN

  res := xmlelement(name ""complexType"", 
                  xmlattributes(item.item || 'MIGSType' as name, '#all' as final), 
          xmlelement(name ""annotation"", 
             xmlelement(name ""documentation"", 
                              xmlattributes('en' as ""xml:lang""), 
                              'Implemantation of ' ||item.item || '. Defined as: ' || item.definition)),
             xmlelement(name ""sequence"", 
                xmlelement(name ""group"", 
                           xmlattributes('gcdml:RegimeTimesGroup' as ""ref"")
                           )
             ),
           xmlelement(name attribute, 
                      xmlattributes('name' as ""name"",
                                    'token' as type,
                                    'required' as use))

          );
     return res;
  END;
$$;",test.sql
"CREATE FUNCTION tricky(text, text) RETURNS bool AS $$
BEGIN
    RAISE NOTICE '% =&gt; %', $1, $2;
    RETURN true;
END
$$ LANGUAGE plpgsql COST 0.0000000000000000000001;",rules.sgml
"CREATE FUNCTION trim_clean(p_text character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
    Return Rtrim(p_text, ', ()-');
END;
$$;",utils.sql
"CREATE FUNCTION twelve(study_uid text) RETURNS text
    LANGUAGE plpgsql
    AS $$declare
------------------------------------------
-- Purpose: Carestream DR header processor
-- 	After successful run clears entry from
--	""exams-to-process"" table
-- Caller: Dispatcher
-----------------------------------------
	func text :='ddw:twelve';
	status text :='failed';

begin
	status :='ok';
	-- right now this is just a stub to clear the ""exams-to-process"" table
	-- and avoid errors in the Log table
	return status ;
end;$$;",purged-ddw.sql
"CREATE FUNCTION type_max(p_typename character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	v_type varchar;
BEGIN
	v_type = Lower(Trim(p_typename));
   If v_type = 'int' OR v_type = 'integer' Then
   	Return '2147483647';
    ElsIf v_type = 'bigint' Then
   	Return '9223372036854775807';
    ElsIf v_type = 'smallint' Then
      Return '32767';
   End If;

   Return 0;
END;
$$;",utils.sql
"CREATE FUNCTION udf_fn_queryfilledfields(filledformid integer, statuscode character) RETURNS TABLE(submitted_form_data_id integer, submitted_form_no integer, field_id integer, field_value text)
    LANGUAGE plpgsql
    AS $$

BEGIN
	IF (filledformid = 0) 
	THEN
	
      SELECT t1.submitted_form_data_id, t1.submitted_form_no, field_id, field_value
		FROM dudf.udf_t_submitted_forms_data tl, dudf.udf_t_submitted_forms t2
		WHERE t1.submitted_form_no = t2.submitted_form_no
			AND t2.status_code = statuscode
		ORDER BY t1.submitted_form_data_id;
	ELSE
      SELECT t1.submitted_form_data_id, t1.submitted_form_no, t1.field_id, t1.field_value
		FROM dudf.udf_t_submitted_forms_data t1
		WHERE t1.submitted_form_no = filledformid;
		END IF;

END
$$;",dudf
"CREATE FUNCTION uf_auth_get_parameter_boolean(prm_parameter character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare var_return boolean;
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select boolean_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_auth_get_parameter_date(prm_parameter character varying) RETURNS timestamp without time zone
    LANGUAGE plpgsql
    AS $$
declare var_return timestamp;
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select date_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_auth_get_parameter_decimal(prm_parameter character varying) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
declare var_return numeric(20,6);
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select decimal_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_auth_get_parameter_integer(prm_parameter character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare var_return integer;
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select integer_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_auth_get_parameter_string(prm_parameter character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare var_return varchar(250);
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select string_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_auth_get_parameter_uuid(prm_parameter character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
declare var_return uuid;
declare var_parameter varchar(20);
begin
  var_parameter := lower(trim(coalesce(prm_parameter, '')));
  var_return := coalesce((select uuid_value from auth_parameter where auth_parameter = var_parameter), null);
  return var_return;
end 
$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_attributeexists(prm_schema name, prm_typename name, prm_attributename name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.attributes
    where udt_schema = prm_schema and udt_name = prm_typename and attribute_name = prm_attributename), 0 );

  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_columnexists(prm_schema name, prm_tablename name, prm_columnname name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.columns
    where table_schema = prm_schema and table_name = prm_tablename and column_name = prm_columnname), 0 );

  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_domainexists(prm_schema name, prm_name name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.domains where domain_schema = prm_schema and domain_name = prm_name), 0 );

  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_dropfunction(prm_schema name, prm_name name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_nargs smallint;
  var_args oidvector;
  var_argmodes char[];
  var_continuar smallint;
  var_sql varchar(1024);
  var_tmparg varchar(100);
begin
  -- Elimina todas las funciones bajo el nombre prm_schema.prm_name

  var_sql := '';
  var_continuar := 1;
  while var_continuar = 1 loop
    var_nargs := null;
    var_args := null;
    -- obtener info de la funcion
    select a.pronargs, a.proargtypes, a.proargmodes
    into var_nargs, var_args, var_argmodes
    from pg_proc a inner join pg_namespace b on a.pronamespace = b.oid
    where a.proname = prm_name and b.nspname = prm_schema
    limit 1;
    if var_args is null then
      var_continuar := 0;
      exit;
    end if;
    -- raise notice 'Cant param %',var_nargs::varchar;
    -- se tiene la cantidad de argmentos y el array de los tipos de datos
    var_sql := 'drop function if exists ' || prm_schema::varchar || '.' || prm_name::varchar || '(';
    -- armar los parametros
    FOR i IN 1..var_nargs LOOP
      select b.nspname::varchar || '.' || a.typname
      into var_tmparg
      from pg_type a inner join pg_namespace b on a.typnamespace = b.oid
      where a.oid = var_args[i - 1];

      if var_argmodes is not null then
        if var_argmodes[i] = 'i' then
          var_tmparg := 'IN ' || var_tmparg;
        elsif var_argmodes[i] = 'o' then
          var_tmparg := 'OUT ' || var_tmparg;
        elsif var_argmodes[i] = 'b' then
          var_tmparg := 'INOUT ' || var_tmparg;
        end if;
      end if;

      var_sql := var_sql || var_tmparg  ;
      if i <> var_nargs then
        var_sql := var_sql || ', '  ;
      end if;
    END LOOP;

    var_sql := var_sql || ');';
    var_nargs := null;
    var_args := null;

    execute var_sql;

  end loop;

  return 1;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_tableexists(prm_schema name, prm_name name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.schemata as xa
  inner join information_schema.tables as xb on xa.schema_name = xb.table_schema
  where xa.schema_name = prm_schema and
  xb.table_type = 'BASE TABLE' and xb.table_name = prm_name), 0 );


  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_typeexists(prm_schema name, prm_typename name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.user_defined_types
    where user_defined_type_schema = prm_schema and user_defined_type_name = prm_typename), 0 );

  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION uf_dbadm_viewexists(prm_schema name, prm_name name) RETURNS integer
    LANGUAGE plpgsql
    AS $$

declare
  var_return smallint;
begin
  var_return := coalesce( (select count(*) from information_schema.views where table_schema = prm_schema and table_name = prm_name), 0 );

  return var_return;
end

$$;",db-base-modif.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.0.4.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.0.6.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.0.7.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.0.8.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.0.9.sql
"CREATE FUNCTION unaccent_string(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚ', 'eeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$_$;",opentheso_dist_4.1.sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
yearlv INTEGER;
ratiopassed numeric;

BEGIN

select sum(credits) / 145 into ratiopassed
from viewclasses
where studentid = $1 and gradeid < 10
group by studentid;

return ratiopassed;
END$_$;",2013-02-01%20Dump%20(Elijah).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
yearlv INTEGER;
ratiopassed numeric;

BEGIN

select sum(credits) / 145 into ratiopassed
from viewclasses
where studentid = $1 and gradeid < 10
group by studentid;

return ratiopassed;
END$_$;",2013-02-05%20Dump%20(Josh).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

unitspassed numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;





	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		--SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		--SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			--SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			--SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		--SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		--SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		--SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN

			--SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			--SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			--SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;



	DROP TABLE first5ahPass;

	DROP TABLE first4mstPass;

	DROP TABLE first5sspPass;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	

	RETURN round(unitspassed,4);	



END$_$;",2013-02-24%20Dump%20(Dan).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

unitspassed numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;





	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		--SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		--SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			--SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			--SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		--SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		--SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		--SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN

			--SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			--SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			--SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;



	DROP TABLE first5ahPass;

	DROP TABLE first4mstPass;

	DROP TABLE first5sspPass;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	

	RETURN round(unitspassed,4);	



END$_$;",2013-03-02%20Create%20(Matthew).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

unitspassed numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;





	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		--SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		--SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			--SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			--SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		--SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		--SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		--SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN

			--SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			--SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			--SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;



	DROP TABLE first5ahPass;

	DROP TABLE first4mstPass;

	DROP TABLE first5sspPass;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	

	RETURN round(unitspassed,4);	



END$_$;",2013-03-02%20Dump%20(Matthew).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

unitspassed numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;





	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		--SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		--SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			--SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			--SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		--SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		--SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		--SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN

			--SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			--SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			--SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;



	DROP TABLE first5ahPass;

	DROP TABLE first4mstPass;

	DROP TABLE first5sspPass;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	

	RETURN round(unitspassed,4);	



END$_$;",2013-03-03%2012.48a%20Dump%20(Adelen).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

unitspassed numeric DEFAULT 0;



BEGIN







	CREATE TEMPORARY TABLE first5ahPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE first4mstPass AS

		SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 4;



	CREATE TEMPORARY TABLE first5sspPass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 5;



	CREATE TEMPORARY TABLE majors AS 

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;



	CREATE TEMPORARY TABLE first3elePass AS

		SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10

		ORDER BY v.termid ASC

		LIMIT 3;





	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN

		--SELECT SUM(x * y) into ah FROM first5ahPass;

		SELECT SUM(y) into ahd FROM first5ahPass;

	END IF;



	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN

		--SELECT SUM(x * y) into mst FROM first4mstPass;

		SELECT SUM(y) into mstd FROM first4mstPass;



		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 

			--SELECT ns1_correction($1) into mst; 

			SELECT ns1_dcorrection($1) into mstd;

		END IF;

		

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 

			--SELECT ns2_correction($1) into mst; 

			SELECT ns2_dcorrection($1) into mstd;

		END IF;

		

	END IF;



	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN

		--SELECT SUM(x * y) into ssp FROM first5sspPass;

		SELECT SUM(y) into sspd FROM first5sspPass;

	END IF;



	IF (SELECT COUNT(*) FROM majors) <> 0 THEN

		--SELECT SUM(x * y) into maj FROM majors;

		SELECT SUM(y) into majd FROM majors;

	END IF;



	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN

		--SELECT SUM(x * y) into ele FROM first3elePass;

		SELECT SUM(y) into eled FROM first3elePass;



		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN

			--SELECT overcs197_correction($1) INTO ele;

			SELECT overcs197_dcorrection($1) INTO eled;

		END IF;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN

			--SELECT overMSEE_correction($1) INTO ele;

			SELECT overMSEE_dcorrection($1) INTO eled;

		END if;



		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN

			--SELECT overFE_correction($1) INTO ele;

			SELECT overFE_dcorrection($1) INTO eled; 

		END IF;

	END IF;



	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;



	DROP TABLE first5ahPass;

	DROP TABLE first4mstPass;

	DROP TABLE first5sspPass;

	DROP TABLE majors;

	DROP TABLE first3elePass;

	

	RETURN round(unitspassed,4);	



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION unitspassed(p_studentid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 
ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
unitspassed numeric DEFAULT 0;

BEGIN



	CREATE TEMPORARY TABLE first5ahPass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE first4mstPass AS
		SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.coursename <> 'math 1' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 4;

	CREATE TEMPORARY TABLE first5sspPass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 5;

	CREATE TEMPORARY TABLE majors AS 
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid < 10;

	CREATE TEMPORARY TABLE first3elePass AS
		SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'CSE197') AND v.gradeid < 10
		ORDER BY v.termid ASC
		LIMIT 3;


	IF (SELECT COUNT(*) FROM first5ahPass) <> 0 THEN
		--SELECT SUM(x * y) into ah FROM first5ahPass;
		SELECT SUM(y) into ahd FROM first5ahPass;
	END IF;

	IF (SELECT COUNT(*) FROM first4mstPass) <> 0 THEN
		--SELECT SUM(x * y) into mst FROM first4mstPass;
		SELECT SUM(y) into mstd FROM first4mstPass;

		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN 
			--SELECT ns1_correction($1) into mst; 
			SELECT ns1_dcorrection($1) into mstd;
		END IF;
		
		IF (SELECT COUNT(*) FROM first4mstPass WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN 
			--SELECT ns2_correction($1) into mst; 
			SELECT ns2_dcorrection($1) into mstd;
		END IF;
		
	END IF;

	IF (SELECT COUNT(*) FROM first5sspPass) <> 0 THEN
		--SELECT SUM(x * y) into ssp FROM first5sspPass;
		SELECT SUM(y) into sspd FROM first5sspPass;
	END IF;

	IF (SELECT COUNT(*) FROM majors) <> 0 THEN
		--SELECT SUM(x * y) into maj FROM majors;
		SELECT SUM(y) into majd FROM majors;
	END IF;

	IF (SELECT COUNT(*) FROM first3elePass) <> 0 THEN
		--SELECT SUM(x * y) into ele FROM first3elePass;
		SELECT SUM(y) into eled FROM first3elePass;

		IF (SELECT COUNT(*) FROM first3elePass WHERE v.domain = 'CSE197') > 2 THEN
			--SELECT overcs197_correction($1) INTO ele;
			SELECT overcs197_dcorrection($1) INTO eled;
		END IF;

		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'MSEE') > 2 THEN
			--SELECT overMSEE_correction($1) INTO ele;
			SELECT overMSEE_dcorrection($1) INTO eled;
		END if;

		IF (SELECT COUNT(*) FROM first3ele WHERE v.domain = 'FE') > 2 THEN
			--SELECT overFE_correction($1) INTO ele;
			SELECT overFE_dcorrection($1) INTO eled; 
		END IF;
	END IF;

	unitspassed = (ahd + mstd + sspd + majd + eled) / 145;

	DROP TABLE first5ahPass;
	DROP TABLE first4mstPass;
	DROP TABLE first5sspPass;
	DROP TABLE majors;
	DROP TABLE first3elePass;
	
	RETURN round(unitspassed,4);	

END$_$;",2013-02-05%20Dump%20(Elijah).sql
"CREATE FUNCTION unix_timestamp(timestamp with time zone) RETURNS integer     AS $_$ BEGIN  RETURN date_part('epoch', $1)::int; END; $_$     LANGUAGE plpgsql IMMUTABLE STRICT;",2.8.2_postgresql.sql
"CREATE FUNCTION upd_fixall() RETURNS void
    LANGUAGE plpgsql
    AS $$
	BEGIN
		PERFORM fixall_til(current_date);
	END;
$$;",dump.sql
"CREATE FUNCTION user_by_username(usr character varying) RETURNS registro_usuario
    LANGUAGE plpgsql
    AS $$
DECLARE
	result registro_usuario;
BEGIN 
	SELECT * into result FROM usuario u WHERE u.username = usr LIMIT 1;
	RETURN result;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION user_by_username(usr character varying) RETURNS registro_usuario
    LANGUAGE plpgsql
    AS $$
DECLARE
	result registro_usuario;
BEGIN 
	SELECT * into result FROM usuario u WHERE u.username = usr LIMIT 1;
	RETURN result;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION user_by_username(usr character varying) RETURNS registro_usuario
    LANGUAGE plpgsql
    AS $$
DECLARE
	result registro_usuario;
BEGIN 
	SELECT * into result FROM usuario u WHERE u.username = usr LIMIT 1;
	RETURN result;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION user_by_username(usr character varying) RETURNS registro_usuario
    LANGUAGE plpgsql
    AS $$
DECLARE
	result registro_usuario;
BEGIN 
	SELECT * into result FROM usuario u WHERE u.username = usr LIMIT 1;
	RETURN result;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION user_by_username(usr character varying) RETURNS registro_usuario
    LANGUAGE plpgsql
    AS $$
DECLARE
	result registro_usuario;
BEGIN 
	SELECT * into result FROM usuario u WHERE u.username = usr LIMIT 1;
	RETURN result;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION user_crypt_password(ppassword character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
declare

begin
  return crypt(ppassword, gen_salt('bf', 8));
end;
$$;",database_full.sql
"CREATE FUNCTION user_device_setting_retrieve(devname character varying, user_id integer) RETURNS userdevicesetting
    AS $$
declare
	r userdevicesetting%rowtype;
BEGIN
   SELECT * into r FROM userdevicesetting where deviceid IN ( select id from devices where strname=devname ) AND userid=user_id;
   return r;
   
END;

  $$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION user_is_in_role(_user_name character varying, _role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	declare
	retval boolean;
begin
-- per the roleprovider pattern, throw an exception if the role does not exist
if not exists(select null from roles where lower(role_name) = lower(_role_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified role does not exist.' using errcode='NOROL';
end if;
-- per the roleprovider pattern, throw an exception if the user does not exist
if not exists(select null from users where lower(user_name) = lower(_user_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified user does not exist.' using errcode='NOUSR';
end if;

select
	exists(
		select null
		from users as u
		inner join users_roles as ur
		on ur.user_id = u.user_id
		inner join roles as r
		on r.role_id = ur.role_id
		where
			lower(u.user_name) = lower(_user_name)
			and lower(u.application_name) =lower( _application_name)
			and lower(r.role_name) = lower( _role_name)
			and lower(r.application_name) = lower(_application_name)
		)
into retval;
return retval;
end;$$;",20151231%20karental_user.sql
"CREATE FUNCTION user_is_in_role(_user_name character varying, _role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	declare
	retval boolean;
begin
-- per the roleprovider pattern, throw an exception if the role does not exist
if not exists(select null from roles where lower(role_name) = lower(_role_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified role does not exist.' using errcode='NOROL';
end if;
-- per the roleprovider pattern, throw an exception if the user does not exist
if not exists(select null from users where lower(user_name) = lower(_user_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified user does not exist.' using errcode='NOUSR';
end if;

select
	exists(
		select null
		from users as u
		inner join users_roles as ur
		on ur.user_id = u.user_id
		inner join roles as r
		on r.role_id = ur.role_id
		where
			lower(u.user_name) = lower(_user_name)
			and lower(u.application_name) =lower( _application_name)
			and lower(r.role_name) = lower( _role_name)
			and lower(r.application_name) = lower(_application_name)
		)
into retval;
return retval;
end;$$;",20160222%20karental_user.sql
"CREATE FUNCTION user_is_in_role(_user_name character varying, _role_name character varying, _application_name character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
	declare
	retval boolean;
begin
-- per the roleprovider pattern, throw an exception if the role does not exist
if not exists(select null from roles where lower(role_name) = lower(_role_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified role does not exist.' using errcode='NOROL';
end if;
-- per the roleprovider pattern, throw an exception if the user does not exist
if not exists(select null from users where lower(user_name) = lower(_user_name) and lower(application_name) = lower(_application_name)) then
	raise exception 'The specified user does not exist.' using errcode='NOUSR';
end if;

select
	exists(
		select null
		from users as u
		inner join users_roles as ur
		on ur.user_id = u.user_id
		inner join roles as r
		on r.role_id = ur.role_id
		where
			lower(u.user_name) = lower(_user_name)
			and lower(u.application_name) =lower( _application_name)
			and lower(r.role_name) = lower( _role_name)
			and lower(r.application_name) = lower(_application_name)
		)
into retval;
return retval;
end;$$;",20160325%20karental_user.sql
"CREATE FUNCTION user_login(par_email character varying, par_password character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
    declare
      local_response text;
    begin
      select into local_response User_contacts.email
      from Users, User_contacts
      where User_contacts.email = par_email
      and Users.user_password = par_password;

      if local_response isnull then
        local_response = 'FAILED';
      else
        local_response = 'OK';
      end if;

      return local_response;
    end;
  $$;",foodcart.backup
"CREATE FUNCTION user_logon(plogin character varying, ppassword character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
declare
  cuser cursor(plogin varchar) is
    select
      u.*
    from
      conf_hall.users as u
    where
      u.login = plogin;
      
  xuser conf_hall.users%rowtype;
  xcheck boolean;
begin
  if plogin is null then
    raise exception using
      message = 'Вход запрещен'
      , detail = 'Не указано имя пользователя.';
  end if;

  open cuser(plogin);
  fetch cuser into xuser;
  close cuser;
  
  if xuser.id is null then
    raise exception using
      message = 'Вход запрещен'
      , detail = 'Пользователь с таким именем не найден.';
  end if;

  if xuser.locked then
    raise exception using
      message = 'Вход запрещен'
      , detail = 'Пользователь с таким именем заблокирован.';
  end if;
  
  xcheck := xuser.password = crypt(ppassword, xuser.password);
  if not xcheck then
    raise exception using
      message = 'Вход запрещен'
      , detail = 'Неверный пароль.';
  end if;
end;
$$;",database_full.sql
"CREATE FUNCTION user_production(integer) RETURNS SETOF type_team_production
    LANGUAGE plpgsql STABLE STRICT
    AS $_$declare
  user_production type_team_production;
  linha record;
  points0 real;
  points1 real;
  wus0 integer;
  wus1 integer;
  cur_batch_date timestamp;
begin

cur_batch_date := (select data from datas order by data desc limit 1);
points0 := coalesce((
  select pontos
  from usuarios
  inner join datas on usuarios.data = datas.data_serial
  where usuario = $1 and datas.data = (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (
        select cur_batch_date - interval '55 days 23 hour'
        )
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
), 0);
wus0 := coalesce((
  select wus
  from usuarios
  inner join datas on usuarios.data = datas.data_serial
  where usuario = $1 and datas.data = (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (
        select cur_batch_date - interval '55 days 23 hour'
        )
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
), 0);

for linha in
-- -----------------------------------
select pontos , wus, 'day', datas.data as d0
from usuarios inner join datas on usuarios.data = datas.data_serial
where usuario = $1 and datas.data in (
  select ymdhm from (
    select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
    from datas
    where data >= (select cur_batch_date - interval '55 days 1 hour')
    group by ymd
    ) as max
)
order by datas.data
-- -----------------------------------
loop
points1 := linha.pontos - points0;
points0 := linha.pontos;
wus1 := linha.wus - wus0;
wus0 := linha.wus;
  select f.points1, f.wus1, ""date"" into user_production
  from (select points1, wus1, linha.d0 as ""date"") as f;
  return next user_production;
end loop;
return;
end;
$_$;",fahstats.schema
"CREATE FUNCTION user_production(integer) RETURNS SETOF type_team_production
    LANGUAGE plpgsql STABLE STRICT
    AS $_$declare
  user_production type_team_production;
  linha record;
  points0 real;
  points1 real;
  wus0 integer;
  wus1 integer;
  cur_batch_date timestamp;
begin

cur_batch_date := (select data from datas order by data desc limit 1);
points0 := coalesce((
  select pontos
  from usuarios
  inner join datas on usuarios.data = datas.data_serial
  where usuario = $1 and datas.data = (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (
        select cur_batch_date - interval '55 days 23 hour'
        )
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
), 0);
wus0 := coalesce((
  select wus
  from usuarios
  inner join datas on usuarios.data = datas.data_serial
  where usuario = $1 and datas.data = (
    select ymdhm from (
      select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
      from datas
      where date_trunc('day', data) < (
        select cur_batch_date - interval '55 days 23 hour'
        )
      group by ymd
      order by ymd desc
      limit 1
      ) as max
  )
), 0);

for linha in
-- -----------------------------------
select pontos , wus, 'day', datas.data as d0
from usuarios inner join datas on usuarios.data = datas.data_serial
where usuario = $1 and datas.data in (
  select ymdhm from (
    select date_trunc ('day', datas.data)::date as ymd, max (data) as ymdhm
    from datas
    where data >= (select cur_batch_date - interval '55 days 1 hour')
    group by ymd
    ) as max
)
order by datas.data
-- -----------------------------------
loop
points1 := linha.pontos - points0;
points0 := linha.pontos;
wus1 := linha.wus - wus0;
wus0 := linha.wus;
  select f.points1, f.wus1, ""date"" into user_production
  from (select points1, wus1, linha.d0 as ""date"") as f;
  return next user_production;
end loop;
return;
end;
$_$;",ks2.schema
"CREATE FUNCTION user_total_answers(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM answers
    INNER JOIN publications
      ON answers.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",dbm
"CREATE FUNCTION user_total_answers(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM answers
    INNER JOIN publications
      ON answers.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION user_total_comments(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM comments
    INNER JOIN publications
      ON comments.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",dbm
"CREATE FUNCTION user_total_comments(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM comments
    INNER JOIN publications
      ON comments.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION user_total_questions(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM questions
    INNER JOIN publications
      ON questions.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",dbm
"CREATE FUNCTION user_total_questions(puser_id integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE questions_count INTEGER;
BEGIN
  SELECT COUNT(*) FROM questions
    INNER JOIN publications
      ON questions.publicationid = publications.publicationid
  WHERE publications.userid = puser_id
  INTO questions_count;

  IF questions_count is null THEN
    questions_count := 0;
  END IF;

  return questions_count;
END
$$;",lbaw_v2.sql
"CREATE FUNCTION usp_set_tiempo() RETURNS integer
    LANGUAGE plpgsql
    AS $$
begin 


return 0;
end;
$$;",efix-01-07-14.backup
"CREATE FUNCTION usp_set_tiempo() RETURNS integer
    LANGUAGE plpgsql
    AS $$
declare fi date;
declare ff date;
begin 

SELECT '2014-06-01 00:00:00' INTO fi;
SELECT '2014-07-31 00:00:00' INTO ff;
 
return 0;
end;
$$;",efix-01-07-14.backup
"CREATE FUNCTION utmzone(geometry) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
 DECLARE
     geomgeog geometry;
     zone int;
     pref int;

 BEGIN
     geomgeog:= ST_Transform($1,4326);

     IF (ST_Y(geomgeog))>0 THEN
        pref:=32600;
     ELSE
        pref:=32700;
     END IF;

     zone:=floor((ST_X(geomgeog)+180)/6)+1;

     RETURN zone+pref;
 END;
 $_$;",vkdb-schema.sql
"CREATE FUNCTION uuid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	output character varying(255);
BEGIN
	SELECT md5(random()::text || clock_timestamp()::text)::uuid INTO output;
	output = replace(output,'-','');
	RETURN output;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION uuid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	output character varying(255);
BEGIN
	SELECT md5(random()::text || clock_timestamp()::text)::uuid INTO output;
	output = replace(output,'-','');
	RETURN output;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION uuid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	output character varying(255);
BEGIN
	SELECT md5(random()::text || clock_timestamp()::text)::uuid INTO output;
	output = replace(output,'-','');
	RETURN output;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION uuid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	output character varying(255);
BEGIN
	SELECT md5(random()::text || clock_timestamp()::text)::uuid INTO output;
	output = replace(output,'-','');
	RETURN output;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION uuid() RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	output character varying(255);
BEGIN
	SELECT md5(random()::text || clock_timestamp()::text)::uuid INTO output;
	output = replace(output,'-','');
	RETURN output;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION uuid_generate() RETURNS uuid
    LANGUAGE plpgsql COST 5
    AS $$declare
  l_result uuid;
begin
  -- random UUID generation 
  select md5(random()::text || clock_timestamp()::text)::uuid into l_result;
  return l_result;
end;
$$;",metadict.sql
"CREATE FUNCTION val(character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
         return  ltrim($1)::int;
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION valid_version_time(dt timestamp without time zone, stypename character varying, uid integer) RETURNS boolean
    AS $$
 
DECLARE
    t timestamp without time zone;
BEGIN
    if uid=-1 then
  select modifytime into t from objtimestamp where typename=stypename;
 else
  select modifytime into t from objtimestamp where typename=stypename and userid=uid;
 end if;
 
    if(t>dt) then 
 RETURN true;
    else
 return false;
    end if;
EXCEPTION
    WHEN OTHERS THEN 
 RETURN false;    
END;
$$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION validar_email(email_in character varying, OUT username_out character varying, OUT flag boolean, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$     
	declare xusu_semail varchar(100);
	declare xusu_nomusuario varchar(100);
	
	begin
		numerror := 0;
		msjerror := ' ';
 
		select
			nomusuario   
		into
			xusu_nomusuario
		from
			usuario
		where
			(email) = email_in;
		IF FOUND THEN
			username_out := xusu_nomusuario;
			flag=TRUE;
		ELSE
			flag=FALSE;
			numerror := '1';
			msjerror := 'Email no encontrado.';
		end if;
	end;     
$$;",3-2-15.sql
"CREATE FUNCTION validar_email(email_in character varying, OUT username_out character varying, OUT flag boolean, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$     
	declare xusu_semail varchar(100);
	declare xusu_nomusuario varchar(100);
	
	begin
		numerror := 0;
		msjerror := ' ';
 
		select
			nomusuario   
		into
			xusu_nomusuario
		from
			usuario
		where
			(email) = email_in;
		IF FOUND THEN
			username_out := xusu_nomusuario;
			flag=TRUE;
		ELSE
			flag=FALSE;
			numerror := '1';
			msjerror := 'Email no encontrado.';
		end if;
	end;     
$$;",bkup.sql
"CREATE FUNCTION validar_usuario(username_in character varying, OUT id_out integer, OUT email_out character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
	declare xusu_snomusuario varchar(100);
	declare xusu_idusuario integer;
	declare xusu_semail 	 varchar(100);

begin
	numerror :=0;
	msjerror :=' ';

	select 
		email,
		idusuario
	into
		xusu_semail,
		xusu_idusuario
	from 
		usuario
	where
		nomusuario = username_in;
	IF FOUND THEN
		email_out := xusu_semail;
		id_out := xusu_idusuario;
	ELSE
	numerror := '1';
	msjerror := 'Usuario no encontrado';
	END IF;
	end;

$$;",3-2-15.sql
"CREATE FUNCTION validar_usuario(username_in character varying, OUT id_out integer, OUT email_out character varying, OUT numerror character varying, OUT msjerror character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
	declare xusu_snomusuario varchar(100);
	declare xusu_idusuario integer;
	declare xusu_semail 	 varchar(100);

begin
	numerror :=0;
	msjerror :=' ';

	select 
		email,
		idusuario
	into
		xusu_semail,
		xusu_idusuario
	from 
		usuario
	where
		nomusuario = username_in;
	IF FOUND THEN
		email_out := xusu_semail;
		id_out := xusu_idusuario;
	ELSE
	numerror := '1';
	msjerror := 'Usuario no encontrado';
	END IF;
	end;

$$;",bkup.sql
"CREATE FUNCTION validate_cuit(cuit character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	cuit_array text[];
	serie integer[];
	aux integer;
	result boolean;
BEGIN
	result = false;
	--Varifico que el cuit no sea nulo
	IF (cuit IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un cuit. Solicitud rechazada';
	ELSE
		--Verifico que el cuit este bien formado
		IF (cuit ~ '^(\d){2}-(\d){8}-(\d)|(\d){11}') THEN
			--Elimino los '-' si es necesario
			IF (char_length(cuit) = 13) THEN
				cuit = regexp_replace(cuit,'-','','g');
			END IF;
			cuit_array = regexp_split_to_array(cuit,'');
			serie = array[5,4,3,2,7,6,5,4,3,2];
			aux = 0;
			FOR i IN 1..10 LOOP
				aux = aux + cuit_array[i]::integer * serie[i];
			END LOOP;
			aux = 11 - (aux % 11);
			IF (aux = 11) THEN
				aux = 0;
			ELSE
				IF (aux = 10) THEN
					aux = 9;
				END IF;
			END IF;
			IF (aux = cuit_array[11]::integer) THEN 
				result = true;
			END IF;
		ELSE
			RAISE EXCEPTION 'CUIT con formato incorrecto. Solicitud rechazada.';
		END IF;
	END IF;
	return result;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION validate_cuit(cuit character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	cuit_array text[];
	serie integer[];
	aux integer;
	result boolean;
BEGIN
	result = false;
	--Varifico que el cuit no sea nulo
	IF (cuit IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un cuit. Solicitud rechazada';
	ELSE
		--Verifico que el cuit este bien formado
		IF (cuit ~ '^(\d){2}-(\d){8}-(\d)|(\d){11}') THEN
			--Elimino los '-' si es necesario
			IF (char_length(cuit) = 13) THEN
				cuit = regexp_replace(cuit,'-','','g');
			END IF;
			cuit_array = regexp_split_to_array(cuit,'');
			serie = array[5,4,3,2,7,6,5,4,3,2];
			aux = 0;
			FOR i IN 1..10 LOOP
				aux = aux + cuit_array[i]::integer * serie[i];
			END LOOP;
			aux = 11 - (aux % 11);
			IF (aux = 11) THEN
				aux = 0;
			ELSE
				IF (aux = 10) THEN
					aux = 9;
				END IF;
			END IF;
			IF (aux = cuit_array[11]::integer) THEN 
				result = true;
			END IF;
		ELSE
			RAISE EXCEPTION 'CUIT con formato incorrecto. Solicitud rechazada.';
		END IF;
	END IF;
	return result;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION validate_cuit(cuit character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	cuit_array text[];
	serie integer[];
	aux integer;
	result boolean;
BEGIN
	result = false;
	--Varifico que el cuit no sea nulo
	IF (cuit IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un cuit. Solicitud rechazada';
	ELSE
		--Verifico que el cuit este bien formado
		IF (cuit ~ '^(\d){2}-(\d){8}-(\d)|(\d){11}') THEN
			--Elimino los '-' si es necesario
			IF (char_length(cuit) = 13) THEN
				cuit = regexp_replace(cuit,'-','','g');
			END IF;
			cuit_array = regexp_split_to_array(cuit,'');
			serie = array[5,4,3,2,7,6,5,4,3,2];
			aux = 0;
			FOR i IN 1..10 LOOP
				aux = aux + cuit_array[i]::integer * serie[i];
			END LOOP;
			aux = 11 - (aux % 11);
			IF (aux = 11) THEN
				aux = 0;
			ELSE
				IF (aux = 10) THEN
					aux = 9;
				END IF;
			END IF;
			IF (aux = cuit_array[11]::integer) THEN 
				result = true;
			END IF;
		ELSE
			RAISE EXCEPTION 'CUIT con formato incorrecto. Solicitud rechazada.';
		END IF;
	END IF;
	return result;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION validate_cuit(cuit character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	cuit_array text[];
	serie integer[];
	aux integer;
	result boolean;
BEGIN
	result = false;
	--Varifico que el cuit no sea nulo
	IF (cuit IS NULL) THEN
		RAISE EXCEPTION 'Debe ingresar un cuit. Solicitud rechazada';
	ELSE
		--Verifico que el cuit este bien formado
		IF (cuit ~ '^(\d){2}-(\d){8}-(\d)|(\d){11}') THEN
			--Elimino los '-' si es necesario
			IF (char_length(cuit) = 13) THEN
				cuit = regexp_replace(cuit,'-','','g');
			END IF;
			cuit_array = regexp_split_to_array(cuit,'');
			serie = array[5,4,3,2,7,6,5,4,3,2];
			aux = 0;
			FOR i IN 1..10 LOOP
				aux = aux + cuit_array[i]::integer * serie[i];
			END LOOP;
			aux = 11 - (aux % 11);
			IF (aux = 11) THEN
				aux = 0;
			ELSE
				IF (aux = 10) THEN
					aux = 9;
				END IF;
			END IF;
			IF (aux = cuit_array[11]::integer) THEN 
				result = true;
			END IF;
		ELSE
			RAISE EXCEPTION 'CUIT con formato incorrecto. Solicitud rechazada.';
		END IF;
	END IF;
	return result;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION validateemail(email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
	IF (email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9-]+[.][A-Za-z]+$') THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END
$_$;",backup%2003-12(1).sql
"CREATE FUNCTION validateemail(email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
	IF (email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9-]+[.][A-Za-z]+$') THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END
$_$;",backup%2007-12.sql
"CREATE FUNCTION validateemail(email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
	IF (email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9-]+[.][A-Za-z]+$') THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END
$_$;",backup%2008-12.sql
"CREATE FUNCTION validateemail(email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
	IF (email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9-]+[.][A-Za-z]+$') THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END
$_$;",backup%2009-12(2).sql
"CREATE FUNCTION validateemail(email character varying) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
BEGIN
	IF (email !~ '^[A-Za-z0-9._%-]+@[A-Za-z0-9-]+[.][A-Za-z]+$') THEN
		RETURN FALSE;
	ELSE
		RETURN TRUE;
	END IF;
END
$_$;",backup%2009-12.sql
"CREATE FUNCTION validatepart(text, text, text, text DEFAULT NULL::text, boolean DEFAULT false) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$DECLARE

	pItemNumber 	ALIAS FOR $1;

	pRevision 	ALIAS FOR $2;

	pSerialNumber 	ALIAS FOR $3;

	pCode		ALIAS FOR $4;

	pAllowInactive	ALIAS FOR $5;

	_viewpart	RECORD;

	_code		TEXT;

BEGIN

	PERFORM (SELECT checkpriv('validatepart'));



	SELECT 	part_id,

		part_active

	INTO _viewpart

	FROM viewpart

	WHERE item_number = pItemNumber 

	AND part_serialnumber = pSerialNumber 

	AND part_rev = pRevision;



	IF pCode IS NULL THEN

		_code := '';

	ELSE

		_code := ' ' || pCode;

	END IF;



	IF _viewpart.part_id IS NULL THEN

		RAISE EXCEPTION 'validatepart:% Item Number % Revision % Serial Number % Not Found in AeryonMES.', 

			_code,

			pItemNumber, 

			pRevision, 

			pSerialNumber;

	ELSIF _viewpart.part_active = false AND pAllowInactive = false THEN

		RAISE EXCEPTION 'validatepart:% Item Number % Revision % Serial Number % Is Inactive.', 

			_code,

			pItemNumber, 

			pRevision, 

			pSerialNumber;

	END IF;



	RETURN true;

END;



	$_$;",ames_dev.backup
"CREATE FUNCTION valorar_idresultat(id_resultat bigint) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
	sql1 text;
	ret varchar :='';
	id_provatecnica bigint;
	id_analitica bigint;
	id_pacient bigint;
	res varchar;
	rec record;
	trobat boolean :=false;
BEGIN
	sql1 := 'SELECT * FROM  resultats WHERE idresultat = ' || id_resultat || ';';
	
	trobat := false;
	FOR rec IN EXECUTE(sql1) LOOP
		trobat          := true;
		id_provatecnica := rec.idprovatecnica;
		id_analitica    := rec.idanalitica;
		res             := rec.resultats;
	END LOOP;
	
	IF NOT trobat THEN
		return '-5';
	END IF;	
	
	sql1 := 'SELECT idpacient FROM analitiques WHERE idanalitica = ' || id_analitica || ';';
	
	trobat := False;	
	FOR rec IN EXECUTE(sql1) LOOP
		trobat := True;
		id_pacient := rec.idpacient;
	END LOOP;
	
	IF NOT trobat THEN
		return '-6';
	END IF;
	
	ret := determina_resultat(id_provatecnica,id_pacient,res);
	
RETURN ret;
	
EXCEPTION 
	WHEN unique_violation THEN return '-1'; 
	WHEN foreign_key_violation THEN return '-2'; 
	WHEN not_null_violation THEN return '-3';
	WHEN others THEN return '-4'; 
END;
$$;",lab_clinic.sql
"CREATE FUNCTION valormedio(p_produtoid integer) RETURNS double precision
    LANGUAGE plpgsql
    AS $$
DECLARE
    v_media double precision;

BEGIN

SELECT AVG(valorunitario) INTO v_media
  FROM estoquemovimento 
 WHERE operacao = 1 
   AND produtoid = p_produtoid;

RETURN v_media;

END;
$$;",almoxarifado.sql
"CREATE FUNCTION vencio(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION vencio(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION vencio(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION vencio(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION vencio(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION verifica_appartenenza(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	a INTEGER;
BEGIN
	SELECT COUNT(*) INTO a FROM conto WHERE userid=$1 AND numero=$2;
	IF a = 1 THEN
		RETURN 1;
	ELSE
		RETURN 0;
	END IF;
END;
$_$;",dump.sql
"CREATE FUNCTION verificar_clan(name text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
	BEGIN
		IF(select nombre FROM clan WHERE nombre=$1)=$1 THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;
$_$;",Postgres.sql
"CREATE FUNCTION verificar_cliente_termino_de_pagar_su_credito(_id_credito bigint) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
  _credito_pagado boolean := false;
  _cantidad_registro_totales integer := 0;
  _cantidad_registro_pagados integer := 0;
BEGIN
	SELECT count(*) INTO _cantidad_registro_totales
	FROM plan_pagos
	WHERE id_credito = _id_credito;

	SELECT count(*) INTO _cantidad_registro_pagados
	FROM plan_pagos
	WHERE id_credito = _id_credito
	AND pagado = true ;

	IF _cantidad_registro_totales =  _cantidad_registro_pagados THEN
		_credito_pagado = true;
	ELSE
		_credito_pagado = false;
	END IF;
	
	RETURN _credito_pagado;
END $$;",creditosDBv5_schema.sql
"CREATE FUNCTION verificar_email(mail text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$	BEGIN
		IF(select email FROM jugador WHERE email=$1)=$1 THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
	END;$_$;",Postgres.sql
"CREATE FUNCTION verificar_existencia_rom(character varying, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	CONTAR INTEGER;
	A INTEGER;
BEGIN	
	CONTAR := COUNT(descripcion) FROM rom WHERE rom.descripcion = $1 and rom.tipo = $2;

	IF CONTAR = 0 THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION verificar_particiapnte_sala(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	CONTAR INTEGER;
BEGIN	
	CONTAR := COUNT(participantes.id) from participantes where participantes.participante = $1;
	IF CONTAR!=0 THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION verificar_particiapnte_sala(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
	CONTAR INTEGER;
BEGIN	
	CONTAR := COUNT(participantes.id) from participantes where participantes.participante = $1 and participantes.idrom = $2;
	IF CONTAR!=0 THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION verificar_participante_sala(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
	CONTAR INTEGER;
BEGIN	
	CONTAR := COUNT(participantes.id) from participantes where participantes.participante = $1 and participantes.idrom = $2;
	IF CONTAR!=0 THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
$_$;",todo.sql
"CREATE FUNCTION verificar_persona_existe_en_firmas_contrato(_id_persona bigint) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
	_cantidad_personas_encontradas integer := 0;
BEGIN
	SELECT count(*) INTO _cantidad_personas_encontradas 
	FROM firmas_contratos
	WHERE id_persona = _id_persona;
	
	RETURN 	_cantidad_personas_encontradas;
END
$$;",creditosDBv5_schema.sql
"CREATE FUNCTION verificar_usuario(id text, pass text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
BEGIN
		IF (select contraseña FROM jugador WHERE id_jugador=$1)=$2 THEN
			RETURN TRUE;
		ELSE
			RETURN FALSE;
		END IF;
END;
$_$;",Postgres.sql
"CREATE FUNCTION verificar_usuario(nick text, pass text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  registro record;
  retorno INTEGER;
BEGIN  
  SELECT * INTO registro FROM empleado WHERE nickname=$1;
  IF NOT FOUND THEN
  	-- significa que el usuario no existe
    retorno:=-2;
  END IF;
  IF FOUND THEN
  	IF ( registro.contrasenia <> $2 )THEN
    	-- significa que el password es incorrecto
        retorno:=-1;
    ELSIF (registro.contrasenia = $2) THEN
    	-- significa que el registro del usuario fue un exito
    	retorno:= 0;        
    END IF;
  END IF;
  RETURN retorno;	
END;
$_$;",bditv
"CREATE FUNCTION verificar_vencimiento(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2003-12(1).sql
"CREATE FUNCTION verificar_vencimiento(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2007-12.sql
"CREATE FUNCTION verificar_vencimiento(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2008-12.sql
"CREATE FUNCTION verificar_vencimiento(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12(2).sql
"CREATE FUNCTION verificar_vencimiento(fecha date) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
DECLARE
	
BEGIN 
	IF (fecha > now()::date) THEN
		RETURN TRUE;
	ELSE
		RETURN FALSE;
	END IF;
END;
$$;",backup%2009-12.sql
"CREATE FUNCTION verifier_connexion(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$	
declare f_login alias for $1;
	declare f_password alias for $2;
	declare id integer;
	declare retour integer;
begin
	select into id idadmin from admin where nomadmin=f_login and mpadmin=f_password;
	if not found
	then
	  retour=0;
	else
	  retour=1;
	end if;
	return retour;
end;
$_$;",dumpProjetWeb.backup
"CREATE FUNCTION verifier_connexion(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare f_login alias for $1;
	declare f_password alias for $2;
	declare id integer;
	declare retour integer;
begin
	select into id id_gt_admin from gt_admin where login=f_login and password=f_password;
	if not found
	then
	  retour=0;
	else
	  retour=1;
	end if;
	return retour;
end;
$_$;",projet_cinema_dump.txt
"CREATE FUNCTION view_nomp_telnetinfo_retrieve(dt timestamp without time zone, stypename character varying, uid integer, funcname character varying) RETURNS SETOF nomp_telnetinfoview
    AS $$
declare
	r nomp_telnetinfoview%rowtype;
	t timestamp without time zone;
	ispublic integer;
BEGIN		
	select c.count into ispublic from (select count(a.id) as count from (select user2role.roleid as id from ""user"",user2role where ""user"".id=uid and ""user"".id =user2role.userid) as a where a.id in (select role2function.roleid as id from role2function,""function"" where ""function"".sidname=funcname and ""function"".id=role2function.functionid)) as c;
        select modifytime into t from objtimestamp where typename=stypename;
	if t is null or t>dt then
		for r in SELECT * FROM nomp_telnetinfoview where userid=uid loop
			if ispublic>0 then 
				select a.count into r.iRefCount from (select count(id) as count from devicesetting where username=r.STRuseRnaMe and UserPassword=r.STRpAssWD) as a;								
			else
				select a.count into r.iRefCount from (select count(id) as count from userdevicesetting where TeLNetUserName=r.STRuseRnaMe and TeLNetPwD=r.STRpAssWD) as a;								
			end if;			
			return next r;
		end loop;	
	End IF;
END;

  $$
    LANGUAGE plpgsql;",ws3.sql
"CREATE FUNCTION white_is_null(att_val character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF CHAR_LENGTH(TRIM(att_val)) = 0 THEN
	
		RETURN null::VARCHAR;
	END IF;

	RETURN TRIM(att_val)::VARCHAR;
		
END;
$$;",back.sql
"CREATE FUNCTION x_decrementtermid(p_termid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$DECLARE
retval INTEGER;
BEGIN

IF ($1 % 10 = 1) THEN
	retval = $1 / 10;
	retval = retval - 1;
	retval = retval * 10;
	retval = retval + 3;	
ELSE return $1 - 1;
END IF;
return retval;

END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION x_iod_perclass2(p_classid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
iod NUMERIC;
j NUMERIC;
k NUMERIC;

BEGIN



/* CREATE TEMPORARY TABLE affectedstudents ON COMMIT DROP AS
		SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1; */
			
	IF (SELECT count(*) FROM (SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1) as z) > 9 THEN
			
		/* CREATE TEMPORARY TABLE topten AS
			SELECT gradeid 
			FROM (SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1;) as z
			ORDER BY xcwa69(affectedstudents.studentid, x_decrementtermid(affectedstudents.termid)) ASC
			LIMIT 10;

		CREATE TEMPORARY TABLE lastten AS
			SELECT gradeid 
			FROM (SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1;) as z
			ORDER BY xcwa69(affectedstudents.studentid, x_decrementtermid(affectedstudents.termid)) DESC
			LIMIT 10; */
			
		SELECT count(*) into j
		FROM (SELECT gradeid 
			FROM (SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1) as z
			ORDER BY xcwa69(z.studentid, x_decrementtermid(z.termid)) ASC
			LIMIT 10) as z 
		WHERE gradeid <= 9;

		SELECT count(*) into k
		FROM (SELECT gradeid 
			FROM (SELECT grades.gradeid, s.studentid, terms.termid
			FROM students s
			JOIN studentterms USING (studentid)
			JOIN studentclasses USING (studenttermid)
			JOIN terms USING (termid)
			JOIN grades USING (gradeid)
			JOIN classes USING (classid)
			JOIN courses USING (courseid)
			WHERE classid = $1) as z
			ORDER BY xcwa69(z.studentid, x_decrementtermid(z.termid)) DESC
			LIMIT 10) as z
		WHERE gradeid <=9;
		
		iod = (j-k)/10;
		/* DROP TABLE affectedstudents;
		DROP TABLE topten;
		DROP TABLE lastten; */
		
		return round(iod, 1);
        

		ELSE 
		/* DROP TABLE affectedstudents; */
		return 100;
	END IF;
	
END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 



ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH

ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH

mst numeric DEFAULT 0;

mstf numeric DEFAULT 0;

ssp numeric DEFAULT 0;

sspf numeric DEFAULT 0;

maj numeric DEFAULT 0;

ele numeric DEFAULT 0;

elef numeric DEFAULT 0;

ahd numeric DEFAULT 0; -- [SUM] units of passing AH

ahdf numeric DEFAULT 0; -- [SUM] units of failed AH

mstd numeric DEFAULT 0;

mstdf numeric DEFAULT 0;

sspd numeric DEFAULT 0;

sspdf numeric DEFAULT 0;

majd numeric DEFAULT 0;

eled numeric DEFAULT 0;

eledf numeric DEFAULT 0;

cwa numeric DEFAULT 0;

numer numeric DEFAULT 0;

denom numeric DEFAULT 0;



BEGIN

	

	--first 5 ah numer

	SELECT COALESCE(SUM(x*y),0) into ah FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 5) as sss;



	--first 5 ah denom

	SELECT COALESCE(SUM(y),0) into ahd FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 5) as sss;



	--ah fail numer

	SELECT COALESCE(SUM(x*y), 0) into ahf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--ah fail denom

	SELECT COALESCE(SUM(y), 0) into ahdf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--first 4 mst numer

	SELECT COALESCE(SUM(x*y), 0) into mst FROM

	(SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 4) as sss;



	--first 4 mst denom

	SELECT COALESCE(SUM(y), 0) into mstd FROM

	(SELECT v.gradevalue as x, v.credits as y, v.coursename

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 4) as sss;



	--ns1 and ns2 corrections

	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename

								FROM viewclasses v 

								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2

								ORDER BY v.termid ASC

								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN

		SELECT xns1_correction($1, $2) into mst;

		SELECT xns1_dcorrection($1, $2) into mstd;

	ELSE 

		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename

								FROM viewclasses v 

								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2

								ORDER BY v.termid ASC

								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN

		SELECT xns2_correction($1, $2) into mst;

		SELECT xns2_dcorrection($1, $2) into mstd;

		END IF;

	END IF;



	--mst fails numer

	SELECT COALESCE(SUM(x*y), 0) into mstf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--mst fails denom

	SELECT COALESCE(SUM(y), 0) into mstdf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--first 5 ssp numer

	SELECT COALESCE(SUM(x*y), 0) into ssp FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 5) as sss;



	--first 5 ssp denom

	SELECT COALESCE(SUM(y), 0) into sspd FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 5) as sss;



	--ssp fails numer

	SELECT COALESCE(SUM(x*y), 0) into sspf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--ssp fails denom

	SELECT COALESCE(SUM(y), 0) into sspdf FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--maj pass+fail numer

	SELECT COALESCE(SUM(x*y), 0) into maj FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;



	--maj pass+fail denom

	SELECT COALESCE(SUM(y), 0) into majd FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v 

		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;



	--first 3 ele numer

	SELECT COALESCE(SUM(x*y), 0) into ele FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 3) as sss;

	

	--first 3 ele denom

	SELECT COALESCE(SUM(y), 0) into eled FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2

		ORDER BY v.termid ASC

		LIMIT 3) as sss;



	--overflowing electives correction

	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain

								FROM viewclasses v

								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2

								ORDER BY v.termid ASC

								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN

		SELECT xovercs197_correction($1, $2) INTO ele;

		SELECT xovercs197_dcorrection($1, $2) INTO eled;

	ELSE

		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain

									FROM viewclasses v

									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2

									ORDER BY v.termid ASC

									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN

			SELECT xovermsee_correction($1, $2) INTO ele;

			SELECT xovermsee_dcorrection($1, $2) INTO eled;

		ELSE

		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain

									FROM viewclasses v

									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2

									ORDER BY v.termid ASC

									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN

			SELECT xoverfe_correction($1, $2) INTO ele;

			SELECT xoverfe_dcorrection($1, $2) INTO eled;

		END IF;

		END IF;

	END IF;



	--ele fails numer

	SELECT COALESCE(SUM(x*y),0) into elef FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	--ele fails denom

	SELECT COALESCE(SUM(y),0) into elef FROM

	(SELECT v.gradevalue as x, v.credits as y

		FROM viewclasses v

		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;



	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);

	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);

	IF denom = 0 THEN RETURN 0; END IF;

	cwa = numer / denom;



	RETURN round(cwa,4);	





END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xoverMSEE_correction($1, $2) INTO ele;
			SELECT xoverMSEE_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverFE_correction($1, $2) INTO ele;
			SELECT xoverFE_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xoverMSEE_correction($1, $2) INTO ele;
			SELECT xoverMSEE_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverFE_correction($1, $2) INTO ele;
			SELECT xoverFE_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid < $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xoverMSEE_correction($1, $2) INTO ele;
			SELECT xoverMSEE_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverFE_correction($1, $2) INTO ele;
			SELECT xoverFE_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid < $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xovermsee_correction($1, $2) INTO ele;
			SELECT xovermsee_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverfe_correction($1, $2) INTO ele;
			SELECT xoverfe_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xovermsee_correction($1, $2) INTO ele;
			SELECT xovermsee_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverfe_correction($1, $2) INTO ele;
			SELECT xoverfe_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xovermsee_correction($1, $2) INTO ele;
			SELECT xovermsee_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverfe_correction($1, $2) INTO ele;
			SELECT xoverfe_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xovermsee_correction($1, $2) INTO ele;
			SELECT xovermsee_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverfe_correction($1, $2) INTO ele;
			SELECT xoverfe_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE 

ah numeric DEFAULT 0; -- [SUM] (units*grade) of passing AH
ahf numeric DEFAULT 0; -- [SUM] (units*grade) of failed AH
mst numeric DEFAULT 0;
mstf numeric DEFAULT 0;
ssp numeric DEFAULT 0;
sspf numeric DEFAULT 0;
maj numeric DEFAULT 0;
ele numeric DEFAULT 0;
elef numeric DEFAULT 0;
ahd numeric DEFAULT 0; -- [SUM] units of passing AH
ahdf numeric DEFAULT 0; -- [SUM] units of failed AH
mstd numeric DEFAULT 0;
mstdf numeric DEFAULT 0;
sspd numeric DEFAULT 0;
sspdf numeric DEFAULT 0;
majd numeric DEFAULT 0;
eled numeric DEFAULT 0;
eledf numeric DEFAULT 0;
cwa numeric DEFAULT 0;
numer numeric DEFAULT 0;
denom numeric DEFAULT 0;

BEGIN
	
	--first 5 ah numer
	SELECT COALESCE(SUM(x*y),0) into ah FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ah denom
	SELECT COALESCE(SUM(y),0) into ahd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'AH' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ah fail numer
	SELECT COALESCE(SUM(x*y), 0) into ahf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ah fail denom
	SELECT COALESCE(SUM(y), 0) into ahdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'AH' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 4 mst numer
	SELECT COALESCE(SUM(x*y), 0) into mst FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--first 4 mst denom
	SELECT COALESCE(SUM(y), 0) into mstd FROM
	(SELECT v.gradevalue as x, v.credits as y, v.coursename
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 4) as sss;

	--ns1 and ns2 corrections
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) > 2 THEN
		SELECT xns1_correction($1, $2) into mst;
		SELECT xns1_dcorrection($1, $2) into mstd;
	ELSE 
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename
								FROM viewclasses v 
								WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 4) as sss WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) > 2 THEN
		SELECT xns2_correction($1, $2) into mst;
		SELECT xns2_dcorrection($1, $2) into mstd;
		END IF;
	END IF;

	--mst fails numer
	SELECT COALESCE(SUM(x*y), 0) into mstf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--mst fails denom
	SELECT COALESCE(SUM(y), 0) into mstdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--first 5 ssp numer
	SELECT COALESCE(SUM(x*y), 0) into ssp FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--first 5 ssp denom
	SELECT COALESCE(SUM(y), 0) into sspd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 5) as sss;

	--ssp fails numer
	SELECT COALESCE(SUM(x*y), 0) into sspf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ssp fails denom
	SELECT COALESCE(SUM(y), 0) into sspdf FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND v.domain = 'SSP' AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--maj pass+fail numer
	SELECT COALESCE(SUM(x*y), 0) into maj FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--maj pass+fail denom
	SELECT COALESCE(SUM(y), 0) into majd FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v 
		WHERE v.studentid = $1 AND v.domain = 'MAJ' AND v.gradeid <= 11 AND v.termid <= $2) as sss;

	--first 3 ele numer
	SELECT COALESCE(SUM(x*y), 0) into ele FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;
	
	--first 3 ele denom
	SELECT COALESCE(SUM(y), 0) into eled FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
		ORDER BY v.termid ASC
		LIMIT 3) as sss;

	--overflowing electives correction
	IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
								FROM viewclasses v
								WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
								ORDER BY v.termid ASC
								LIMIT 3) as sss WHERE sss.domain = 'C197') > 2 THEN
		SELECT xovercs197_correction($1, $2) INTO ele;
		SELECT xovercs197_dcorrection($1, $2) INTO eled;
	ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'MSEE') > 2 THEN
			SELECT xovermsee_correction($1, $2) INTO ele;
			SELECT xovermsee_dcorrection($1, $2) INTO eled;
		ELSE
		IF (SELECT COUNT(*) FROM (SELECT v.gradevalue as x, v.credits as y, v.domain
									FROM viewclasses v
									WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2
									ORDER BY v.termid ASC
									LIMIT 3) as sss WHERE sss.domain = 'FE') > 2 THEN
			SELECT xoverfe_correction($1, $2) INTO ele;
			SELECT xoverfe_dcorrection($1, $2) INTO eled;
		END IF;
		END IF;
	END IF;

	--ele fails numer
	SELECT COALESCE(SUM(x*y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	--ele fails denom
	SELECT COALESCE(SUM(y),0) into elef FROM
	(SELECT v.gradevalue as x, v.credits as y
		FROM viewclasses v
		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND (v.gradeid = 11 OR v.gradeid = 10) AND v.termid <= $2) as sss;

	numer = (ah + ahf + mst + mstf + ssp + sspf + maj + ele);
	denom = (ahd + ahdf + mstd + mstdf + sspd + sspdf + majd + eled);
	IF denom = 0 THEN RETURN 0; END IF;
	cwa = numer / denom;

	RETURN round(cwa,4);	


END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE

sid INTEGER;

tid INTEGER;

BEGIN

	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;

	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;



	return xcwa69(sid, tid);

END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return xcwa69(sid, tid);
END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return xcwa69(sid, tid);
END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return xcwa69(sid, tid);
END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return xcwa69(sid, tid);
END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xcwa69(p_studenttermid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE
sid INTEGER;
tid INTEGER;
BEGIN
	SELECT studentid into sid FROM studentterms WHERE studenttermid = $1;
	SELECT termid into tid FROM studentterms WHERE studenttermid = $1;

	return xcwa69(sid, tid);
END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xml_forest(p_content character varying, p_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
BEGIN
   Return '<' || p_name || '>' || p_content || '</' || p_name || '>';
END;
$$;",utils.sql
"CREATE FUNCTION xml_forest(p_content_arr character varying[], p_name character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE
	i integer;
	v_content varchar = '';
BEGIN
	IF fx.is_null_or_empty(p_content_arr) THEN
   	Return '';
   END IF;
	FOR i IN array_lower(p_content_arr, 1)..array_upper(p_content_arr, 1) LOOP
  		v_content = v_content || Coalesce(p_content_arr[i], '');
	END LOOP;

   Return '<' || p_name || '>' || v_content || '</' || p_name || '>';
END;
$$;",utils.sql
"CREATE FUNCTION xml_import(filename text) RETURNS xml
    LANGUAGE plpgsql
    AS $$
    declare
        content bytea;
        loid oid;
        lfd integer;
        lsize integer;
    begin
        loid := lo_import(filename);
        lfd := lo_open(loid,262144);
        lsize := lo_lseek(lfd,0,2);
        perform lo_lseek(lfd,0,0);
        content := loread(lfd,lsize);
        perform lo_close(lfd);
        perform lo_unlink(loid);
 
        return xmlparse(document convert_from(content,'UTF8'));
    end;
$$;",pg.sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







ns1group_credits numeric DEFAULT 0;







otherMST_credits numeric DEFAULT 0;







BEGIN









	SELECT SUM(x * y) into ns1group_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')







	LIMIT 2;











	SELECT COALESCE(SUM(x * y),0) into otherMST_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')







	LIMIT 2;









	return ns1group_credits + otherMST_credits;















END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN




	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;




	return ns1group_credits + otherMST_credits;







END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN




	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;




	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN




	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;




	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN




	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;




	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN




	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;




	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



-- 		LIMIT 2;



-- 	END IF;



	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



-- 		LIMIT 2;



-- 	END IF;



	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns1_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;



BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns1group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')



-- 		LIMIT 2;



-- 	END IF;



	return ns1group_credits + otherMST_credits;







END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







ns1group_units numeric DEFAULT 0;







otherMST_units numeric DEFAULT 0;















BEGIN



	SELECT SUM(y) into ns1group_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')







	LIMIT 2;



	







	SELECT COALESCE(SUM(y),0) into otherMST_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')







	LIMIT 2;



	return ns1group_units + otherMST_units;















END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	return ns1group_units + otherMST_units;







END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	return ns1group_units + otherMST_units;







END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	return ns1group_units + otherMST_units;







END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	return ns1group_units + otherMST_units;







END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	return ns1group_units + otherMST_units;







END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



-- 		LIMIT 2;



-- 	END IF;







	return ns1group_units + otherMST_units;







END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 1', 'Chem 1', 'Physics 10')



-- 		LIMIT 2;



-- 	END IF;







	return ns1group_units + otherMST_units;







END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns1_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns1group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns1group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('nat sci 1', 'chem 1', 'physics 10')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('nat sci 1', 'chem 1', 'physics 10')



-- 		LIMIT 2;



-- 	END IF;







	return ns1group_units + otherMST_units;







END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







ns2group_credits numeric DEFAULT 0;







otherMST_credits numeric DEFAULT 0;















BEGIN



	SELECT SUM(x * y) into ns2group_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')







	LIMIT 2;











	SELECT COALESCE(SUM(x * y),0) into otherMST_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')







	LIMIT 2;



	return ns2group_credits + otherMST_credits;















END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_credits + otherMST_credits;







END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns2_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_credits numeric DEFAULT 0;



otherMST_credits numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into ns2group_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherMST_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN



-- 		SELECT SUM(x * y) into otherMST_credits



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_credits + otherMST_credits;







END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







ns2group_units numeric DEFAULT 0;







otherMST_units numeric DEFAULT 0;















BEGIN



	SELECT SUM(y) into ns2group_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss 







	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')







	LIMIT 2;



	







	SELECT COALESCE(SUM(y),0) into otherMST_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename







		FROM viewclasses v 







		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')







	LIMIT 2;



	return ns2group_units + otherMST_units;















END;$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_units + otherMST_units;







END;$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_units + otherMST_units;







END;$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_units + otherMST_units;







END;$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_units + otherMST_units;







END;$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	return ns2group_units + otherMST_units;







END;$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_units + otherMST_units;







END;$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'Math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('Nat Sci 2', 'Bio 1', 'Geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_units + otherMST_units;







END;$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xns2_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



ns2group_units numeric DEFAULT 0;



otherMST_units numeric DEFAULT 0;







BEGIN







-- 	CREATE TEMPORARY TABLE allmstPass AS



-- 		SELECT v.gradevalue as x, v.credits as y, v.coursename



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into ns2group_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss 



	WHERE coursename IN ('nat sci 2', 'bio 1', 'geol 1')



	LIMIT 2;

	



	SELECT COALESCE(SUM(y),0) into otherMST_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.coursename



		FROM viewclasses v 



		WHERE v.studentid = $1 AND v.domain = 'MST' AND v.coursename <> 'math 2' AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')



	LIMIT 2;







-- 	IF (SELECT COUNT(*) FROM allmstPass WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')) != 0 THEN



-- 		SELECT SUM(y) into otherMST_units



-- 		FROM allmstPass



-- 		WHERE coursename NOT IN ('nat sci 2', 'bio 1', 'geol 1')



-- 		LIMIT 2;



-- 	END IF;







	return ns2group_units + otherMST_units;







END;$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xoptode_data_selector(integer, text) RETURNS refcursor
    AS $_$
DECLARE 

instrumentID alias for $1;
mooringID alias for $2;
mycurs refcursor; 
BEGIN

drop table if exists dphase;
drop table if exists optode_temp;
drop table if exists sbe16_temperature;
drop table if exists sbe16_pressure;
drop table if exists sbe16_conductivity;
drop table if exists set1;
drop table if exists set2;
drop table if exists set3;

create temp table dphase as
select distinct on (date_trunc('hour',data_timestamp)) 
date_trunc('hour',data_timestamp) as obs_time, depth, parameter_value 
from raw_instrument_data
where instrument_id = instrumentID
and mooring_id = mooringID
and parameter_code = 'OPTODE_DPHASE'
;

create temp table optode_temp as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where instrument_id = instrumentID
and mooring_id = mooringID
and parameter_code = 'OPTODE_TEMP'
;

create temp table sbe16_temperature as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where instrument_id = instrumentID
and mooring_id = mooringID
and parameter_code = 'WATER_TEMP'
;


create temp table sbe16_pressure as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where instrument_id = instrumentID
and mooring_id = mooringID
and parameter_code = 'WATER_PRESSURE'
;

create temp table sbe16_conductivity as
select distinct on (date_trunc('hour',data_timestamp) )
date_trunc('hour',data_timestamp)as obs_time, depth, parameter_value 
from raw_instrument_data
where instrument_id = instrumentID
and mooring_id = mooringID
and parameter_code = 'CONDUCTIVITY'
;

create temp table set1 as
select 
	dphase.obs_time,
	dphase.depth,
	dphase.parameter_value as optode_dphase,
	optode_temp.parameter_value as optode_temperature
from dphase full join optode_temp on 
(
dphase.obs_time = optode_temp.obs_time
)
;

create temp table set2 as
select 
	set1.obs_time,
	set1.depth,
	set1.optode_dphase,
	set1.optode_temperature,
	sbe16_temperature.parameter_value as sbe16_temperature
from set1 full join sbe16_temperature on 
(
set1.obs_time = sbe16_temperature.obs_time
)
;

create temp table set3 as
select 
	set2.obs_time,
	set2.depth,
	set2.optode_dphase,
	set2.optode_temperature,
        set2.sbe16_temperature,
	sbe16_pressure.parameter_value as sbe16_pressure
from set2 full join sbe16_pressure on 
(
set2.obs_time = sbe16_pressure.obs_time
)
;

create temp table set4 as
select 
	set3.obs_time,
	set3.depth,
	set3.optode_temperature,
	set3.optode_dphase,
        set3.sbe16_temperature,
	set3.sbe16_pressure,
	sbe16_conductivity.parameter_value as sbe16_conductivity
from set3 full join sbe16_conductivity on 
(
set3.obs_time = sbe16_conductivity.obs_time
)
;

OPEN mycurs FOR  select * from set4 order by obs_time;
RETURN mycurs; 
END;
$_$
    LANGUAGE plpgsql;",ABOS20110308.sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







CSEgroup_credits numeric DEFAULT 0;







otherELE_credits numeric DEFAULT 0;















BEGIN



	SELECT SUM(x * y) into CSEgroup_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'C197'







	LIMIT 2;











	SELECT COALESCE(SUM(x * y),0) into otherELE_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'C197'







	LIMIT 1;



	return CSEgroup_credits + otherELE_credits;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_credits + otherELE_credits;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xovercs197_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(x * y) into CSEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(x * y) into otherELE_credits



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_credits + otherELE_credits;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







CSEgroup_units numeric DEFAULT 0;







otherELE_units numeric DEFAULT 0;















BEGIN



	SELECT SUM(y) into CSEgroup_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'C197'







	LIMIT 2;











	SELECT COALESCE(SUM(y),0) into otherELE_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'C197'







	LIMIT 1;



	return CSEgroup_units + otherELE_units;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_units + otherELE_units;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'C197'



	LIMIT 1;

	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.15a%20Dump%20(Adelen).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-04%2011.26a%20Dump%20(Adelen).sql
"CREATE FUNCTION xovercs197_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



CSEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN



-- 	CREATE TEMPORARY TABLE allelePass AS 



-- 		SELECT v.gradevalue as x, v.credits as y



-- 		FROM viewclasses v 



-- 		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10



-- 		ORDER BY v.termid ASC;







	SELECT SUM(y) into CSEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain = 'C197'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid < $2



		ORDER BY v.termid ASC) as sss



	WHERE v.domain <> 'C197'



	LIMIT 1;







-- 	IF (SELECT COUNT(*) FROM allelePass WHERE v.domain <> 'CSE') <> 0 THEN



-- 		SELECT SUM(y) into otherELE_units



-- 		FROM allelePass



-- 		WHERE v.domain <> 'C197'



-- 		LIMIT 1;



-- 	END IF;







	return CSEgroup_units + otherELE_units;



END$_$;",2013-03-04%20Dump%20(Elijah).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







FEgroup_credits numeric DEFAULT 0;







otherELE_credits numeric DEFAULT 0;















BEGIN



	SELECT SUM(x * y) into FEgroup_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'FE'







	LIMIT 1;











	SELECT COALESCE(SUM(x * y),0) into otherELE_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'FE'







	LIMIT 2;



	return FEgroup_credits + otherELE_credits;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_credits + otherELE_credits;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into FEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_credits + otherELE_credits;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







FEgroup_units numeric DEFAULT 0;







otherELE_units numeric DEFAULT 0;















BEGIN



	SELECT SUM(y) into FEgroup_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'FE'







	LIMIT 1;











	SELECT COALESCE(SUM(y),0) into otherELE_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'FE'







	LIMIT 2;



	return FEgroup_units + otherELE_units;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_units + otherELE_units;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_units + otherELE_units;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_units + otherELE_units;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_units + otherELE_units;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xoverfe_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



FEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into FEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'FE'



	LIMIT 1;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'FE'



	LIMIT 2;

	return FEgroup_units + otherELE_units;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







MSEEgroup_credits numeric DEFAULT 0;







otherELE_credits numeric DEFAULT 0;















BEGIN



	SELECT SUM(x * y) into MSEEgroup_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'MSEE'







	LIMIT 2;











	SELECT COALESCE(SUM(x * y),0) into otherELE_credits







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'MSEE'







	LIMIT 1;



	return MSEEgroup_credits + otherELE_credits;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_credits + otherELE_credits;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_correction(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_credits numeric DEFAULT 0;



otherELE_credits numeric DEFAULT 0;







BEGIN

	SELECT SUM(x * y) into MSEEgroup_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(x * y),0) into otherELE_credits



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_credits + otherELE_credits;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE







MSEEgroup_units numeric DEFAULT 0;







otherELE_units numeric DEFAULT 0;















BEGIN



	SELECT SUM(y) into MSEEgroup_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain = 'MSEE'







	LIMIT 2;











	SELECT COALESCE(SUM(y),0) into otherELE_units







	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain







		FROM viewclasses v 







		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2







		ORDER BY v.termid ASC) as sss







	WHERE sss.domain <> 'MSEE'







	LIMIT 1;



	return MSEEgroup_units + otherELE_units;







END$_$;",2013-03-21%2012.31a%20Dump%20(Dan).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_units + otherELE_units;



END$_$;",2012-03-20%2010.01a%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-06%202.00p%20Dump%20(Elijah).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-17%20Sample%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-19%20Dump%20(Josh).sql
"CREATE FUNCTION xovermsee_dcorrection(p_studentid integer, p_termid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$DECLARE



MSEEgroup_units numeric DEFAULT 0;



otherELE_units numeric DEFAULT 0;







BEGIN

	SELECT SUM(y) into MSEEgroup_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain = 'MSEE'



	LIMIT 2;





	SELECT COALESCE(SUM(y),0) into otherELE_units



	FROM (SELECT v.gradevalue as x, v.credits as y, v.domain



		FROM viewclasses v 



		WHERE v.studentid = $1 AND (v.domain = 'CSE' OR v.domain = 'MSEE' OR v.domain = 'FE' OR v.domain = 'C197') AND v.gradeid < 10 AND v.termid <= $2



		ORDER BY v.termid ASC) as sss



	WHERE sss.domain <> 'MSEE'



	LIMIT 1;

	return MSEEgroup_units + otherELE_units;



END$_$;",2013-03-20%205.39p%20Dump%20(Josh).sql
"CREATE FUNCTION ydm_to_date(numeric, numeric, numeric) RETURNS date
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
DECLARE
   i_year alias for $1;
   i_month alias for $2;
   i_day alias for $3;
BEGIN
   if ((i_year is null) or (i_month is null) or (i_day is null)) then
      return null;
   end if;
   return cast (
      (cast (i_year as char(4)) || '-' ||
       cast (i_month as char(2)) || '-' ||
       cast (i_day as char(2))) as date);
END
$_$;",testdb.sql
"CREATE FUNCTION year(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
     
         return  cast(extract(year from $1) as int);
end; 
$_$;",sql_schema_20170101.sql
"CREATE FUNCTION yearweek(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
date timestamp with time zone = $1;
fyear integer;
begin
fyear :=  extract (year from date - ((isodow (date) -3)::text || ' day')::interval);
return fyear * 100 + extract (week from date);
end;$_$;",fahstats.schema
"CREATE FUNCTION yearweek(timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE STRICT
    AS $_$
declare
date timestamp with time zone = $1;
fyear integer;
begin
fyear :=  extract (year from date - ((isodow (date) -3)::text || ' day')::interval);
return fyear * 100 + extract (week from date);
end;$_$;",ks2.schema
"CREATE FUNCTION zero_bits(value bit, count integer) RETURNS bit
    LANGUAGE plpgsql
    AS $$
BEGIN

return ~(~value | (cast(cast(pow(2, count) as bigint) - 1 as bit(32))));

END;
$$;",data_analysis.psql
"CREATE FUNCTION zero_is_null(att_val bigint) RETURNS bigint
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF att_val = 0 THEN
	
		RETURN null::BIGINT;
	END IF;

	RETURN att_val::BIGINT;
		
END;
$$;",back.sql
"CREATE FUNCTION zero_is_null(att_val integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
	IF att_val = 0 THEN
	
		RETURN null::INTEGER;
	END IF;

	RETURN att_val::INTEGER;
		
END;
$$;",back.sql
"CREATE OR REPLACE  FUNCTION process_log_get(process_id_v character varying) RETURNS text
    LANGUAGE plpgsql
    AS $$
DECLARE
  path_to_logs varchar;
  dynamic_sql varchar;
  log_body varchar;
BEGIN
  path_to_logs = (SELECT setting FROM pg_settings where name = 'data_directory') || '/' || (SELECT setting FROM pg_settings where name = 'log_directory') || '/';

  create temporary table temp_process_log(
    log text
  );
  
  dynamic_sql = 'COPY temp_process_log FROM ' || quote_literal(path_to_logs || process_id_v || '_log.log');
  execute dynamic_sql;
  log_body = (select log from temp_process_log);
  drop table if exists temp_process_log;
  return coalesce(log_body, '');  
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION process_progress_get(process_id character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  sequence_prefix varchar default 'system.process_';
  vl double precision;
BEGIN
  execute 'select last_value from ' || sequence_prefix || process_id into vl;
  return vl;
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION process_progress_get_in_percentage(process_id character varying) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE
  sequence_prefix varchar default 'system.process_';
  vl double precision;
BEGIN
  execute 'select cast(100 * last_value::double precision/max_value::double precision as integer) from ' || sequence_prefix || process_id into vl;
  return vl;
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION process_progress_set(process_id character varying, progress_value integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  sequence_prefix varchar default 'system.process_';
  max_progress_value integer;
BEGIN
  execute 'select max_value from ' || sequence_prefix || process_id into max_progress_value;
  if progress_value> max_progress_value then
    progress_value = max_progress_value;
  end if;
  perform setval(sequence_prefix || process_id, progress_value);
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION process_progress_start(process_id character varying, max_value integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  sequence_prefix varchar default 'system.process_';
BEGIN
  execute system.process_progress_stop(process_id);
  execute 'CREATE SEQUENCE ' || sequence_prefix || process_id
   || ' INCREMENT 1 START 1 MINVALUE 1 MAXVALUE ' || max_value::varchar;   
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION process_progress_stop(process_id character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
  sequence_prefix varchar default 'system.process_';
BEGIN
  execute 'DROP SEQUENCE IF EXISTS ' || sequence_prefix || process_id;   
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE  FUNCTION run_script(script_body text) RETURNS void
    LANGUAGE plpgsql
    AS $$
BEGIN
  execute script_body;
END;
$$;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE FUNCTION  genall_upsertID()
RETURNS VOID
AS $main$
DECLARE
tablenames RECORD;
newfunc VARCHAR;
BEGIN
 FOR tablenames IN SELECT table_name FROM information_schema.tables WHERE table_schema!='information_schema' AND table_schema!='pg_catalog' AND table_type='BASE TABLE' LOOP
	SELECT INTO newfunc gen_upsertID(tablenames.table_name);
	EXECUTE newfunc;
  END LOOP;
END;
$main$ LANGUAGE plpgsql
VOLATILE;",PreCheckCrea.log
"CREATE OR REPLACE FUNCTION ""search_article_content""(keyword varchar, lm int4, o int4)
  RETURNS SETOF ""public"".""v_list_all_article"" AS $BODY$
BEGIN
  RETURN QUERY  SELECT
*
  FROM
    v_list_all_article
  WHERE
    LOWER(CONTENT) LIKE LOWER('%' || keyword || '%')
  ORDER BY
    ID
  LIMIT lm OFFSET o ;
  END $BODY$
  LANGUAGE 'plpgsql' VOLATILE COST 100
 ROWS 1000
;",articledb_gin_fts.sql
"CREATE OR REPLACE FUNCTION ""search_article_title""(keyword varchar, lm int4, o int4)
  RETURNS SETOF ""public"".""v_list_all_article"" AS $BODY$
BEGIN
  RETURN QUERY  SELECT
*
  FROM
    v_list_all_article
  WHERE
    LOWER(TITLE) LIKE LOWER('%' || keyword || '%')
  ORDER BY
    ID
  LIMIT lm OFFSET o ;
  END $BODY$
  LANGUAGE 'plpgsql' VOLATILE COST 100
 ROWS 1000
;",articledb_gin_fts.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN
	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",ETL.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN
	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",scripts_dw.sql
"CREATE OR REPLACE FUNCTION Carga_General(ainicial integer, afinal integer) RETURNS VOID AS
$$
DECLARE
	i integer; j integer; a record;
BEGIN

	FOR i IN 1 .. 3 LOOP
		SELECT * INTO a FROM (SELECT CargaTEClientes(20,i)) as s;
		SELECT * INTO a FROM (SELECT CargaTEProductos(20,i)) as s;
	END LOOP;

	FOR k IN 1 .. 3 LOOP
		FOR i IN ainicial .. afinal LOOP
			FOR j IN 1 .. 12 LOOP
				SELECT * INTO a FROM (SELECT Carga_Particular(k,j,i)) as s;
			END LOOP;
		END LOOP;
	END LOOP;
END;
$$ LANGUAGE plpgsql;",ETL%20(mod).sql
"CREATE OR REPLACE FUNCTION Get_DefaultSystemName() RETURNS VARCHAR(60) AS $$
DECLARE
        v_system_name   VARCHAR(60);
BEGIN
	SELECT _system_name
        INTO    v_system_name
	FROM	coincomo_systems_table
	WHERE _system_name LIKE '(System%)'
        ORDER BY _system_name DESC
        LIMIT 1;

	IF FOUND THEN
		RETURN v_system_name;
	ELSE
		RETURN '(System)';
	END IF;
END;
$$ LANGUAGE plpgsql;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION GoogleEncodeLine
(
  g GEOMETRY
)
RETURNS TEXT AS $$
DECLARE
  pt1 GEOMETRY;
  pt2 GEOMETRY;
  p INT; np INT;
  deltaX INT;
  deltaY INT;
  enX VARCHAR(255);
  enY VARCHAR(255);
  gEncoded TEXT;
BEGIN
  gEncoded = '';
  np = ST_NPoints(g);

  IF np > 3 THEN
    g = ST_SimplifyPreserveTopology(g, 0.00001);
    np = ST_NPoints(g);
  END IF;

  pt1 = ST_SetSRID(ST_MakePoint(0, 0),4326);

  FOR p IN 1..np BY 1 LOOP
    pt2 = ST_PointN(g, p);
    deltaX = (floor(ST_X(pt2)*1e5)-floor(ST_X(pt1)*1e5))::INT;
    deltaY = (floor(ST_Y(pt2)*1e5)-floor(ST_Y(pt1)*1e5))::INT;
    enX = GoogleEncodeSignedInteger(deltaX);
    enY = GoogleEncodeSignedInteger(deltaY);
    gEncoded = gEncoded || enY || enX;

    pt1 = ST_SetSRID(ST_MakePoint(ST_X(pt2), ST_Y(pt2)),4326);
  END LOOP;
RETURN gEncoded;
End
$$ LANGUAGE plpgsql;",cmdOut.txt
"CREATE OR REPLACE FUNCTION GoogleEncodeSignedInteger(c INT)
RETURNS VARCHAR(255) AS $$
DECLARE
  e VARCHAR(255);
  s BIT(32);
  b BIT(6);
  n INT;
BEGIN
 e = '';
 s = (c::BIT(32))<<1;

 IF s::INT < 0 THEN
   s = ~s;
   END IF;

 WHILE s::INT >= B'100000'::INT LOOP
   b = B'100000' | (('0'||substring(s, 28, 5))::BIT(6));
   n = b::INT + 63;
   e = e || chr(n);
   s = s >> 5;
 END LOOP;
 e = e || chr(s::INT+63);

RETURN e;
End
$$ LANGUAGE plpgsql;",cmdOut.txt
"CREATE OR REPLACE FUNCTION Has_SystemName(VARCHAR(60)) RETURNS BOOLEAN AS $$
BEGIN
        PERFORM _system_name
	FROM	coincomo_systems_table
	WHERE _system_name = $1;

	IF FOUND THEN
		RETURN true;
	ELSE
		RETURN false;
	END IF;
END;
$$ LANGUAGE plpgsql;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION MembersIn(char(5), REFCURSOR) RETURNS refcursor AS
$$
DECLARE
	inputNumber	char(5)       := $1;
	resultSet   REFCURSOR 	  := $2;
BEGIN
	OPEN resultSet for
		SELECT firstName, lastName, expectedGradSemester
		FROM   People p, Musicians m, Member_Of, Ensembles
		WHERE  p.person_id = m.person_id
		AND    m.person_id = member_of.person_id
    AND	   member_of.ensemble_id = ensembles.ensemble_id
    AND	   ensembles.ensemble_id = inputNumber;
	RETURN resultSet;
END;
$$
LANGUAGE plpgsql;",finalProject.sql
"CREATE OR REPLACE FUNCTION PerformsIn(char(4), REFCURSOR) RETURNS refcursor AS
$$
DECLARE
	inputNumber	char(4)       := $1;
	resultSet   REFCURSOR 	  := $2;
BEGIN
	OPEN resultSet for
		SELECT eventDate, eventTime, ensembleName
		FROM Ensembles e, Performs_In, Locations l
		WHERE l.location_id = performs_In.location_id
		AND e.ensemble_id = performs_In.ensemble_id
		AND l.location_id = inputNumber;
	RETURN resultSet;
END;
$$
LANGUAGE plpgsql;",finalProject.sql
"CREATE OR REPLACE FUNCTION VXC()
RETURNS SETOF RECORD
AS $PROCEDURE$
DECLARE
	registro RECORD;
	cursor_cxv CURSOR FOR
	SELECT 
	cliente.nom_cliente::text as nombre, sum(factura.val_factura)::integer as ventas
	FROM
	cliente, factura
	where cliente.cod_cliente = factura.cod_cliente 
	GROUP BY nombre;

BEGIN
	FOR registro IN cursor_cxv LOOP
		RETURN NEXT registro;
	END LOOP;

END;
$PROCEDURE$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION __tmp_create_user() returns void as $$
BEGIN
  IF NOT EXISTS (
          SELECT                       -- SELECT list can stay empty for this
          FROM   pg_catalog.pg_user
          WHERE  usename = 'postgres_exporter') THEN
    CREATE USER postgres_exporter;
  END IF;
END;
$$ language plpgsql;",Installing_Daemons_on_target_host.md
"CREATE OR REPLACE FUNCTION _d_c0(text,int,int)
RETURNS integer AS $$
DECLARE 
r int;
BEGIN

FOR r IN
EXECUTE format('SELECT split_part(table_name,''_'',3)::int FROM information_schema.tables WHERE table_name ~ ''v2_dna_'' and split_part(table_name,''_'',3)::int > %s and split_part(table_name,''_'',3)::int < %s order by split_part(table_name,''_'',3)::
int',$2,$3)
    LOOP
EXECUTE format('drop table if exists %s_c0_%s', $1, r);
    END LOOP;
RETURN 0;

END;$$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _d_rocksdb(int,int)
RETURNS integer AS $$
DECLARE 
r int;
BEGIN

FOR r IN
EXECUTE format('SELECT split_part(table_name,''_'',3)::int FROM information_schema.tables WHERE table_name ~ ''v2_dna_'' and split_part(table_name,''_'',3)::int > %s and split_part(table_name,''_'',3)::int < %s order by split_part(table_name,''_'',3)::int',$1,$2)
    LOOP
EXECUTE format('select rocks_destroy(%s)',  r);
    END LOOP;
RETURN 0;

END;$$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _ec_v2_dna(text,text,int,int,int,int)
returns integer AS $_ec_v2_dna$
DECLARE 
resultCount integer := 0;
r int := $3+1;
BEGIN

-- EXECUTE format('create index if not exists %s_idx on %s (%s)',$1,$1,$2); -- better do it manually before the first run
EXECUTE format('CREATE TEMP TABLE tmp on commit drop as select * from %s limit 0',$1);
EXECUTE format('CREATE TEMP TABLE v2_dna_tmp (tab text, rev int, key bigint, ancestor bigint) on commit drop');

FOR r IN
EXECUTE format('SELECT distinct %s FROM %s where %s > %s and %s < %s order by %s',$2,$1,$2,$3,$2,$4,$2)
    LOOP
RAISE NOTICE 'Executing _e_v2_dna(''%'',''%'',%, %, %):', $1, $2, r, $5, $6;
EXECUTE format('select _e_v2_dna(''%s'',''%s'',%s, %s, %s)',$1, $2, r, $5, $6) into resultCount;

    END LOOP;
RETURN resultCount;

END;$_ec_v2_dna$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _i_v2_dna(int,int,int)
RETURNS integer AS $$
DECLARE 
r integer := 0;
resultCount integer := 0;

BEGIN

FOR r IN

EXECUTE format('SELECT split_part(table_name,''_'',3)::int FROM information_schema.tables WHERE table_name ~ ''v2_dna_'' and split_part(table_name,''_'',3)::int > %s and split_part(table_name,''_'',3)::int < %s order by split_part(table_name,''_'',3)::
int',$1,$2)
    LOOP
	EXECUTE format('drop table if exists v2_dna_%s', r);
	if $3 = 1 then 
		EXECUTE format('create table v2_dna_%s (tab text, rev int, key bigint, ancestor bigint)', r);
	end if;
	resultCount = resultCount + 1;
    END LOOP;
   
    return resultCount;

END;$$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _i_v2_dna(text,text,int,int)
RETURNS integer AS $$
DECLARE 
r integer := 0;
resultCount integer := 0;
BEGIN

FOR r IN EXECUTE format('SELECT distinct %s FROM %s where %s > %s and %s < %s order by %s',$2,$1,$2,$3,$2,$4,$2)
    LOOP
EXECUTE format('create table if not exists v2_dna_%s (tab text, rev int, key bigint, ancestor bigint)', r);
resultCount = resultCount + 1;
    END LOOP;
   
return resultCount;
END;$$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _p_c0(text,int,int,int)
returns integer AS $$
DECLARE 
r int;
BEGIN

FOR r IN
EXECUTE format('SELECT split_part(table_name,''_'',3)::int FROM information_schema.tables WHERE table_name ~ ''v2_dna_'' and split_part(table_name,''_'',3)::int > %s and split_part(table_name,''_'',3)::int < %s order by split_part(table_name,''_'',3)::
int',$2,$3)
    LOOP
RAISE NOTICE 'Executing _checkout_c0(''%'',%,%):',$1,r,$4;
EXECUTE format('select _checkout_c0(''%s'',%s,%s)',$1,r,$4) into r;

    END LOOP;
RETURN 0;

END;$$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION _wc_v2_dna(text,text,int,int)
returns integer AS $_wc_v2_dna$
DECLARE 
resultCount integer := 0;
r int := $3+1;
BEGIN

-- EXECUTE format('create index if not exists %s_idx on %s (%s)',$1,$1,$2); -- better do it manually before the first run
EXECUTE format('CREATE TEMP TABLE tmp on commit drop as select * from %s limit 0',$1);
EXECUTE format('CREATE TEMP TABLE v2_dna_tmp (tab text, rev int, key bigint, ancestor bigint) on commit drop');

FOR r IN EXECUTE format('SELECT distinct %s FROM %s where %s > %s and %s < %s order by %s',$2,$1,$2,$3,$2,$4,$2)
    LOOP
	RAISE NOTICE 'Executing _w_v2_dna(''%'',''%'',%):', $1, $2, r;
	EXECUTE format('select _w_v2_dna(''%s'',''%s'',%s)',$1, $2, r) into resultCount;

    END LOOP;
RETURN resultCount;

END;$_wc_v2_dna$ LANGUAGE plpgsql;",pl_pgsql_lib.txt
"CREATE OR REPLACE FUNCTION ad_treeGetLowerHierarchy(p_nodeId varchar,pTreeId varchar,p_initlevel in numeric, p_lowerNode OUT varchar, p_level out numeric,p_seq out numeric, p_created out timestamp) RETURNS setof RECORD
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2014 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************

*****************************************************/

v_nodeId character varying;
v_cur RECORD;
v_cur2 record;
v_level numeric;
v_parentnode varchar;
BEGIN 
    v_nodeId:=coalesce(p_nodeId,'0');
    v_level:=p_initlevel+1;
    for v_cur in (select  * from ad_treenode where ad_tree_id=pTreeId and parent_id=v_nodeId order by seqno,created)
    LOOP
        p_lowerNode:=v_cur.node_id;
        p_level:=v_level;
        p_seq:=v_cur.seqno;
        p_created:=v_cur.created;
        v_parentnode:=v_cur.node_id;
        RETURN NEXT;
        for v_cur2 in (select  a.p_lowerNode,a.p_level,a.p_seq,a.p_created from ad_treeGetLowerHierarchy(v_parentnode,pTreeId,v_level) a)
        LOOP
            p_lowerNode:=v_cur2.p_lowerNode;
            p_level:=v_cur2.p_level;
            p_seq:=v_cur2.p_seq;
            p_created:=v_cur2.p_created;
            RETURN NEXT;
        END LOOP;
    END LOOP;
END;
$_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE OR REPLACE FUNCTION ad_treeGetUpperHierarchy(p_nodeId varchar,pTreeId varchar, p_upperNode OUT varchar, xy out varchar) RETURNS setof RECORD
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2014 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************

*****************************************************/

v_nodeId character varying;
v_temp varchar;
--cur_node RECORD;
weiter character varying:='Y';
BEGIN 
    v_nodeId:=p_nodeId;
    WHILE weiter='Y'
    LOOP
        select parent_id into v_temp from ad_treenode where ad_tree_id=pTreeId and node_id=v_nodeId;
        p_upperNode:=v_temp;
        xy:='DUMMY';
        if p_upperNode is not null and p_upperNode!='0' then
            RETURN NEXT;
        else
            weiter='N';
        end if;
        v_nodeId:=p_upperNode;
    end loop;
END;
$_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE OR REPLACE FUNCTION add_position_jsonVD(
	i_json json,
	i_json_position json,
	i_clave varchar,
	i_value varchar)
RETURNS varchar AS
$BODY$
DECLARE
	d_router varchar;
	d_json varchar;
	String varchar;
	d_values record;
	d_long integer;
	d_record record;
	d_array varchar = '$$array$$';
	d_object varchar = '$$object$$';
BEGIN
	/*
	Hecho por: Vlade Párica

	Para probarlo:
					select add_position_jsonVD('[{""x"": 45, ""demenecia"": 458 }, {""y"": 78, ""locura"": 458 }, {""ezz"": {""z"": 15, ""desquiciado"": 357, ""nodo_pro"": [{""jarvis"": ""locote""}, {""normal"": 45 }] } }]','[{""clave"": ""ezz"", ""posicion"": 2}, {""clave"": ""nodo_pro"", ""posicion"": 0}, {""posicion"": 1}]','prueba','{""prueba"":1 ,""rawayana"":""sin ti""}')


 					select add_position_jsonVD('[{""tx_esp"": ""Cardiología"", ""id_especialidadesmed"": 4, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenCardiovascular_1528813590.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 4, ""tx_esp"": ""Cardiología"", ""id_recaudo"": 158, ""ruta"": ""http://192.168.0.200//file/arch/15990.pdf"", ""descripcion"": ""Reporte Cardiología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Medicina General"", ""id_especialidadesmed"": 1, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenMedicoGeneral_1528813588.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 1, ""tx_esp"": ""Medicina General"", ""id_recaudo"": 155, ""ruta"": ""http://192.168.0.200//file/arch/15987.pdf"", ""descripcion"": ""Reporte Medicina General""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Neurología"", ""id_especialidadesmed"": 5, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenNeurologico_1528813591.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 5, ""tx_esp"": ""Neurología"", ""id_recaudo"": 159, ""ruta"": ""http://192.168.0.200//file/arch/15991.pdf"", ""descripcion"": ""Reporte Neurología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Odontología"", ""id_especialidadesmed"": 8, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenOdontologia_1528813593.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 8, ""tx_esp"": ""Odontología"", ""id_recaudo"": 162, ""ruta"": ""http://192.168.0.200//file/arch/15994.pdf"", ""descripcion"": ""Reporte Odontología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Oftalmología"", ""id_especialidadesmed"": 3, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenOftalmologico_1528813590.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 3, ""tx_esp"": ""Oftalmología"", ""id_recaudo"": 157, ""ruta"": ""http://192.168.0.200//file/arch/15989.pdf"", ""descripcion"": ""Reporte Oftalmología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Otorrinolaringología"", ""id_especialidadesmed"": 2, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenOtorrinolaringologico_1528813589.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 2, ""tx_esp"": ""Otorrinolaringología"", ""id_recaudo"": 156, ""ruta"": ""http://192.168.0.200//file/arch/15988.pdf"", ""descripcion"": ""Reporte Otorrinolaringología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Psicología"", ""id_especialidadesmed"": 6, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenPsicologico_1528813592.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 6, ""tx_esp"": ""Psicología"", ""id_recaudo"": 160, ""ruta"": ""http://192.168.0.200//file/arch/15992.pdf"", ""descripcion"": ""Reporte Psicología""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }, {""tx_esp"": ""Psiquiatría"", ""id_especialidadesmed"": 7, ""tramite"": [{""evaluacion_inicial"": [{""id_solicitud"": 831, ""clase_medicina"": 2, ""id_tipo_tramite"": 50, ""id_tramite"": 649, ""descripcion_archivo"": ""ExamenPsiquiatria_1528813592.pdf"", ""fecha"": ""12-06-018"", ""id_especialidadesmed"": 7, ""tx_esp"": ""Psiquiatría"", ""id_recaudo"": 161, ""ruta"": ""http://192.168.0.200//file/arch/15993.pdf"", ""descripcion"": ""Reporte Psiquiatría""}], ""evaluacion_periodica"": null, ""evaluacion_extraordinaria"": null, ""auditoria"": null }] }]','[{""clave"": ""tramite"", ""posicion"": 6}, {""clave"": ""evaluacion_inicial"", ""posicion"": 0}, {""posicion"": 0}]','prueba2','true')
	-- */

	d_long = json_array_length(i_json_position);

	with destruc_position_tmp as (

		select
			value->>'clave' as clave,
			value->>'posicion' as posicion
		from
			json_array_elements(i_json_position)
		limit 1

	)
		select
			* into d_values
		from
			destruc_position_tmp
	;


	if json_typeof(i_json) = 'object' then
		d_router = '->$$'||d_values.clave||'$$';
	else

		if d_long = 1 then
			d_router = '->'||d_values.posicion;
		else
			d_router = '->'||d_values.posicion||'->$$'||d_values.clave||'$$';
		end if;

	end if;

	execute 'select $$'||i_json||'$$::json'||d_router into d_json;
	d_router = '';

	String ='
		with position_tmp as (

			select
				value,
				ordinality as position
			from
				json_array_elements($$'||i_json_position||'$$)
				with ordinality
			order by position desc

		), json_position_tmp as (

			select
				*
			from
				position_tmp
			limit '||d_long-1||'

		)
			select
				value
			from
				json_position_tmp
			order by position
	';

	for d_record in execute String
	loop
		d_router = d_router || d_record.value ||'#';
	end loop;

	if d_long > 1 then
		d_json = add_position_jsonVD(d_json::json,convert_array_jsonvd(rtrim(d_router,'#')),i_clave,i_value);
		d_router = '';
	end if;



if d_long = 1 then
	d_json = json_push_vd(d_json::json,i_clave,i_value);
end if;
	-----------------------------------------------------------------------------------------------------------------------------------------

	if json_typeof(i_json) = 'array' then


		if not d_values.clave is null and json_typeof(d_json::json) = 'object' then

			string = '
					select
						$$'||d_values.clave||'$$ as elem,
						$$'||d_json||'$$ as position';


			for d_record in execute string
			loop
				d_router = d_router ||'$$'|| d_record.elem::varchar ||'$$,$$'|| d_record.position::varchar || '$$,';
			end loop;

			d_router = rtrim(d_router,',');

			execute 'select to_json_build_vd('||d_router||')' into d_json;

		end if;

		-----------------------------------------------------------------------------------------------------------------------------------------

		if json_typeof(d_json::json) = 'array' and not d_values.clave is null then

			String ='

				with json_array_tmp as (

					select
						elems,
						(positions -1) as positions
					from
						json_array_elements($$'||i_json||'$$) with ordinality arr(elems, positions)

				), each_tmp as (

					select
						elem,
						position,
						(ordinality -1) as ordinality
					from
						json_array_tmp,
						json_each(elems) with ordinality arr(elem, position)
					where
						positions = '||d_values.posicion||'

				), select_position_tmp as (

					select
						ordinality
					from
						each_tmp
					where
						elem = $$'||d_values.clave||'$$

				)
					select
						*
					from
						each_tmp
					where
						elem <> $$'||d_values.clave||'$$

					union all

					select
						$$'||d_values.clave||'$$ as elem,
						$$'||d_json||'$$ as position,
						(select * from select_position_tmp) as ordinality
					order by ordinality';


			for d_record in execute string
			loop
				if d_record.position is null then
					d_record.position = 'null';
				end if;
				d_router = d_router ||'$$'|| d_record.elem ||'$$,$$'|| d_record.position || '$$,';
			end loop;

			d_router = rtrim(d_router,',');

			execute 'select to_json_build_vd('||d_router||')' into d_json;
			String = '';




			String = '
				with json_construc_tmp as (

					select
						elems,
						(positions -1) as positions
					from
						json_array_elements($$'||i_json||'$$) with ordinality arr(elems, positions)

				), json_array_final_tmp as (

					select
						*
					from
						json_construc_tmp
					where
						positions <> '||d_values.posicion||'

					union all

					select
						$$'||d_json||'$$ as elems,
						'||d_values.posicion||' as positions
					order by positions
				)
					select
						elems as value
					from
						json_array_final_tmp';

			d_json = query_convert_array_jsonVD(String);
			-----------------------------------------------------------------------------------------------------------------

		else
			-----------------------------------------------------------------------------------------------------------------
			String ='

				with json_array_tmp as (

					select
						elem,
						(position -1) as position
					from
						json_array_elements($$'||i_json||'$$) with ordinality arr(elem, position)

				), agg_tmp as (

					select
						elem as value,
						position
					from
						json_array_tmp
					where
						position <> '||d_values.posicion||'

					union all


					select
						$$'||d_json||'$$ as value,
						'||d_values.posicion||' as position
					order by position

				)

					select
						value
					from
						agg_tmp';

			d_json = query_convert_array_jsonVD(String);

		end if;
		----------------------------------------------------------------------------------------------------------------------------------------------
	else
		----------------------------------------------------------------------------------------------------------------------------------------------
		string = '

			with json_tmp as (

				select
					elem,
					position,
					(ordinality -1) as ordinality
				from
					json_each($$'||i_json||'$$) with ordinality arr(elem, position)

			), select_position_tmp as (

				select
					ordinality
				from
					json_tmp
				where
					elem = $$'||d_values.clave||'$$

			), to_json_tmp as (

				select
					*
				from
					json_tmp
				where
					elem <> $$'||d_values.clave||'$$

			)

				select
					*
				from
					to_json_tmp

				union all

				select
					$$'||d_values.clave||'$$ as elem,
					$$'||d_json||'$$ as position,
					(select * from select_position_tmp) as ordinality

				order by ordinality';

		for d_record in execute string
		loop
			if d_record.position is null then
				d_record.position = 'null';
			end if;
			d_router = d_router ||'$$'|| d_record.elem ||'$$,'''|| d_record.position || ''',';
		end loop;

		d_router = rtrim(d_router,',');

		execute 'select to_json_build_vd('||d_router||')' into d_json;

		-----------------------------------------------------------------------------------------------------------------------------------------
	end if;


	RETURN d_json;
END;$BODY$
	LANGUAGE plpgsql VOLATILE
	COST 100;",add_position_json.sql
"CREATE OR REPLACE FUNCTION addindexifnotexists(
    indexname character varying,
    tablename character varying,
    columnname character varying)
  RETURNS numeric AS
$BODY$
BEGIN
	RETURN addindexifnotexists(indexname, tablename, columnname, '');
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION addindexifnotexists(
    indexname character varying,
    tablename character varying,
    columnname character varying)
  RETURNS numeric AS
$BODY$
DECLARE
	existe integer;
BEGIN
	
	  select into existe count(1)
	from
	    pg_class t,
	    pg_class i,
	    pg_index ix,
	    pg_attribute a
	where
	    t.oid = ix.indrelid
	    and i.oid = ix.indexrelid
	    and a.attrelid = t.oid
	    and a.attnum = ANY(ix.indkey)
	    and t.relkind = 'r'
	    and lower(i.relname) = lower(indexname)
	    and lower(t.relname) = lower(tablename)
	    and lower(a.attname) = lower(columnname);


	IF (existe = 0) THEN
		EXECUTE 'CREATE INDEX ' || indexname || 
			' ON ' || tablename || 
			' (' || columnname || ')';
		RETURN 1;
	END IF;

	RETURN 0;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION addindexifnotexists(
    indexname character varying,
    tablename character varying,
    columnname character varying,
    whereclause character varying)
  RETURNS numeric AS
$BODY$
DECLARE
	existe integer;
BEGIN
	
	  select into existe count(1)
	from
	    pg_class t,
	    pg_class i,
	    pg_index ix,
	    pg_attribute a
	where
	    t.oid = ix.indrelid
	    and i.oid = ix.indexrelid
	    and a.attrelid = t.oid
	    and a.attnum = ANY(ix.indkey)
	    and t.relkind = 'r'
	    and lower(i.relname) = lower(indexname)
	    and lower(t.relname) = lower(tablename)
	    and lower(a.attname) = lower(columnname);


	IF (existe = 0) THEN
		EXECUTE 'CREATE INDEX ' || indexname || 
			' ON ' || tablename || 
			' (' || columnname || ') ' || 
			whereclause;
		RETURN 1;
	END IF;

	RETURN 0;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION addtype_Alignement_format() RETURNS VOID AS $$
BEGIN
    IF not exists(SELECT e.enumlabel from pg_type t, pg_enum e
		 where t.oid = e.enumtypid and t.typname = 'alignement_format') then 
		 execute 				
			'CREATE TYPE public.alignement_format AS ENUM
			   (''skos'',
			    ''json'',
			    ''xml'');';
			  END IF;

END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION addtype_auth_method() RETURNS VOID AS $$
BEGIN
    IF not exists(SELECT e.enumlabel from pg_type t, pg_enum e
		 where t.oid = e.enumtypid and t.typname = 'auth_method') then 
		 execute 				
			'CREATE TYPE public.auth_method AS ENUM
			   (''DB'',
			    ''LDAP'',
			    ''FILE'',
			    ''test'');';
			  END IF;

END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION aggregatedailyenergyconsumption_plugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE
	rec plugload_daily_record;
	diffInDays numeric;
	rec_plugload plugload_record;
	aggregation_time timestamp;
BEGIN
	FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
	LOOP
	select max(capture_at) into aggregation_time from plugload_energy_consumption_daily where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('day',now()::timestamp) - interval '7 days') then
	aggregation_time = (date_trunc('day',now()::timestamp) - interval '7 days');
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/(3600*24) into diffInDays;
		if diffInDays >1 then
			aggregation_time = aggregation_time + interval '1 day';
			WHILE aggregation_time <= toDate LOOP
			perform plugload_ec_aggregation_daily(aggregation_time);
			aggregation_time = aggregation_time + interval '1 day';
			end loop;
		else
		perform plugload_ec_aggregation_daily(todate);
		end if;
	else
	perform plugload_ec_aggregation_daily(todate);
	end IF;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION aggregatedailyenergyconsumption_plugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE 
	rec plugload_daily_record;	
	diffInDays numeric;	
	rec_plugload plugload_record;
	aggregation_time timestamp;
BEGIN
	FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
	LOOP
	select max(capture_at) into aggregation_time from plugload_energy_consumption_daily where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('day',now()::timestamp) - interval '7 days') then	
	aggregation_time = (date_trunc('day',now()::timestamp) - interval '7 days');	
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/(3600*24) into diffInDays;		
		if diffInDays >1 then
			aggregation_time = aggregation_time + interval '1 day';		
			WHILE aggregation_time <= toDate LOOP			
			perform plugload_ec_aggregation_daily(aggregation_time);
			aggregation_time = aggregation_time + interval '1 day';				
			end loop;
		else		
		perform plugload_ec_aggregation_daily(todate);			
		end if;
	else
	perform plugload_ec_aggregation_daily(todate);		
	end IF;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION aggregatedailyenergyconsumptionforplugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE 
	rec plugload_daily_record;	
	diffInDays numeric;	
	rec_plugload plugload_record;
	aggregation_time timestamp;
BEGIN
	FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
	LOOP
	select max(capture_at) into aggregation_time from plugload_energy_consumption_daily where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('day',now()::timestamp) - interval '7 days') then	
	aggregation_time = (date_trunc('day',now()::timestamp) - interval '7 days');	
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/(3600*24) into diffInDays;		
		if diffInDays >1 then
			aggregation_time = aggregation_time + interval '1 day';		
			WHILE aggregation_time <= toDate LOOP			
			perform plugload_ec_aggregation_daily(aggregation_time);
			aggregation_time = aggregation_time + interval '1 day';				
			end loop;
		else		
		perform plugload_ec_aggregation_daily(todate);			
		end if;
	else
	perform plugload_ec_aggregation_daily(todate);		
	end IF;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION aggregatehourlyenergyconsumption_plugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE
	rec_plugload plugload_record;
	diffInHours numeric;
	rec_count integer;
	aggregation_time timestamp;
BEGIN

FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
LOOP

	select max(capture_at) into aggregation_time from plugload_energy_consumption_hourly where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('hour',now()::timestamp) - interval '7 days') then
	aggregation_time = (date_trunc('hour',now()::timestamp) - interval '7 days');
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/3600 into diffInHours;

		if diffInHours >1 then
		aggregation_time = aggregation_time + interval '1 hour';
		WHILE aggregation_time <= toDate LOOP
		perform plugload_ec_aggregation_hourly(aggregation_time);
		aggregation_time = aggregation_time + interval '1 hour';
		END LOOP;
		else
		perform plugload_ec_aggregation_hourly(todate);
		end if;
	else
	perform plugload_ec_aggregation_hourly(todate);
	end if;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION aggregatehourlyenergyconsumption_plugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE 
	rec_plugload plugload_record;
	diffInHours numeric;
	rec_count integer;
	aggregation_time timestamp;
BEGIN

FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
LOOP

	select max(capture_at) into aggregation_time from plugload_energy_consumption_hourly where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('hour',now()::timestamp) - interval '7 days') then	
	aggregation_time = (date_trunc('hour',now()::timestamp) - interval '7 days');	
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/3600 into diffInHours;
		
		if diffInHours >1 then					
		aggregation_time = aggregation_time + interval '1 hour';
		WHILE aggregation_time <= toDate LOOP								
		perform plugload_ec_aggregation_hourly(aggregation_time);		
		aggregation_time = aggregation_time + interval '1 hour';
		END LOOP;
		else
		perform plugload_ec_aggregation_hourly(todate);
		end if;
	else
	perform plugload_ec_aggregation_hourly(todate);
	end if;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION aggregatehourlyenergyconsumptionforplugload(todate timestamp without time zone)
  RETURNS void AS
$BODY$
DECLARE 
	rec_plugload plugload_record;
	diffInHours numeric;
	rec_count integer;
	aggregation_time timestamp;
BEGIN

FOR rec_plugload IN(select id as plugload_id from plugload where state='COMMISSIONED')
LOOP

	select max(capture_at) into aggregation_time from plugload_energy_consumption_hourly where plugload_id=rec_plugload.plugload_id;
	if aggregation_time < (date_trunc('hour',now()::timestamp) - interval '7 days') then	
	aggregation_time = (date_trunc('hour',now()::timestamp) - interval '7 days');	
	end if;
	IF aggregation_time is not null THEN
		select (EXTRACT(EPOCH FROM toDate) - EXTRACT(EPOCH FROM aggregation_time))/3600 into diffInHours;
		
		if diffInHours >1 then					
		aggregation_time = aggregation_time + interval '1 hour';
		WHILE aggregation_time <= toDate LOOP								
		perform plugload_ec_aggregation_hourly(aggregation_time);		
		aggregation_time = aggregation_time + interval '1 hour';
		END LOOP;
		else
		perform plugload_ec_aggregation_hourly(todate);
		end if;
	else
	perform plugload_ec_aggregation_hourly(todate);
	end if;
	END LOOP;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION ajouter_column_concept() RETURNS VOID AS $$
BEGIN
    IF not EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS
     WHERE COLUMN_NAME = 'gps' AND TABLE_NAME = 'concept') THEN
	Execute
	'Alter TABLE concept ADD COLUMN gps boolean default false;';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION ajouter_sequence(TEXT) RETURNS VOID AS $$
DECLARE
 nom_sequence ALIAS FOR $1;

BEGIN
    IF NOT EXISTS (SELECT * FROM information_schema.sequences WHERE sequence_name = nom_sequence) THEN

        execute 'CREATE sequence ' || nom_sequence || '
              INCREMENT 1
		  MINVALUE 1
		  MAXVALUE 9223372036854775807
		  START 1
		  CACHE 1;';

    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION ajoutercolumn_alignement() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS
     WHERE COLUMN_NAME = 'id_alignement_source' AND TABLE_NAME = 'alignement') THEN
	Execute
	'
	 Alter TABLE alignement ADD COLUMN id_alignement_source integer;
	 ALTER TABLE ONLY alignement ADD CONSTRAINT alignement_uri_target_internal_id_thesaurus_internal_id_con_key 
	 UNIQUE (uri_target, internal_id_thesaurus, internal_id_concept);

';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION ajoutercolumn_alignement_source() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS
     WHERE COLUMN_NAME = 'description' AND TABLE_NAME = 'alignement_source') THEN
	Execute
	'
	 Alter TABLE alignement_source ADD COLUMN description character varying;';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION ajoutercolumn_preferences() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS
     WHERE COLUMN_NAME = 'url_counter_bdd' AND TABLE_NAME = 'preferences') THEN
        begin
            DROP TABLE preferences;
            CREATE TABLE preferences
            (
              id_pref integer NOT NULL DEFAULT nextval('pref__id_seq'::regclass),
              id_thesaurus character varying NOT NULL,
              source_lang character varying(2) DEFAULT 'fr'::character varying,
              nb_alert_cdt integer DEFAULT 10,
              alert_cdt boolean DEFAULT false,
              identifier_type integer DEFAULT 2,
              use_ark boolean DEFAULT false,
              server_ark character varying DEFAULT 'http://ark.mondomaine.fr/ark:/'::character varying,
              path_image character varying DEFAULT '/var/www/images/'::character varying,
              dossier_resize character varying DEFAULT 'resize'::character varying,
              bdd_active boolean DEFAULT false,
              bdd_use_id boolean DEFAULT false,
              url_bdd character varying DEFAULT 'http://www.mondomaine.fr/concept/##value##'::character varying,
              url_counter_bdd character varying DEFAULT 'http://mondomaine.fr/concept/##conceptId##/total'::character varying,
              z3950actif boolean DEFAULT false,
              collection_adresse character varying DEFAULT 'KOHA/biblios'::character varying,
              notice_url character varying DEFAULT 'http://catalogue.mondomaine.fr/cgi-bin/koha/opac-search.pl?type=opac&op=do_search&q=an=terme'::character varying,
              url_encode character varying(10) DEFAULT 'UTF-8'::character varying,
              path_notice1 character varying DEFAULT '/var/www/notices/repositories.xml'::character varying,
              path_notice2 character varying DEFAULT '/var/www/notices/SchemaMappings.xml'::character varying,
              chemin_site character varying DEFAULT 'http://mondomaine.fr/'::character varying,
              webservices boolean DEFAULT true,
              CONSTRAINT preferences_pkey PRIMARY KEY (id_pref),
              CONSTRAINT preferences_id_thesaurus_key UNIQUE (id_thesaurus)
            )
            WITH (
              OIDS=FALSE
            );                                                       
        end;
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION ajoutercolumngps_alignement_source() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT * FROM INFORMATION_SCHEMA.COLUMNS
     WHERE COLUMN_NAME = 'gps' AND TABLE_NAME = 'alignement_source') THEN
	Execute
	'
	 Alter TABLE alignement_source ADD COLUMN gps boolean  default false;';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION alignement_preferences() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'alignement_preferences') THEN

        execute 
		'Create table alignement_preferences (
                    id integer DEFAULT nextval(''alignement_preferences_id_seq''::regclass)NOT NULL,
                    id_thesaurus character varying NOT NULL,
                    id_user integer NOT NULL,
                    id_concept_depart character varying,
                    id_concept_tratees character varying,
                    id_alignement_source integer,
                    CONSTRAINT alignement_preferences_pkey PRIMARY KEY (id_thesaurus, id_user, id_concept_depart, id_alignement_source)
                     );';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION apply_cluster(p_parent_schema text, p_parent_tablename text, p_child_schema text, p_child_tablename text) RETURNS void
    LANGUAGE plpgsql SECURITY DEFINER 
AS $$
DECLARE
    v_new_search_path   text := '@extschema@,pg_temp';
    v_old_search_path   text;
    v_parent_indexdef   text;
    v_relkind           char;
    v_row               record;
    v_sql               text;
BEGIN
/*
* Function to apply cluster from parent to child table
* Adapted from code fork by https://github.com/dturon/pg_partman
*/
    
SELECT current_setting('search_path') INTO v_old_search_path;
EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_new_search_path, 'false');

SELECT c.relkind INTO v_relkind
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE n.nspname = p_parent_schema
AND c.relname = p_parent_tablename;

IF v_relkind = 'p' THEN
    RAISE EXCEPTION 'This function cannot run on natively partitioned tables';
ELSIF v_relkind IS NULL THEN
    RAISE EXCEPTION 'Unable to find given table in system catalogs: %.%', v_parent_schema, v_parent_tablename;
END IF;

WITH parent_info AS (
    SELECT c.oid AS parent_oid 
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    WHERE n.nspname = p_parent_schema::name
    AND c.relname = p_parent_tablename::name
)
SELECT substring(pg_get_indexdef(i.indexrelid) from ' USING .*$') AS index_def
INTO v_parent_indexdef
FROM pg_catalog.pg_index i
JOIN pg_catalog.pg_class c ON i.indexrelid = c.oid
JOIN parent_info p ON p.parent_oid = indrelid
WHERE i.indisclustered = true;

-- Loop over all existing indexes in child table to find one with matching definition
FOR v_row IN
    WITH child_info AS (
        SELECT c.oid AS child_oid 
        FROM pg_catalog.pg_class c
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = p_child_schema::name
        AND c.relname = p_child_tablename::name
    )
    SELECT substring(pg_get_indexdef(i.indexrelid) from ' USING .*$') AS child_indexdef
        , c.relname AS child_indexname
    FROM pg_catalog.pg_index i
    JOIN pg_catalog.pg_class c ON i.indexrelid = c.oid
    JOIN child_info p ON p.child_oid = indrelid
LOOP
    IF v_row.child_indexdef = v_parent_indexdef THEN
        v_sql = format('ALTER TABLE %I.%I CLUSTER ON %I', p_child_schema, p_child_tablename, v_row.child_indexname);
        RAISE DEBUG '%', v_sql;
        EXECUTE v_sql;
    END IF;
END LOOP;

EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');

END;
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION arrayToArrStr(arr text[]) RETURNS text AS $$
   BEGIN
    return concat('[^[', array_to_string(arr, '^,^'), ']^]');
   END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION arrayToArrStr2(arr text[]) RETURNS text AS $$
   BEGIN
    return concat('[%[', array_to_string(arr, '%,%'), ']%]');
   END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION arrayToObjStr(arr text[]) RETURNS text AS $$
   BEGIN
    return concat('{^{', array_to_string(arr, '^:^'), '}^}');
   END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION arrayToObjStr2(arr text[]) RETURNS text AS $$
   BEGIN
    return concat('{%{', array_to_string(arr, '%:%'), '}%}');
   END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION averageCopies()
RETURNS float AS $average$
declare
average float;
BEGIN
RETURN(
SELECT AVG(pnumcopy ) �Average of copies in library� FROM print
);
END;
$average$
LANGUAGE 'plpgsql';",libraryDatabase.sql
"CREATE OR REPLACE FUNCTION avg_temp_alter(cmd VARCHAR, tablename VARCHAR , columnname VARCHAR)
RETURNS bool AS
$$
DECLARE
          querytxt text;
          onerow record;
BEGIN
	  querytxt = 'select table_name, column_name, data_type, numeric_precision , numeric_scale from information_schema.columns where table_name=' || '''' || tablename || '''' || ' and column_name=' || '''' || columnname || '''' ;
	  For onerow IN execute querytxt
	  LOOP
		  if ( onerow.data_type <> 'numeric' ) OR ( onerow.numeric_precision <> '7' ) OR (  onerow.numeric_scale <> '2' )
		  then
			execute cmd;
			return true;
		  end if;
		  return false;

	  END LOOP;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION avg_temp_alter(cmd VARCHAR, tablename VARCHAR , columnname VARCHAR)
RETURNS bool AS
$$
DECLARE
          querytxt text;
          onerow record;
BEGIN 
	  querytxt = 'select table_name, column_name, data_type, numeric_precision , numeric_scale from information_schema.columns where table_name=' || '''' || tablename || '''' || ' and column_name=' || '''' || columnname || '''' ;
	  For onerow IN execute querytxt
	  LOOP
		  if ( onerow.data_type <> 'numeric' ) OR ( onerow.numeric_precision <> '7' ) OR (  onerow.numeric_scale <> '2' )
		  then
			execute cmd;
			return true;
		  end if;
		  return false;

	  END LOOP;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getavgforcompeg(
    eg character varying,
    ev character varying,
    comp character varying)
  RETURNS integer AS
$BODY$
DECLARE average integer;

BEGIN
 SELECT AVG(note) into average FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.label_eg = eg AND
 v_resultats_eg_ev_comp.label_eval = ev AND
 v_resultats_eg_ev_comp.label_comp = comp;
 
 RETURN average;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getavgforcompeg(
    eg character varying,
    ev character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE average integer;

BEGIN
 SELECT AVG(note) into average FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.ap = eg AND
 v_resultats_eg_ev_comp.travail = ev AND
 v_resultats_eg_ev_comp.competence = comp;
 
 RETURN average;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getecarttypeforcompeg(
    eg character varying,
    ev character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE et integer;

BEGIN
 SELECT stddev(note) into et FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.ap = eg AND
 v_resultats_eg_ev_comp.travail = ev AND
 v_resultats_eg_ev_comp.competence = comp;

  IF et = NULL THEN
    et := 0;
 END IF;
 
 RETURN et;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getgroupavgforcompeg(
    semestre character varying,
    eg character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE average integer;

BEGIN
 SELECT AVG(total) into average FROM bulletin.v_totals_comp 
 WHERE 
 v_totals_comp.session = semestre AND
 v_totals_comp.ap = eg AND
 v_totals_comp.competence = comp;
 
 RETURN average;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getgroupavgfortravail(
    semestre character varying,
    eg character varying,
    ev character varying)
  RETURNS integer AS
$BODY$
DECLARE travavg integer;

BEGIN
 SELECT AVG(total) into travavg FROM bulletin.v_totals_ap
 WHERE 
 v_totals_ap.session = semestre AND
 v_totals_ap.ap = eg AND
 v_totals_ap.travail = ev;
 
 RETURN travavg;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getgroupecrtforcompeg(
    semestre character varying,
    eg character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE et integer;

BEGIN
 SELECT stddev(total) into et FROM bulletin.v_totals_comp 
 WHERE 
 v_totals_comp.session = semestre AND
 v_totals_comp.ap = eg AND
 v_totals_comp.competence = comp;
 
 RETURN et;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getgroupecrtfortravail(
    semestre character varying,
    eg character varying,
    ev character varying)
  RETURNS integer AS
$BODY$
DECLARE travavg integer;

BEGIN
 SELECT stddev(total) into travavg FROM bulletin.v_totals_ap
 WHERE 
 v_totals_ap.session = semestre AND
 v_totals_ap.ap = eg AND
 v_totals_ap.travail = ev;
 
 RETURN travavg;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getpondforcompeg(
    cip character varying,
    eg character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE pondsum integer;

BEGIN
 SELECT SUM(maxpoints) into pondsum FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.student_id = cip AND
 v_resultats_eg_ev_comp.AP = eg AND
 v_resultats_eg_ev_comp.competence = comp;
 
 RETURN pondsum;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getpondfortravail(
    cip character varying,
    eg character varying,
    ev character varying)
  RETURNS integer AS
$BODY$
DECLARE pondsum integer;

BEGIN
 SELECT SUM(maxpoints) into pondsum FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.student_id = cip AND
 v_resultats_eg_ev_comp.AP = eg AND
 v_resultats_eg_ev_comp.travail = ev;
 
 RETURN pondsum;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getsumforcompeg(
    cip character varying,
    eg character varying,
    comp integer)
  RETURNS integer AS
$BODY$
DECLARE compsum integer;

BEGIN
 SELECT SUM(note) into compsum FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.student_id = cip AND
 v_resultats_eg_ev_comp.AP = eg AND
 v_resultats_eg_ev_comp.competence = comp;
 
 RETURN compsum;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bulletin.f_getsumfortravail(
    cip character varying,
    eg character varying,
    ev character varying)
  RETURNS integer AS
$BODY$
DECLARE travsum integer;

BEGIN
 SELECT SUM(note) into travsum FROM bulletin.v_resultats_eg_ev_comp 
 WHERE 
 v_resultats_eg_ev_comp.student_id = cip AND
 v_resultats_eg_ev_comp.AP = eg AND
 v_resultats_eg_ev_comp.travail = ev;
 
 RETURN travsum;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",bulletin_schema_all.sql
"CREATE OR REPLACE FUNCTION bytea_import(p_path text, p_result out bytea) 
                   LANGUAGE plpgsql as $$
DECLARE
  l_oid oid;
  r record;
BEGIN
  p_result := '';
  select lo_import(p_path) into l_oid;
  for r in ( select data 
             from pg_largeobject 
             where loid = l_oid 
             order by pageno ) loop
    p_result = p_result || r.data;
  end loop;
  perform lo_unlink(l_oid);
END;
$$;",replicacao-logica-com-o-londiste.md
"CREATE OR REPLACE FUNCTION c_getDefaultDocInfo(p_tablename character varying, p_idvalue character varying,OUT ad_org_id character varying, OUT  document_id character varying, OUT docstatus  character varying,OUT   docTypeTargetId  character varying, OUT  ourreference  character varying, OUT  cusreference  character varying, OUT  bpartner_id  character varying, OUT  bpartner_language  character varying, OUT  unique_timestamp  character varying, OUT  bpartner_name  character varying, OUT  orga  character varying, OUT  docname  character varying)
  RETURNS setof record AS
$BODY$ 
DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
 
 Default Doc-Info Used in Print-Controller
 
*****************************************************/
v_doctypeid varchar;

BEGIN
if p_tablename='C_PROJECT' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Project';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='C_PROJECTTASK' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Projecttask';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEP_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Workstep';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='C_BPARTNEREMPLOYEE_VIEW' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Employee';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,'',p.c_bpartner_id,p.ad_language, 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from C_BPARTNEREMPLOYEE_VIEW p where C_BPARTNEREMPLOYEE_VIEW_id=p_idvalue;
elsif p_tablename='SNR_MASTERDATA' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Serialnumber';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.serialnumber,'','','', 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from SNR_MASTERDATA p where SNR_MASTERDATA_id=p_idvalue;
elsif p_tablename='ZSSM_PRODUCTIONORDER_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Productionorder';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEPACTIVITIES_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'WorkstepActivity';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt,zspm_ptaskhrplan hr where pt.c_project_id=p.c_project_id 
         and pt.c_projecttask_id=hr. c_projecttask_id and hr.zspm_ptaskhrplan_id=p_idvalue;
end if;
    return next;
END ; $BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;

  
CREATE OR REPLACE FUNCTION getDocStatus(p_table_id character varying,p_currentvalue character varying)
  RETURNS character varying AS
$BODY$ DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2012 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
*/
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_sql character varying;
v_keycolumname character varying;
v_columnid character varying;
v_tablename character varying;
v_result character varying;
BEGIN
  if p_table_id is not null then
      select columnname,tablename into v_keycolumname,v_tablename from ad_column,ad_table where 
              ad_table.ad_table_id=ad_column.ad_table_id and iskey='Y' and ad_table.ad_table_id=p_table_id;
      v_sql:='select docstatus from '||v_tablename||' where '||v_keycolumname||' = '|| chr(39)||coalesce(p_currentvalue,'')||chr(39);
      OPEN v_cursor FOR EXECUTE v_sql;
      LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_result:=v_cur.docstatus;
      END LOOP;
      close v_cursor;
  end if;   
  RETURN v_result;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE OR REPLACE FUNCTION c_getDefaultDocInfo(p_tablename character varying, p_idvalue character varying,OUT ad_org_id character varying, OUT  document_id character varying, OUT docstatus  character varying,OUT   docTypeTargetId  character varying, OUT  ourreference  character varying, OUT  cusreference  character varying, OUT  bpartner_id  character varying, OUT  bpartner_language  character varying, OUT  unique_timestamp  character varying, OUT  bpartner_name  character varying, OUT  orga  character varying, OUT  docname  character varying)
  RETURNS setof record AS
$BODY$ 
DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
 
 Default Doc-Info Used in Print-Controller
 
*****************************************************/
v_doctypeid varchar;

BEGIN
if p_tablename='C_PROJECT' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Project';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.value||'-'||p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='C_PROJECTTASK' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Projecttask';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEP_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Workstep';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='C_BPARTNEREMPLOYEE_VIEW' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Employee';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,replace(p.name,',',''),'',p.c_bpartner_id,p.ad_language, 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from C_BPARTNEREMPLOYEE_VIEW p where C_BPARTNEREMPLOYEE_VIEW_id=p_idvalue;
    elsif p_tablename='A_ASSET' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Asset';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,'','','','', 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from a_asset p where a_asset_id=p_idvalue;
elsif p_tablename='SNR_MASTERDATA' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Serialnumber';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.serialnumber,'','','', 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from SNR_MASTERDATA p where SNR_MASTERDATA_id=p_idvalue;
elsif p_tablename='ZSSM_PRODUCTIONORDER_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Productionorder';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEPACTIVITIES_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'WorkstepActivity';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt,zspm_ptaskhrplan hr where pt.c_project_id=p.c_project_id 
         and pt.c_projecttask_id=hr. c_projecttask_id and hr.zspm_ptaskhrplan_id=p_idvalue;
elsif p_tablename='C_BPARTNER' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'BusinessPartner';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,'',p.c_bpartner_id,
           p.ad_language , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name ,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_bpartner p where p.c_bpartner_id=p_idvalue;
elsif p_tablename='M_REQUISITION' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Requisition';
    select p.ad_org_id,p_idvalue,p.docstatus,v_doctypeid,p.documentno,'',p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from m_requisition p where p.m_requisition_id=p_idvalue;
elsif p_tablename='C_CASH' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Cashbook';
    select p.ad_org_id,p_idvalue,p.docstatus,v_doctypeid,p.name,'','',
           'de_DE' , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_cash p where p.c_cash_id=p_idvalue;
else 
    if p_tablename is not null then 
        raise exception '%','This Doctype must be added to the  c_getDefaultDocInfo - Function';
    end if;
end if;
    return next;
END ; $BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;

  
CREATE OR REPLACE FUNCTION getDocStatus(p_table_id character varying,p_currentvalue character varying)
  RETURNS character varying AS
$BODY$ DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2012 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
*/
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_sql character varying;
v_keycolumname character varying;
v_columnid character varying;
v_tablename character varying;
v_result character varying;
BEGIN
  if p_table_id is not null then
      select columnname,tablename into v_keycolumname,v_tablename from ad_column,ad_table where 
              ad_table.ad_table_id=ad_column.ad_table_id and iskey='Y' and ad_table.ad_table_id=p_table_id;
      v_sql:='select docstatus from '||v_tablename||' where '||v_keycolumname||' = '|| chr(39)||coalesce(p_currentvalue,'')||chr(39);
      OPEN v_cursor FOR EXECUTE v_sql;
      LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_result:=v_cur.docstatus;
      END LOOP;
      close v_cursor;
  end if;   
  RETURN v_result;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE OR REPLACE FUNCTION c_getDefaultDocInfo(p_tablename character varying, p_idvalue character varying,OUT ad_org_id character varying, OUT  document_id character varying, OUT docstatus  character varying,OUT   docTypeTargetId  character varying, OUT  ourreference  character varying, OUT  cusreference  character varying, OUT  bpartner_id  character varying, OUT  bpartner_language  character varying, OUT  unique_timestamp  character varying, OUT  bpartner_name  character varying, OUT  orga  character varying, OUT  docname  character varying)
  RETURNS setof record AS
$BODY$ 
DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
 
 Default Doc-Info Used in Print-Controller
 
*****************************************************/
v_doctypeid varchar;

BEGIN
if p_tablename='C_PROJECT' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Project';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.value||'-'||p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='C_PROJECTTASK' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Projecttask';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEP_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Workstep';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt where pt.c_project_id=p.c_project_id and pt.c_projecttask_id=p_idvalue;
elsif p_tablename='C_BPARTNEREMPLOYEE_VIEW' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Employee';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,replace(p.name,',',''),'',p.c_bpartner_id,p.ad_language, 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from C_BPARTNEREMPLOYEE_VIEW p where C_BPARTNEREMPLOYEE_VIEW_id=p_idvalue;
    elsif p_tablename='A_ASSET' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Asset';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,'','','','', 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from a_asset p where a_asset_id=p_idvalue;
elsif p_tablename='SNR_MASTERDATA' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Serialnumber';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.serialnumber,'','','', 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from SNR_MASTERDATA p where SNR_MASTERDATA_id=p_idvalue;
elsif p_tablename='ZSSM_PRODUCTIONORDER_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Productionorder';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p where c_project_id=p_idvalue;
elsif p_tablename='ZSSM_WORKSTEPACTIVITIES_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'WorkstepActivity';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,p.poreference,p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_project p, c_projecttask pt,zspm_ptaskhrplan hr where pt.c_project_id=p.c_project_id 
         and pt.c_projecttask_id=hr. c_projecttask_id and hr.zspm_ptaskhrplan_id=p_idvalue;
elsif p_tablename='C_BPARTNER' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'BusinessPartner';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,'',p.c_bpartner_id,
           p.ad_language , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           p.name ,
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_bpartner p where p.c_bpartner_id=p_idvalue;
elsif p_tablename='M_REQUISITION' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Requisition';
    select p.ad_org_id,p_idvalue,p.docstatus,v_doctypeid,p.documentno,'',p.c_bpartner_id,
           (select ad_language from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id) , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           (select name from c_bpartner b where b.c_bpartner_id=p.c_bpartner_id),
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from m_requisition p where p.m_requisition_id=p_idvalue;
elsif p_tablename='C_CASH' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Cashbook';
    select p.ad_org_id,p_idvalue,p.docstatus,v_doctypeid,p.name,'','',
           'de_DE' , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from c_cash p where p.c_cash_id=p_idvalue;
elsif p_tablename='M_RETOUR_MANAGEMENT' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Retour';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.name,'','',
           'de_DE' , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from M_RETOUR_MANAGEMENT p where p.M_RETOUR_MANAGEMENT_id=p_idvalue;
elsif p_tablename='M_PRODUCT' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Product';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,p.value||'-'||p.name,'','',
           (select ad_language from ad_client b where ad_client_id='C726FEC915A54A0995C568555DA5BB3C') , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from m_product p where m_product_id=p_idvalue;
elsif p_tablename='MRP_CRITICALITEMS_V' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Criticalitems';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,'','','',
           (select ad_language from ad_client b where ad_client_id='C726FEC915A54A0995C568555DA5BB3C') , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from MRP_CRITICALITEMS_V p where MRP_CRITICALITEMS_V_id=p_idvalue;
elsif p_tablename='M_PRODUCT_PO' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Purchasesubtab';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,'','','',
           (select ad_language from ad_client b where ad_client_id='C726FEC915A54A0995C568555DA5BB3C') , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from M_PRODUCT_PO p where M_PRODUCT_PO_id=p_idvalue;
elsif p_tablename='MRP_DELIVERIES_EXPECTED' then
    select c_doctype_id into v_doctypeid from c_doctype where name = 'Deliveriesexpected';
    select p.ad_org_id,p_idvalue,'CO',v_doctypeid,'','','',
           (select ad_language from ad_client b where ad_client_id='C726FEC915A54A0995C568555DA5BB3C') , 
           to_char(CURRENT_TIMESTAMP, 'YYDDDSSSS'), 
           '',
           zssi_juwiorgshortcut(p.ad_org_id),
           zssi_docshortcut(v_doctypeid)
    into ad_org_id,document_id,docstatus,docTypeTargetId,ourreference,cusreference,bpartner_id,bpartner_language,unique_timestamp,bpartner_name,orga,docname
    from MRP_DELIVERIES_EXPECTED p where MRP_DELIVERIES_EXPECTED_id=p_idvalue;
else 
    if p_tablename is not null then 
        raise exception '%','This Doctype must be added to the  c_getDefaultDocInfo - Function';
    end if;
end if;
    return next;
END ; $BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;

  
CREATE OR REPLACE FUNCTION getDocStatus(p_table_id character varying,p_currentvalue character varying)
  RETURNS character varying AS
$BODY$ DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2012 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
*/
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_sql character varying;
v_keycolumname character varying;
v_columnid character varying;
v_tablename character varying;
v_result character varying;
BEGIN
  if p_table_id is not null then
      select columnname,tablename into v_keycolumname,v_tablename from ad_column,ad_table where 
              ad_table.ad_table_id=ad_column.ad_table_id and iskey='Y' and ad_table.ad_table_id=p_table_id;
      v_sql:='select docstatus from '||v_tablename||' where '||v_keycolumname||' = '|| chr(39)||coalesce(p_currentvalue,'')||chr(39);
      OPEN v_cursor FOR EXECUTE v_sql;
      LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_result:=v_cur.docstatus;
      END LOOP;
      close v_cursor;
  end if;   
  RETURN v_result;
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_cash_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalCashIDs varchar;
	whereClauseStd varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalCashFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalCashIDs = '';
	if existsPosJournalIDs then
		wherePosJournalCashIDs = ' AND pj.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;
	
	-- Condición std
	whereClauseStd = 'cl.docstatus in (''CO'',''CL'')';

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalCashFunctionCall = 'c_posjournal_c_cash_v_filtered(' || parameterFunctionCall || ')';
	
	-- Consulta
	consulta = 
	'SELECT c.ad_client_id, c.ad_org_id, c.c_posjournal_id, c.ad_user_id, c.c_currency_id, c.datetrx, c.docstatus, c.cashtype AS category, c.tendertype, 
        CASE
            WHEN length(c.description::text) > 0 THEN c.description
            ELSE c.info
        END AS description, c.c_charge_id, c.chargename, c.c_cashline_id AS doc_id, 
        CASE sign(c.amount)
            WHEN (-1) THEN 0::numeric
            ELSE c.total
        END::numeric(22,2) AS ingreso, 
        CASE sign(c.amount)
            WHEN (-1) THEN abs(c.total)
            ELSE 0::numeric
        END::numeric(22,2) AS egreso, c.c_invoice_id, c.invoice_documentno, c.invoice_grandtotal, c.entidadfinanciera_value, c.entidadfinanciera_name, c.bp_entidadfinanciera_value, c.bp_entidadfinanciera_name, c.cupon, c.creditcard, NULL::unknown AS generated_invoice_documentno, c.allocation_active, c.c_pos_id, c.posname
   FROM ( SELECT cl.ad_client_id, cl.ad_org_id, cl.c_cashline_id, c.c_posjournal_id, pj.ad_user_id, cl.c_currency_id, c.statementdate::date AS datetrx, cl.docstatus, cl.description, pjp.info, pjp.tendertype, cl.cashtype, ch.c_charge_id, ch.name AS chargename, sum(currencybase(pjp.amount, pjp.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id))::numeric(22,2) AS total, pjp.invoice_documentno, currencybase(pjp.invoice_grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(22,2) as invoice_grandtotal, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, cl.amount, pjp.isactive AS allocation_active, pjp.c_invoice_id, pos.c_pos_id, pos.name AS posname
           FROM c_cashline cl
      JOIN c_cash c ON c.c_cash_id = cl.c_cash_id
   JOIN ' || posJournalCashFunctionCall || ' pjp ON pjp.c_cashline_id = cl.c_cashline_id
   JOIN c_posjournal pj ON pj.c_posjournal_id = c.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   LEFT JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
   LEFT JOIN c_charge ch ON ch.c_charge_id = cl.c_charge_id
   WHERE ' || whereClauseStd || wherePosJournalCashIDs ||
   ' GROUP BY cl.ad_client_id, cl.ad_org_id, cl.c_cashline_id, c.c_posjournal_id, pj.ad_user_id, cl.c_currency_id, c.statementdate::date, cl.docstatus, cl.description, pjp.info, pjp.tendertype, cl.cashtype, ch.c_charge_id, ch.name, pjp.invoice_documentno, pjp.invoice_grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, cl.amount, pjp.isactive, pjp.c_invoice_id, pos.c_pos_id, pos.name) c;';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_credit_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalCreditIDs varchar;
	whereClauseStd varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalCreditFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalCreditIDs = '';
	if existsPosJournalIDs then
		wherePosJournalCreditIDs = ' AND pj.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;
	
	-- Condición std
	whereClauseStd = 'i.docstatus in (''CO'',''CL'')';

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalCreditFunctionCall = 'c_posjournal_c_invoice_credit_v_filtered(' || parameterFunctionCall || ')';
	
	-- Consulta
	consulta = 
	'SELECT i.ad_client_id, i.ad_org_id, i.c_posjournal_id, i.ad_user_id, i.c_currency_id, i.dateinvoiced AS datetrx, i.docstatus, NULL::unknown AS category, i.tendertype, (i.documentno::text || '' ''::text) || COALESCE(i.description, ''''::character varying)::text AS description, i.c_charge_id, i.chargename, i.c_invoice_id AS doc_id, i.total AS ingreso, 0 AS egreso, i.invoice_id AS c_invoice_id, i.invoice_documentno, i.invoice_grandtotal, i.entidadfinanciera_value, i.entidadfinanciera_name, i.bp_entidadfinanciera_value, i.bp_entidadfinanciera_name, i.cupon, i.creditcard, NULL::unknown AS generated_invoice_documentno, i.allocation_active, i.c_pos_id, i.posname
   FROM ( SELECT i.ad_client_id, i.ad_org_id, i.documentno, i.description, ah.c_posjournal_id, pj.ad_user_id, i.c_invoice_id, i.c_currency_id, i.docstatus, pjp.tendertype, i.dateinvoiced::date AS dateinvoiced, i.c_bpartner_id, i.c_doctype_id, ch.c_charge_id, ch.name AS chargename, sum(currencybase(pjp.amount, pjp.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(22,2))::numeric(22,2) AS total, pjp.invoice_documentno, currencybase(pjp.invoice_grandtotal, si.c_currency_id, si.dateacct, si.ad_client_id, si.ad_org_id)::numeric(22,2) as invoice_grandtotal, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive AS allocation_active, pjp.c_invoice_id AS invoice_id, pos.c_pos_id, pos.name AS posname
           FROM c_invoice i
      JOIN ' || posJournalCreditFunctionCall || ' pjp ON pjp.c_invoice_credit_id = i.c_invoice_id
   JOIN c_allocationhdr ah ON ah.c_allocationhdr_id = pjp.c_allocationhdr_id
   JOIN c_posjournal pj ON pj.c_posjournal_id = ah.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   LEFT JOIN c_invoice si ON si.c_invoice_id = pjp.c_invoice_id
   LEFT JOIN c_charge ch ON ch.c_charge_id = i.c_charge_id
   WHERE ' || whereClauseStd || wherePosJournalCreditIDs ||
  ' GROUP BY i.ad_client_id, i.ad_org_id, i.documentno, i.description, ah.c_posjournal_id, pj.ad_user_id, i.c_invoice_id, i.c_currency_id, i.docstatus, pjp.tendertype, i.dateinvoiced::date, i.c_bpartner_id, i.c_doctype_id, ch.c_charge_id, ch.name, pjp.invoice_documentno, pjp.invoice_grandtotal, si.c_currency_id, si.dateacct, si.ad_client_id, si.ad_org_id, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive, pjp.c_invoice_id, pos.c_pos_id, pos.name) i
   JOIN c_doctype dt ON i.c_doctype_id = dt.c_doctype_id';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_payments_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalPaymentsIDs varchar;
	whereClauseStd varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalPaymentsFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalPaymentsIDs = '';
	if existsPosJournalIDs then
		wherePosJournalPaymentsIDs = ' AND pj.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;
	
	-- Condición std
	whereClauseStd = 'p.docstatus in (''CO'',''CL'')';

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalPaymentsFunctionCall = 'c_posjournal_c_payment_v_filtered(' || parameterFunctionCall || ')';
	
	-- Consulta
	consulta = 
	'SELECT p.ad_client_id, p.ad_org_id, p.c_posjournal_id, p.ad_user_id, p.c_currency_id, p.datetrx, p.docstatus, NULL::text AS category, p.tendertype, (p.documentno::text || '' ''::text) || COALESCE(p.description, ''''::character varying)::text AS description, p.c_charge_id, p.chargename, p.c_payment_id AS doc_id, 
        CASE WHEN (p.total * p.signo_issotrx) < 0 
            THEN abs(p.total)
            ELSE 0::numeric
        END::numeric(22,2) AS ingreso, 
        CASE WHEN (p.total * p.signo_issotrx) >= 0 
	    THEN abs(p.total)
            ELSE 0::numeric
        END::numeric(22,2) AS egreso, p.c_invoice_id, p.invoice_documentno, p.invoice_grandtotal, p.entidadfinanciera_value, p.entidadfinanciera_name, p.bp_entidadfinanciera_value, p.bp_entidadfinanciera_name, p.cupon, p.creditcard, NULL::unknown AS generated_invoice_documentno, p.allocation_active, p.c_pos_id, p.posname, p.m_entidadfinanciera_id
   FROM ( SELECT p.ad_client_id, p.ad_org_id, p.c_payment_id, p.c_posjournal_id, pj.ad_user_id, p.c_currency_id, p.datetrx::date AS datetrx, p.docstatus, p.documentno, p.description, p.isreceipt, p.tendertype, ch.c_charge_id, ch.name AS chargename, 
		sum(currencybase(pjp.amount, pjp.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id) + 
                CASE
                    WHEN p.tendertype = ''C''::bpchar THEN pjp.changeamt
                    ELSE 0::numeric
                END)::numeric(22,2) AS total, pjp.invoice_documentno, 
                (currencybase(pjp.invoice_grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id) + 
                CASE
                    WHEN p.tendertype = ''C''::bpchar THEN pjp.changeamt
                    ELSE 0::numeric
                END)::numeric(20,2) AS invoice_grandtotal, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive AS allocation_active, pjp.c_invoice_id, pos.c_pos_id, pos.name AS posname, pjp.m_entidadfinanciera_id, dt.signo_issotrx
           FROM c_payment p
           INNER JOIN c_doctype dt on dt.c_doctype_id = p.c_doctype_id
      JOIN ' || posJournalPaymentsFunctionCall || ' pjp ON pjp.c_payment_id = p.c_payment_id
   JOIN c_posjournal pj ON pj.c_posjournal_id = p.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   LEFT JOIN c_charge ch ON ch.c_charge_id = p.c_charge_id
   LEFT JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
  WHERE ' || whereClauseStd || wherePosJournalPaymentsIDs ||
  ' AND (i.c_invoice_id IS NULL OR NOT (EXISTS ( SELECT cl.c_cashline_id
   FROM c_cashline cl
  WHERE cl.c_payment_id = p.c_payment_id AND i.isvoidable = ''Y''::bpchar)))
GROUP BY p.ad_client_id, p.ad_org_id, p.c_payment_id, p.c_posjournal_id, pj.ad_user_id, p.c_currency_id, p.datetrx::date, p.docstatus, p.documentno, p.description, p.isreceipt, p.tendertype, ch.c_charge_id, ch.name, pjp.invoice_documentno, pjp.invoice_grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id, pjp.changeamt, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive, pjp.c_invoice_id, pos.c_pos_id, pos.name, pjp.m_entidadfinanciera_id, dt.signo_issotrx) p;';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_payments_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalPaymentsIDs varchar;
	whereClauseStd varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalPaymentsFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalPaymentsIDs = '';
	if existsPosJournalIDs then
		wherePosJournalPaymentsIDs = ' AND pj.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;
	
	-- Condición std
	whereClauseStd = 'p.docstatus in (''CO'',''CL'')';

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalPaymentsFunctionCall = 'c_posjournal_c_payment_v_filtered(' || parameterFunctionCall || ')';
	
	-- Consulta
	consulta = 
	'SELECT p.ad_client_id, p.ad_org_id, p.c_posjournal_id, p.ad_user_id, p.c_currency_id, p.datetrx, p.docstatus, NULL::text AS category, p.tendertype, (p.documentno::text || '' ''::text) || COALESCE(p.description, ''''::character varying)::text AS description, p.c_charge_id, p.chargename, p.c_payment_id AS doc_id, 
        CASE WHEN (p.total * p.signo_issotrx) < 0 
            THEN abs(p.total)
            ELSE 0::numeric
        END::numeric(22,2) AS ingreso, 
        CASE WHEN (p.total * p.signo_issotrx) >= 0 
	    THEN abs(p.total)
            ELSE 0::numeric
        END::numeric(22,2) AS egreso, p.c_invoice_id, p.invoice_documentno, p.invoice_grandtotal, p.entidadfinanciera_value, p.entidadfinanciera_name, p.bp_entidadfinanciera_value, p.bp_entidadfinanciera_name, p.cupon, p.creditcard, NULL::unknown AS generated_invoice_documentno, p.allocation_active, p.c_pos_id, p.posname, p.m_entidadfinanciera_id
   FROM ( SELECT p.ad_client_id, p.ad_org_id, p.c_payment_id, p.c_posjournal_id, pj.ad_user_id, p.c_currency_id, p.datetrx::date AS datetrx, p.docstatus, p.documentno, p.description, p.isreceipt, p.tendertype, ch.c_charge_id, ch.name AS chargename, sum(pjp.amount + 
                CASE
                    WHEN p.tendertype = ''C''::bpchar THEN pjp.changeamt
                    ELSE 0::numeric
                END)::numeric(22,2) AS total, pjp.invoice_documentno, (pjp.invoice_grandtotal + 
                CASE
                    WHEN p.tendertype = ''C''::bpchar THEN pjp.changeamt
                    ELSE 0::numeric
                END)::numeric(20,2) AS invoice_grandtotal, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive AS allocation_active, pjp.c_invoice_id, pos.c_pos_id, pos.name AS posname, pjp.m_entidadfinanciera_id, dt.signo_issotrx
           FROM c_payment p
           INNER JOIN c_doctype dt on dt.c_doctype_id = p.c_doctype_id
      JOIN ' || posJournalPaymentsFunctionCall || ' pjp ON pjp.c_payment_id = p.c_payment_id
   JOIN c_posjournal pj ON pj.c_posjournal_id = p.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   LEFT JOIN c_charge ch ON ch.c_charge_id = p.c_charge_id
   LEFT JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
  WHERE ' || whereClauseStd || wherePosJournalPaymentsIDs ||
  ' AND (i.c_invoice_id IS NULL OR NOT (EXISTS ( SELECT cl.c_cashline_id
   FROM c_cashline cl
  WHERE cl.c_payment_id = p.c_payment_id AND i.isvoidable = ''Y''::bpchar)))
  GROUP BY p.ad_client_id, p.ad_org_id, p.c_payment_id, p.c_posjournal_id, pj.ad_user_id, p.c_currency_id, p.datetrx::date, p.docstatus, p.documentno, p.description, p.isreceipt, p.tendertype, ch.c_charge_id, ch.name, pjp.invoice_documentno, pjp.invoice_grandtotal, pjp.changeamt, pjp.entidadfinanciera_value, pjp.entidadfinanciera_name, pjp.bp_entidadfinanciera_value, pjp.bp_entidadfinanciera_name, pjp.cupon, pjp.creditcard, pjp.isactive, pjp.c_invoice_id, pos.c_pos_id, pos.name, pjp.m_entidadfinanciera_id, dt.signo_issotrx) p;';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_ventas_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalInvoicesIDs varchar;
	wherePosJournalAllocationsIDs varchar;
	whereClauseStd varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalInvoicesFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalInvoicesIDs = '';
	wherePosJournalAllocationsIDs = '';
	if existsPosJournalIDs then
		wherePosJournalInvoicesIDs = ' AND i.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
		wherePosJournalAllocationsIDs = ' AND ah.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;
	
	-- Condición std
	whereClauseStd = 'i.docstatus in (''CO'',''CL'')';

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalInvoicesFunctionCall = 'c_posjournalinvoices_v_filtered(' || parameterFunctionCall || ')';
	
	-- Consulta
	consulta = 
	'SELECT i.ad_client_id, i.ad_org_id, i.c_posjournal_id, i.ad_user_id, i.c_currency_id, i.dateinvoiced AS datetrx, i.docstatus, NULL::unknown AS category, dt.docbasetype AS tendertype, (i.documentno::text || '' ''::text) || COALESCE(i.description, ''''::character varying)::text AS description, i.c_charge_id, i.chargename, i.c_invoice_id AS doc_id, 
        CASE dt.signo_issotrx
            WHEN 1 THEN i.ca_amount
            WHEN (-1) THEN 0::numeric
            ELSE NULL::numeric
        END::numeric(22,2) AS ingreso, 
        CASE dt.signo_issotrx
            WHEN 1 THEN 0::numeric
            WHEN (-1) THEN abs(i.ca_amount)
            ELSE NULL::numeric
        END::numeric(22,2) AS egreso, i.c_invoice_id, i.documentno AS invoice_documentno, i.total AS invoice_grandtotal, NULL::unknown AS entidadfinanciera_value, NULL::unknown AS entidadfinanciera_name, NULL::unknown AS bp_entidadfinanciera_value, NULL::unknown AS bp_entidadfinanciera_name, NULL::unknown AS cupon, NULL::unknown AS creditcard, NULL::unknown AS generated_invoice_documentno, i.allocation_active, i.c_pos_id, i.posname
   FROM ( SELECT DISTINCT i.ad_client_id, i.ad_org_id, i.documentno, inv.description, i.c_posjournal_id, pj.ad_user_id, i.c_invoice_id, i.c_currency_id, i.docstatus, i.dateinvoiced::date AS dateinvoiced, i.c_bpartner_id, i.c_doctype_id, ch.c_charge_id, ch.name AS chargename, currencybase(i.grandtotal, i.c_currency_id, i.dateacct::timestamp with time zone, i.ad_client_id, i.ad_org_id)::numeric(22,2) AS total, COALESCE(ds.amount, 0::numeric)::numeric(22,2) AS ca_amount, i.allocation_active, pos.c_pos_id, pos.name AS posname
           FROM ' || posJournalInvoicesFunctionCall || ' i
      JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   JOIN c_invoice inv ON i.c_invoice_id = inv.c_invoice_id
   LEFT JOIN ( SELECT al.c_invoice_id, ah.c_posjournal_id, sum(al.amount) AS amount
    FROM c_allocationhdr ah
   JOIN c_allocationline al ON al.c_allocationhdr_id = ah.c_allocationhdr_id
   JOIN c_invoice i ON i.c_invoice_id = al.c_invoice_id
  WHERE ' || whereClauseStd || wherePosJournalAllocationsIDs ||
  ' AND ah.isactive = ''Y''::bpchar AND i.isvoidable = ''N''::bpchar
  GROUP BY al.c_invoice_id, ah.c_posjournal_id) ds ON ds.c_invoice_id = inv.c_invoice_id AND pj.c_posjournal_id = ds.c_posjournal_id
   LEFT JOIN c_charge ch ON ch.c_charge_id = inv.c_charge_id
   WHERE '  || whereClauseStd || wherePosJournalInvoicesIDs ||
  ' ORDER BY i.ad_client_id, i.ad_org_id, i.documentno, inv.description, i.c_posjournal_id, pj.ad_user_id, i.c_invoice_id, i.c_currency_id, i.docstatus, i.dateinvoiced::date, i.c_bpartner_id, i.c_doctype_id, ch.c_charge_id, ch.name, currencybase(i.grandtotal, i.c_currency_id, i.dateacct::timestamp with time zone, i.ad_client_id, i.ad_org_id)::numeric(22,2), COALESCE(ds.amount, 0::numeric)::numeric(22,2), i.allocation_active, pos.c_pos_id, pos.name) i
   JOIN c_doctype dt ON i.c_doctype_id = dt.c_doctype_id;';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION c_pos_declaracionvalores_voided_filtered(posjournalids anyarray)
  RETURNS SETOF c_pos_declaracionvalores_type AS
$BODY$
declare
	consulta varchar;
	wherePosJournalAllocationsIDs varchar;
	existsPosJournalIDs boolean;
	parameterFunctionCall varchar;
	posJournalInvoicesFunctionCall varchar;
	adocument c_pos_declaracionvalores_type;
BEGIN
	-- Armado de condiciones de filtro parámetro
	existsPosJournalIDs = posjournalIDs is not null and array_length(posjournalIDs,1) > 0 and posjournalIDs[1] <> -1;
	
	-- Filtro de cajas diarias
	wherePosJournalAllocationsIDs = '';
	if existsPosJournalIDs then
		wherePosJournalAllocationsIDs = ' AND ji.c_posjournal_id IN ('|| array_to_string(posjournalIDs, ',') || ')';
	end if;

	-- Armado del parámetro a la función c_posjournalinvoices_v_filtered
	parameterFunctionCall = 'array[-1]';
	if existsPosJournalIDs then
		parameterFunctionCall = 'ARRAY[' || array_to_string(posjournalIDs, ',') || ']';
	end if;
	
	-- Armado de llamado a función c_posjournalinvoices_v_filtered
	posJournalInvoicesFunctionCall = 'c_posjournalinvoices_v_filtered(' || parameterFunctionCall || ', false)';
	
	-- Consulta
	consulta = 
	'SELECT ji.ad_client_id, ji.ad_org_id, ji.c_posjournal_id, pj.ad_user_id, ji.c_currency_id, ji.dateinvoiced AS datetrx, ji.docstatus, NULL::unknown AS category, ji.docbasetype AS tendertype, (ji.documentno::text || '' ''::text) || COALESCE(ji.description, ''''::character varying)::text AS description, NULL::unknown AS c_charge_id, NULL::unknown AS chargename, ji.c_invoice_id AS doc_id, ji.signo_issotrx::numeric * currencybase(ji.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric + COALESCE(( SELECT sum(al2.changeamt) AS sum
           FROM c_allocationline al2
      JOIN c_payment p2 ON p2.c_payment_id = al2.c_payment_id
   JOIN c_cashline cl ON cl.c_payment_id = p2.c_payment_id
  WHERE al2.c_invoice_id = ji.c_invoice_id AND p2.tendertype = ''C''::bpchar AND al2.isactive = ''N''::bpchar), 0::numeric) AS ingreso, 0::numeric(22,2) AS egreso, ji.c_invoice_id, ji.documentno AS invoice_documentno, ji.grandtotal AS invoice_grandtotal, NULL::unknown AS entidadfinanciera_value, NULL::unknown AS entidadfinanciera_name, NULL::unknown AS bp_entidadfinanciera_value, NULL::unknown AS bp_entidadfinanciera_name, NULL::unknown AS cupon, NULL::unknown AS creditcard, ic.documentno AS generated_invoice_documentno, ji.allocation_active, pos.c_pos_id, pos.name AS posname
   FROM ' || posJournalInvoicesFunctionCall || ' ji
   JOIN c_posjournal pj ON ji.c_posjournal_id = pj.c_posjournal_id
   JOIN c_pos pos ON pos.c_pos_id = pj.c_pos_id
   JOIN c_allocationline al ON al.c_allocationhdr_id = ji.c_allocationhdr_id
   JOIN c_invoice i ON i.c_invoice_id = al.c_invoice_id
   JOIN c_invoice ic ON al.c_invoice_credit_id = ic.c_invoice_id
  WHERE (ji.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) ' || wherePosJournalAllocationsIDs || 
  ' AND (ji.isfiscal IS NULL OR ji.isfiscal = ''N''::bpchar OR ji.isfiscal = ''Y''::bpchar AND ji.fiscalalreadyprinted = ''Y''::bpchar) AND i.isvoidable = ''N''::bpchar;';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION cadastre.get_map_center_label(center_point geometry)
RETURNS character varying AS $BODY$ begin
return coalesce((select 'Public Display Area:' || label from cadastre.spatial_unit_group
where hierarchy_level = 4 and st_within(center_point, geom) limit 1), ''); end;
$BODY$ LANGUAGE plpgsql;",spatial_config.sql
"CREATE OR REPLACE FUNCTION cadastre.get_map_center_label(center_point geometry)
RETURNS character varying AS $BODY$ begin
return coalesce((select 'Section:' || label from cadastre.spatial_unit_group
where hierarchy_level = 4 and st_within(center_point, geom) limit 1), ''); end;
$BODY$ LANGUAGE plpgsql;",spatial_config.sql
"CREATE OR REPLACE FUNCTION cantidadDeComentariosBuenos(idPeliculap int) RETURNS int AS 
$$
DECLARE	
	numeroTotal int default 0;
	porcentaje int default 0;
	numeroNegativos int default 0;
	r record;
	c CURSOR FOR SELECT * FROM 
			(select * from dbLink('host = localhost user= postgres password= 12345 dbname= multimedia',
			'SELECT descripcion FROM comentario  where idPelicula = '''||idPeliculap||'''')
			as estudiantes(descripcion varchar(500)))as comentarios;	
BEGIN	
	FOR r IN c LOOP		
		numeroTotal= numeroTotal + 1;
		RAISE NOTICE 'descripcion: %', r.descripcion;			
		if r.descripcion similar to '%esta bien fe%' 			or r.descripcion similar to '%no esta para nada bonit%' 	or r.descripcion similar to '%esta fe%' 
			or r.descripcion similar to '%esta bien fe%'    	or r.descripcion similar to '%esta aburrid%'			or r.descripcion similar to '%estuvo aburrid%'
			or r.descripcion similar to '%esta horrible%'   	or r.descripcion similar to '%estuvo horrible%' 		or r.descripcion similar to '%no me gusto%' 
			or r.descripcion similar to '%no me encanto%'   	or r.descripcion similar to '%no es atractiv%' 			or r.descripcion similar to '%no es genial%' 
			or r.descripcion similar to '%no es para nada genial%'  or r.descripcion similar to '%no es en lo absoluto genial%' 
			or r.descripcion similar to '%no posee nada atractiv%'  or r.descripcion similar to '%no estaba bueno%'
			
			THEN
			numeroNegativos= numeroNegativos + 1;
		end if;

		porcentaje = numeroTotal-numeroNegativos;
				
	END LOOP;
	RETURN porcentaje;
END;
$$ LANGUAGE plpgsql;",postgresProyecto.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_get_demographic_snapshot (username text, orgname text, geom geometry(Geometry, 4326), time_span text DEFAULT '2009 - 2013', geometry_level text DEFAULT '""us.census.tiger"".block_group')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_get_demographic_snapshot invoked with params (%, %, %, %, %)', username, orgname, geom, time_span, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_get_demographic_snapshot (username text, orgname text, geom geometry(Geometry, 4326), time_span text DEFAULT '2009 - 2013', geometry_level text DEFAULT '""us.census.tiger"".block_group')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_get_demographic_snapshot invoked with params (%, %, %, %, %)', username, orgname, geom, time_span, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_get_segment_snapshot (username text, orgname text, geom geometry(Geometry, 4326), geometry_level text DEFAULT '""us.census.tiger"".census_tract')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_get_segment_snapshot invoked with params (%, %, %, %)', username, orgname, geom, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_get_segment_snapshot (username text, orgname text, geom geometry(Geometry, 4326), geometry_level text DEFAULT '""us.census.tiger"".census_tract')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_get_segment_snapshot invoked with params (%, %, %, %)', username, orgname, geom, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundary (username text, orgname text, geom geometry(Geometry, 4326), boundary_id text, time_span text DEFAULT NULL)
RETURNS Geometry(Geometry, 4326) AS $$
DECLARE
  ret Geometry;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundary invoked with params (%, %, %, %, %)', username, orgname, geom, boundary_id, time_span;
  SELECT '0106000020E6100000010000000103000000010000003500000056EF703B347C52C054FF2092215B44401B9AB2D30F7C52C03FE1ECD6325B4440B14B546F0D7C52C0BBCE86FC335B4440730F09DFFB7B52C0B796C9703C5B4440108FC4CBD37B52C0B96C74CE4F5B444001C0B167CF7B52C0ED0BE8853B5B4440C843DFDDCA7B52C05DDDB1D8265B4440A73D25E7C47B52C0D53BDC0E0D5B4440BB5E9A22C07B52C0F8A3A833F75A4440355F251FBB7B52C0B64604E3E05A444008910C39B67B52C098BF42E6CA5A44405227A089B07B52C0F204C24EB15A444024F1F274AE7B52C069E4F38AA75A44402B4A09C1AA7B52C06B63EC84975A4440E199D024B17B52C0546F0D6C955A44403C873254C57B52C02EAC1BEF8E5A44402593533BC37B52C0588AE42B815A4440973AC8EBC17B52C087890629785A44407A6F0C01C07B52C0E1EB6B5D6A5A44401B9B1DA9BE7B52C03F6F2A52615A444088855AD3BC7B52C088669E5C535A4440E1EA0088BB7B52C0E6E95C514A5A44400CE6AF90B97B52C070D05E7D3C5A44401E85EB51B87B52C0B03A72A4335A4440BAF3C473B67B52C09929ADBF255A4440CD920035B57B52C0454AB3791C5A4440F78DAF3DB37B52C0E09BA6CF0E5A4440DBC2F352B17B52C0703FE081015A444015C440D7BE7B52C05E83BEF4F659444041446ADAC57B52C0EFDFBC38F15944405FB1868BDC7B52C0C03E3A75E559444034BC5983F77B52C0205ED72FD8594440EFFCA204FD7B52C07E384888F25944403ACAC16C027C52C00876FC17085A444056478E74067C52C00FECF82F105A44400FECF82F107C52C0876D8B321B5A4440BB438A01127C52C0DE1CAED51E5A4440B9C15087157C52C034643C4A255A444099F221A81A7C52C0D0EFFB372F5A44404AED45B41D7C52C0785DBF60375A4440373465A71F7C52C065A71FD4455A4440C558A65F227C52C0D80DDB16655A4440F92EA52E197C52C09BA73AE4665A4440DEE522BE137C52C00664AF777F5A44405698BED7107C52C04759BF99985A444012D90759167C52C09430D3F6AF5A444044679945287C52C01F680586AC5A444049F086342A7C52C09CC3B5DAC35A44401FF5D72B2C7C52C0CB811E6ADB5A4440247EC51A2E7C52C0548B8862F25A4440FF59F3E32F7C52C0CB290131095B4440F96871C6307C52C09605137F145B444056EF703B347C52C054FF2092215B4440'::geometry INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundary (username text, orgname text, geom geometry(Geometry, 4326), boundary_id text, time_span text DEFAULT NULL)
RETURNS Geometry(Geometry, 4326) AS $$
DECLARE
  ret Geometry;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundary invoked with params (%, %, %, %, %)', username, orgname, geom, boundary_id, time_span;
  SELECT '0106000020E6100000010000000103000000010000003500000056EF703B347C52C054FF2092215B44401B9AB2D30F7C52C03FE1ECD6325B4440B14B546F0D7C52C0BBCE86FC335B4440730F09DFFB7B52C0B796C9703C5B4440108FC4CBD37B52C0B96C74CE4F5B444001C0B167CF7B52C0ED0BE8853B5B4440C843DFDDCA7B52C05DDDB1D8265B4440A73D25E7C47B52C0D53BDC0E0D5B4440BB5E9A22C07B52C0F8A3A833F75A4440355F251FBB7B52C0B64604E3E05A444008910C39B67B52C098BF42E6CA5A44405227A089B07B52C0F204C24EB15A444024F1F274AE7B52C069E4F38AA75A44402B4A09C1AA7B52C06B63EC84975A4440E199D024B17B52C0546F0D6C955A44403C873254C57B52C02EAC1BEF8E5A44402593533BC37B52C0588AE42B815A4440973AC8EBC17B52C087890629785A44407A6F0C01C07B52C0E1EB6B5D6A5A44401B9B1DA9BE7B52C03F6F2A52615A444088855AD3BC7B52C088669E5C535A4440E1EA0088BB7B52C0E6E95C514A5A44400CE6AF90B97B52C070D05E7D3C5A44401E85EB51B87B52C0B03A72A4335A4440BAF3C473B67B52C09929ADBF255A4440CD920035B57B52C0454AB3791C5A4440F78DAF3DB37B52C0E09BA6CF0E5A4440DBC2F352B17B52C0703FE081015A444015C440D7BE7B52C05E83BEF4F659444041446ADAC57B52C0EFDFBC38F15944405FB1868BDC7B52C0C03E3A75E559444034BC5983F77B52C0205ED72FD8594440EFFCA204FD7B52C07E384888F25944403ACAC16C027C52C00876FC17085A444056478E74067C52C00FECF82F105A44400FECF82F107C52C0876D8B321B5A4440BB438A01127C52C0DE1CAED51E5A4440B9C15087157C52C034643C4A255A444099F221A81A7C52C0D0EFFB372F5A44404AED45B41D7C52C0785DBF60375A4440373465A71F7C52C065A71FD4455A4440C558A65F227C52C0D80DDB16655A4440F92EA52E197C52C09BA73AE4665A4440DEE522BE137C52C00664AF777F5A44405698BED7107C52C04759BF99985A444012D90759167C52C09430D3F6AF5A444044679945287C52C01F680586AC5A444049F086342A7C52C09CC3B5DAC35A44401FF5D72B2C7C52C0CB811E6ADB5A4440247EC51A2E7C52C0548B8862F25A4440FF59F3E32F7C52C0CB290131095B4440F96871C6307C52C09605137F145B444056EF703B347C52C054FF2092215B4440'::geometry INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundarybyid (username text, orgname text, geometry_id text, boundary_id text, time_span text DEFAULT NULL)
RETURNS Geometry(Geometry, 4326) AS $$
DECLARE
  ret Geometry;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundarybyid invoked with params (%, %, %, %, %)', username, orgname, geometry_id, boundary_id, time_span;
  SELECT '0106000020E610000001000000010300000001000000930200005051F52B9D8352C042B28009DC50444093C2BCC7998352C0E89E758D965144402EFD4B52998352C09A07B0C8AF514440E75086AA988352C022FAB5F5D351444027874F3A918352C0A46B26DF6C53444018E945ED7E8352C04D81CCCEA25344401346B3B27D8352C05D50DF32A753444068226C787A8352C08D25AC8DB153444015C8EC2C7A8352C004560E2DB2534440DF8618AF798352C00FD07D39B3534440FEB627486C8352C0DC9E20B1DD534440B98C9B1A688352C05D328E91EC5344408B8A389D648352C0929048DBF853444075CAA31B618352C0986A662D05544440EA758BC0588352C0D6C397892254444048DFA469508352C0151DC9E53F544440B67F65A5498352C0F73DEAAF575444401403249A408352C05E2A36E6755444402367614F3B8352C06DE2E47E8754444011FC6F253B8352C0431B800D885444403E7958A8358352C0DD0A6135965444401D739EB12F8352C093DFA293A5544440FB04508C2C8352C035289A07B05444401EA4A7C8218352C0347F4C6BD3544440D7C05609168352C05053CBD6FA544440AC8E1CE90C8352C0C9AA083719554440FC8D76DCF08252C0BD18CA897655444048895DDBDB8252C0C3B7B06EBC554440698995D1C88252C032207BBDFB55444004A73E90BC8252C0DB4C857824564440BC1FB75F3E8252C08F368E588B574440E15D2EE23B8252C066F4A3E194574440C614AC71368252C0381268B0A9574440CEA44DD53D8152C04F1F813FFC564440A51133FB3C8152C0F607CA6DFB56444070D05E7D3C8152C0CB0C1B65FD564440C5C6BC8E388152C0F303577902574440EA043411368152C03F390A1005574440840B7904378152C0D34ECDE506574440390A1005338152C047E350BF0B5744405D143DF0318152C0D53BDC0E0D5744401D59F965308152C00A4966F50E574440236420CF2E8152C00FD253E41057444084EE92382B8152C0AD2D3C2F15574440E23D0796238152C0A304FD851E574440B3EDB435228152C001D9EBDD1F5744401EBE4C14218152C08BDCD3D51D574440A2D0B2EE1F8152C0FC1BB4571F57444007B0C8AF1F8152C0CC9717601F574440F678211D1E8152C0374E0AF31E5744401A69A9BC1D8152C0793D98141F574440102384471B8152C0CB2F833122574440B7EEE6A90E8152C09F1D705D315744405968E7340B8152C02C0E677E355744400E4A9869FB8052C0C91EA166485744401B2C9CA4F98052C05C001AA54B5744401AF8510DFB8052C0C51A2E724F574440925CFE43FA8052C0309DD66D50574440BB9866BAD78052C0035DFB027A574440A04FE449D28052C02920ED7F80574440DC9BDF30D18052C0E8305F5E80574440B43C0FEECE8052C0D8614CFA7B5744404AEEB089CC8052C0950A2AAA7E5744409A5B21ACC68052C032FE7DC6855744406682E15CC38052C01EF7ADD689574440F78DAF3DB38052C020CD58349D5744402FFA0AD28C8052C00919C8B3CB574440D0251C7A8B8052C00EA2B5A2CD57444001DE02098A8052C030444E5FCF5744404A404CC2858052C0992A1895D45744403480B740828052C0A33CF372D857444028ECA2E8818052C0CD0358E4D7574440F3AACE6A818052C074ECA012D75744402920ED7F808052C0DFA293A5D657444036E84B6F7F8052C092054CE0D6574440AD4CF8A57E8052C0E55FCB2BD757444042CA4FAA7D8052C01AA19FA9D7574440A2EC2DE57C8052C0205ED72FD8574440BB6246787B8052C08BE07F2BD95744405C74B2D47A8052C025E7C41EDA5744405CA8FC6B798052C0F52EDE8FDB574440FF0758AB768052C09AAF928FDD574440A60A4625758052C0C442AD69DE574440A73E90BC738052C05E49F25CDF574440BF9A0304738052C046ED7E15E0574440A19BFD81728052C070B4E386DF5744403D0AD7A3708052C0D0F0660DDE574440680586AC6E8052C04D469561DC57444063963D096C8052C0965AEF37DA574440944E24986A8052C0BA641C23D957444059501894698052C014B01D8CD8574440E21FB6F4688052C0614D6551D85744401895D409688052C0205ED72FD85744406379573D608052C0A4A487A1D55744401878EE3D5C8052C041B5C189E85744402F4FE78A528052C0A580B4FF01584440983270404B8052C0EECEDA6D1758444050357A35408052C0E3C281902C58444086C43D963E8052C0DC9DB5DB2E584440C5E061DA378052C0BFF2203D455844409946938B318052C0C4E9245B5D5844407C478D09318052C040A374E95F584440E3A8DC442D8052C0F92AF9D85D584440919C4CDC2A8052C06BD26D895C584440276893C3278052C0E9279CDD5A58444053B131AF238052C061C092AB5858444055336B29208052C068E55E605658444091990B5C1E8052C082C64CA25E584440AA2688BA0F8052C027F6D03E56584440F488D1730B8052C0D21C59F9655844400C1CD0D2158052C0BB96900F7A584440C6A69542208052C0B77BB94F8E584440D3A23EC91D8052C02EC901BB9A584440B6BDDD921C8052C0BF42E6CAA058444082E49D43198052C036902E36AD58444072FBE593158052C0ACA92C0ABB5844402B4F20EC148052C0EC3026FDBD584440E4BCFF8F138052C04E266E15C4584440C26856B60F8052C06E15C440D7584440C404357C0B8052C00F5EBBB4E1584440397CD289048052C0CA87A06AF4584440FB761211FE7F52C090F7AA9509594440D93C0E83F97F52C03561FBC9185944402828452BF77F52C0F06DFAB31F594440F9BD4D7FF67F52C0DC9A745B225944403AADDBA0F67F52C0BE4D7FF62359444093C49272F77F52C0526342CC25594440450DA661F87F52C0798EC87729594440F2CCCB61F77F52C0067FBF982D5944409B030473F47F52C017821C94305944401E300F99F27F52C05609168733594440E57FF277EF7F52C0EDBAB72231594440A3AA09A2EE7F52C0EA1ED95C355944405D18E945ED7F52C0D3F6AFAC345944401C5DA5BBEB7F52C076DB85E63A5944404BADF71BED7F52C0B1D991EA3B5944401F477364E57F52C0E48409A35959444022179CC1DF7F52C001D8800871594440A4703D0AD77F52C02EC6C03A8E594440457F68E6C97F52C061C26856B659444070404B57B07F52C0FCDEA63FFB594440DC10E335AF7F52C048E00F3FFF59444055F7C8E6AA7F52C02DB4739A055A4440A4E2FF8EA87F52C00CFFE9060A5A44407E8AE3C0AB7F52C0EC4960730E5A444006F2ECF2AD7F52C08CD99255115A444042588D25AC7F52C09BA8A5B9155A44405A9A5B21AC7F52C0F4BF5C8B165A44406762BA10AB7F52C0A5BA8097195A4440E5B7E864A97F52C0B6BDDD921C5A44402B4A09C1AA7F52C0499F56D11F5A4440D48041D2A77F52C0177FDB13245A4440C22FF5F3A67F52C0D55B035B255A4440FE7BF0DAA57F52C0F8FD9B17275A44409A046F48A37F52C04FADBEBA2A5A444045F12A6B9B7F52C0AC1919E42E5A44404BE2AC889A7F52C0A75CE15D2E5A4440462575029A7F52C0965984622B5A4440E75086AA987F52C0906802452C5A44400B2769FE987F52C05FB01BB62D5A444004029D499B7F52C0DD2230D6375A44404301DBC1887F52C0CBF10A444F5A4440D6A88768747F52C0B81E85EB515A44407C0C569C6A7F52C0F6CFD380415A4440CB113290677F52C0A9328CBB415A44407905A227657F52C03D7C9928425A44407EA5F3E1597F52C0787AA52C435A444009F7CABC557F52C0A2410A9E425A44408D23D6E2537F52C00EF8FC30425A444029780AB9527F52C08B19E1ED415A44402992AF04527F52C08B19E1ED415A4440C51A2E724F7F52C08B19E1ED415A4440AC36FFAF3A7F52C01AA6B6D4415A444009522976347F52C0A2410A9E425A4440F25D4A5D327F52C0252026E1425A44408252B4722F7F52C05A61FA5E435A444032E202D0287F52C013B534B7425A4440E0BBCD1B277F52C014E97E4E415A44409352D0ED257F52C0151DC9E53F5A444022F94A20257F52C0B08BA2073E5A4440CF9ECBD4247F52C0F3AE7AC03C5A444077A1B94E237F52C0F3AE7AC03C5A4440DDB419A7217F52C097FBE428405A4440666A12BC217F52C016A243E0485A44408EACFC32187F52C0CD8DE9094B5A44404F05DCF3FC7E52C0B952CF82505A4440D2E0B6B6F07E52C0FFCA4A93525A44404F029B73F07E52C0A7E7DD58505A4440EA3C2AFEEF7E52C020B41EBE4C5A44404A5F0839EF7E52C01AF7E6374C5A4440D462F030ED7E52C055F5F23B4D5A4440825660C8EA7E52C0B5FD2B2B4D5A4440825660C8EA7E52C072DA53724E5A44403C2CD49AE67E52C030B77BB94F5A44400DDC813AE57E52C0D76B7A50505A4440670DDE57E57E52C0072461DF4E5A4440C77DAB75E27E52C0A25EF0694E5A4440ABB2EF8AE07E52C04F04711E4E5A44403A3FC571E07E52C03C65355D4F5A4440643A747ADE7E52C04ED026874F5A444077F35487DC7E52C08A027D224F5A4440F0A5F0A0D97E52C031EBC5504E5A444068588CBAD67E52C0D8D30E7F4D5A444046B3B27DC87E52C06FB9FAB1495A4440B85A272EC77E52C03C821B295B5A444039CE6DC2BD7E52C097016729595A44409A07B0C8AF7E52C07FD93D79585A44407E8AE3C0AB7E52C0EBC37AA3565A4440C1E10511A97E52C0D097DEFE5C5A44401B82E3326E7E52C03F170D198F5A44408A3C49BA667E52C0D619DF17975A444026DF6C73637E52C07A32FFE89B5A4440E78BBD175F7E52C000FE2955A25A4440594DD7135D7E52C040852348A55A4440E36A64575A7E52C03EE94482A95A4440E603029D497E52C067B62BF4C15A4440ED42739D467E52C04701A260C65A4440253ACB2C427E52C03E40F7E5CC5A4440D026874F3A7E52C061C5A9D6C25A44405C5837DE1D7E52C0868F8829915A4440162EABB0197E52C007B5DFDA895A4440B859BC58187E52C083A279008B5A44408FE046CA167E52C011FB04508C5A4440B131AF230E7E52C0D2C43BC0935A44401A4CC3F0117E52C0F0FACC599F5A44401A321EA5127E52C06631B1F9B85A44402B836A83137E52C0E55C8AABCA5A4440C9737D1F0E7E52C0B376DB85E65A4440D3687231067E52C07405DB88275B444009DE9046057E52C09A94826E2F5B4440158C4AEA047E52C08D7E349C325B4440C808A870047E52C0B6114F76335B4440634337FB037E52C00F290648345B4440DAA7E331037E52C03E7958A8355B444082902C60027E52C0DE3CD521375B4440AB5791D1017E52C048BF7D1D385B4440942F6821017E52C095287B4B395B4440268C6665FB7D52C0548A1D8D435B44405C1B2AC6F97D52C065187783685B4440FA0B3D62F47D52C03FE08101845B4440E2E313B2F37D52C03196E997885B444038F4160FEF7D52C05D50DF32A75B4440109546CCEC7D52C07FDB1324B65B44401C261AA4E07D52C0BA641C23D95B444076BF0AF0DD7D52C06AF7AB00DF5B4440DCB8C5FCDC7D52C0B06F2711E15B44405A0EF450DB7D52C0081F4AB4E45B444084D558C2DA7D52C0F57F0EF3E55B4440BBB20B06D77D52C06E693524EE5B4440CE6BEC12D57D52C0FB592C45F25B444073672618CE7D52C09A0645F3005C4440BB7B80EECB7D52C0C7BAB88D065C4440F5F411F8C37D52C057E9EE3A1B5C44407B8670CCB27D52C09AB4A9BA475C4440240B98C0AD7D52C0282A1BD6545C4440E4839ECDAA7D52C0FA5E43705C5C4440E4805D4D9E7D52C08AAA5FE97C5C44401B2AC6F99B7D52C01C2444F9825C4440D3122BA3917D52C059F8FA5A975C4440A7ACA6EB897D52C0FD2D01F8A75C444007B5DFDA897D52C04818062CB95C44401EF7ADD6897D52C0399A232BBF5C444036397CD2897D52C0904946CEC25C444001DE02098A7D52C08A58C4B0C35C4440CB68E4F38A7D52C0527B116DC75C4440AD4F39268B7D52C0AB92C83EC85C4440531EDD088B7D52C0EB19C231CB5C4440C5C551B9897D52C070EB6E9EEA5C444090847D3B897D52C02E5393E00D5D44409C4CDC2A887D52C01D39D219185D4440FC6EBA65877D52C00D87A5811F5D4440D9CC21A9857D52C0641F6459305D44402D7590D7837D52C0DB4FC6F8305D44409354A698837D52C03FE1ECD6325D44402D5BEB8B847D52C05CC64D0D345D44403A3DEFC6827D52C02C0E677E355D44405299620E827D52C0938C9C853D5D444011AAD4EC817D52C0CE8AA8893E5D44407689EAAD817D52C045BB0A293F5D444094A2957B817D52C02C5F97E13F5D4440EDED96E4807D52C060048D99445D44407C7A6CCB807D52C00551F701485D4440BE69FAEC807D52C0999A046F485D44401781B1BE817D52C0ECF483BA485D444028ECA2E8817D52C0F6D214014E5D44403480B740827D52C07024D060535D4440BD35B055827D52C0CEF8BEB8545D44401C3EE944827D52C03F389F3A565D4440FF243E77827D52C0B534B742585D44407B2C7DE8827D52C02AFD84B35B5D44406F7EC344837D52C0535C55F65D5D4440DA006C40847D52C041F163CC5D5D4440459DB987847D52C0CE15A584605D4440FDBCA948857D52C0F4A44C6A685D44408658FD11867D52C097A608707A5D44404FAF9465887D52C03EC91D36915D4440BD38F1D58E7D52C0CFF753E3A55D44406876DD5B917D52C0F1B6D26BB35D44405B7A34D5937D52C0E4F1B4FCC05D4440B6476FB88F7D52C0C0E78711C25D4440743E3C4B907D52C0A5BBEB6CC85D4440D190F128957D52C03A394371C75D4440ADA06989957D52C0512D228AC95D4440D74D29AF957D52C01BB80375CA5D4440307F85CC957D52C0E542E55FCB5D444042EA76F6957D52C049D40B3ECD5D444054556820967D52C0B3226AA2CF5D44408F6D1970967D52C0C189E8D7D65D4440AD6C1FF2967D52C0F71BEDB8E15D4440BED7101C977D52C0C8B4368DED5D4440D47D00529B7D52C0EBE1CB44115E44403F00A94D9C7D52C068774831405E4440F7393E5A9C7D52C04339D1AE425E44409831056B9C7D52C090A2CEDC435E4440984BAAB69B7D52C02384471B475E4440A547533D997D52C04ED026874F5E44403F170D198F7D52C00E661360585E4440545227A0897D52C0E202D0285D5E4440D3139678407D52C026A435069D5E44406C753925207D52C0CA54C1A8A45E44403B1BF2CF0C7D52C0E17CEA58A55E4440FD12F1D6F97C52C078962023A05E444068C9E369F97C52C0A81ABD1AA05E44406FBA6587F87C52C037A79201A05E44407008556AF67C52C0CC24EA059F5E44404CE141B3EB7C52C0F3FE3F4E985E444003CE52B29C7C52C06C239EEC665E44409AB33EE5987C52C020EEEA55645E4440DFC0E446917C52C0CF6394675E5E444014200A664C7C52C07F315BB22A5E44401D8D43FD2E7C52C0D71533C2DB5D4440C4758C2B2E7C52C09C4B7155D95D4440EE08A7052F7C52C0444B1E4FCB5D444091B6F1272A7C52C0A7069ACFB95D444014C95702297C52C0CC785BE9B55D4440807F4A95287C52C0567C43E1B35D44407405DB88277C52C0A0C4E74EB05D44400057B263237C52C07E39B35DA15D4440AC8BDB68007C52C0AB90F2936A5D444025E4839ECD7B52C0395E81E8495D444018265305A37B52C0C2DCEEE53E5D44402781CD39787B52C0685721E5275D4440514832AB777B52C0639AE95E275D4440F2599E07777B52C0EC6987BF265D4440F94A2025767B52C0B16B7BBB255D44409485AFAF757B52C088D860E1245D4440893F8A3A737B52C09622F94A205D44408D0C7217617B52C0BF5E61C1FD5C444026C286A7577B52C0D3DA34B6D75C4440FCDD3B6A4C7B52C0D0967329AE5C444030630AD6387B52C082C64CA25E5C444081E7DEC3257B52C0A33B889D295C4440639AE95E277B52C0D47FD6FCF85B44407EC34483147B52C03A394371C75B4440342A70B20D7B52C0D826158DB55B444099EFE0270E7B52C06762BA10AB5B4440D3F36E2C287B52C0350873BB975B4440D427B9C3267B52C07842AF3F895B4440C4245CC8237B52C030D7A205685B4440880CAB78237B52C08B8A389D645B4440902E36AD147B52C0718C648F505B4440AF928FDD057B52C05169C4CC3E5B44407E8978EBFC7A52C0FC1BB4571F5B44409DF0129CFA7A52C05D86FF74035B4440DCD8EC48F57A52C044A51133FB5A444027BD6F7CED7A52C0D769A4A5F25A44406B9C4D47007B52C0E4F4F57CCD5A4440F29881CAF87A52C095D233BDC45A44403F19E3C3EC7A52C05BEB8B84B65A44403468E89FE07A52C0DF14562AA85A4440E0F08288D47A52C0224F92AE995A44403448C153C87A52C0B8E34D7E8B5A44401155F833BC7A52C06C91B41B7D5A44401DE6CB0BB07A52C050C3B7B06E5A444029779FE3A37A52C0A568E55E605A44400584D6C3977A52C0889AE8F3515A44401215AA9B8B7A52C0DD3F16A2435A4440EE21E17B7F7A52C0C1711937355A4440B3EC4960737A52C0E692AAED265A4440D7BFEB33677A52C0CAC4AD82185A4440E350BF0B5B7A52C04EEE77280A5A4440CE18E6046D7A52C001FA7DFFE6594440DAA9B9DC607A52C0B5A7E49CD8594440B7B6F0BC547A52C0DAC87553CA594440DB899290487A52C0ED7E15E0BB594440CB0EF10F5B7A52C0239D819197594440A25EF0694E7A52C0B340BB438A594440BBEB6CC83F7A52C092E9D0E9795944407F68E6C9357A52C033C4B12E6E594440205D6C5A297A52C05DA27A6B605944401B834E081D7A52C065AA605452594440765089EB187A52C0A27895B54D5944402A357BA0157A52C07B4D0F0A4A5944408A5759DB147A52C0F2B1BB404959444097530262127A52C0D0436D1B465944409E5E29CB107A52C0ADA1D45E445944400A630B410E7A52C07F85CC9541594440DB12B9E00C7A52C00F46EC134059444000378B170B7A52C039419B1C3E5944408A20CEC3097A52C06AF981AB3C59444080423D7D047A52C0670C738236594440CAA48636007A52C034677DCA31594440BF44BC75FE7952C0A051BAF42F594440605628D2FD7952C077BE9F1A2F59444093AAED26F87952C0DF87838428594440CFF6E80DF77952C033164D672759444011346612F57952C07C2AA73D2559444001310917F27952C0E8482EFF21594440730CC85EEF7952C05567B5C01E594440984A3FE1EC7952C0B6D782DE1B5944404CE141B3EB7952C0570394861A594440C91CCBBBEA7952C00B9A9658195944408E1EBFB7E97952C08EACFC3218594440A794D74AE87952C08FE046CA165944409677D503E67952C0B41EBE4C145944402EC55565DF7952C0E2E995B20C5944408F52094FE87952C09DF0129CFA58444052EC681CEA7952C06326512FF8584440E02D90A0F87952C0739EB12FD9584440519E7939EC7952C05C8DEC4ACB584440938AC6DADF7952C0A5846055BD5844401666A19DD37952C07C08AA46AF58444029CE5147C77952C0B3942C27A1584440B2666490BB7952C0AEEE586C935844404E232D95B77952C0EDF0D7648D584440A4198BA6B37952C0FC6EBA65875844401E34BBEEAD7952C0179B560A81584440A297512CB77952C0289831056B5844400DE02D90A07952C0B3D0CE6916584440789961A3AC7952C0A6D1E4620C58444076FEEDB25F7952C015713AC956574440D50627A25F7952C06072A3C85A574440E7A562635E7952C0E08096AE6057444012876C205D7952C05AD2510E6657444072C3EFA65B7952C0C4EC65DB69574440FCC6D79E597952C0374D9F1D7057444051D7DAFB547952C0554FE61F7D574440658D7A88467952C04F1DAB949E57444008556AF6407952C04A7D59DAA95744406F9C14E63D7952C0A5811FD5B0574440A679C7293A7952C09CC0745AB757444061FBC9181F7952C097A608707A574440B0C91AF5107952C03483F8C08E5744402E36AD14027952C0718BF9B9A1574440D4997B48F87852C089D00836AE574440BBD23252EF7852C090BB085394574440EF8E8CD5E67852C01840F850A2574440EACE13CFD97852C0B6847CD0B35744408C48145AD67852C09012BBB6B7574440E690D442C97852C084B53176C257444063F030ED9B7852C090BA9D7DE5574440DFC0E446917852C0DEE2E13D075844403FFD67CD8F7852C0719010E50B5844401C2785798F7852C0764D486B0C584440B1BE81C98D7852C093FE5E0A0F58444037363B527D7852C0093543AA28584440C3D50110777852C09355116E32584440EEE714E4677852C03387A4164A584440717500C45D7852C07EA5F3E1595844407442E8A04B7852C0E108522976584440211CB3EC497852C0CE35CCD0785844405791D101497852C09D7DE5417A584440CB660E492D7852C0056A3178985844401AC1C6F5EF7752C0B9162D40DB5844400F7C0C569C7752C03EE8D9ACFA584440AC1E300F997752C0828AAA5FE9584440A661F888987752C0C2A38D23D6584440DCBC7152987752C042959A3DD0584440A661F888987752C0302AA913D0584440E7FF55478E7752C05DC2A1B7785844402FFA0AD28C7752C0581CCEFC6A584440DCB930D28B7752C021567F8461584440FB20CB82897752C062D7F6764B58444079909E22877752C0D89942E7355844408C63247B847752C0B58993FB1D584440ACE46377817752C0677E350708584440C6C210397D7752C0B2F4A10BEA57444074B680D07A7752C0909DB7B1D9574440DB317557767752C0077767EDB65744409A7631CD747752C02D7B12D89C5744400D6C9560717752C054FEB5BC72574440FC34EECD6F7752C0A3E6ABE4635744409E7AA4C16D7752C0D1949D7E50574440FE9C82FC6C7752C0E046CA16495744401E4FCB0F5C7752C09B53C90050574440D503E621537752C0E063B0E25457444037DC476E4D7752C032569BFF5757444070ED4449487752C0836C59BE2E57444066F50EB7437752C054C554FA0957444032022A1C417752C0713C9F01F55644404487C091407752C01F7EFE7BF05644406E4E2503407752C05D4C33DDEB56444088F546AD307752C03ECBF3E0EE5644401F0F7D772B7752C04835ECF7C4564440A33B889D297752C026AAB706B656444087A4164A267752C0938E72309B5644403B6F63B3237752C050FD834886564440D7F7E120217752C00D6C956071564440132A38BC207752C07A8A1C226E564440315D88D51F7752C07E8E8F1667564440D4F02DAC1B7752C0ADA415DF505644409E95B4E21B7752C09AE8F35146564440B88D06F0167752C0BB46CB811E564440A435069D107752C0C8E88024EC554440C9703C9F017752C0F01307D0EF55444083DE1B43007752C0855D143DF05544404EB4AB90F27652C0A69718CBF45544401ABE8575E37652C0C214E5D2F855444041649126DE7652C0FACE2F4AD0554440293C6876DD7652C0807D74EACA554440FAD170CADC7652C0779FE3A3C55544403FABCC94D67652C0F58079C8945544405AD76839D07652C0B41D537765554440849ECDAACF7652C0272D5C56615544405DA79196CA7652C0D87F9D9B36554440331477BCC97652C06A10E6762F55444060AB048BC37652C062F20698F95444402D23F59ECA7652C05D6919A9F754444011C30E63D27652C0B8E864A9F554444021C9ACDEE17652C073D87DC7F0544440F0F96184F07652C06FB72407EC5444408577B988EF7652C0DFA5D425E3544440A089B0E1E97652C0C8091346B35444403621AD31E87652C0999CDA19A6544440C763062AE37652C0EF3B86C77E5444401F4AB4E4F17652C0E0D4079277544440E2E65432007752C054E4107173544440FF0241800C7752C061FA5E437054444057B26323107752C0F677B6476F5444402026E1421E7752C00FEB8D5A61544440834F73F2227752C0E3361AC05B544440C2F693313E7752C0C05AB56B4254444097900F7A367752C0780C8FFD2C544440F834272F327752C06684B70721544440C4758C2B2E7752C03D0801F9125444408D959867257752C00E4A9869FB534440E68F696D1A7752C02FF99FFCDD53444022C2BF081A7752C0247F30F0DC534440EF1CCA50157752C03599F1B6D2534440C0B2D2A4147752C06551D845D15344409048DBF8137752C09509BFD4CF53444014419C87137752C0FB027AE1CE534440E5F04927127752C01A84B9DDCB53444092B06F27117752C0DAC87553CA5344407EA65EB7087752C0228C9FC6BD534440A3E4D539067752C065170CAEB9534440C2FA3F87F97652C059F5B9DA8A5344408BFA2477D87652C082A62556465344406403E962D37652C03197546D3753444018B49080D17652C0D5928E72305344404A22FB20CB7652C0765089EB185344402A1900AAB87652C0BE0F070951524440E386DF4DB77652C01F63EE5A425244400F7D772B4B7652C005A568E55E524440FB3F87F9F27552C07D224F92AE5144405793A7ACA67552C0D7C0560916514440BEDA519CA37552C0A44FABE80F514440745B22179C7552C0E2CCAFE600514440DCD6169E977552C00B43E4F4F5504440A93121E6927552C05E807D74EA504440D13FC1C58A7552C056ED9A90D6504440096B63EC847552C0AB92C83EC8504440AE80423D7D7552C04127840EBA50444040F7E5CC767552C0D0967329AE50444089CE328B507552C0162D40DB6A504440C8ED974F567552C05646239F57504440211FF46C567552C03674B33F5050444015713AC9567552C059DC7F643A5044404AB20E47577552C028B682A62550444037AB3E575B7552C0F7AE415F7A4F44408D261763607552C0226C787AA54E444045460724617552C0A94885B1854E4440F62686E4647552C02D978DCEF94D444036AE7FD7677552C018AE0E80B84D4440B9E00CFE7E7552C0B01F6283854D4440446B459BE37552C0C5E23785954C444012A27C410B7652C03C1405FA444C4440588B4F01307652C0B058C345EE4B4440A6457D923B7652C07C28D192C74B44402C9CA4F9637652C0A2957B81594B4440A81ABD1AA07652C0300C5872154B4440FBC8AD49B77652C035272F32014B44404127840EBA7652C02AE109BDFE4A44401DCBBBEA017752C02172FA7ABE4A4440130CE71A667752C0C6A2E9EC644A44400A4B3CA06C7752C0BEF8A23D5E4A4440A5D93C0E837752C06473D53C474A4440FDBCA948857752C06B98A1F1444A4440F0C000C2877752C0F0DE5163424A4440D8817346947752C04450357A354A4440BF28417FA17752C08099EFE0274A44400A2DEBFEB17752C0BCAE5FB01B4A44407FF8F9EFC17752C08C0DDDEC0F4A444053C90050C57752C0B14B546F0D4A44402E71E481C87752C0BF61A2410A4A44401EFB592C457852C09F39EB538E494440056D72F8A47852C06D8E739B7049444036AD1402B97852C0D68BA19C68494440F59F353FFE7852C0BAA0BE654E494440289A07B0C87952C0C58F31772D4944406133C005D97952C0D862B7CF2A494440E1783E03EA7952C04DDA54DD2349444046B3B27DC87A52C06A11514CDE4844402F185C73477B52C0FCE25295B6484440A26131EA5A7B52C06A696E85B04844408499B67F657B52C036902E36AD4844404F8F6D19707B52C0C1C760C5A94844402E1D739EB17B52C02BDCF29194484440F9122A38BC7B52C0B5132521914844401021AE9CBD7B52C080D250A39048444081CEA44DD57B52C0431B800D88484440BBB88D06F07B52C076A38FF980484440B5A50EF27A7C52C07780272D5C484440F7C77BD5CA7C52C08AE5965643484440614D6551D87C52C05CFDD8243F484440E84CDA54DD7C52C03F1878EE3D4844409947FE60E07C52C05774EB353D484440AF0793E2E37C52C0FF5C34643C48444065A54929E87C52C0C45E28603B484440EFAB72A1F27C52C01F12BEF737484440D07D39B35D7D52C0075F984C1548444025AB22DC647D52C03D0801F912484440C39E76F86B7D52C0861C5BCF104844401211FE45D07F52C0F2CEA10C55474440B804E09F528252C0785C548B884644407615527E528252C0DB85E63A8D464440E2E5E95C518252C0BB270F0BB546444089B48D3F518252C0A7203F1BB94644400858AB764D8252C0F294D5743D474440CD565EF23F8252C07D7555A0164944401B28F04E3E8252C0E9F010C64F494440AAB4C5353E8252C0BDC117265349444032CB9E04368252C0F6285C8FC24944405111A7936C8252C09FE238F06A4B44402252D32EA68252C0BC02D193324D44404C50C3B7B08252C0F9F36DC1524D444068075C57CC8252C0ECDCB419A74D4440A31F0DA7CC8252C086E3F90CA84D44409D2E8B89CD8252C0438CD7BCAA4D44402BA1BB24CE8252C00726378AAC4D4440DDE9CE13CF8252C035423F53AF4D4440A774B0FECF8252C0C266800BB24D4440A626C11BD28252C007431D56B84D4440EDD286C3D28252C0DC476E4DBA4D44402638F581E48252C04A5F0839EF4D444074779D0DF98252C0E3C281902C4E4440890629780A8352C016DC0F78604E44408315A75A0B8352C0E5EFDE51634E4440EA793716148352C036E84B6F7F4E44404703780B248352C0C24CDBBFB24E44403046240A2D8352C09BE09BA6CF4E4440A4C00298328352C02D776682E14E444055F833BC598352C09F91088D604F4440B3B27DC85B8352C08922A46E674F444075E789E76C8352C066118AADA04F44400D52F014728352C051F355F2B14F4440C5ABAC6D8A8352C0D4D00660035044403D7E6FD39F8352C05C1ABFF04A5044405051F52B9D8352C042B28009DC504440'::geometry INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundarybyid (username text, orgname text, geometry_id text, boundary_id text, time_span text DEFAULT NULL)
RETURNS Geometry(Geometry, 4326) AS $$
DECLARE
  ret Geometry;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundarybyid invoked with params (%, %, %, %, %)', username, orgname, geometry_id, boundary_id, time_span;
  SELECT '0106000020E610000001000000010300000001000000930200005051F52B9D8352C042B28009DC50444093C2BCC7998352C0E89E758D965144402EFD4B52998352C09A07B0C8AF514440E75086AA988352C022FAB5F5D351444027874F3A918352C0A46B26DF6C53444018E945ED7E8352C04D81CCCEA25344401346B3B27D8352C05D50DF32A753444068226C787A8352C08D25AC8DB153444015C8EC2C7A8352C004560E2DB2534440DF8618AF798352C00FD07D39B3534440FEB627486C8352C0DC9E20B1DD534440B98C9B1A688352C05D328E91EC5344408B8A389D648352C0929048DBF853444075CAA31B618352C0986A662D05544440EA758BC0588352C0D6C397892254444048DFA469508352C0151DC9E53F544440B67F65A5498352C0F73DEAAF575444401403249A408352C05E2A36E6755444402367614F3B8352C06DE2E47E8754444011FC6F253B8352C0431B800D885444403E7958A8358352C0DD0A6135965444401D739EB12F8352C093DFA293A5544440FB04508C2C8352C035289A07B05444401EA4A7C8218352C0347F4C6BD3544440D7C05609168352C05053CBD6FA544440AC8E1CE90C8352C0C9AA083719554440FC8D76DCF08252C0BD18CA897655444048895DDBDB8252C0C3B7B06EBC554440698995D1C88252C032207BBDFB55444004A73E90BC8252C0DB4C857824564440BC1FB75F3E8252C08F368E588B574440E15D2EE23B8252C066F4A3E194574440C614AC71368252C0381268B0A9574440CEA44DD53D8152C04F1F813FFC564440A51133FB3C8152C0F607CA6DFB56444070D05E7D3C8152C0CB0C1B65FD564440C5C6BC8E388152C0F303577902574440EA043411368152C03F390A1005574440840B7904378152C0D34ECDE506574440390A1005338152C047E350BF0B5744405D143DF0318152C0D53BDC0E0D5744401D59F965308152C00A4966F50E574440236420CF2E8152C00FD253E41057444084EE92382B8152C0AD2D3C2F15574440E23D0796238152C0A304FD851E574440B3EDB435228152C001D9EBDD1F5744401EBE4C14218152C08BDCD3D51D574440A2D0B2EE1F8152C0FC1BB4571F57444007B0C8AF1F8152C0CC9717601F574440F678211D1E8152C0374E0AF31E5744401A69A9BC1D8152C0793D98141F574440102384471B8152C0CB2F833122574440B7EEE6A90E8152C09F1D705D315744405968E7340B8152C02C0E677E355744400E4A9869FB8052C0C91EA166485744401B2C9CA4F98052C05C001AA54B5744401AF8510DFB8052C0C51A2E724F574440925CFE43FA8052C0309DD66D50574440BB9866BAD78052C0035DFB027A574440A04FE449D28052C02920ED7F80574440DC9BDF30D18052C0E8305F5E80574440B43C0FEECE8052C0D8614CFA7B5744404AEEB089CC8052C0950A2AAA7E5744409A5B21ACC68052C032FE7DC6855744406682E15CC38052C01EF7ADD689574440F78DAF3DB38052C020CD58349D5744402FFA0AD28C8052C00919C8B3CB574440D0251C7A8B8052C00EA2B5A2CD57444001DE02098A8052C030444E5FCF5744404A404CC2858052C0992A1895D45744403480B740828052C0A33CF372D857444028ECA2E8818052C0CD0358E4D7574440F3AACE6A818052C074ECA012D75744402920ED7F808052C0DFA293A5D657444036E84B6F7F8052C092054CE0D6574440AD4CF8A57E8052C0E55FCB2BD757444042CA4FAA7D8052C01AA19FA9D7574440A2EC2DE57C8052C0205ED72FD8574440BB6246787B8052C08BE07F2BD95744405C74B2D47A8052C025E7C41EDA5744405CA8FC6B798052C0F52EDE8FDB574440FF0758AB768052C09AAF928FDD574440A60A4625758052C0C442AD69DE574440A73E90BC738052C05E49F25CDF574440BF9A0304738052C046ED7E15E0574440A19BFD81728052C070B4E386DF5744403D0AD7A3708052C0D0F0660DDE574440680586AC6E8052C04D469561DC57444063963D096C8052C0965AEF37DA574440944E24986A8052C0BA641C23D957444059501894698052C014B01D8CD8574440E21FB6F4688052C0614D6551D85744401895D409688052C0205ED72FD85744406379573D608052C0A4A487A1D55744401878EE3D5C8052C041B5C189E85744402F4FE78A528052C0A580B4FF01584440983270404B8052C0EECEDA6D1758444050357A35408052C0E3C281902C58444086C43D963E8052C0DC9DB5DB2E584440C5E061DA378052C0BFF2203D455844409946938B318052C0C4E9245B5D5844407C478D09318052C040A374E95F584440E3A8DC442D8052C0F92AF9D85D584440919C4CDC2A8052C06BD26D895C584440276893C3278052C0E9279CDD5A58444053B131AF238052C061C092AB5858444055336B29208052C068E55E605658444091990B5C1E8052C082C64CA25E584440AA2688BA0F8052C027F6D03E56584440F488D1730B8052C0D21C59F9655844400C1CD0D2158052C0BB96900F7A584440C6A69542208052C0B77BB94F8E584440D3A23EC91D8052C02EC901BB9A584440B6BDDD921C8052C0BF42E6CAA058444082E49D43198052C036902E36AD58444072FBE593158052C0ACA92C0ABB5844402B4F20EC148052C0EC3026FDBD584440E4BCFF8F138052C04E266E15C4584440C26856B60F8052C06E15C440D7584440C404357C0B8052C00F5EBBB4E1584440397CD289048052C0CA87A06AF4584440FB761211FE7F52C090F7AA9509594440D93C0E83F97F52C03561FBC9185944402828452BF77F52C0F06DFAB31F594440F9BD4D7FF67F52C0DC9A745B225944403AADDBA0F67F52C0BE4D7FF62359444093C49272F77F52C0526342CC25594440450DA661F87F52C0798EC87729594440F2CCCB61F77F52C0067FBF982D5944409B030473F47F52C017821C94305944401E300F99F27F52C05609168733594440E57FF277EF7F52C0EDBAB72231594440A3AA09A2EE7F52C0EA1ED95C355944405D18E945ED7F52C0D3F6AFAC345944401C5DA5BBEB7F52C076DB85E63A5944404BADF71BED7F52C0B1D991EA3B5944401F477364E57F52C0E48409A35959444022179CC1DF7F52C001D8800871594440A4703D0AD77F52C02EC6C03A8E594440457F68E6C97F52C061C26856B659444070404B57B07F52C0FCDEA63FFB594440DC10E335AF7F52C048E00F3FFF59444055F7C8E6AA7F52C02DB4739A055A4440A4E2FF8EA87F52C00CFFE9060A5A44407E8AE3C0AB7F52C0EC4960730E5A444006F2ECF2AD7F52C08CD99255115A444042588D25AC7F52C09BA8A5B9155A44405A9A5B21AC7F52C0F4BF5C8B165A44406762BA10AB7F52C0A5BA8097195A4440E5B7E864A97F52C0B6BDDD921C5A44402B4A09C1AA7F52C0499F56D11F5A4440D48041D2A77F52C0177FDB13245A4440C22FF5F3A67F52C0D55B035B255A4440FE7BF0DAA57F52C0F8FD9B17275A44409A046F48A37F52C04FADBEBA2A5A444045F12A6B9B7F52C0AC1919E42E5A44404BE2AC889A7F52C0A75CE15D2E5A4440462575029A7F52C0965984622B5A4440E75086AA987F52C0906802452C5A44400B2769FE987F52C05FB01BB62D5A444004029D499B7F52C0DD2230D6375A44404301DBC1887F52C0CBF10A444F5A4440D6A88768747F52C0B81E85EB515A44407C0C569C6A7F52C0F6CFD380415A4440CB113290677F52C0A9328CBB415A44407905A227657F52C03D7C9928425A44407EA5F3E1597F52C0787AA52C435A444009F7CABC557F52C0A2410A9E425A44408D23D6E2537F52C00EF8FC30425A444029780AB9527F52C08B19E1ED415A44402992AF04527F52C08B19E1ED415A4440C51A2E724F7F52C08B19E1ED415A4440AC36FFAF3A7F52C01AA6B6D4415A444009522976347F52C0A2410A9E425A4440F25D4A5D327F52C0252026E1425A44408252B4722F7F52C05A61FA5E435A444032E202D0287F52C013B534B7425A4440E0BBCD1B277F52C014E97E4E415A44409352D0ED257F52C0151DC9E53F5A444022F94A20257F52C0B08BA2073E5A4440CF9ECBD4247F52C0F3AE7AC03C5A444077A1B94E237F52C0F3AE7AC03C5A4440DDB419A7217F52C097FBE428405A4440666A12BC217F52C016A243E0485A44408EACFC32187F52C0CD8DE9094B5A44404F05DCF3FC7E52C0B952CF82505A4440D2E0B6B6F07E52C0FFCA4A93525A44404F029B73F07E52C0A7E7DD58505A4440EA3C2AFEEF7E52C020B41EBE4C5A44404A5F0839EF7E52C01AF7E6374C5A4440D462F030ED7E52C055F5F23B4D5A4440825660C8EA7E52C0B5FD2B2B4D5A4440825660C8EA7E52C072DA53724E5A44403C2CD49AE67E52C030B77BB94F5A44400DDC813AE57E52C0D76B7A50505A4440670DDE57E57E52C0072461DF4E5A4440C77DAB75E27E52C0A25EF0694E5A4440ABB2EF8AE07E52C04F04711E4E5A44403A3FC571E07E52C03C65355D4F5A4440643A747ADE7E52C04ED026874F5A444077F35487DC7E52C08A027D224F5A4440F0A5F0A0D97E52C031EBC5504E5A444068588CBAD67E52C0D8D30E7F4D5A444046B3B27DC87E52C06FB9FAB1495A4440B85A272EC77E52C03C821B295B5A444039CE6DC2BD7E52C097016729595A44409A07B0C8AF7E52C07FD93D79585A44407E8AE3C0AB7E52C0EBC37AA3565A4440C1E10511A97E52C0D097DEFE5C5A44401B82E3326E7E52C03F170D198F5A44408A3C49BA667E52C0D619DF17975A444026DF6C73637E52C07A32FFE89B5A4440E78BBD175F7E52C000FE2955A25A4440594DD7135D7E52C040852348A55A4440E36A64575A7E52C03EE94482A95A4440E603029D497E52C067B62BF4C15A4440ED42739D467E52C04701A260C65A4440253ACB2C427E52C03E40F7E5CC5A4440D026874F3A7E52C061C5A9D6C25A44405C5837DE1D7E52C0868F8829915A4440162EABB0197E52C007B5DFDA895A4440B859BC58187E52C083A279008B5A44408FE046CA167E52C011FB04508C5A4440B131AF230E7E52C0D2C43BC0935A44401A4CC3F0117E52C0F0FACC599F5A44401A321EA5127E52C06631B1F9B85A44402B836A83137E52C0E55C8AABCA5A4440C9737D1F0E7E52C0B376DB85E65A4440D3687231067E52C07405DB88275B444009DE9046057E52C09A94826E2F5B4440158C4AEA047E52C08D7E349C325B4440C808A870047E52C0B6114F76335B4440634337FB037E52C00F290648345B4440DAA7E331037E52C03E7958A8355B444082902C60027E52C0DE3CD521375B4440AB5791D1017E52C048BF7D1D385B4440942F6821017E52C095287B4B395B4440268C6665FB7D52C0548A1D8D435B44405C1B2AC6F97D52C065187783685B4440FA0B3D62F47D52C03FE08101845B4440E2E313B2F37D52C03196E997885B444038F4160FEF7D52C05D50DF32A75B4440109546CCEC7D52C07FDB1324B65B44401C261AA4E07D52C0BA641C23D95B444076BF0AF0DD7D52C06AF7AB00DF5B4440DCB8C5FCDC7D52C0B06F2711E15B44405A0EF450DB7D52C0081F4AB4E45B444084D558C2DA7D52C0F57F0EF3E55B4440BBB20B06D77D52C06E693524EE5B4440CE6BEC12D57D52C0FB592C45F25B444073672618CE7D52C09A0645F3005C4440BB7B80EECB7D52C0C7BAB88D065C4440F5F411F8C37D52C057E9EE3A1B5C44407B8670CCB27D52C09AB4A9BA475C4440240B98C0AD7D52C0282A1BD6545C4440E4839ECDAA7D52C0FA5E43705C5C4440E4805D4D9E7D52C08AAA5FE97C5C44401B2AC6F99B7D52C01C2444F9825C4440D3122BA3917D52C059F8FA5A975C4440A7ACA6EB897D52C0FD2D01F8A75C444007B5DFDA897D52C04818062CB95C44401EF7ADD6897D52C0399A232BBF5C444036397CD2897D52C0904946CEC25C444001DE02098A7D52C08A58C4B0C35C4440CB68E4F38A7D52C0527B116DC75C4440AD4F39268B7D52C0AB92C83EC85C4440531EDD088B7D52C0EB19C231CB5C4440C5C551B9897D52C070EB6E9EEA5C444090847D3B897D52C02E5393E00D5D44409C4CDC2A887D52C01D39D219185D4440FC6EBA65877D52C00D87A5811F5D4440D9CC21A9857D52C0641F6459305D44402D7590D7837D52C0DB4FC6F8305D44409354A698837D52C03FE1ECD6325D44402D5BEB8B847D52C05CC64D0D345D44403A3DEFC6827D52C02C0E677E355D44405299620E827D52C0938C9C853D5D444011AAD4EC817D52C0CE8AA8893E5D44407689EAAD817D52C045BB0A293F5D444094A2957B817D52C02C5F97E13F5D4440EDED96E4807D52C060048D99445D44407C7A6CCB807D52C00551F701485D4440BE69FAEC807D52C0999A046F485D44401781B1BE817D52C0ECF483BA485D444028ECA2E8817D52C0F6D214014E5D44403480B740827D52C07024D060535D4440BD35B055827D52C0CEF8BEB8545D44401C3EE944827D52C03F389F3A565D4440FF243E77827D52C0B534B742585D44407B2C7DE8827D52C02AFD84B35B5D44406F7EC344837D52C0535C55F65D5D4440DA006C40847D52C041F163CC5D5D4440459DB987847D52C0CE15A584605D4440FDBCA948857D52C0F4A44C6A685D44408658FD11867D52C097A608707A5D44404FAF9465887D52C03EC91D36915D4440BD38F1D58E7D52C0CFF753E3A55D44406876DD5B917D52C0F1B6D26BB35D44405B7A34D5937D52C0E4F1B4FCC05D4440B6476FB88F7D52C0C0E78711C25D4440743E3C4B907D52C0A5BBEB6CC85D4440D190F128957D52C03A394371C75D4440ADA06989957D52C0512D228AC95D4440D74D29AF957D52C01BB80375CA5D4440307F85CC957D52C0E542E55FCB5D444042EA76F6957D52C049D40B3ECD5D444054556820967D52C0B3226AA2CF5D44408F6D1970967D52C0C189E8D7D65D4440AD6C1FF2967D52C0F71BEDB8E15D4440BED7101C977D52C0C8B4368DED5D4440D47D00529B7D52C0EBE1CB44115E44403F00A94D9C7D52C068774831405E4440F7393E5A9C7D52C04339D1AE425E44409831056B9C7D52C090A2CEDC435E4440984BAAB69B7D52C02384471B475E4440A547533D997D52C04ED026874F5E44403F170D198F7D52C00E661360585E4440545227A0897D52C0E202D0285D5E4440D3139678407D52C026A435069D5E44406C753925207D52C0CA54C1A8A45E44403B1BF2CF0C7D52C0E17CEA58A55E4440FD12F1D6F97C52C078962023A05E444068C9E369F97C52C0A81ABD1AA05E44406FBA6587F87C52C037A79201A05E44407008556AF67C52C0CC24EA059F5E44404CE141B3EB7C52C0F3FE3F4E985E444003CE52B29C7C52C06C239EEC665E44409AB33EE5987C52C020EEEA55645E4440DFC0E446917C52C0CF6394675E5E444014200A664C7C52C07F315BB22A5E44401D8D43FD2E7C52C0D71533C2DB5D4440C4758C2B2E7C52C09C4B7155D95D4440EE08A7052F7C52C0444B1E4FCB5D444091B6F1272A7C52C0A7069ACFB95D444014C95702297C52C0CC785BE9B55D4440807F4A95287C52C0567C43E1B35D44407405DB88277C52C0A0C4E74EB05D44400057B263237C52C07E39B35DA15D4440AC8BDB68007C52C0AB90F2936A5D444025E4839ECD7B52C0395E81E8495D444018265305A37B52C0C2DCEEE53E5D44402781CD39787B52C0685721E5275D4440514832AB777B52C0639AE95E275D4440F2599E07777B52C0EC6987BF265D4440F94A2025767B52C0B16B7BBB255D44409485AFAF757B52C088D860E1245D4440893F8A3A737B52C09622F94A205D44408D0C7217617B52C0BF5E61C1FD5C444026C286A7577B52C0D3DA34B6D75C4440FCDD3B6A4C7B52C0D0967329AE5C444030630AD6387B52C082C64CA25E5C444081E7DEC3257B52C0A33B889D295C4440639AE95E277B52C0D47FD6FCF85B44407EC34483147B52C03A394371C75B4440342A70B20D7B52C0D826158DB55B444099EFE0270E7B52C06762BA10AB5B4440D3F36E2C287B52C0350873BB975B4440D427B9C3267B52C07842AF3F895B4440C4245CC8237B52C030D7A205685B4440880CAB78237B52C08B8A389D645B4440902E36AD147B52C0718C648F505B4440AF928FDD057B52C05169C4CC3E5B44407E8978EBFC7A52C0FC1BB4571F5B44409DF0129CFA7A52C05D86FF74035B4440DCD8EC48F57A52C044A51133FB5A444027BD6F7CED7A52C0D769A4A5F25A44406B9C4D47007B52C0E4F4F57CCD5A4440F29881CAF87A52C095D233BDC45A44403F19E3C3EC7A52C05BEB8B84B65A44403468E89FE07A52C0DF14562AA85A4440E0F08288D47A52C0224F92AE995A44403448C153C87A52C0B8E34D7E8B5A44401155F833BC7A52C06C91B41B7D5A44401DE6CB0BB07A52C050C3B7B06E5A444029779FE3A37A52C0A568E55E605A44400584D6C3977A52C0889AE8F3515A44401215AA9B8B7A52C0DD3F16A2435A4440EE21E17B7F7A52C0C1711937355A4440B3EC4960737A52C0E692AAED265A4440D7BFEB33677A52C0CAC4AD82185A4440E350BF0B5B7A52C04EEE77280A5A4440CE18E6046D7A52C001FA7DFFE6594440DAA9B9DC607A52C0B5A7E49CD8594440B7B6F0BC547A52C0DAC87553CA594440DB899290487A52C0ED7E15E0BB594440CB0EF10F5B7A52C0239D819197594440A25EF0694E7A52C0B340BB438A594440BBEB6CC83F7A52C092E9D0E9795944407F68E6C9357A52C033C4B12E6E594440205D6C5A297A52C05DA27A6B605944401B834E081D7A52C065AA605452594440765089EB187A52C0A27895B54D5944402A357BA0157A52C07B4D0F0A4A5944408A5759DB147A52C0F2B1BB404959444097530262127A52C0D0436D1B465944409E5E29CB107A52C0ADA1D45E445944400A630B410E7A52C07F85CC9541594440DB12B9E00C7A52C00F46EC134059444000378B170B7A52C039419B1C3E5944408A20CEC3097A52C06AF981AB3C59444080423D7D047A52C0670C738236594440CAA48636007A52C034677DCA31594440BF44BC75FE7952C0A051BAF42F594440605628D2FD7952C077BE9F1A2F59444093AAED26F87952C0DF87838428594440CFF6E80DF77952C033164D672759444011346612F57952C07C2AA73D2559444001310917F27952C0E8482EFF21594440730CC85EEF7952C05567B5C01E594440984A3FE1EC7952C0B6D782DE1B5944404CE141B3EB7952C0570394861A594440C91CCBBBEA7952C00B9A9658195944408E1EBFB7E97952C08EACFC3218594440A794D74AE87952C08FE046CA165944409677D503E67952C0B41EBE4C145944402EC55565DF7952C0E2E995B20C5944408F52094FE87952C09DF0129CFA58444052EC681CEA7952C06326512FF8584440E02D90A0F87952C0739EB12FD9584440519E7939EC7952C05C8DEC4ACB584440938AC6DADF7952C0A5846055BD5844401666A19DD37952C07C08AA46AF58444029CE5147C77952C0B3942C27A1584440B2666490BB7952C0AEEE586C935844404E232D95B77952C0EDF0D7648D584440A4198BA6B37952C0FC6EBA65875844401E34BBEEAD7952C0179B560A81584440A297512CB77952C0289831056B5844400DE02D90A07952C0B3D0CE6916584440789961A3AC7952C0A6D1E4620C58444076FEEDB25F7952C015713AC956574440D50627A25F7952C06072A3C85A574440E7A562635E7952C0E08096AE6057444012876C205D7952C05AD2510E6657444072C3EFA65B7952C0C4EC65DB69574440FCC6D79E597952C0374D9F1D7057444051D7DAFB547952C0554FE61F7D574440658D7A88467952C04F1DAB949E57444008556AF6407952C04A7D59DAA95744406F9C14E63D7952C0A5811FD5B0574440A679C7293A7952C09CC0745AB757444061FBC9181F7952C097A608707A574440B0C91AF5107952C03483F8C08E5744402E36AD14027952C0718BF9B9A1574440D4997B48F87852C089D00836AE574440BBD23252EF7852C090BB085394574440EF8E8CD5E67852C01840F850A2574440EACE13CFD97852C0B6847CD0B35744408C48145AD67852C09012BBB6B7574440E690D442C97852C084B53176C257444063F030ED9B7852C090BA9D7DE5574440DFC0E446917852C0DEE2E13D075844403FFD67CD8F7852C0719010E50B5844401C2785798F7852C0764D486B0C584440B1BE81C98D7852C093FE5E0A0F58444037363B527D7852C0093543AA28584440C3D50110777852C09355116E32584440EEE714E4677852C03387A4164A584440717500C45D7852C07EA5F3E1595844407442E8A04B7852C0E108522976584440211CB3EC497852C0CE35CCD0785844405791D101497852C09D7DE5417A584440CB660E492D7852C0056A3178985844401AC1C6F5EF7752C0B9162D40DB5844400F7C0C569C7752C03EE8D9ACFA584440AC1E300F997752C0828AAA5FE9584440A661F888987752C0C2A38D23D6584440DCBC7152987752C042959A3DD0584440A661F888987752C0302AA913D0584440E7FF55478E7752C05DC2A1B7785844402FFA0AD28C7752C0581CCEFC6A584440DCB930D28B7752C021567F8461584440FB20CB82897752C062D7F6764B58444079909E22877752C0D89942E7355844408C63247B847752C0B58993FB1D584440ACE46377817752C0677E350708584440C6C210397D7752C0B2F4A10BEA57444074B680D07A7752C0909DB7B1D9574440DB317557767752C0077767EDB65744409A7631CD747752C02D7B12D89C5744400D6C9560717752C054FEB5BC72574440FC34EECD6F7752C0A3E6ABE4635744409E7AA4C16D7752C0D1949D7E50574440FE9C82FC6C7752C0E046CA16495744401E4FCB0F5C7752C09B53C90050574440D503E621537752C0E063B0E25457444037DC476E4D7752C032569BFF5757444070ED4449487752C0836C59BE2E57444066F50EB7437752C054C554FA0957444032022A1C417752C0713C9F01F55644404487C091407752C01F7EFE7BF05644406E4E2503407752C05D4C33DDEB56444088F546AD307752C03ECBF3E0EE5644401F0F7D772B7752C04835ECF7C4564440A33B889D297752C026AAB706B656444087A4164A267752C0938E72309B5644403B6F63B3237752C050FD834886564440D7F7E120217752C00D6C956071564440132A38BC207752C07A8A1C226E564440315D88D51F7752C07E8E8F1667564440D4F02DAC1B7752C0ADA415DF505644409E95B4E21B7752C09AE8F35146564440B88D06F0167752C0BB46CB811E564440A435069D107752C0C8E88024EC554440C9703C9F017752C0F01307D0EF55444083DE1B43007752C0855D143DF05544404EB4AB90F27652C0A69718CBF45544401ABE8575E37652C0C214E5D2F855444041649126DE7652C0FACE2F4AD0554440293C6876DD7652C0807D74EACA554440FAD170CADC7652C0779FE3A3C55544403FABCC94D67652C0F58079C8945544405AD76839D07652C0B41D537765554440849ECDAACF7652C0272D5C56615544405DA79196CA7652C0D87F9D9B36554440331477BCC97652C06A10E6762F55444060AB048BC37652C062F20698F95444402D23F59ECA7652C05D6919A9F754444011C30E63D27652C0B8E864A9F554444021C9ACDEE17652C073D87DC7F0544440F0F96184F07652C06FB72407EC5444408577B988EF7652C0DFA5D425E3544440A089B0E1E97652C0C8091346B35444403621AD31E87652C0999CDA19A6544440C763062AE37652C0EF3B86C77E5444401F4AB4E4F17652C0E0D4079277544440E2E65432007752C054E4107173544440FF0241800C7752C061FA5E437054444057B26323107752C0F677B6476F5444402026E1421E7752C00FEB8D5A61544440834F73F2227752C0E3361AC05B544440C2F693313E7752C0C05AB56B4254444097900F7A367752C0780C8FFD2C544440F834272F327752C06684B70721544440C4758C2B2E7752C03D0801F9125444408D959867257752C00E4A9869FB534440E68F696D1A7752C02FF99FFCDD53444022C2BF081A7752C0247F30F0DC534440EF1CCA50157752C03599F1B6D2534440C0B2D2A4147752C06551D845D15344409048DBF8137752C09509BFD4CF53444014419C87137752C0FB027AE1CE534440E5F04927127752C01A84B9DDCB53444092B06F27117752C0DAC87553CA5344407EA65EB7087752C0228C9FC6BD534440A3E4D539067752C065170CAEB9534440C2FA3F87F97652C059F5B9DA8A5344408BFA2477D87652C082A62556465344406403E962D37652C03197546D3753444018B49080D17652C0D5928E72305344404A22FB20CB7652C0765089EB185344402A1900AAB87652C0BE0F070951524440E386DF4DB77652C01F63EE5A425244400F7D772B4B7652C005A568E55E524440FB3F87F9F27552C07D224F92AE5144405793A7ACA67552C0D7C0560916514440BEDA519CA37552C0A44FABE80F514440745B22179C7552C0E2CCAFE600514440DCD6169E977552C00B43E4F4F5504440A93121E6927552C05E807D74EA504440D13FC1C58A7552C056ED9A90D6504440096B63EC847552C0AB92C83EC8504440AE80423D7D7552C04127840EBA50444040F7E5CC767552C0D0967329AE50444089CE328B507552C0162D40DB6A504440C8ED974F567552C05646239F57504440211FF46C567552C03674B33F5050444015713AC9567552C059DC7F643A5044404AB20E47577552C028B682A62550444037AB3E575B7552C0F7AE415F7A4F44408D261763607552C0226C787AA54E444045460724617552C0A94885B1854E4440F62686E4647552C02D978DCEF94D444036AE7FD7677552C018AE0E80B84D4440B9E00CFE7E7552C0B01F6283854D4440446B459BE37552C0C5E23785954C444012A27C410B7652C03C1405FA444C4440588B4F01307652C0B058C345EE4B4440A6457D923B7652C07C28D192C74B44402C9CA4F9637652C0A2957B81594B4440A81ABD1AA07652C0300C5872154B4440FBC8AD49B77652C035272F32014B44404127840EBA7652C02AE109BDFE4A44401DCBBBEA017752C02172FA7ABE4A4440130CE71A667752C0C6A2E9EC644A44400A4B3CA06C7752C0BEF8A23D5E4A4440A5D93C0E837752C06473D53C474A4440FDBCA948857752C06B98A1F1444A4440F0C000C2877752C0F0DE5163424A4440D8817346947752C04450357A354A4440BF28417FA17752C08099EFE0274A44400A2DEBFEB17752C0BCAE5FB01B4A44407FF8F9EFC17752C08C0DDDEC0F4A444053C90050C57752C0B14B546F0D4A44402E71E481C87752C0BF61A2410A4A44401EFB592C457852C09F39EB538E494440056D72F8A47852C06D8E739B7049444036AD1402B97852C0D68BA19C68494440F59F353FFE7852C0BAA0BE654E494440289A07B0C87952C0C58F31772D4944406133C005D97952C0D862B7CF2A494440E1783E03EA7952C04DDA54DD2349444046B3B27DC87A52C06A11514CDE4844402F185C73477B52C0FCE25295B6484440A26131EA5A7B52C06A696E85B04844408499B67F657B52C036902E36AD4844404F8F6D19707B52C0C1C760C5A94844402E1D739EB17B52C02BDCF29194484440F9122A38BC7B52C0B5132521914844401021AE9CBD7B52C080D250A39048444081CEA44DD57B52C0431B800D88484440BBB88D06F07B52C076A38FF980484440B5A50EF27A7C52C07780272D5C484440F7C77BD5CA7C52C08AE5965643484440614D6551D87C52C05CFDD8243F484440E84CDA54DD7C52C03F1878EE3D4844409947FE60E07C52C05774EB353D484440AF0793E2E37C52C0FF5C34643C48444065A54929E87C52C0C45E28603B484440EFAB72A1F27C52C01F12BEF737484440D07D39B35D7D52C0075F984C1548444025AB22DC647D52C03D0801F912484440C39E76F86B7D52C0861C5BCF104844401211FE45D07F52C0F2CEA10C55474440B804E09F528252C0785C548B884644407615527E528252C0DB85E63A8D464440E2E5E95C518252C0BB270F0BB546444089B48D3F518252C0A7203F1BB94644400858AB764D8252C0F294D5743D474440CD565EF23F8252C07D7555A0164944401B28F04E3E8252C0E9F010C64F494440AAB4C5353E8252C0BDC117265349444032CB9E04368252C0F6285C8FC24944405111A7936C8252C09FE238F06A4B44402252D32EA68252C0BC02D193324D44404C50C3B7B08252C0F9F36DC1524D444068075C57CC8252C0ECDCB419A74D4440A31F0DA7CC8252C086E3F90CA84D44409D2E8B89CD8252C0438CD7BCAA4D44402BA1BB24CE8252C00726378AAC4D4440DDE9CE13CF8252C035423F53AF4D4440A774B0FECF8252C0C266800BB24D4440A626C11BD28252C007431D56B84D4440EDD286C3D28252C0DC476E4DBA4D44402638F581E48252C04A5F0839EF4D444074779D0DF98252C0E3C281902C4E4440890629780A8352C016DC0F78604E44408315A75A0B8352C0E5EFDE51634E4440EA793716148352C036E84B6F7F4E44404703780B248352C0C24CDBBFB24E44403046240A2D8352C09BE09BA6CF4E4440A4C00298328352C02D776682E14E444055F833BC598352C09F91088D604F4440B3B27DC85B8352C08922A46E674F444075E789E76C8352C066118AADA04F44400D52F014728352C051F355F2B14F4440C5ABAC6D8A8352C0D4D00660035044403D7E6FD39F8352C05C1ABFF04A5044405051F52B9D8352C042B28009DC504440'::geometry INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundaryid (username text, orgname text, geom geometry(Geometry, 4326), boundary_id text, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundaryid invoked with params (%, %, %, %, %)', username, orgname, geom, boundary_id, time_span;
  SELECT '36047048500'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getboundaryid (username text, orgname text, geom geometry(Geometry, 4326), boundary_id text, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getboundaryid invoked with params (%, %, %, %, %)', username, orgname, geom, boundary_id, time_span;
  SELECT '36047048500'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getcategory (username text, orgname text, geom Geometry, category_id text, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getcategory invoked with params (%, %, %, %, %, %)', username, orgname, geom, category_id, boundary_id, time_span;
  SELECT 'Wealthy, urban without Kids'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getcategory (username text, orgname text, geom Geometry, category_id text, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getcategory invoked with params (%, %, %, %, %, %)', username, orgname, geom, category_id, boundary_id, time_span;
  SELECT 'Wealthy, urban without Kids'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getdemographicsnapshot (username text, orgname text, geom geometry(Geometry, 4326), time_span text DEFAULT '2009 - 2013', geometry_level text DEFAULT '""us.census.tiger"".block_group')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getdemographicsnapshot invoked with params (%, %, %, %, %)', username, orgname, geom, time_span, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getdemographicsnapshot (username text, orgname text, geom geometry(Geometry, 4326), time_span text DEFAULT '2009 - 2013', geometry_level text DEFAULT '""us.census.tiger"".block_group')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getdemographicsnapshot invoked with params (%, %, %, %, %)', username, orgname, geom, time_span, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeasure (username text, orgname text, geom Geometry, measure_id text, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeasure invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, measure_id, normalize, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeasure (username text, orgname text, geom Geometry, measure_id text, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeasure invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, measure_id, normalize, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeasurebyid (username text, orgname text, geom_ref text, measure_id text, boundary_id text, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeasurebyid invoked with params (%, %, %, %, %, %)', username, orgname, geom_ref, measure_id, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeasurebyid (username text, orgname text, geom_ref text, measure_id text, boundary_id text, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeasurebyid invoked with params (%, %, %, %, %, %)', username, orgname, geom_ref, measure_id, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeta(username text, orgname text, geom geometry(Geometry, 4326), params JSON, max_timespan_rank INTEGER DEFAULT NULL, max_score_rank INTEGER DEFAULT NULL, target_geoms INTEGER DEFAULT NULL)
RETURNS JSON AS $$
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeta invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, params, max_timespan_rank, max_score_rank, target_geoms;
  RETURN '[{""id"" : 1, ""numer_id"" : ""us.census.acs.B01003001"", ""timespan_rank"" : 1, ""score_rank"" : 1, ""score"" : 19.9580760018781868330120152747832081562684, ""numer_aggregate"" : ""sum"", ""numer_colname"" : ""total_pop"", ""numer_geomref_colname"" : ""geoid"", ""numer_tablename"" : ""obs_209d3476ef8eaaa18e597cabcf1bdb627f37aa5e"", ""numer_type"" : ""Numeric"", ""denom_aggregate"" : null, ""denom_colname"" : null, ""denom_geomref_colname"" : null, ""denom_tablename"" : null, ""denom_type"" : null, ""geom_colname"" : ""the_geom"", ""geom_geomref_colname"" : ""geoid"", ""geom_tablename"" : ""obs_78fb6c1d6ff6505225175922c2c389ce48d7632c"", ""geom_type"" : ""Geometry"", ""geom_timespan"" : ""2015"", ""numer_timespan"" : ""2011 - 2015"", ""numer_name"" : ""Total Population"", ""denom_name"" : null, ""geom_name"" : ""US Census Block Groups"", ""normalization"" : null, ""denom_id"" : null, ""geom_id"" : ""us.census.tiger.block_group""}]'::JSON;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getmeta(username text, orgname text, geom geometry(Geometry, 4326), params JSON, max_timespan_rank INTEGER DEFAULT NULL, max_score_rank INTEGER DEFAULT NULL, target_geoms INTEGER DEFAULT NULL)
RETURNS JSON AS $$
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getmeta invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, params, max_timespan_rank, max_score_rank, target_geoms;
  RETURN '[{""id"" : 1, ""numer_id"" : ""us.census.acs.B01003001"", ""timespan_rank"" : 1, ""score_rank"" : 1, ""score"" : 19.9580760018781868330120152747832081562684, ""numer_aggregate"" : ""sum"", ""numer_colname"" : ""total_pop"", ""numer_geomref_colname"" : ""geoid"", ""numer_tablename"" : ""obs_209d3476ef8eaaa18e597cabcf1bdb627f37aa5e"", ""numer_type"" : ""Numeric"", ""denom_aggregate"" : null, ""denom_colname"" : null, ""denom_geomref_colname"" : null, ""denom_tablename"" : null, ""denom_type"" : null, ""geom_colname"" : ""the_geom"", ""geom_geomref_colname"" : ""geoid"", ""geom_tablename"" : ""obs_78fb6c1d6ff6505225175922c2c389ce48d7632c"", ""geom_type"" : ""Geometry"", ""geom_timespan"" : ""2015"", ""numer_timespan"" : ""2011 - 2015"", ""numer_name"" : ""Total Population"", ""denom_name"" : null, ""geom_name"" : ""US Census Block Groups"", ""normalization"" : null, ""denom_id"" : null, ""geom_id"" : ""us.census.tiger.block_group""}]'::JSON;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getpopulation (username text, orgname text, geom Geometry, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getpopulation invoked with params (%, %, %, %, %, %)', username, orgname, geom, normalize, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getpopulation (username text, orgname text, geom Geometry, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getpopulation invoked with params (%, %, %, %, %, %)', username, orgname, geom, normalize, boundary_id, time_span;
  SELECT 10923.093200390833950::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getsegmentsnapshot (username text, orgname text, geom geometry(Geometry, 4326), geometry_level text DEFAULT '""us.census.tiger"".census_tract')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getsegmentsnapshot invoked with params (%, %, %, %)', username, orgname, geom, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getsegmentsnapshot (username text, orgname text, geom geometry(Geometry, 4326), geometry_level text DEFAULT '""us.census.tiger"".census_tract')
RETURNS json AS $$
DECLARE
  ret json;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getsegmentsnapshot invoked with params (%, %, %, %)', username, orgname, geom, geometry_level;
  SELECT '{""total_pop"":9516.27915900609,""male_pop"":6152.51885204623,""female_pop"":3363.76030695986,""median_age"":28.8,""white_pop"":5301.51624447348,""black_pop"":149.500458087105,""asian_pop"":230.000704749392,""hispanic_pop"":3835.26175169611,""amerindian_pop"":0,""other_race_pop"":0,""two_or_more_races_pop"":0,""not_hispanic_pop"":5681.01740730998,""households"":3323.51018362871,""pop_25_years_over"":7107.02177675621,""high_school_diploma"":1040.753188991,""less_one_year_college"":69.0002114248176,""one_year_more_college"":793.502431385402,""associates_degree"":327.751004267883,""bachelors_degree"":2742.7584041365,""masters_degree"":931.502854235037,""median_income"":66304,""gini_index"":0.3494,""income_per_capita"":28291,""housing_units"":3662.76122313407,""vacant_housing_units"":339.251039505353,""vacant_housing_units_for_rent"":120.750369993431,""vacant_housing_units_for_sale"":0,""median_rent"":1764,""percent_income_spent_on_rent"":35.3,""owner_occupied_housing_units"":339.251039505353,""million_dollar_housing_units"":0,""mortgaged_housing_units"":224.250687130657,""commuters_16_over"":6549.27006773893,""commute_less_10_mins"":327.751004267883,""commute_10_14_mins"":28.750088093674,""commute_15_19_mins"":201.250616655718,""commute_20_24_mins"":621.001902823358,""commute_25_29_mins"":373.751145217762,""commute_30_34_mins"":1851.5056732326,""commute_35_44_mins"":1414.50433420876,""commute_45_59_mins"":1115.50341803455,""commute_60_more_mins"":615.251885204623,""aggregate_travel_time_to_work"":null,""income_less_10000"":57.500176187348,""income_10000_14999"":0,""income_15000_19999"":212.750651893187,""income_20000_24999"":408.251250930171,""income_25000_29999"":0,""income_30000_34999"":155.25047570584,""income_35000_39999"":109.250334755961,""income_40000_44999"":92.0002818997568,""income_45000_49999"":63.2501938060828,""income_50000_59999"":184.000563799514,""income_60000_74999"":621.001902823358,""income_75000_99999"":552.001691398541,""income_100000_124999"":327.751004267883,""income_125000_149999"":333.501021886618,""income_150000_199999"":126.500387612166,""income_200000_or_more"":null,""land_area"":null}'::json INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getuscensuscategory (username text, orgname text, geom Geometry, name text, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getuscensuscategory invoked with params (%, %, %, %, %, %)', username, orgname, geom, name, boundary_id, time_span;
  SELECT 'Wealthy, urban without Kids'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getuscensuscategory (username text, orgname text, geom Geometry, name text, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS text AS $$
DECLARE
  ret text;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getuscensuscategory invoked with params (%, %, %, %, %, %)', username, orgname, geom, name, boundary_id, time_span;
  SELECT 'Wealthy, urban without Kids'::text INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getuscensusmeasure (username text, orgname text, geom Geometry, name text, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getuscensusmeasure invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, name, normalize, boundary_id, time_span;
  SELECT 6789.5647735060920500::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.out
"CREATE OR REPLACE FUNCTION cdb_dataservices_server.obs_getuscensusmeasure (username text, orgname text, geom Geometry, name text, normalize text DEFAULT NULL, boundary_id text DEFAULT NULL, time_span text DEFAULT NULL)
RETURNS numeric AS $$
DECLARE
  ret numeric;
BEGIN
  RAISE NOTICE 'cdb_dataservices_server.obs_getuscensusmeasure invoked with params (%, %, %, %, %, %, %)', username, orgname, geom, name, normalize, boundary_id, time_span;
  SELECT 6789.5647735060920500::numeric INTO ret;
  RETURN ret;
END;
$$ LANGUAGE 'plpgsql';",90_data_observatory_test.sql
"CREATE OR REPLACE FUNCTION checkNull(s text) RETURNS TEXT AS $$
    BEGIN
        IF (s = '') THEN
            RETURN 'NULL';
        ELSIF (s is NULL) THEN
            RETURN 'NULL';
        ELSE
            RETURN s;
        END IF;
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION check_partition_type (p_type text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER
    AS $$
DECLARE
v_result    boolean;
BEGIN
/*
 * Check for valid config table partition types
 */
    SELECT p_type IN ('partman', 'time-custom', 'native') INTO v_result;
    RETURN v_result;
END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION check_subpartition_limits(p_parent_table text, p_type text, OUT sub_min text, OUT sub_max text) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE

v_parent_schema         text;
v_parent_tablename      text;
v_top_control           text;
v_top_control_type      text;
v_top_epoch             text;
v_top_interval          text;
v_top_schema            text;
v_top_tablename         text;

BEGIN
/*
 * Check if parent table is a subpartition of an already existing partition set managed by pg_partman
 *  If so, return the limits of what child tables can be created under the given parent table based on its own suffix
 *  If not, return NULL. Allows caller to check for NULL and then know if the given parent has sub-partition limits.
 */

SELECT n.nspname, c.relname INTO v_parent_schema, v_parent_tablename
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE n.nspname = split_part(p_parent_table, '.', 1)::name
AND c.relname = split_part(p_parent_table, '.', 2)::name;

WITH top_oid AS (
    SELECT i.inhparent AS top_parent_oid
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_inherits i ON c.oid = i.inhrelid
    JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = v_parent_schema
    AND c.relname = v_parent_tablename
) 
SELECT n.nspname, c.relname, p.partition_interval, p.control, p.epoch
INTO v_top_schema, v_top_tablename, v_top_interval, v_top_control, v_top_epoch
FROM pg_catalog.pg_class c
JOIN top_oid t ON c.oid = t.top_parent_oid
JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace
JOIN @extschema@.part_config p ON p.parent_table = n.nspname||'.'||c.relname
WHERE c.oid = t.top_parent_oid;

SELECT general_type INTO v_top_control_type
FROM @extschema@.check_control_type(v_top_schema, v_top_tablename, v_top_control);

IF v_top_control_type = 'id' AND v_top_epoch <> 'none' THEN
    v_top_control_type := 'time';
END IF;

-- If sub-partition is different type than top parent, no need to set limits
IF p_type = v_top_control_type THEN
    IF p_type = 'time' THEN
        SELECT child_start_time::text, child_end_time::text 
        INTO sub_min, sub_max
        FROM @extschema@.show_partition_info(p_parent_table, v_top_interval, v_top_schema||'.'||v_top_tablename);
    ELSIF p_type = 'id' THEN
        SELECT child_start_id::text, child_end_id::text 
        INTO sub_min, sub_max
        FROM @extschema@.show_partition_info(p_parent_table, v_top_interval, v_top_schema||'.'||v_top_tablename);
    ELSE
        RAISE EXCEPTION 'Reached unknown state in check_subpartition_limits(). Please report what lead to this condition to author';
    END IF;
END IF;

RETURN;

END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION check_version(p_check_version text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

v_check_version     text[];
v_current_version   text[] := string_to_array(current_setting('server_version'), '.');
 
BEGIN
/*
 * Check PostgreSQL version number. Parameter must be full 3 point version if prior to 10.0. Otherwise 2 point version.
 * Returns true if current version is greater than or equal to the parameter given.
 * If running version is devel, alpha, beta or rc, the check always returns true.
 */

v_check_version := string_to_array(p_check_version, '.');

IF substring(v_current_version[1] from 'devel') IS NOT NULL THEN
    -- You're running a test version. You're on your own if things fail.
    RETURN true;
END IF;
IF v_current_version[1]::int > v_check_version[1]::int THEN
    RETURN true;
END IF;
IF v_current_version[1]::int = v_check_version[1]::int THEN
    IF substring(v_current_version[2] from 'beta') IS NOT NULL 
        OR substring(v_current_version[2] from 'alpha') IS NOT NULL 
        OR substring(v_current_version[2] from 'rc') IS NOT NULL 
    THEN
        -- You're running a test version. You're on your own if things fail.
        RETURN true;
    END IF;
    IF v_current_version[2]::int > v_check_version[2]::int THEN
        RETURN true;
    END IF;
    IF v_current_version[2]::int = v_check_version[2]::int THEN
        IF array_length(v_current_version, 1) <= 2 THEN
            -- Account for reduction to 2 number version in 10.0
            RETURN true;
        END IF; 
        IF v_current_version[3]::int >= v_check_version[3]::int THEN
            RETURN true;
        END IF; -- 0.0.x
    END IF; -- 0.x.0
END IF; -- x.0.0

RETURN false;

END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.change_ade_column_srid(
  table_name varchar,
  geom_column varchar,
  geom_type varchar,
  schema_name varchar DEFAULT 'citydb'::varchar
)
  RETURNS void AS $$
DECLARE
  db_srid integer;
BEGIN
-- get the Srid already defined in the table database_srs
EXECUTE format('SELECT srid FROM %I.database_srs LIMIT 1',schema_name) INTO db_srid; 
-- RAISE INFO 'Found SRID % for schema %', db_srid, schema_name;
-- RAISE INFO 'Setting SRID for %.%', table_name, geom_column;
EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I TYPE geometry(%I,%L) USING ST_SetSrid(%I,%L)',
			 schema_name, 
			 table_name, 
			 geom_column, 
			 geom_type, 
			 db_srid, 
			 geom_column,
			 db_srid); 
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.change_ade_column_srid(%, %, %, %): %', table_name, geom_column, geom_type,  schema_name, SQLERRM;
END;
$$ LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.change_ade_column_srid(
  table_name varchar,
  geom_column varchar,
  geom_type varchar,
  schema_name varchar DEFAULT 'citydb'::varchar
)
  RETURNS void AS $$
DECLARE
  db_srid integer;
BEGIN
-- get the Srid already defined in the table database_srs
EXECUTE format('SELECT srid FROM %I.database_srs LIMIT 1',schema_name) INTO db_srid; 
-- RAISE INFO 'Found SRID % for schema %', db_srid, schema_name;
-- RAISE INFO 'Setting SRID for %.%', table_name, geom_column;
EXECUTE format('ALTER TABLE %I.%I ALTER COLUMN %I TYPE geometry(%I,%L) USING ST_SetSrid(%I,%L)',
			 schema_name, 
			 table_name, 
			 geom_column, 
			 geom_type, 
			 db_srid, 
			 geom_column,
			 db_srid); 
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.change_ade_column_srid(%, %, %, %): %', table_name, geom_column, geom_type,  schema_name, SQLERRM;
END;
$$ LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.cleanup_schema(
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS void AS
$BODY$
DECLARE
	test varchar = NULL;
	db_prefix varchar;	
BEGIN
-- First check whether there are ADE-related tables (by db_prefix)
-- If so, then first truncate the ADE-tables, and only then proceed
-- with the vanilla tables
EXECUTE format('SELECT db_prefix FROM %I.ade LIMIT 1',schema_name) INTO test;
IF test IS NOT NULL THEN
	-- there is at least an ADE
	FOR db_prefix IN EXECUTE format('SELECT db_prefix FROM %I.ade', schema_name) LOOP
		--RAISE NOTICE '---------- Found db_prefix: ""%"" in %',db_prefix, schema_name;
		EXECUTE format('SELECT citydb_pkg.%I_cleanup_schema(%L)',db_prefix, schema_name);
	END LOOP;
	RAISE NOTICE '--- Completed data cleanup of ADE with db_prefix: ""%"" in %',db_prefix, schema_name;
ELSE
-- do nothing
END IF;

-- Now proceed with the vanilla tables.
-- clear vanilla tables
EXECUTE format('TRUNCATE TABLE %I.cityobject CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.tex_image CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.grid_coverage CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.address CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.citymodel CASCADE', schema_name);

--restart vanilla sequences
EXECUTE format('ALTER SEQUENCE %I.address_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.appearance_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.citymodel_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_genericatt_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.external_ref_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.grid_coverage_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.implicit_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_data_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.tex_image_seq RESTART', schema_name);

EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.cleanup_schema: %', SQLERRM;
END; 
$BODY$
  LANGUAGE plpgsql VOLATILE;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.cleanup_schema(
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS void AS
$BODY$
DECLARE
	test varchar = NULL;
	db_prefix varchar;	
BEGIN
-- First check whether there are ADE-related tables (by db_prefix)
-- If so, then first truncate the ADE-tables, and only then proceed
-- with the vanilla tables
EXECUTE format('SELECT db_prefix FROM %I.ade LIMIT 1',schema_name) INTO test;
IF test IS NOT NULL THEN
	-- there is at least an ADE
	FOR db_prefix IN EXECUTE format('SELECT db_prefix FROM %I.ade', schema_name) LOOP
		--RAISE NOTICE '---------- Found db_prefix: ""%"" in %',db_prefix, schema_name;
		EXECUTE format('SELECT citydb_pkg.%I_cleanup_schema(%L)',db_prefix, schema_name);
	END LOOP;
	RAISE NOTICE '--- Completed data cleanup of ADE with db_prefix: ""%"" in %',db_prefix, schema_name;
ELSE
-- do nothing
END IF;

-- Now proceed with the vanilla tables.
-- clear vanilla tables
EXECUTE format('TRUNCATE TABLE %I.cityobject CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.tex_image CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.grid_coverage CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.address CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.citymodel CASCADE', schema_name);
--restart vanilla sequences
EXECUTE format('ALTER SEQUENCE %I.address_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.appearance_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.citymodel_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_genericatt_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.external_ref_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.grid_coverage_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.implicit_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_data_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.tex_image_seq RESTART', schema_name);

EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.cleanup_schema: %', SQLERRM;
END; 
$BODY$
  LANGUAGE plpgsql VOLATILE;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.cleanup_schema_orig(
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS void AS
$BODY$
BEGIN
-- clear tables
EXECUTE format('TRUNCATE TABLE %I.cityobject CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.tex_image CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.grid_coverage CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.address CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.citymodel CASCADE', schema_name);

-- restart sequences
EXECUTE format('ALTER SEQUENCE %I.address_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.appearance_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.citymodel_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_genericatt_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.external_ref_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.grid_coverage_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.implicit_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_data_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.tex_image_seq RESTART', schema_name);

EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.cleanup_schema: %', SQLERRM;
END; 
$BODY$
  LANGUAGE plpgsql VOLATILE;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.cleanup_schema_orig(
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS void AS
$BODY$
BEGIN
-- clear tables
EXECUTE format('TRUNCATE TABLE %I.cityobject CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.tex_image CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.grid_coverage CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.address CASCADE', schema_name);
EXECUTE format('TRUNCATE TABLE %I.citymodel CASCADE', schema_name);
-- restart sequences
EXECUTE format('ALTER SEQUENCE %I.address_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.appearance_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.citymodel_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_genericatt_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.cityobject_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.external_ref_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.grid_coverage_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.implicit_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_data_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.surface_geometry_seq RESTART', schema_name);
EXECUTE format('ALTER SEQUENCE %I.tex_image_seq RESTART', schema_name);

EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.cleanup_schema: %', SQLERRM;
END; 
$BODY$
  LANGUAGE plpgsql VOLATILE;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.drop_ade_functions(
	db_prefix varchar)
RETURNS varchar AS $$
DECLARE
	db_prefix_length varchar;
	test integer;
	rec RECORD;
BEGIN
IF db_prefix IS NOT NULL THEN
	db_prefix_length=char_length(db_prefix);
	-- Check whether there are any prefixed functions to drop at all!
	EXECUTE format('SELECT 1 FROM information_schema.routines WHERE routine_type=''FUNCTION'' AND routine_schema=''citydb_pkg'' AND substring(routine_name, 1, %L::integer)=%L LIMIT 1', db_prefix_length, db_prefix) INTO test;
	IF test IS NOT NULL AND test=1 THEN
		--RAISE INFO 'Removing all functions with db_prefix ""%"" in schema citydb_pkg',  db_prefix;	
		FOR rec IN EXECUTE format('SELECT proname || ''('' || oidvectortypes(proargtypes) || '')'' AS function_name
		FROM pg_proc INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid)
		WHERE ns.nspname = ''citydb_pkg'' AND substring(proname, 1, %L)=%L ORDER BY proname', db_prefix_length, db_prefix) LOOP
			--RAISE NOTICE 'Dropping FUNCTION citydb_pkg.%',rec.function_name;
			EXECUTE 'DROP FUNCTION IF EXISTS citydb_pkg.' || rec.function_name || ' CASCADE'; 
		END LOOP;
		RETURN db_prefix;
	ELSE
		RAISE INFO '-- No functions found';
		RETURN NULL;		
	END IF;
ELSE
	RAISE NOTICE 'citydb_pkg.adrop_ade_functions: db_prefix is NULL, nothing to do';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.drop_ade_functions (db_prefix: %) in ""%"", %', db_prefix, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.drop_ade_functions(
	db_prefix varchar)
RETURNS varchar AS $$
DECLARE
	db_prefix_length varchar;
	test integer;
	rec RECORD;
BEGIN
IF db_prefix IS NOT NULL THEN
	db_prefix_length=char_length(db_prefix);
	-- Check whether there are any prefixed functions to drop at all!
	EXECUTE format('SELECT 1 FROM information_schema.routines WHERE routine_type=''FUNCTION'' AND routine_schema=''citydb_pkg'' AND substring(routine_name, 1, %L::integer)=%L LIMIT 1', db_prefix_length, db_prefix) INTO test;
	IF test IS NOT NULL AND test=1 THEN
		--RAISE INFO 'Removing all functions with db_prefix ""%"" in schema citydb_pkg',  db_prefix;	
		FOR rec IN EXECUTE format('SELECT proname || ''('' || oidvectortypes(proargtypes) || '')'' AS function_name
		FROM pg_proc INNER JOIN pg_namespace ns ON (pg_proc.pronamespace = ns.oid)
		WHERE ns.nspname = ''citydb_pkg'' AND substring(proname, 1, %L)=%L ORDER BY proname', db_prefix_length, db_prefix) LOOP
			--RAISE NOTICE 'Dropping FUNCTION citydb_pkg.%',rec.function_name;
			EXECUTE 'DROP FUNCTION IF EXISTS citydb_pkg.' || rec.function_name || ' CASCADE'; 
		END LOOP;
		RETURN db_prefix;
	ELSE
		RAISE INFO '-- No functions found';
		RETURN NULL;		
	END IF;
ELSE
	RAISE NOTICE 'citydb_pkg.adrop_ade_functions: db_prefix is NULL, nothing to do';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.drop_ade_functions (db_prefix: %) in ""%"", %', db_prefix, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.drop_ade_tables(
	db_prefix varchar,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS varchar AS $$
DECLARE
	db_prefix_length varchar;
	test integer;
	rec RECORD;
BEGIN
IF db_prefix IS NOT NULL THEN
	db_prefix_length=char_length(db_prefix);
	-- Check whether there are any prefixed tables to drop at all!
	EXECUTE format('SELECT 1 FROM information_schema.tables WHERE table_type=''BASE TABLE'' AND table_schema=%L AND substring(table_name, 1, %L::integer)=%L LIMIT 1',schema_name, db_prefix_length, db_prefix) INTO test;
	IF test IS NOT NULL AND test=1 THEN
		--RAISE INFO 'Removing all tables with db_prefix ""%"" in schema ""%""',  db_prefix, schema_name;		
		FOR rec IN EXECUTE format('SELECT table_schema, table_name FROM information_schema.tables WHERE table_type=''BASE TABLE'' AND table_schema=%L AND substring(table_name, 1, %L::integer)=%L',schema_name,  
			 db_prefix_length, db_prefix) LOOP
			--RAISE INFO 'Dropping table %.%',rec.table_schema, rec.table_name;
			EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE',rec.table_schema, rec.table_name);
		END LOOP;
		RETURN db_prefix;
	ELSE
		RAISE INFO '-- No tables found'; 
		RETURN NULL;
	END IF;
ELSE
	RAISE NOTICE 'citydb_pkg.drop_ade_tables: db_prefix is NULL, nothing to do';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.drop_ade_tables (db_prefix: %) in ""%"", %', db_prefix, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.drop_ade_tables(
	db_prefix varchar,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS varchar AS $$
DECLARE
	db_prefix_length varchar;
	test integer;
	rec RECORD;
BEGIN
IF db_prefix IS NOT NULL THEN
	db_prefix_length=char_length(db_prefix);
	-- Check whether there are any prefixed tables to drop at all!
	EXECUTE format('SELECT 1 FROM information_schema.tables WHERE table_type=''BASE TABLE'' AND table_schema=%L AND substring(table_name, 1, %L::integer)=%L LIMIT 1',schema_name, db_prefix_length, db_prefix) INTO test;
	IF test IS NOT NULL AND test=1 THEN
		--RAISE INFO 'Removing all tables with db_prefix ""%"" in schema ""%""',  db_prefix, schema_name;		
		FOR rec IN EXECUTE format('SELECT table_schema, table_name FROM information_schema.tables WHERE table_type=''BASE TABLE'' AND table_schema=%L AND substring(table_name, 1, %L::integer)=%L',schema_name,  
			 db_prefix_length, db_prefix) LOOP
			--RAISE INFO 'Dropping table %.%',rec.table_schema, rec.table_name;
			EXECUTE format('DROP TABLE IF EXISTS %I.%I CASCADE',rec.table_schema, rec.table_name);
		END LOOP;
		RETURN db_prefix;
	ELSE
		RAISE INFO '-- No tables found'; 
		RETURN NULL;
	END IF;
ELSE
	RAISE NOTICE 'citydb_pkg.drop_ade_tables: db_prefix is NULL, nothing to do';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.drop_ade_tables (db_prefix: %) in ""%"", %', db_prefix, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_classname(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS varchar
AS $BODY$
DECLARE
	classname varchar;
BEGIN
IF class_id IS NOT NULL THEN
	-- get the classname of the class
	EXECUTE format('SELECT classname FROM %I.objectclass WHERE id=%L',schema_name,class_id) INTO classname;
	--RAISE NOTICE 'classname %', classname
	RETURN classname;
ELSE
	RAISE NOTICE 'citydb_pkg.get_classname: Class_id is NULL';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_classname (class_id: %, schema_name ""%""): %', class_id, schema_name, SQLERRM;
END;
$BODY$
LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_classname(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS varchar
AS $BODY$
DECLARE
	classname varchar;
BEGIN
IF class_id IS NOT NULL THEN
	-- get the classname of the class
	EXECUTE format('SELECT classname FROM %I.objectclass WHERE id=%L',schema_name,class_id) INTO classname;
	--RAISE NOTICE 'classname %', classname
	RETURN classname;
ELSE
	RAISE NOTICE 'citydb_pkg.get_classname: Class_id is NULL';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_classname (class_id: %, schema_name ""%""): %', class_id, schema_name, SQLERRM;
END;
$BODY$
LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_envelope_cityobject(
	co_id integer,
	objclass_id integer DEFAULT 0,
	set_envelope integer DEFAULT 0,
	schema_name varchar DEFAULT 'citydb'::varchar)
  RETURNS geometry AS
$BODY$
DECLARE
	class_id INTEGER = 0;
	class_info RECORD;
	envelope GEOMETRY;
	db_srid INTEGER;
BEGIN
-- get class_id if it is NULL or zero
IF objclass_id IS NULL OR objclass_id = 0 THEN
    EXECUTE format('SELECT objectclass_id FROM %I.cityobject WHERE id = %L', schema_name, co_id) INTO class_id;
ELSE
    class_id:=objclass_id;
END IF;
-- now I am sure that class id <> 0 AND IS NOT NULL

EXECUTE format('SELECT t.* FROM citydb_pkg.get_objectclass_info(%L, %L) AS t', class_id, schema_name) INTO class_info;
-- This funtion returns class_info.db_prefix varchar, class_info.classname varchar, class_info.is_ade_class numeric(1,0)
--RAISE NOTICE 'Class_info %'), class_info;

IF class_info.is_ade_class::integer=1 THEN
-- we are dealing with an ADE cityobject, so call the respective ADE get_envelope_cityobject() function, which is identified by its db_prefix

	EXECUTE format('SELECT citydb_pkg.%I_get_envelope_cityobject(%L, %L, %L, %L)', class_info.db_prefix, co_id, objclass_id, set_envelope, schema_name) INTO envelope;			

ELSE -- i.e. is_ade_class::integer=0 
	-- we are dealing with a vanilla CityObject class, so use the ""vanilla"" approach.
	CASE
		WHEN class_id = 4 THEN envelope := citydb_pkg.get_envelope_land_use(co_id, set_envelope, schema_name);
		WHEN class_id = 5 THEN envelope := citydb_pkg.get_envelope_generic_cityobj(co_id, set_envelope, schema_name);
		WHEN class_id = 7 THEN envelope := citydb_pkg.get_envelope_solitary_veg_obj(co_id, set_envelope, schema_name);
		WHEN class_id = 8 THEN envelope := citydb_pkg.get_envelope_plant_cover(co_id, set_envelope, schema_name);
		WHEN class_id = 9 THEN envelope := citydb_pkg.get_envelope_waterbody(co_id, set_envelope, schema_name);
		WHEN class_id = 11 OR
			 class_id = 12 OR
			 class_id = 13 THEN envelope := citydb_pkg.get_envelope_waterbnd_surface(co_id, set_envelope, schema_name);
		WHEN class_id = 14 THEN envelope := citydb_pkg.get_envelope_relief_feature(co_id, set_envelope, schema_name);
		WHEN class_id = 16 OR
			 class_id = 17 OR
			 class_id = 18 OR
			 class_id = 19 THEN envelope := citydb_pkg.get_envelope_relief_component(co_id, class_id, set_envelope, schema_name);
		WHEN class_id = 21 THEN envelope := citydb_pkg.get_envelope_city_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 23 THEN envelope := citydb_pkg.get_envelope_cityobjectgroup(co_id, set_envelope, 1, schema_name);
		WHEN class_id = 25 OR
			 class_id = 26 THEN envelope := citydb_pkg.get_envelope_building(co_id, set_envelope, schema_name);
		WHEN class_id = 27 OR
			 class_id = 28 THEN envelope := citydb_pkg.get_envelope_building_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 30 OR
			 class_id = 31 OR
			 class_id = 32 OR
			 class_id = 33 OR
			 class_id = 34 OR
			 class_id = 35 OR
			 class_id = 36 OR
			 class_id = 60 OR
			 class_id = 61 THEN envelope := citydb_pkg.get_envelope_thematic_surface(co_id, set_envelope, schema_name);
		WHEN class_id = 38 OR
			 class_id = 39 THEN envelope := citydb_pkg.get_envelope_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 40 THEN envelope := citydb_pkg.get_envelope_building_furn(co_id, set_envelope, schema_name);
		WHEN class_id = 41 THEN envelope := citydb_pkg.get_envelope_room(co_id, set_envelope, schema_name);
		WHEN class_id = 43 OR
			 class_id = 44 OR
			 class_id = 45 OR
			 class_id = 46 THEN envelope := citydb_pkg.get_envelope_trans_complex(co_id, set_envelope, schema_name);
		WHEN class_id = 47 OR
			 class_id = 48 THEN envelope := citydb_pkg.get_envelope_traffic_area(co_id, set_envelope, schema_name);
		WHEN class_id = 63 OR
			 class_id = 64 THEN envelope := citydb_pkg.get_envelope_bridge(co_id, set_envelope, schema_name);
		WHEN class_id = 65 OR
			 class_id = 66 THEN envelope := citydb_pkg.get_envelope_bridge_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 68 OR
			 class_id = 69 OR
			 class_id = 70 OR
			 class_id = 71 OR
			 class_id = 72 OR
			 class_id = 73 OR
			 class_id = 74 OR
			 class_id = 75 OR
			 class_id = 76 THEN envelope := citydb_pkg.get_envelope_bridge_them_srf(co_id, set_envelope, schema_name);
		WHEN class_id = 78 OR
			 class_id = 79 THEN envelope := citydb_pkg.get_envelope_bridge_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 80 THEN envelope := citydb_pkg.get_envelope_bridge_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 81 THEN envelope := citydb_pkg.get_envelope_bridge_room(co_id, set_envelope, schema_name);
		WHEN class_id = 82 THEN envelope := citydb_pkg.get_envelope_bridge_const_elem(co_id, set_envelope, schema_name);
		WHEN class_id = 84 OR
			 class_id = 85 THEN envelope := citydb_pkg.get_envelope_tunnel(co_id, set_envelope, schema_name);
		WHEN class_id = 86 OR
			 class_id = 87 THEN envelope := citydb_pkg.get_envelope_tunnel_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 89 OR
			 class_id = 90 OR
			 class_id = 91 OR
			 class_id = 92 OR
			 class_id = 93 OR
			 class_id = 94 OR
			 class_id = 95 OR
			 class_id = 96 OR
			 class_id = 97 THEN envelope := citydb_pkg.get_envelope_tunnel_them_srf(co_id, set_envelope, schema_name);
		WHEN class_id = 99 OR
			 class_id = 100 THEN envelope := citydb_pkg.get_envelope_tunnel_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 101 THEN envelope := citydb_pkg.get_envelope_tunnel_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 102 THEN envelope := citydb_pkg.get_envelope_tunnel_hspace(co_id, set_envelope, schema_name);
	ELSE
		RAISE NOTICE 'Cannot get envelope of object with ID % and objectclass_id %.', co_id, class_id;
		RETURN NULL;
	END CASE;
END IF;

RAISE NOTICE 'Computed envelope of CityObject (%, class_id %) with id: %', class_info.classname, class_id, co_id;
RETURN envelope;

EXCEPTION
  WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_envelope_cityobject (id: %): %', co_id, SQLERRM;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_envelope_cityobject(
	co_id integer,
	objclass_id integer DEFAULT 0,
	set_envelope integer DEFAULT 0,
	schema_name varchar DEFAULT 'citydb'::varchar)
  RETURNS geometry AS
$BODY$
DECLARE
	class_id INTEGER = 0;
	class_info RECORD;
	envelope GEOMETRY;
	db_srid INTEGER;
BEGIN
-- get class_id if it is NULL or zero
IF objclass_id IS NULL OR objclass_id = 0 THEN
    EXECUTE format('SELECT objectclass_id FROM %I.cityobject WHERE id = %L', schema_name, co_id) INTO class_id;
ELSE
    class_id:=objclass_id;
END IF;
-- now I am sure that class id <> 0 AND IS NOT NULL

EXECUTE format('SELECT t.* FROM citydb_pkg.get_objectclass_info(%L, %L) AS t', class_id, schema_name) INTO class_info;
-- This funtion returns class_info.db_prefix varchar, class_info.classname varchar, class_info.is_ade_class numeric(1,0)
--RAISE NOTICE 'Class_info %'), class_info;

IF class_info.is_ade_class::integer=1 THEN
-- we are dealing with an ADE cityobject, so call the respective ADE get_envelope_cityobject() function, which is identified by its db_prefix

	EXECUTE format('SELECT citydb_pkg.%I_get_envelope_cityobject(%L, %L, %L, %L)', class_info.db_prefix, co_id, objclass_id, set_envelope, schema_name) INTO envelope;			

ELSE -- i.e. is_ade_class::integer=0 
	-- we are dealing with a vanilla CityObject class, so use the ""vanilla"" approach.
	CASE
		WHEN class_id = 4 THEN envelope := citydb_pkg.get_envelope_land_use(co_id, set_envelope, schema_name);
		WHEN class_id = 5 THEN envelope := citydb_pkg.get_envelope_generic_cityobj(co_id, set_envelope, schema_name);
		WHEN class_id = 7 THEN envelope := citydb_pkg.get_envelope_solitary_veg_obj(co_id, set_envelope, schema_name);
		WHEN class_id = 8 THEN envelope := citydb_pkg.get_envelope_plant_cover(co_id, set_envelope, schema_name);
		WHEN class_id = 9 THEN envelope := citydb_pkg.get_envelope_waterbody(co_id, set_envelope, schema_name);
		WHEN class_id = 11 OR
			 class_id = 12 OR
			 class_id = 13 THEN envelope := citydb_pkg.get_envelope_waterbnd_surface(co_id, set_envelope, schema_name);
		WHEN class_id = 14 THEN envelope := citydb_pkg.get_envelope_relief_feature(co_id, set_envelope, schema_name);
		WHEN class_id = 16 OR
			 class_id = 17 OR
			 class_id = 18 OR
			 class_id = 19 THEN envelope := citydb_pkg.get_envelope_relief_component(co_id, class_id, set_envelope, schema_name);
		WHEN class_id = 21 THEN envelope := citydb_pkg.get_envelope_city_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 23 THEN envelope := citydb_pkg.get_envelope_cityobjectgroup(co_id, set_envelope, 1, schema_name);
		WHEN class_id = 25 OR
			 class_id = 26 THEN envelope := citydb_pkg.get_envelope_building(co_id, set_envelope, schema_name);
		WHEN class_id = 27 OR
			 class_id = 28 THEN envelope := citydb_pkg.get_envelope_building_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 30 OR
			 class_id = 31 OR
			 class_id = 32 OR
			 class_id = 33 OR
			 class_id = 34 OR
			 class_id = 35 OR
			 class_id = 36 OR
			 class_id = 60 OR
			 class_id = 61 THEN envelope := citydb_pkg.get_envelope_thematic_surface(co_id, set_envelope, schema_name);
		WHEN class_id = 38 OR
			 class_id = 39 THEN envelope := citydb_pkg.get_envelope_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 40 THEN envelope := citydb_pkg.get_envelope_building_furn(co_id, set_envelope, schema_name);
		WHEN class_id = 41 THEN envelope := citydb_pkg.get_envelope_room(co_id, set_envelope, schema_name);
		WHEN class_id = 43 OR
			 class_id = 44 OR
			 class_id = 45 OR
			 class_id = 46 THEN envelope := citydb_pkg.get_envelope_trans_complex(co_id, set_envelope, schema_name);
		WHEN class_id = 47 OR
			 class_id = 48 THEN envelope := citydb_pkg.get_envelope_traffic_area(co_id, set_envelope, schema_name);
		WHEN class_id = 63 OR
			 class_id = 64 THEN envelope := citydb_pkg.get_envelope_bridge(co_id, set_envelope, schema_name);
		WHEN class_id = 65 OR
			 class_id = 66 THEN envelope := citydb_pkg.get_envelope_bridge_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 68 OR
			 class_id = 69 OR
			 class_id = 70 OR
			 class_id = 71 OR
			 class_id = 72 OR
			 class_id = 73 OR
			 class_id = 74 OR
			 class_id = 75 OR
			 class_id = 76 THEN envelope := citydb_pkg.get_envelope_bridge_them_srf(co_id, set_envelope, schema_name);
		WHEN class_id = 78 OR
			 class_id = 79 THEN envelope := citydb_pkg.get_envelope_bridge_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 80 THEN envelope := citydb_pkg.get_envelope_bridge_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 81 THEN envelope := citydb_pkg.get_envelope_bridge_room(co_id, set_envelope, schema_name);
		WHEN class_id = 82 THEN envelope := citydb_pkg.get_envelope_bridge_const_elem(co_id, set_envelope, schema_name);
		WHEN class_id = 84 OR
			 class_id = 85 THEN envelope := citydb_pkg.get_envelope_tunnel(co_id, set_envelope, schema_name);
		WHEN class_id = 86 OR
			 class_id = 87 THEN envelope := citydb_pkg.get_envelope_tunnel_inst(co_id, set_envelope, schema_name);
		WHEN class_id = 89 OR
			 class_id = 90 OR
			 class_id = 91 OR
			 class_id = 92 OR
			 class_id = 93 OR
			 class_id = 94 OR
			 class_id = 95 OR
			 class_id = 96 OR
			 class_id = 97 THEN envelope := citydb_pkg.get_envelope_tunnel_them_srf(co_id, set_envelope, schema_name);
		WHEN class_id = 99 OR
			 class_id = 100 THEN envelope := citydb_pkg.get_envelope_tunnel_opening(co_id, set_envelope, schema_name);
		WHEN class_id = 101 THEN envelope := citydb_pkg.get_envelope_tunnel_furniture(co_id, set_envelope, schema_name);
		WHEN class_id = 102 THEN envelope := citydb_pkg.get_envelope_tunnel_hspace(co_id, set_envelope, schema_name);
	ELSE
		RAISE NOTICE 'Cannot get envelope of object with ID % and objectclass_id %.', co_id, class_id;
		RETURN NULL;
	END CASE;
END IF;

RAISE NOTICE 'Computed envelope of CityObject (%, class_id %) with id: %', class_info.classname, class_id, co_id;
RETURN envelope;

EXCEPTION
  WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_envelope_cityobject (id: %): %', co_id, SQLERRM;
END;
$BODY$
LANGUAGE plpgsql VOLATILE;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_envelope_cityobject_orig(
	co_id integer,
	objclass_id integer DEFAULT 0,
	set_envelope integer DEFAULT 0,
	schema_name character varying DEFAULT 'citydb'::character varying)
  RETURNS geometry AS
$BODY$
DECLARE
	class_id INTEGER = 0;
	envelope GEOMETRY;
	db_srid INTEGER;
BEGIN
-- fetching class_id if it is NULL
IF objclass_id IS NULL OR objclass_id = 0 THEN
    EXECUTE format('SELECT objectclass_id FROM %I.cityobject WHERE id = %L', schema_name, co_id) INTO class_id;
ELSE
    class_id := objclass_id;
END IF;
CASE
	WHEN class_id = 4 THEN envelope := citydb_pkg.get_envelope_land_use(co_id, set_envelope, schema_name);
	WHEN class_id = 5 THEN envelope := citydb_pkg.get_envelope_generic_cityobj(co_id, set_envelope, schema_name);
	WHEN class_id = 7 THEN envelope := citydb_pkg.get_envelope_solitary_veg_obj(co_id, set_envelope, schema_name);
	WHEN class_id = 8 THEN envelope := citydb_pkg.get_envelope_plant_cover(co_id, set_envelope, schema_name);
	WHEN class_id = 9 THEN envelope := citydb_pkg.get_envelope_waterbody(co_id, set_envelope, schema_name);
	WHEN class_id = 11 OR
		 class_id = 12 OR
		 class_id = 13 THEN envelope := citydb_pkg.get_envelope_waterbnd_surface(co_id, set_envelope, schema_name);
	WHEN class_id = 14 THEN envelope := citydb_pkg.get_envelope_relief_feature(co_id, set_envelope, schema_name);
	WHEN class_id = 16 OR
		 class_id = 17 OR
		 class_id = 18 OR
		 class_id = 19 THEN envelope := citydb_pkg.get_envelope_relief_component(co_id, class_id, set_envelope, schema_name);
	WHEN class_id = 21 THEN envelope := citydb_pkg.get_envelope_city_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 23 THEN envelope := citydb_pkg.get_envelope_cityobjectgroup(co_id, set_envelope, 1, schema_name);
	WHEN class_id = 25 OR
		 class_id = 26 THEN envelope := citydb_pkg.get_envelope_building(co_id, set_envelope, schema_name);
	WHEN class_id = 27 OR
		 class_id = 28 THEN envelope := citydb_pkg.get_envelope_building_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 30 OR
		 class_id = 31 OR
		 class_id = 32 OR
		 class_id = 33 OR
		 class_id = 34 OR
		 class_id = 35 OR
		 class_id = 36 OR
		 class_id = 60 OR
		 class_id = 61 THEN envelope := citydb_pkg.get_envelope_thematic_surface(co_id, set_envelope, schema_name);
	WHEN class_id = 38 OR
		 class_id = 39 THEN envelope := citydb_pkg.get_envelope_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 40 THEN envelope := citydb_pkg.get_envelope_building_furn(co_id, set_envelope, schema_name);
	WHEN class_id = 41 THEN envelope := citydb_pkg.get_envelope_room(co_id, set_envelope, schema_name);
	WHEN class_id = 43 OR
		 class_id = 44 OR
		 class_id = 45 OR
		 class_id = 46 THEN envelope := citydb_pkg.get_envelope_trans_complex(co_id, set_envelope, schema_name);
	WHEN class_id = 47 OR
		 class_id = 48 THEN envelope := citydb_pkg.get_envelope_traffic_area(co_id, set_envelope, schema_name);
	WHEN class_id = 63 OR
		 class_id = 64 THEN envelope := citydb_pkg.get_envelope_bridge(co_id, set_envelope, schema_name);
	WHEN class_id = 65 OR
		 class_id = 66 THEN envelope := citydb_pkg.get_envelope_bridge_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 68 OR
		 class_id = 69 OR
		 class_id = 70 OR
		 class_id = 71 OR
		 class_id = 72 OR
		 class_id = 73 OR
		 class_id = 74 OR
		 class_id = 75 OR
		 class_id = 76 THEN envelope := citydb_pkg.get_envelope_bridge_them_srf(co_id, set_envelope, schema_name);
	WHEN class_id = 78 OR
		 class_id = 79 THEN envelope := citydb_pkg.get_envelope_bridge_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 80 THEN envelope := citydb_pkg.get_envelope_bridge_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 81 THEN envelope := citydb_pkg.get_envelope_bridge_room(co_id, set_envelope, schema_name);
	WHEN class_id = 82 THEN envelope := citydb_pkg.get_envelope_bridge_const_elem(co_id, set_envelope, schema_name);
	WHEN class_id = 84 OR
		 class_id = 85 THEN envelope := citydb_pkg.get_envelope_tunnel(co_id, set_envelope, schema_name);
	WHEN class_id = 86 OR
		 class_id = 87 THEN envelope := citydb_pkg.get_envelope_tunnel_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 89 OR
		 class_id = 90 OR
		 class_id = 91 OR
		 class_id = 92 OR
		 class_id = 93 OR
		 class_id = 94 OR
		 class_id = 95 OR
		 class_id = 96 OR
		 class_id = 97 THEN envelope := citydb_pkg.get_envelope_tunnel_them_srf(co_id, set_envelope, schema_name);
	WHEN class_id = 99 OR
		 class_id = 100 THEN envelope := citydb_pkg.get_envelope_tunnel_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 101 THEN envelope := citydb_pkg.get_envelope_tunnel_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 102 THEN envelope := citydb_pkg.get_envelope_tunnel_hspace(co_id, set_envelope, schema_name);
ELSE
	RAISE NOTICE 'Cannot get envelope of object with ID % and objectclass_id %.', co_id, class_id;
END CASE;

RETURN envelope;

EXCEPTION
  WHEN OTHERS THEN RAISE NOTICE 'An error occurred when executing function ""citydb_pkg.get_envelope_cityobject"": %', SQLERRM;
END;
$BODY$
LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_envelope_cityobject_orig(
	co_id integer,
	objclass_id integer DEFAULT 0,
	set_envelope integer DEFAULT 0,
	schema_name character varying DEFAULT 'citydb'::character varying)
  RETURNS geometry AS
$BODY$
DECLARE
	class_id INTEGER = 0;
	envelope GEOMETRY;
	db_srid INTEGER;
BEGIN
-- fetching class_id if it is NULL
IF objclass_id IS NULL OR objclass_id = 0 THEN
    EXECUTE format('SELECT objectclass_id FROM %I.cityobject WHERE id = %L', schema_name, co_id) INTO class_id;
ELSE
    class_id := objclass_id;
END IF;
CASE
	WHEN class_id = 4 THEN envelope := citydb_pkg.get_envelope_land_use(co_id, set_envelope, schema_name);
	WHEN class_id = 5 THEN envelope := citydb_pkg.get_envelope_generic_cityobj(co_id, set_envelope, schema_name);
	WHEN class_id = 7 THEN envelope := citydb_pkg.get_envelope_solitary_veg_obj(co_id, set_envelope, schema_name);
	WHEN class_id = 8 THEN envelope := citydb_pkg.get_envelope_plant_cover(co_id, set_envelope, schema_name);
	WHEN class_id = 9 THEN envelope := citydb_pkg.get_envelope_waterbody(co_id, set_envelope, schema_name);
	WHEN class_id = 11 OR
		 class_id = 12 OR
		 class_id = 13 THEN envelope := citydb_pkg.get_envelope_waterbnd_surface(co_id, set_envelope, schema_name);
	WHEN class_id = 14 THEN envelope := citydb_pkg.get_envelope_relief_feature(co_id, set_envelope, schema_name);
	WHEN class_id = 16 OR
		 class_id = 17 OR
		 class_id = 18 OR
		 class_id = 19 THEN envelope := citydb_pkg.get_envelope_relief_component(co_id, class_id, set_envelope, schema_name);
	WHEN class_id = 21 THEN envelope := citydb_pkg.get_envelope_city_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 23 THEN envelope := citydb_pkg.get_envelope_cityobjectgroup(co_id, set_envelope, 1, schema_name);
	WHEN class_id = 25 OR
		 class_id = 26 THEN envelope := citydb_pkg.get_envelope_building(co_id, set_envelope, schema_name);
	WHEN class_id = 27 OR
		 class_id = 28 THEN envelope := citydb_pkg.get_envelope_building_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 30 OR
		 class_id = 31 OR
		 class_id = 32 OR
		 class_id = 33 OR
		 class_id = 34 OR
		 class_id = 35 OR
		 class_id = 36 OR
		 class_id = 60 OR
		 class_id = 61 THEN envelope := citydb_pkg.get_envelope_thematic_surface(co_id, set_envelope, schema_name);
	WHEN class_id = 38 OR
		 class_id = 39 THEN envelope := citydb_pkg.get_envelope_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 40 THEN envelope := citydb_pkg.get_envelope_building_furn(co_id, set_envelope, schema_name);
	WHEN class_id = 41 THEN envelope := citydb_pkg.get_envelope_room(co_id, set_envelope, schema_name);
	WHEN class_id = 43 OR
		 class_id = 44 OR
		 class_id = 45 OR
		 class_id = 46 THEN envelope := citydb_pkg.get_envelope_trans_complex(co_id, set_envelope, schema_name);
	WHEN class_id = 47 OR
		 class_id = 48 THEN envelope := citydb_pkg.get_envelope_traffic_area(co_id, set_envelope, schema_name);
	WHEN class_id = 63 OR
		 class_id = 64 THEN envelope := citydb_pkg.get_envelope_bridge(co_id, set_envelope, schema_name);
	WHEN class_id = 65 OR
		 class_id = 66 THEN envelope := citydb_pkg.get_envelope_bridge_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 68 OR
		 class_id = 69 OR
		 class_id = 70 OR
		 class_id = 71 OR
		 class_id = 72 OR
		 class_id = 73 OR
		 class_id = 74 OR
		 class_id = 75 OR
		 class_id = 76 THEN envelope := citydb_pkg.get_envelope_bridge_them_srf(co_id, set_envelope, schema_name);
	WHEN class_id = 78 OR
		 class_id = 79 THEN envelope := citydb_pkg.get_envelope_bridge_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 80 THEN envelope := citydb_pkg.get_envelope_bridge_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 81 THEN envelope := citydb_pkg.get_envelope_bridge_room(co_id, set_envelope, schema_name);
	WHEN class_id = 82 THEN envelope := citydb_pkg.get_envelope_bridge_const_elem(co_id, set_envelope, schema_name);
	WHEN class_id = 84 OR
		 class_id = 85 THEN envelope := citydb_pkg.get_envelope_tunnel(co_id, set_envelope, schema_name);
	WHEN class_id = 86 OR
		 class_id = 87 THEN envelope := citydb_pkg.get_envelope_tunnel_inst(co_id, set_envelope, schema_name);
	WHEN class_id = 89 OR
		 class_id = 90 OR
		 class_id = 91 OR
		 class_id = 92 OR
		 class_id = 93 OR
		 class_id = 94 OR
		 class_id = 95 OR
		 class_id = 96 OR
		 class_id = 97 THEN envelope := citydb_pkg.get_envelope_tunnel_them_srf(co_id, set_envelope, schema_name);
	WHEN class_id = 99 OR
		 class_id = 100 THEN envelope := citydb_pkg.get_envelope_tunnel_opening(co_id, set_envelope, schema_name);
	WHEN class_id = 101 THEN envelope := citydb_pkg.get_envelope_tunnel_furniture(co_id, set_envelope, schema_name);
	WHEN class_id = 102 THEN envelope := citydb_pkg.get_envelope_tunnel_hspace(co_id, set_envelope, schema_name);
ELSE
	RAISE NOTICE 'Cannot get envelope of object with ID % and objectclass_id %.', co_id, class_id;
END CASE;

RETURN envelope;

EXCEPTION
  WHEN OTHERS THEN RAISE NOTICE 'An error occurred when executing function ""citydb_pkg.get_envelope_cityobject"": %', SQLERRM;
END;
$BODY$
LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_objectclass_info(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS TABLE (
	db_prefix varchar,
	classname varchar,
	is_ade_class numeric(1,0)
)
AS $$
DECLARE
BEGIN
IF class_id IS NOT NULL THEN
	-- get more info about the objectclass
	EXECUTE format('SELECT a.db_prefix, o.classname, o.is_ade_class
		FROM %I.ade a, %I.schema_to_objectclass so, %I.objectclass o, %I.schema s
		WHERE 
		  so.schema_id = s.id AND
		  o.id = so.objectclass_id AND
		  s.ade_id = a.id AND
		  o.id= %L
		LIMIT 1',	
		schema_name, schema_name, schema_name, schema_name, class_id) INTO db_prefix, classname, is_ade_class;
	--RAISE NOTICE '% % %', db_prefix, classname, is_ade_class;
	RETURN NEXT;
ELSE
	RAISE NOTICE 'citydb_pkg.get_classname: Class_id is NULL';
	-- RETURN NEXT -- outputs an empty row i.e. (,,)
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_objectclass_info (class_id: %, schema_name ""%""): %', class_id, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.get_objectclass_info(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar)
RETURNS TABLE (
	db_prefix varchar,
	classname varchar,
	is_ade_class numeric(1,0)
)
AS $$
DECLARE
BEGIN
IF class_id IS NOT NULL THEN
	-- get more info about the objectclass
	EXECUTE format('SELECT a.db_prefix, o.classname, o.is_ade_class  
                  FROM %I.schema_to_objectclass so, %I.objectclass o, %I.schema s
                  LEFT OUTER JOIN %I.ade a ON (a.id=s.ade_id) 
                  WHERE s.id = so.schema_id AND so.objectclass_id = o.id AND o.id=%L
                  LIMIT 1',
		schema_name, schema_name, schema_name, schema_name, class_id) INTO db_prefix, classname, is_ade_class;
	--RAISE NOTICE '% % %', db_prefix, classname, is_ade_class;
	RETURN NEXT;
ELSE
	RAISE NOTICE 'citydb_pkg.get_classname: Class_id is NULL';
	-- RETURN NEXT -- outputs an empty row i.e. (,,)
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.get_objectclass_info (class_id: %, schema_name ""%""): %', class_id, schema_name, SQLERRM;
END;
$$
LANGUAGE plpgsql;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_classname_to_id(
	class_name varchar,
	db_prefix varchar,
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS integer AS
$BODY$
DECLARE
	class_id varchar;
BEGIN
IF class_name IS NOT NULL THEN
	IF db_prefix IS NULL THEN
		-- we are looking for a vanilla objectclass
		EXECUTE format('SELECT o.id FROM %I.objectclass o WHERE o.classname=%L', schema_name, class_name) INTO class_id;
	ELSE
		-- we are looking for an ADE objectclass
		EXECUTE format('SELECT o.id FROM %I.ade a, %I.schema s, %I.schema_to_objectclass so, %I.objectclass o WHERE a.id = s.ade_id AND s.id = so.schema_id AND so.objectclass_id = o.id AND a.db_prefix=%L AND o.classname=%L LIMIT 1',
		schema_name, schema_name, schema_name, schema_name, db_prefix, class_name) INTO class_id;
	END IF;
	IF class_id IS NOT NULL THEN
		RETURN class_id;
	ELSE
		RAISE EXCEPTION 'citydb_pkg.objectclass_classname_to_id: class_id is NULL for db_prefix ""%"" and classname ""%""', db_prefix, class_name;
	END IF;
ELSE
	RAISE EXCEPTION 'citydb_pkg.objectclass_classname_to_id: class_name is NULL for db_prefix ""%"" and classname ""%""',db_prefix, class_name;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.objectclass_classname_to_id (db_prefix ""%"", classname ""%""): %)', db_prefix, class_name, SQLERRM;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_classname_to_id(
	class_name varchar,
	db_prefix varchar,
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS integer AS
$BODY$
DECLARE
	class_id varchar;
BEGIN
IF class_name IS NOT NULL THEN
	IF db_prefix IS NULL THEN
		-- we are looking for a vanilla objectclass
		EXECUTE format('SELECT o.id FROM %I.objectclass o WHERE o.classname=%L', schema_name, class_name) INTO class_id;
	ELSE
		-- we are looking for an ADE objectclass
		EXECUTE format('SELECT o.id FROM %I.ade a, %I.schema s, %I.schema_to_objectclass so, %I.objectclass o WHERE a.id = s.ade_id AND s.id = so.schema_id AND so.objectclass_id = o.id AND a.db_prefix=%L AND o.classname=%L LIMIT 1',
		schema_name, schema_name, schema_name, schema_name, db_prefix, class_name) INTO class_id;
	END IF;
	IF class_id IS NOT NULL THEN
		RETURN class_id;
	ELSE
		RAISE EXCEPTION 'citydb_pkg.objectclass_classname_to_id: class_id is NULL for db_prefix ""%"" and classname ""%""', db_prefix, class_name;
	END IF;
ELSE
	RAISE EXCEPTION 'citydb_pkg.objectclass_classname_to_id: class_name is NULL for db_prefix ""%"" and classname ""%""',db_prefix, class_name;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.objectclass_classname_to_id (db_prefix ""%"", classname ""%""): %)', db_prefix, class_name, SQLERRM;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_id_to_table_name(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS varchar AS
$BODY$
DECLARE
	table_name varchar;
BEGIN
IF class_id IS NOT NULL THEN
	EXECUTE format('SELECT tablename FROM %I.objectclass WHERE id=%L', schema_name, db_prefix) INTO table_name;
	IF table_name IS NOT NULL THEN
		RETURN table_name;
	ELSE
		RAISE NOTICE 'Table name unknown';
		RETURN NULL;
	END IF;
ELSE
	RAISE NOTICE 'objectclass_id_to_table_name: Class_id is NULL';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.objectclass_id_to_table_name(%) in schema %, %', class_id, table_name, SQLERRM;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_id_to_table_name(
	class_id integer,
	schema_name varchar DEFAULT 'citydb'::varchar
)
RETURNS varchar AS
$BODY$
DECLARE
	table_name varchar;
BEGIN
IF class_id IS NOT NULL THEN
	EXECUTE format('SELECT tablename FROM %I.objectclass WHERE id=%L', schema_name, db_prefix) INTO table_name;
	IF table_name IS NOT NULL THEN
		RETURN table_name;
	ELSE
		RAISE NOTICE 'Table name unknown';
		RETURN NULL;
	END IF;
ELSE
	RAISE NOTICE 'objectclass_id_to_table_name: Class_id is NULL';
	RETURN NULL;
END IF;
EXCEPTION
	WHEN OTHERS THEN RAISE NOTICE 'citydb_pkg.objectclass_id_to_table_name(%) in schema %, %', class_id, table_name, SQLERRM;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_id_to_table_name_orig(
	class_id integer
)
  RETURNS text AS
$BODY$
DECLARE
	table_name TEXT := '';
BEGIN
  CASE 
    WHEN class_id = 4 THEN table_name := 'land_use';
    WHEN class_id = 5 THEN table_name := 'generic_cityobject';
    WHEN class_id = 7 THEN table_name := 'solitary_vegetat_object';
    WHEN class_id = 8 THEN table_name := 'plant_cover';
    WHEN class_id = 9 THEN table_name := 'waterbody';
    WHEN class_id = 11 OR 
         class_id = 12 OR 
         class_id = 13 THEN table_name := 'waterboundary_surface';
    WHEN class_id = 14 THEN table_name := 'relief_feature';
    WHEN class_id = 16 OR 
         class_id = 17 OR 
         class_id = 18 OR 
         class_id = 19 THEN table_name := 'relief_component';
    WHEN class_id = 21 THEN table_name := 'city_furniture';
    WHEN class_id = 23 THEN table_name := 'cityobjectgroup';
    WHEN class_id = 25 OR 
         class_id = 26 THEN table_name := 'building';
    WHEN class_id = 27 OR 
         class_id = 28 THEN table_name := 'building_installation';
    WHEN class_id = 30 OR 
         class_id = 31 OR 
         class_id = 32 OR 
         class_id = 33 OR 
         class_id = 34 OR 
         class_id = 35 OR
         class_id = 36 OR
         class_id = 60 OR
         class_id = 61 THEN table_name := 'thematic_surface';
    WHEN class_id = 38 OR 
         class_id = 39 THEN table_name := 'opening';
    WHEN class_id = 40 THEN table_name := 'building_furniture';
    WHEN class_id = 41 THEN table_name := 'room';
    WHEN class_id = 43 OR 
         class_id = 44 OR 
         class_id = 45 OR 
         class_id = 46 THEN table_name := 'transportation_complex';
    WHEN class_id = 47 OR 
         class_id = 48 THEN table_name := 'traffic_area';
    WHEN class_id = 57 THEN table_name := 'citymodel';
    WHEN class_id = 63 OR
         class_id = 64 THEN table_name := 'bridge';
    WHEN class_id = 65 OR
         class_id = 66 THEN table_name := 'bridge_installation';
    WHEN class_id = 68 OR 
         class_id = 69 OR 
         class_id = 70 OR 
         class_id = 71 OR 
         class_id = 72 OR
         class_id = 73 OR
         class_id = 74 OR
         class_id = 75 OR
         class_id = 76 THEN table_name := 'bridge_thematic_surface';
    WHEN class_id = 78 OR 
         class_id = 79 THEN table_name := 'bridge_opening';		 
    WHEN class_id = 80 THEN table_name := 'bridge_furniture';
    WHEN class_id = 81 THEN table_name := 'bridge_room';
    WHEN class_id = 82 THEN table_name := 'bridge_constr_element';
    WHEN class_id = 84 OR
         class_id = 85 THEN table_name := 'tunnel';
    WHEN class_id = 86 OR
         class_id = 87 THEN table_name := 'tunnel_installation';
    WHEN class_id = 88 OR 
         class_id = 89 OR 
         class_id = 90 OR 
         class_id = 91 OR 
         class_id = 92 OR
         class_id = 93 OR
         class_id = 94 OR
         class_id = 95 OR
         class_id = 96 THEN table_name := 'tunnel_thematic_surface';
    WHEN class_id = 99 OR 
         class_id = 100 THEN table_name := 'tunnel_opening';		 
    WHEN class_id = 101 THEN table_name := 'tunnel_furniture';
    WHEN class_id = 102 THEN table_name := 'tunnel_hollow_space';
  ELSE
    RAISE NOTICE 'Table name unknown.';
  END CASE;
  
  RETURN table_name;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",01_metadata_module_FUNCTIONS.sql
"CREATE OR REPLACE FUNCTION citydb_pkg.objectclass_id_to_table_name_orig(
	class_id integer
)
  RETURNS text AS
$BODY$
DECLARE
	table_name TEXT := '';
BEGIN
  CASE 
    WHEN class_id = 4 THEN table_name := 'land_use';
    WHEN class_id = 5 THEN table_name := 'generic_cityobject';
    WHEN class_id = 7 THEN table_name := 'solitary_vegetat_object';
    WHEN class_id = 8 THEN table_name := 'plant_cover';
    WHEN class_id = 9 THEN table_name := 'waterbody';
    WHEN class_id = 11 OR 
         class_id = 12 OR 
         class_id = 13 THEN table_name := 'waterboundary_surface';
    WHEN class_id = 14 THEN table_name := 'relief_feature';
    WHEN class_id = 16 OR 
         class_id = 17 OR 
         class_id = 18 OR 
         class_id = 19 THEN table_name := 'relief_component';
    WHEN class_id = 21 THEN table_name := 'city_furniture';
    WHEN class_id = 23 THEN table_name := 'cityobjectgroup';
    WHEN class_id = 25 OR 
         class_id = 26 THEN table_name := 'building';
    WHEN class_id = 27 OR 
         class_id = 28 THEN table_name := 'building_installation';
    WHEN class_id = 30 OR 
         class_id = 31 OR 
         class_id = 32 OR 
         class_id = 33 OR 
         class_id = 34 OR 
         class_id = 35 OR
         class_id = 36 OR
         class_id = 60 OR
         class_id = 61 THEN table_name := 'thematic_surface';
    WHEN class_id = 38 OR 
         class_id = 39 THEN table_name := 'opening';
    WHEN class_id = 40 THEN table_name := 'building_furniture';
    WHEN class_id = 41 THEN table_name := 'room';
    WHEN class_id = 43 OR 
         class_id = 44 OR 
         class_id = 45 OR 
         class_id = 46 THEN table_name := 'transportation_complex';
    WHEN class_id = 47 OR 
         class_id = 48 THEN table_name := 'traffic_area';
    WHEN class_id = 57 THEN table_name := 'citymodel';
    WHEN class_id = 63 OR
         class_id = 64 THEN table_name := 'bridge';
    WHEN class_id = 65 OR
         class_id = 66 THEN table_name := 'bridge_installation';
    WHEN class_id = 68 OR 
         class_id = 69 OR 
         class_id = 70 OR 
         class_id = 71 OR 
         class_id = 72 OR
         class_id = 73 OR
         class_id = 74 OR
         class_id = 75 OR
         class_id = 76 THEN table_name := 'bridge_thematic_surface';
    WHEN class_id = 78 OR 
         class_id = 79 THEN table_name := 'bridge_opening';		 
    WHEN class_id = 80 THEN table_name := 'bridge_furniture';
    WHEN class_id = 81 THEN table_name := 'bridge_room';
    WHEN class_id = 82 THEN table_name := 'bridge_constr_element';
    WHEN class_id = 84 OR
         class_id = 85 THEN table_name := 'tunnel';
    WHEN class_id = 86 OR
         class_id = 87 THEN table_name := 'tunnel_installation';
    WHEN class_id = 88 OR 
         class_id = 89 OR 
         class_id = 90 OR 
         class_id = 91 OR 
         class_id = 92 OR
         class_id = 93 OR
         class_id = 94 OR
         class_id = 95 OR
         class_id = 96 THEN table_name := 'tunnel_thematic_surface';
    WHEN class_id = 99 OR 
         class_id = 100 THEN table_name := 'tunnel_opening';		 
    WHEN class_id = 101 THEN table_name := 'tunnel_furniture';
    WHEN class_id = 102 THEN table_name := 'tunnel_hollow_space';
  ELSE
    RAISE NOTICE 'Table name unknown.';
  END CASE;
  
  RETURN table_name;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",03_metadata_module_TABLE_DATA.sql
"CREATE OR REPLACE FUNCTION column_exists(colName text, tablename text)
 RETURNS boolean AS
 $$
 DECLARE
 colname ALIAS FOR $1;
 tablename ALIAS For $2;
 query text;
 onerow record;

 BEGIN
 query = 'SELECT attname FROM pg_attribute WHERE attrelid = ( SELECT oid FROM pg_class WHERE relname = ' || '''' || tablename || '''' ||  ') AND attname = ' || '''' || colname || ''''   ;
 FOR onerow IN EXECUTE query
 LOOP
 RETURN true;
 END LOOP;
 RETURN false;
 END;
 $$
 LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION column_exists(colName text, tablename text)
 RETURNS boolean AS
 $$
 DECLARE
 colname ALIAS FOR $1;
 tablename ALIAS For $2;
 query text;
 onerow record;
 
 BEGIN
  --Raise Notice 'colname=> %', colname;
  --Raise Notice 'tablename=> %', tablename;
 query = 'SELECT attname FROM pg_attribute WHERE attrelid = ( SELECT oid FROM pg_class WHERE relname = ' || '''' || tablename || '''' ||  ') AND attname = ' || '''' || colname || ''''   ;
 FOR onerow IN EXECUTE query
 LOOP
 --Raise Notice '1=> %', true;
 RETURN true;
 END LOOP;
-- Raise Notice '2=> %, %', false, q;
 RETURN false;
 END;
 $$
 LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION column_exists(colName text, tablename text)
 RETURNS boolean AS
 $$
 DECLARE
 colname ALIAS FOR $1;
 tablename ALIAS For $2;
 query text;
 onerow record;
 
 BEGIN
 query = 'SELECT attname FROM pg_attribute WHERE attrelid = ( SELECT oid FROM pg_class WHERE relname = ' || '''' || tablename || '''' ||  ') AND attname = ' || '''' || colname || ''''   ;
 FOR onerow IN EXECUTE query
 LOOP
 RETURN true;
 END LOOP;
 RETURN false;
 END;
 $$
 LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION compute(i int, out result_1 bigint, out result_2 bigint)
returns SETOF RECORD
as $$
begin
result_1 = i + 1;
result_2 = i * 10;
return next;
end;
$$language plpgsql;",gaussdb200.sql
"CREATE OR REPLACE FUNCTION contribucion_total_stock (OUT monto_contribucion float8)
RETURNS float8 AS $$
DECLARE
	query varchar(255);
	monto_pci float8; -- monto productos con impuestos
	monto_psi float8; -- monto productos sin impuestos
	--------------------
	corriente int4; -- id de mercadería del tipo discreta (normal)
	derivada int4; -- id de mercaderia derivada
	--------------------
BEGIN

   corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
   derivada := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'DERIVADA');

   -- Productos con impuestos
   SELECT SUM (( (precio / (SELECT (SUM(monto)/100)+1 FROM impuesto WHERE id = otros OR id = 1)) -
   	         (SELECT costo FROM obtener_costo_promedio_desde_barcode (barcode)) ) *
               (SELECT disponible FROM obtener_stock_desde_barcode (barcode)))
   INTO monto_pci
   FROM producto WHERE impuestos = TRUE
   AND tipo = corriente
   OR tipo = derivada;

   -- Productos sin impuestos   -- costo_promedio
   SELECT (SELECT SUM( (precio - (SELECT costo FROM obtener_costo_promedio_desde_barcode (barcode))) *
   	  	       (SELECT disponible FROM obtener_stock_desde_barcode (barcode))))
   INTO monto_psi
   FROM producto WHERE impuestos = FALSE
   AND tipo = corriente
   OR tipo = derivada;

   -- Contribucion total stock
   monto_contribucion := COALESCE(monto_pci,0) + COALESCE(monto_psi,0);

RETURN;
END; $$ language plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION cortarApellidos(nombre text) RETURNS text AS $$
DECLARE
	result text;
BEGIN
	SELECT REGEXP_REPLACE(nombre, '^((\w+\s)*\w+,\s)', '') INTO result;
	RETURN result;
END;
$$ LANGUAGE plpgsql;",scripts_dw.sql
"CREATE OR REPLACE FUNCTION createSeqId(text, text)
RETURNS text AS
$BODY$
DECLARE
t text;
i int;
j int;
n int;
BEGIN
n=nextval($2);
i=32-character_length($1)-character_length(n||'');
j=1;
t='';
for j IN 1..i loop
T = T||'0';
END loop ;
t = $1 || t||n;
RETURN t;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE;",sql.md
"CREATE OR REPLACE FUNCTION create_table_concept_group_concept() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'concept_group_concept') THEN

        execute 
		'CREATE TABLE concept_group_concept
                (
                  idgroup text NOT NULL,
                  idthesaurus text NOT NULL,
                  idconcept text NOT NULL,
                  CONSTRAINT concept_group_concept_pkey PRIMARY KEY (idgroup, idthesaurus, idconcept)
                )
                WITH (
                  OIDS=FALSE
                );';

    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION create_table_info() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'info') THEN
        execute 
		'CREATE TABLE info (
		    version_Opentheso character varying,
		    version_Bdd character varying
		);';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION create_table_thesaurus_alignement_source() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'thesaurus_alignement_source') THEN

        execute 
		'CREATE TABLE public.thesaurus_alignement_source
		(
		  id_thesaurus character varying NOT NULL,
		  id_alignement_source integer NOT NULL,
		  CONSTRAINT thesaurus_alignement_source_pkey PRIMARY KEY (id_thesaurus, id_alignement_source)
		)
		WITH (
		  OIDS=FALSE
		);';

    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION deuda_total_cliente (IN rut_cliente int4)
RETURNS INTEGER AS $$
DECLARE
	resultado INTEGER;
BEGIN

resultado := (SELECT SUM (monto) FROM search_deudas_cliente (rut_cliente, true));

RETURN resultado;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION do_count( pk int, tabella text)
RETURNS integer
AS $BODY$ DECLARE
        v_count int;
BEGIN
        EXECUTE 'SELECT count(*) FROM '
                 || tabella
                 || ' WHERE pk >= $1'
        INTO STRICT v_count
        USING pk;

        RETURN v_count;
END;
$BODY$ LANGUAGE plpgsql;",pg10-cheatsheet.org
"CREATE OR REPLACE FUNCTION do_count( pk int, tabella text)
RETURNS integer
AS $BODY$ DECLARE
        v_count int;
BEGIN
        EXECUTE 'SELECT count(*) FROM '
                 || tabella
                 || ' WHERE pk >= $1'
        INTO STRICT v_count
        USING pk;

        RETURN v_count;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
        counter int := 0;
        my_curs CURSOR (s_eta int)
             FOR SELECT * FROM persona
                 WHERE eta >= s_eta;
        my_record persona%rowtype;
BEGIN
        OPEN my_curs( 18 );
        FETCH my_curs INTO my_record;
        WHILE FOUND
        LOOP
          counter := counter + 1;
          FETCH my_curs INTO my_record;
        END LOOP;

     CLOSE my_curs;
     RETURN counter;
END; $BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
        counter int := 0;
        my_curs CURSOR FOR
          SELECT * FROM persona
          WHERE eta >= 18;
        my_record persona%rowtype;
BEGIN
   FOR my_record IN my_curs
   LOOP
     counter := counter + 1;
   END LOOP;
  RETURN counter;
END; $BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
        counter int := 0;
        my_curs refcursor;
        my_record persona%rowtype;
BEGIN
        OPEN my_curs FOR
            SELECT * FROM persona
            WHERE eta >= 18;
        FETCH my_curs INTO my_record;
        WHILE FOUND
        LOOP
          counter := counter + 1;
          FETCH my_curs INTO my_record;
        END LOOP;

     CLOSE my_curs;
     RETURN counter;
END;
$BODY$ LANGUAGE plpgsql;",pg10-cheatsheet.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
        counter int := 0;
        my_curs refcursor;
        my_record persona%rowtype;
BEGIN
        OPEN my_curs FOR
            SELECT * FROM persona
            WHERE eta >= 18;
        FETCH my_curs INTO my_record;
        WHILE FOUND
        LOOP
          counter := counter + 1;
          FETCH my_curs INTO my_record;
        END LOOP;

     CLOSE my_curs;
     RETURN counter;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
       ...
BEGIN
   FOR my_record IN my_curs
   LOOP
     counter := counter + 1;
   END LOOP;
  RETURN counter;
END; $BODY$ LANGUAGE plpgsql;",pg10-cheatsheet.org
"CREATE OR REPLACE FUNCTION do_cursor()
RETURNS int AS $BODY$
DECLARE
   counter int := 0;
   my_curs CURSOR FOR SELECT * FROM persona;
   my_record persona%rowtype;
BEGIN
    OPEN my_curs;
    FETCH my_curs INTO my_record;
    WHILE FOUND
    LOOP
      IF my_record.eta >= 18
      THEN
         counter := counter + 1;
      END IF;
      FETCH my_curs INTO my_record;
    END LOOP;

     CLOSE my_curs;
     RETURN counter;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID
AS $BODY$ DECLARE
BEGIN
        PERFORM  * FROM persona;
END;
$BODY$ LANGUAGE plpgsql;",pg10-cheatsheet.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID
AS $BODY$ DECLARE
BEGIN
        PERFORM  * FROM persona;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID AS $BODY$
DECLARE
        v_nome text;
        v_cognome text;
BEGIN
        SELECT nome, cognome
        INTO STRICT v_nome, v_cognome
        FROM persona
        WHERE codice_fiscale = 'FRRLCU78L19F257B';

        RAISE INFO 'Trovati % %',
                   v_nome,
                   v_cognome;
END;
$BODY$ LANGUAGE plpgsql;",pg10-cheatsheet.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID AS $BODY$
DECLARE
        v_nome text;
        v_cognome text;
BEGIN
        SELECT nome, cognome
        INTO STRICT v_nome, v_cognome
        FROM persona
        WHERE codice_fiscale = 'FRRLCU78L19F257B';

        RAISE INFO 'Trovati % %',
                   v_nome,
                   v_cognome;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID AS $BODY$
DECLARE
        v_nome text;
        v_cognome text;
BEGIN
        SELECT nome, cognome
        INTO v_nome, v_cognome
        FROM persona;

        RAISE INFO 'Trovati % %',
                    v_nome,
                    v_cognome;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION do_select()
RETURNS VOID AS $BODY$
DECLARE
BEGIN
        SELECT * FROM persona;
END;
$BODY$ LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION docwin.alteracoes_r011() RETURNS void as
$$
BEGIN
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns WHERE table_schema='docwin' 
									AND table_name='c_pcas_detalhes_tb' AND column_name='datautilizacao_selodigital_termo' )
	THEN
		ALTER TABLE docwin.c_pcas_detalhes_tb ADD COLUMN datautilizacao_selodigital_termo date;
	END IF;	
	
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns WHERE table_schema='docwin' 
									AND table_name='c_pcas_detalhes_tb' AND column_name='selodigital_habilitacao' )
	THEN
		ALTER TABLE docwin.c_pcas_detalhes_tb ADD COLUMN selodigital_habilitacao text;
		ALTER TABLE docwin.c_pcas_detalhes_tb ADD COLUMN datautilizacao_selodigital_habilitacao date;
	END IF;	
	
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns WHERE table_schema='docwin' 
									AND table_name='pessoa_fisica_tb' AND column_name='pf_cnh' )
	THEN
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_cnh text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_cnh_uf text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_complemento_qualificacao_conjuge text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_residencia_domicilio_mesmo_endereco boolean default true;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_logradouro_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_numero_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_complemento_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_bairro_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_cidade_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_uf_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_cep_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_tb ADD COLUMN pf_pais_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_cnh text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_cnh_uf text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_complemento_qualificacao_conjuge text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_residencia_domicilio_mesmo_endereco boolean default true;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_logradouro_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_numero_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_complemento_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_bairro_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_cidade_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_uf_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_cep_end_domicilio text;
		ALTER TABLE docwin.pessoa_fisica_historico_tb ADD COLUMN ph_pais_end_domicilio text;
	END IF;

		
END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION docwin.colunas() RETURNS void as
$$
BEGIN
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns 
                   WHERE table_schema='docwin' AND table_name='u_item_ato_padronizado_tb' AND column_name='vincula_os' )
    THEN
		ALTER TABLE docwin.u_item_ato_padronizado_tb ADD COLUMN vincula_os boolean DEFAULT true;
    END IF;
END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION docwin.colunas() RETURNS void as
$$
BEGIN
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns 
                   WHERE table_schema='docwin' AND table_name='u_item_ordem_servico_tb' AND column_name='gratuito' )
    THEN
		ALTER TABLE docwin.u_item_ordem_servico_tb ADD COLUMN gratuito boolean DEFAULT false;
    END IF;
END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION docwin.colunas() RETURNS void as
$$
BEGIN

		
	IF NOT EXISTS (SELECT column_name FROM information_schema.columns 
                   WHERE table_schema='docwin' AND table_name='u_item_ordem_servico_tb' AND column_name='protocolo_id')
    THEN
		ALTER TABLE docwin.u_item_ordem_servico_tb ADD COLUMN protocolo_id int;
    END IF;
	
END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION docwin.colunas() RETURNS void as
$$
BEGIN

	IF NOT EXISTS (SELECT column_name FROM information_schema.columns 
                   WHERE table_schema='docwin' AND table_name='u_item_ordem_servico_tb' AND column_name='consolidado' )
    THEN
		ALTER TABLE docwin.u_item_ordem_servico_tb ADD COLUMN consolidado boolean;
    END IF;
	
		IF NOT EXISTS (SELECT column_name FROM information_schema.columns 
                   WHERE table_schema='docwin' AND table_name='u_item_ordem_servico_tb' AND column_name='fechamento_id' )
    THEN
		ALTER TABLE docwin.u_item_ordem_servico_tb ADD COLUMN fechamento_id int;
    END IF;
 
END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION docwin.release_0_7() RETURNS void as
$$
BEGIN

	IF NOT EXISTS(SELECT column_name FROM information_schema.columns WHERE table_schema='docwin' AND table_name='s_entrada_tb' AND column_name='ent_acervorj') 
	THEN
		ALTER TABLE docwin.s_entrada_tb ADD COLUMN ent_acervorj smallint;
	END IF;

END;
$$ LANGUAGE plpgsql VOLATILE;",UPDATE%202017%20r1.0.sql
"CREATE OR REPLACE FUNCTION dropRelations() RETURNS character varying
AS $$
DECLARE
    output character varying;
    rec character varying;
    fks RECORD;
BEGIN

    for fks in (SELECT tc.constraint_name, tc.table_name FROM information_schema.table_constraints AS tc WHERE constraint_type = 'FOREIGN KEY')
    LOOP
        EXECUTE  'ALTER TABLE public.' || fks.table_name ||  ' DROP CONSTRAINT ' ||    fks.constraint_name   ;
    END LOOP;

	FOR rec IN (SELECT table_name FROM information_schema.tables WHERE table_schema='public')
	LOOP
       if rec != 'energy_consumption' AND rec != 'energy_consumption_hourly' AND rec != 'energy_consumption_daily' AND rec != 'em_motion_bits' AND rec != 'plugload_energy_consumption' AND rec != 'plugload_energy_consumption_hourly' AND rec != 'plugload_energy_consumption_daily' then
        	EXECUTE  'DROP TABLE ' || rec ;
       end if;
	 END LOOP;

    FOR rec IN (SELECT c.relname FROM pg_class c WHERE c.relkind = 'S')
	LOOP
       if rec != 'energy_consumption_seq' AND rec != 'energy_consumption_hourly_seq' AND rec != 'energy_consumption_daily_seq' AND rec != 'em_motion_bits_seq' AND rec != 'plugload_energy_consumption_seq' AND rec != 'plugload_energy_consumption_hourly_seq' AND rec != 'plugload_energy_consumption_daily_seq'  then
        	EXECUTE  'DROP SEQUENCE ' || rec ;
       end if;
	 END LOOP;

    RETURN output;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION dropRelations() RETURNS character varying
AS $$
DECLARE 
    output character varying;
    rec character varying;
    fks RECORD;
BEGIN	
    
    for fks in (SELECT tc.constraint_name, tc.table_name FROM information_schema.table_constraints AS tc WHERE constraint_type = 'FOREIGN KEY')
    LOOP
        EXECUTE  'ALTER TABLE public.' || fks.table_name ||  ' DROP CONSTRAINT ' ||    fks.constraint_name   ;
    END LOOP;

	FOR rec IN (SELECT table_name FROM information_schema.tables WHERE table_schema='public')
	LOOP
       if rec != 'energy_consumption' AND rec != 'energy_consumption_hourly' AND rec != 'energy_consumption_daily' AND rec != 'em_motion_bits' AND rec != 'plugload_energy_consumption' AND rec != 'plugload_energy_consumption_hourly' AND rec != 'plugload_energy_consumption_daily' then
        	EXECUTE  'DROP TABLE ' || rec ;
       end if;
	 END LOOP;

    FOR rec IN (SELECT c.relname FROM pg_class c WHERE c.relkind = 'S')
	LOOP
       if rec != 'energy_consumption_seq' AND rec != 'energy_consumption_hourly_seq' AND rec != 'energy_consumption_daily_seq' AND rec != 'em_motion_bits_seq' AND rec != 'plugload_energy_consumption_seq' AND rec != 'plugload_energy_consumption_hourly_seq' AND rec != 'plugload_energy_consumption_daily_seq'  then
        	EXECUTE  'DROP SEQUENCE ' || rec ;
       end if;
	 END LOOP;

    RETURN output;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION dropRelations() RETURNS character varying
AS $$
DECLARE 
    output character varying;
    rec character varying;
    fks RECORD;
BEGIN	
    
    for fks in (SELECT tc.constraint_name, tc.table_name FROM information_schema.table_constraints AS tc WHERE constraint_type = 'FOREIGN KEY')
    LOOP
        EXECUTE  'ALTER TABLE public.' || fks.table_name ||  ' DROP CONSTRAINT ' ||    fks.constraint_name   ;
    END LOOP;

	FOR rec IN (SELECT table_name FROM information_schema.tables WHERE table_schema='public')
	LOOP
       if rec != 'energy_consumption' AND rec != 'energy_consumption_hourly' AND rec != 'energy_consumption_daily' AND rec != 'em_motion_bits' then
        	EXECUTE  'DROP TABLE ' || rec ;
       end if;
	 END LOOP;

    FOR rec IN (SELECT c.relname FROM pg_class c WHERE c.relkind = 'S')
	LOOP
       if rec != 'energy_consumption_seq' AND rec != 'energy_consumption_hourly_seq' AND rec != 'energy_consumption_daily_seq' AND rec != 'em_motion_bits_seq' then
        	EXECUTE  'DROP SEQUENCE ' || rec ;
       end if;
	 END LOOP;

    RETURN output;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION epi_week (indate timestamp)
RETURNS integer AS 
$result$
DECLARE year integer;
	doy integer;
	doy_end integer;
	isodow_start_next integer;
	isodow_start integer;
	epi_week integer;
BEGIN
   year := date_part('year', indate);
   -- days until end of year
   -- DOY: The day of the year (1 - 365/366)
   doy = date_part('DOY', indate);
   doy_end := date_part('DOY', date (year || '-12-31'));
   -- week day of first day in next year
   -- isodow: The day of the week as Monday (1) to Sunday (7)
   isodow_start_next := date_part('isodow', date ((year+1) || '-01-01'));
   -- check end of date year
   -- DOY 31.12 - DOY < DOY(01.01.Y+1)
   if (doy_end - doy < isodow_start_next-1) THEN
	-- falls into next epi year
	epi_week := 1;
   ELSE
	-- 2018: 01.01 is monday -> ceil(doy/7) = epi-week
	-- 2017: 01.01 is sunday -> ceil((doy+6)/7) = epi-week
	-- 2016: 01.01 is friday -> ceil((doy+4)/7) = epi-week
	isodow_start := date_part('isodow', date (year || '-01-01'));
	epi_week := ceil((doy + isodow_start - 1) / 7.0);
   END if;
   
   RETURN epi_week;
END;
$result$
LANGUAGE plpgsql;",sormas_schema.sql
"CREATE OR REPLACE FUNCTION epi_year (indate timestamp)
RETURNS integer AS 
$result$
DECLARE year integer;
	doy integer;
	doy_end integer;
	isodow_start_next integer;
	isodow_start integer;
	epi_year integer;
BEGIN
   year := date_part('year', indate);
   doy = date_part('DOY', indate);
   doy_end := date_part('DOY', date (year || '-12-31'));
   isodow_start_next := date_part('isodow', date ((year+1) || '-01-01'));
   if (doy_end - doy < isodow_start_next-1) THEN
	-- next year
	epi_year := year+1;
   ELSE
	epi_year := year;
   END if;
   
   RETURN epi_year;
END;
$result$ 
LANGUAGE plpgsql;",sormas_schema.sql
"CREATE OR REPLACE FUNCTION event_full_cleanup_p ()
returns void as $$
DECLARE
   event_partition VARCHAR (200);
BEGIN
     TRUNCATE TABLE VPX_EVENT_PARTITION_LOOKUP;
     --Truncate partitions
     FOR part IN 1..92
     LOOP
       event_partition = 'TRUNCATE TABLE VPX_EVENT_' || CAST(part AS TEXT) || ' CASCADE ';
       EXECUTE event_partition;
       event_partition = 'TRUNCATE TABLE VPX_EVENT_ARG_' || CAST(part AS TEXT) || ' CASCADE ';
       EXECUTE event_partition;
       event_partition = 'ANALYZE VPX_EVENT_' || CAST(part AS TEXT);
       EXECUTE event_partition;
       event_partition = 'ANALYZE VPX_EVENT_ARG_' || CAST(part AS TEXT);
       EXECUTE event_partition;
    END LOOP;
    TRUNCATE TABLE VPX_ENTITY_LAST_EVENT;
END
$$language plpgsql;",cleanvcdb.sh
"CREATE OR REPLACE FUNCTION execute_query (id text, query text)
RETURNS void AS $$
BEGIN
    EXECUTE query;
END;
$$ LANGUAGE plpgsql;",plproxy
"CREATE OR REPLACE FUNCTION extract_positionvd(
    i_json json,
    i_object_json json)
  RETURNS character varying AS
$BODY$
DECLARE
	d_data record;
	d_object varchar = 'object';
	d_array varchar = 'array';
	d_execute varchar;
	d_type_data varchar;
	broke varchar;
BEGIN
	/*
	Hecho por: Vlade Párica
	Fecha:
	Resumen:

	Para probarlo:
					select public.extract_positionVD('[{""tramites"":[{""title"":""Actualización"",""id"":23,""tipostramites"":null},{""title"":""Autorización de"",""id"":41,""tipostramites"":[{""title"":""Cambio de Dirección"",""idTipoTramiteGeneral"":74,""clase"":null,""tipoLicencias"":[{""idTipoTramiteDetallado"":483,""tipoLicencia"":""No especificado"",""idTipoLicencia"":0,""categorias"":null}]}]},{""title"":""Certificación de"",""id"":38,""tipostramites"":[{""title"":""Horas de Vuelo"",""idTipoTramiteGeneral"":80,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":367,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":511,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":510,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":372,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":378,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":512,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":368,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":362,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":508,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":509,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":365,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":507,""tipoLicencia"":""Piloto de Dirigible"",""idTipoLicencia"":29,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":504,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":505,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":506,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":361,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":364,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":377,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":379,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":363,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":366,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":369,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]},{""title"":""Licencia y Certificado Médico"",""idTipoTramiteGeneral"":54,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":351,""tipoLicencia"":""Controlador de Tránsito Aéreo"",""idTipoLicencia"":17,""categorias"":null},{""idTipoTramiteDetallado"":484,""tipoLicencia"":""Despachador de Vuelo"",""idTipoLicencia"":19,""categorias"":null},{""idTipoTramiteDetallado"":347,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":502,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":500,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":352,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":350,""tipoLicencia"":""Instructor de Vuelo Instrumental Simulado"",""idTipoLicencia"":16,""categorias"":null},{""idTipoTramiteDetallado"":358,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":360,""tipoLicencia"":""Instructor de Vuelo RPA Ala Rotativa"",""idTipoLicencia"":36,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":503,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":348,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":486,""tipoLicencia"":""Operador de Estaciones Aeronáuticas"",""idTipoLicencia"":18,""categorias"":null},{""idTipoTramiteDetallado"":342,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":498,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":499,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":345,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":495,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":496,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":497,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":341,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":344,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":357,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":359,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":343,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":346,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":354,""tipoLicencia"":""Técnico en Mantenimiento de Aeronaves"",""idTipoLicencia"":28,""categorias"":null},{""idTipoTramiteDetallado"":349,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]}]},{""title"":""Convalidación de Licencia Aeronáutica"",""id"":18,""tipostramites"":null},{""title"":""Duplicado de Licencia Aeronáutica"",""id"":17,""tipostramites"":null},{""title"":""Emisión de Licencia Aeronáutica"",""id"":15,""tipostramites"":null},{""title"":""Otorgamiento de"",""id"":24,""tipostramites"":null},{""title"":""Otorgamiento de Habilitación Aeronáutica"",""id"":22,""tipostramites"":null},{""title"":""Renovación de Licencia Aeronáutica"",""id"":16,""tipostramites"":null}]}]','{""idTipoTramiteDetallado"": 510, ""tipoLicencia"": ""Instructor de Vuelo de Planeador"", ""idTipoLicencia"": 27, ""categorias"": [{""idCategoria"": 7, ""categoria"": ""Planeador""}] }')

					select extract_positionVD('{""idTipoTramiteDetallado"": 367, ""tipoLicencia"": ""Instructor de Vuelo Avión"", ""idTipoLicencia"": 12, ""categorias"": [{""idCategoria"": 2, ""categoria"": ""Avión""}]}','[{""idCategoria"": 2, ""categoria"": ""Avión""}]')
					*/

	--elimino los espacios en blanco

	i_json = replace(i_json::varchar, ' ', '');
	i_object_json = replace(i_object_json::varchar, ' ', '');
	i_json = i_json::jsonb;
	i_object_json = i_object_json::jsonb;

	if i_object_json::varchar like '[%' and i_object_json::varchar like '%]' then
		i_object_json = ltrim(rtrim(i_object_json::varchar , ']'), '[');
	end if;


	if i_json::varchar like '{%' and i_json::varchar like '%}' then
		i_json = convert_array_jsonVD(i_json);
	end if;

d_execute = 'with destructor_tmp as (

		  		select
		 			*
		 		from
		 			jsonb_array_elements($$'||i_json||'$$::jsonb) with ordinality arr(elem, position)
		  ), select_tmp as (

			  	select
			  		*
			  	from
			  		destructor_tmp,
			  		json_each(elem::json)

		  ), search_json as (

			select
				elem,
				position,
				key,
				(select convert_array_jsonVD(elem::varchar)) as value,
			  	json_typeof(value::json) as datos,
			  	value as value_inicial
		  	from
		  		select_tmp
		  	where
		  	(elem::varchar = $$'||i_object_json||'$$::varchar) or (value::varchar = $$'||i_object_json||'$$::varchar)

		  	union all

		  	select
				elem,
				position,
				key,
				case
					WHEN json_typeof(value::json) = $$'||d_object||'$$ THEN (select convert_array_jsonVD(value::varchar)::json)
					ELSE value
				end,
		  		json_typeof(value::json) as datos,
		  		value as value_inicial
		  	from
		  		select_tmp
		  	where
		  	(json_typeof(value::json) like $$'||d_object||'$$ or
		  	json_typeof(value::json) like $$'||d_array||'$$)
		  	order by datos asc
		  )
		  	select
		  		*
		  	from
		  		search_json'
		  ;


	  for d_data in execute d_execute
	  loop

	  if (
		  	(
		  		replace(d_data.value::varchar, ' ', '') = replace(convert_array_jsonVD(i_object_json::varchar), ' ', '')
		  	) or
		  	(
		  		replace(d_data.elem::varchar, ' ', '') = replace(i_object_json::varchar, ' ', '')
		  	) or
		  	(
		  		replace(d_data.value_inicial::varchar, ' ', '') = replace(i_object_json::varchar, ' ', '')
		  	)
	  	) then

	  	if json_array_length(d_data.value) = 1 and d_data.value::varchar = d_data.value_inicial::varchar then

	  		return '{""posicion"": '||json_array_length(d_data.value_inicial)-1||'}@{""clave"": ""'||d_data.key||'"", ""posicion"": '||(d_data.position-1)||'}@';

	  	end if;

		  if json_array_length(d_data.value) = 1 and d_data.value::varchar != d_data.value_inicial::varchar then

		  	return '{""posicion"": '||(d_data.position-1)||'}@';

		  else

		  	return '{""clave"": ""'||d_data.key||'"", ""posicion"": '||(d_data.position-1)||'}@';

		  end if;

	  end if;

	  if not d_data.datos is null then

	  	broke = (select public.extract_positionVD(d_data.value,i_object_json));

	  end if;


	  if not broke = 'No se encuentra el objecto' then

	  		return broke||'{""clave"": ""'||d_data.key||'"", ""posicion"": '||(d_data.position-1)||'}@';

	  end if;

	  end loop;

	RETURN 'No se encuentra el objecto';
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",extract_positionVD.sql
"CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
    SELECT c1 INTO v_c1 FROM ft1 WHERE c1 = p_c1 LIMIT 1;
    PERFORM c1 FROM ft1 WHERE c1 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;",influxdb_fdw_post.out
"CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
    SELECT c1 INTO v_c1 FROM ft1 WHERE c1 = p_c1 LIMIT 1;
    PERFORM c1 FROM ft1 WHERE c1 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;",odbc_fdw.out
"CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
    SELECT c1 INTO v_c1 FROM ft1 WHERE c1 = p_c1 LIMIT 1;
    PERFORM c1 FROM ft1 WHERE c1 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;",postgres_fdw.out
"CREATE OR REPLACE FUNCTION f_test(p_c1 int) RETURNS int AS $$
DECLARE
	v_c1 int;
BEGIN
    SELECT c1 INTO v_c1 FROM ft1 WHERE c1 = p_c1 LIMIT 1;
    PERFORM c1 FROM ft1 WHERE c1 = p_c1 AND p_c1 = v_c1 LIMIT 1;
    RETURN v_c1;
END;
$$ LANGUAGE plpgsql;",sqlite_fdw_post.out
"CREATE OR REPLACE FUNCTION f_vxvxfpc(codPago INTEGER)
RETURNS SETOF RECORD
AS $FUNCTION$
DECLARE
	cursor_vxvxfp CURSOR(codPagoC INTEGER)
	FOR
	SELECT VENDEDOR.nom_vendedor::VARCHAR(100) AS nombre, F_PAGO.nom_f_pago::VARCHAR(100) AS pago, SUM(FACTURA.val_factura)::INTEGER AS total
	FROM F_PAGO,FACTURA,CLIENTE,VENDEDOR
	WHERE F_PAGO.cod_f_pago=codPagoC AND FACTURA.cod_cliente=CLIENTE.cod_cliente AND CLIENTE.cod_f_pago=F_PAGO.cod_f_pago AND CLIENTE.cod_vendedor=VENDEDOR.cod_vendedor
	GROUP BY VENDEDOR.nom_vendedor,F_PAGO.nom_f_pago;
BEGIN
	FOR registro IN cursor_vxvxfp(codPago)
	LOOP
		RETURN NEXT registro;
	END LOOP;
END; $FUNCTION$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION fc_foo()
RETURNS VARCHAR AS $$

BEGIN
    RETURN 'Hello, World!';
END; $$ LANGUAGE PLPGSQL;",README.md
"CREATE OR REPLACE FUNCTION fc_foo(num1 INT, num2 INT)
RETURNS INT AS $$

DECLARE res INT;

BEGIN
    RETURN (num1 + num2) * 2;
END; $$ LANGUAGE PLPGSQL;",README.md
"CREATE OR REPLACE FUNCTION find_partydivisor()
  RETURNS SETOF divisorspec AS
$BODY$

DECLARE
  lower_bound     NUMERIC := 1;
  /* AT LEAST ONE VOTE PER SEAT */
  upper_bound     NUMERIC := 80000000;
  /* NOT MORE VOTES PER SEAT THAN PEOPLE VOTING */
  row             RECORD;
  cur_divisor     NUMERIC := lower_bound;
  /* INITIAL VALUE */
  cur_total_seats NUMERIC := 0;
  /* INITIAL VALUE */
BEGIN
  CREATE TEMP TABLE mandates_votes AS (
    SELECT
      vb.election,
      votes,
      mandates,
      vb.party
    FROM votes_bundesland vb LEFT JOIN mandates_party_bland mb
        ON vb.bundesland = mb.bundesland
           AND mb.party = vb.party
           AND vb.election = mb.election
  );

  FOR row IN
  SELECT
    sp.election,
    sp.party,
    sp.seats
  FROM seats_by_party sp
  LOOP

    lower_bound := 1;
    upper_bound := 80000000;
    cur_divisor := lower_bound;
    cur_total_seats := 0;

    CREATE TEMP TABLE mandates_votes_instance AS (
      SELECT *
      FROM mandates_votes mv
      WHERE mv.party = row.party
            AND mv.election = row.election
    );

    WHILE NOT cur_total_seats = row.seats LOOP

      cur_total_seats = (SELECT sum(greatest(round(votes / cur_divisor, 0), coalesce(mandates, 0)))
                         FROM mandates_votes_instance);

      /* binary search */
      IF cur_total_seats > row.seats
      THEN
        lower_bound := cur_divisor;
        cur_divisor := (cur_divisor + upper_bound) / 2;
      ELSIF cur_total_seats < row.seats
        THEN
          upper_bound := cur_divisor;
          cur_divisor := (cur_divisor + lower_bound) / 2;

      END IF;

    END LOOP;

    DROP TABLE mandates_votes_instance;

    RETURN NEXT (row.election, row.party, cur_divisor);


  END LOOP;

  DROP TABLE mandates_votes;
  RETURN;
END

$BODY$
LANGUAGE plpgsql VOLATILE
COST 10000
ROWS 1000;",election_algorithm.sql
"CREATE OR REPLACE FUNCTION fn_get_hijos_unidad(IN id_unidad_param integer)
  RETURNS TABLE(id_unidad integer, id_tipo_unidad integer, codigo_seguimiento integer, denominacion character varying, fecha_creacion date, fecha_fin date, estado character, codigo_unidad character varying, codigo_unidad_padre character varying, id_entidad integer, normativa character, nivel integer, id_unidad_padre integer, sigla character varying, id_version integer) AS
$BODY$
declare
	V_UNIDAD ALIAS FOR $1;
begin
    RETURN QUERY
    SELECT 
	
	dblink.id_unidad,
        dblink.id_tipo_unidad,
        dblink.codigo_seguimiento,
        dblink.denominacion,
        dblink.fecha_creacion,
        dblink.fecha_fin,
        dblink.estado,
        dblink.codigo_unidad,
        dblink.codigo_unidad_padre,
        dblink.id_entidad,
        dblink.normativa,
        dblink.nivel,
        dblink.id_unidad_padre,
        dblink.sigla,
        dblink.id_version
	
	
	from
	dblink('hostaddr=192.168.0.110 port=5432 dbname=prod_mof user=postgres password=admin'::text, 
	'SELECT 
	       T0.id_unidad
                ,T0.id_tipo_unidad
                ,T0.codigo_seguimiento
                ,T0.denominacion
                ,T0.fecha_creacion
                ,T0.fecha_fin
                ,T0.estado
                ,T0.codigo_unidad
                ,T0.codigo_unidad_padre
                ,T0.id_entidad
                ,T0.normativa
                ,T0.nivel
                ,T0.id_unidad_padre
                ,T0.sigla
                ,T0.id_version
	 FROM get_hijos_unidad('||V_UNIDAD||') as T0
	 
	 '::TEXT)
	dblink(
	  id_unidad integer,
  id_tipo_unidad integer,
  codigo_seguimiento integer,
  denominacion character varying,
  fecha_creacion date,
  fecha_fin date,
  estado character,
  codigo_unidad character varying,
  codigo_unidad_padre character varying,
  id_entidad integer,
  normativa character,
  nivel integer,
  id_unidad_padre integer,
  sigla character varying,
  id_version integer
	);


    
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",procedim_13-02-2017.sql
"CREATE OR REPLACE FUNCTION fn_og_by_gestion(IN gestion integer, IN id_unidad integer)
  RETURNS TABLE(codigo_poa text, og_separador text, og_id_das character varying, og_codigo integer, og_id_obj_gestion integer, og_id_unidad integer, og_sigla_unidad character varying, og_unidad character varying, og_descripcion character varying, oe_separador text, oe_codigo integer, oe_id_obj_esp integer, oe_id_unidad_resp numeric, oe_sigla_unidad_resp character varying, oe_unidad_resp character varying, oe_descripcion character varying, oe_resultado_esperado character varying, oe_cve_tipo_obj character, oe_indicador character varying, op_separador text, op_codigo integer, op_id_operacion integer, op_id_unidad integer, op_sigla_unidad character varying, op_descripcion character varying, op_metas character varying, op_medio_verificacion character varying, op_ponderacion double precision, op_cve_tipo_operacion character varying, op_indicador character varying, op_periodo_inicio character varying, op_periodo_fin character varying) AS
$BODY$
declare
	V_GESTION ALIAS FOR $1;
	V_ID_UNIDAD ALIAS FOR $2;

	V_WHERE text := ' ';
begin

       IF (V_ID_UNIDAD IS NOT NULL) THEN
         BEGIN
               V_WHERE = ' and oe.id_unidad_resp = '||V_ID_UNIDAD||' ';
         END;
       END IF;

    RETURN QUERY

SELECT dblink.*
FROM dblink('hostaddr=192.168.0.110 port=5432    
dbname=poa_ppto user=postgres password=admin'::text,
'SELECT
    (e.sigla ||''.'' || og.codigo || ''.'' || oe.codigo || ''.'' || o.codigo) AS codigo_poa,
    '' || ''                                                              AS og_separador,
    og.id_das                                                           AS og_id_das,
    og.codigo                                                           AS og_codigo,
    og.id_obj_gestion                                                   AS og_id_obj_gestion,
    ou.id_unidad                                                        AS og_id_unidad,
    eo_og.sigla                                                         AS og_sigla_unidad,
    eo_og.descripcion                                                   AS og_unidad,
    og.descripcion                                                      AS og_descripcion,
    '' || ''                                                              AS oe_separador,
    oe.codigo                                                           AS oe_codigo,
    oe.id_obj_esp                                                       AS oe_id_obj_esp,
    oe.id_unidad_resp                                                   AS oe_id_unidad_resp,
    eo.sigla                                                            AS oe_sigla_unidad_resp,
    eo.descripcion                                                      AS oe_unidad_resp,
    oe.descripcion                                                      AS oe_descripcion,
    oe.resultado_esperado                                               AS oe_resultado_esperado,
    oe.cve_tipo_obj                                                     AS oe_cve_tipo_obj,
    cc.interpretacion                                                   AS oe_indicador,
    '' || ''                                                              AS op_separador,
    o.codigo                                                            AS op_codigo,
    o.id_ope                                                            AS op_id_operacion,
    eo_ope.id_unidad                                                    AS op_id_unidad,
    eo_ope.sigla                                                        AS op_sigla_unidad,
    o.descripcion                                                       AS op_descripcion,
    o.metas                                                             AS op_metas,
    o.medio_verificacion                                                AS op_medio_verificacion,
    o.ponderacion                                                       AS op_ponderacion,
    o.cve_tipo_objetivo__                                               AS op_cve_tipo_operacion,
    c.interpretacion                                                    AS op_indicador,
    cfi.interpretacion                                                  AS op_periodo_inicio,
    cff.interpretacion                                                  AS op_periodo_fin
from objges_unid ou
inner join objetivo_gestion og on og.id_obj_gestion = ou.id_obj_gestion
inner join objetivo_especifico oe on oe.id_obj_gestion = og.id_obj_gestion
inner join operacion o on o.id_obj_esp = oe.id_obj_esp
inner join estructura_organizacional eo_og on eo_og.id_unidad = ou.id_unidad
inner join estructura_organizacional eo on eo.id_unidad = oe.id_unidad_resp
inner join estructura_organizacional eo_ope on eo_ope.id_unidad = o.id_unidad_ejec
inner join claves c on c.valor_clave = o.cve_tipo_objetivo__
inner join claves cc on cc.valor_clave = oe.cve_tipo_obj
inner join claves cfi on cfi.valor_clave = o.periodo_inicio
inner join claves cff on cff.valor_clave = o.periodo_fin
inner join entidad e on og.id_entidad = e.id_entidad
where  og.id_entidad = 35
and ou.cve_vigente = ''V''
and og.cve_vigente = ''V''
and og.cve_estado = ''A''
and oe.cve_vigente = ''V''
and oe.cve_estado = ''A''
and o.cve_vigente = ''V''
and o.cve_estado = ''A''
and c.clave = ''cve_tipo_objetivo''
and cc.clave = ''cve_tipo_objetivo_esp''
and ou.id_unidad = (SELECT gup.id_unidad FROM get_unidad_padre(oe.id_unidad_resp::integer,1) gup )
'||V_WHERE||'
and og.id_gestion in (SELECT gpp.id_gestion FROM gestion_poa_ppto gpp where gpp.gestion = '||V_GESTION||'::integer)
order by  og.codigo , oe.codigo , o.codigo'::text) 
dblink(
codigo_poa	text,
og_separador	text,
og_id_das	character varying,
og_codigo	integer,
og_id_obj_gestion	integer,
og_id_unidad	integer,
og_sigla_unidad	character varying,
og_unidad	character varying,
og_descripcion	character varying,
oe_separador	text,
oe_codigo	integer,
oe_id_obj_esp	integer,
oe_id_unidad_resp	numeric,
oe_sigla_unidad_resp	character varying,
oe_unidad_resp	character varying,
oe_descripcion	character varying,
oe_resultado_esperado	character varying,
oe_cve_tipo_obj	bpchar,
oe_indicador	character varying,
op_separador	text,
op_codigo	integer,
op_id_operacion	integer,
op_id_unidad	integer,
op_sigla_unidad	character varying,
op_descripcion	character varying,
op_metas	character varying,
op_medio_verificacion	character varying,
op_ponderacion	double precision,
op_cve_tipo_operacion	character varying,
op_indicador	character varying,
op_periodo_inicio	character varying,
op_periodo_fin	character varying
);
    
    
    
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",procedim_13-02-2017.sql
"CREATE OR REPLACE FUNCTION fn_og_by_gestion(IN id_gestion integer)
  RETURNS TABLE(codigo_poa text, og_separador text, og_id_das character varying, og_codigo integer, og_id_obj_gestion integer, og_id_unidad integer, og_sigla_unidad character varying, og_unidad character varying, og_descripcion character varying, oe_separador text, oe_codigo integer, oe_id_obj_esp integer, oe_id_unidad_resp numeric, oe_sigla_unidad_resp character varying, oe_unidad_resp character varying, oe_descripcion character varying, oe_resultado_esperado character varying, oe_cve_tipo_obj character, oe_indicador character varying, op_separador text, op_codigo integer, op_id_operacion integer, op_id_unidad integer, op_sigla_unidad character varying, op_descripcion character varying, op_metas character varying, op_medio_verificacion character varying, op_ponderacion double precision, op_cve_tipo_operacion character varying, op_indicador character varying, op_periodo_inicio character varying, op_periodo_fin character varying) AS
$BODY$
declare
	V_GESTION ALIAS FOR $1;
begin
    RETURN QUERY

SELECT dblink.*
FROM dblink('hostaddr=192.168.0.110 port=5432    
dbname=poa_ppto user=postgres password=admin'::text,
'SELECT
    (e.sigla ||''.'' || og.codigo || ''.'' || oe.codigo || ''.'' || o.codigo) AS codigo_poa,
    '' || ''                                                              AS og_separador,
    og.id_das                                                           AS og_id_das,
    og.codigo                                                           AS og_codigo,
    og.id_obj_gestion                                                   AS og_id_obj_gestion,
    ou.id_unidad                                                        AS og_id_unidad,
    eo_og.sigla                                                         AS og_sigla_unidad,
    eo_og.descripcion                                                   AS og_unidad,
    og.descripcion                                                      AS og_descripcion,
    '' || ''                                                              AS oe_separador,
    oe.codigo                                                           AS oe_codigo,
    oe.id_obj_esp                                                       AS oe_id_obj_esp,
    oe.id_unidad_resp                                                   AS oe_id_unidad_resp,
    eo.sigla                                                            AS oe_sigla_unidad_resp,
    eo.descripcion                                                      AS oe_unidad_resp,
    oe.descripcion                                                      AS oe_descripcion,
    oe.resultado_esperado                                               AS oe_resultado_esperado,
    oe.cve_tipo_obj                                                     AS oe_cve_tipo_obj,
    cc.interpretacion                                                   AS oe_indicador,
    '' || ''                                                              AS op_separador,
    o.codigo                                                            AS op_codigo,
    o.id_ope                                                            AS op_id_operacion,
    eo_ope.id_unidad                                                    AS op_id_unidad,
    eo_ope.sigla                                                        AS op_sigla_unidad,
    o.descripcion                                                       AS op_descripcion,
    o.metas                                                             AS op_metas,
    o.medio_verificacion                                                AS op_medio_verificacion,
    o.ponderacion                                                       AS op_ponderacion,
    o.cve_tipo_objetivo__                                               AS op_cve_tipo_operacion,
    c.interpretacion                                                    AS op_indicador,
    cfi.interpretacion                                                  AS op_periodo_inicio,
    cff.interpretacion                                                  AS op_periodo_fin
from objges_unid ou
inner join objetivo_gestion og on og.id_obj_gestion = ou.id_obj_gestion
inner join objetivo_especifico oe on oe.id_obj_gestion = og.id_obj_gestion
inner join operacion o on o.id_obj_esp = oe.id_obj_esp
inner join estructura_organizacional eo_og on eo_og.id_unidad = ou.id_unidad
inner join estructura_organizacional eo on eo.id_unidad = oe.id_unidad_resp
inner join estructura_organizacional eo_ope on eo_ope.id_unidad = o.id_unidad_ejec
inner join claves c on c.valor_clave = o.cve_tipo_objetivo__
inner join claves cc on cc.valor_clave = oe.cve_tipo_obj
inner join claves cfi on cfi.valor_clave = o.periodo_inicio
inner join claves cff on cff.valor_clave = o.periodo_fin
inner join entidad e on og.id_entidad = e.id_entidad
where  og.id_entidad = 35
and ou.cve_vigente = ''V''
and og.cve_vigente = ''V''
and og.cve_estado = ''A''
and oe.cve_vigente = ''V''
and oe.cve_estado = ''A''
and o.cve_vigente = ''V''
and o.cve_estado = ''A''
and c.clave = ''cve_tipo_objetivo''
and cc.clave = ''cve_tipo_objetivo_esp''
and ou.id_unidad = (SELECT gup.id_unidad FROM get_unidad_padre(oe.id_unidad_resp::integer,1) gup )
--and oe.id_unidad_resp = 950
and og.id_gestion in (SELECT gpp.id_gestion FROM gestion_poa_ppto gpp where gpp.gestion = '||V_GESTION||'::integer)
order by  og.codigo , oe.codigo , o.codigo'::text) 
dblink(
codigo_poa	text,
og_separador	text,
og_id_das	character varying,
og_codigo	integer,
og_id_obj_gestion	integer,
og_id_unidad	integer,
og_sigla_unidad	character varying,
og_unidad	character varying,
og_descripcion	character varying,
oe_separador	text,
oe_codigo	integer,
oe_id_obj_esp	integer,
oe_id_unidad_resp	numeric,
oe_sigla_unidad_resp	character varying,
oe_unidad_resp	character varying,
oe_descripcion	character varying,
oe_resultado_esperado	character varying,
oe_cve_tipo_obj	bpchar,
oe_indicador	character varying,
op_separador	text,
op_codigo	integer,
op_id_operacion	integer,
op_id_unidad	integer,
op_sigla_unidad	character varying,
op_descripcion	character varying,
op_metas	character varying,
op_medio_verificacion	character varying,
op_ponderacion	double precision,
op_cve_tipo_operacion	character varying,
op_indicador	character varying,
op_periodo_inicio	character varying,
op_periodo_fin	character varying
);
    
    
    
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",procedim_13-02-2017.sql
"CREATE OR REPLACE FUNCTION func_increment_plsql(i integer) RETURNS integer AS $$
BEGIN
RETURN i + 1;
END;
$$ LANGUAGE plpgsql;",gaussdb200.sql
"CREATE OR REPLACE FUNCTION game_finish() RETURNS void AS $$
BEGIN
END;
$$ LANGUAGE plpgsql;",fb.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '22'
    LOOP
			param = param||rec.user_id||'=>'||rec.rakeback_id||', ';
	END LOOP;
	IF length(param)>0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	--raise info '结果:%', param;
	SELECT param::hstore INTO hash;
	--测试引用值.
  	--raise info '4:%', hash->'3';
	RETURN hash;
END;

$$ language plpgsql;",E_gamebox_rakeback_0125.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '22'
    LOOP
			param = param||rec.user_id||'=>'||rec.rakeback_id||', ';
	END LOOP;
	IF length(param)>0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	--raise info '结果:%', param;
	SELECT param::hstore INTO hash;
	--测试引用值.
  	--raise info '4:%', hash->'3';
	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '22'
    LOOP
			param = param||rec.user_id||'=>'||rec.rakeback_id||', ';
	END LOOP;
	IF length(param)>0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	--raise info '结果:%', param;
	SELECT param::hstore INTO hash;
	--测试引用值.
  	--raise info '4:%', hash->'3';
	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0357__C_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '23'
		   AND a.rakeback_id >= 0
    LOOP
		param = param||rec.user_id||'=>'||rec.rakeback_id||', ';
	END LOOP;
	IF length(param)>0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	--raise info '结果:%', param;
	SELECT param::hstore INTO hash;
	--测试引用值.
  	--raise info '4:%', hash->'3';
	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '23'
		   AND a.rakeback_id >= 0
    LOOP
		param = param||rec.user_id||'=>'||rec.rakeback_id||', ';
	END LOOP;
	IF length(param)>0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	--raise info '结果:%', param;
	SELECT param::hstore INTO hash;
	--测试引用值.
  	--raise info '4:%', hash->'3';
	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '23'
		   AND a.rakeback_id >= 0
    LOOP
		param = param||rec.user_id||'=>'||rec.rakeback_id||',';
	END LOOP;
	IF length(param) > 0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	SELECT param::hstore INTO hash;
	RETURN hash;
END;

$$ language plpgsql;",1_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_agent_rakeback()
	returns hstore as $$
DECLARE
	hash 	hstore;
	rec		record;
	param 	text:='';
BEGIN
	FOR rec IN
		SELECT a.user_id,
			   a.rakeback_id
		  FROM user_agent_rakeback a,
			   sys_user u
	     WHERE a.user_id = u.id
		   AND u.user_type = '23'
		   AND a.rakeback_id >= 0
    LOOP
		param = param||rec.user_id||'=>'||rec.rakeback_id||',';
	END LOOP;
	IF length(param) > 0 THEN
		param = substring(param,  1 , length(param)-1);
	END IF;
	SELECT param::hstore INTO hash;
	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_effective_volume(
	back_time  TIMESTAMP
) returns hstore as $$
DECLARE
    rec         record;
    volumehash  hstore;
    keyname     TEXT;
    keyvalue    FLOAT:=0.0;
BEGIN
    FOR rec IN
        SELECT pgo.player_id, SUM(COALESCE(effective_trade_amount, 0.00)) volume
          FROM player_game_order pgo
         WHERE to_char(pgo.create_time, 'yyyy-MM-dd') = to_char(back_time, 'yyyy-MM-dd')
           AND order_state = 'settle'
		   AND is_profit_loss = TRUE
         GROUP BY pgo.player_id
         ORDER BY pgo.player_id

    LOOP
        keyname:=rec.player_id::TEXT;
        keyvalue:=rec.volume::FLOAT;
        IF volumehash IS NULL THEN
            SELECT keyname||'=>'||keyvalue into volumehash;
        ELSE
            volumehash = (SELECT (keyname||'=>'||keyvalue)::hstore)||volumehash;
        END IF;

    END LOOP;
    RETURN volumehash;

END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_api_grads()
  RETURNS hstore AS
$BODY$
DECLARE
	rec 		record;
	param 		text:='';
	gradshash 	hstore;
	tmphash 	hstore;
	keyname 	text:='';
	val 		text:='';
	val2 		text:='';
BEGIN
	FOR rec in
	SELECT m.id,
		   s.id as grads_id,
		   d.api_id,
		   d.game_type,
		   COALESCE(d.ratio,0) 			as ratio,
		   COALESCE(s.max_rakeback,0) 	as max_rakeback,
		   COALESCE(s.valid_value,0) 	as valid_value,
		   m.name,
		   COALESCE(m.audit_num,0) 		as audit_num
	  FROM rakeback_grads s, rakeback_grads_api d, rakeback_set m
	 WHERE s.id = d.rakeback_grads_id
	   AND s.rakeback_id = m.id
	   AND m.status='1'
--   		 AND m.ID = 60
------------------------------------------
	 ORDER BY m.id,d.api_id,d.game_type,s.valid_value desc
   	LOOP
		--判断主方案是否存在.
		--键值格式:ID+GRADSID+API+GAMETYPE
		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text;

		val:=row_to_json(rec);
		val:=replace(val,',','\|');
		val:=replace(val,'null','-1');
		IF (gradshash?keyname) is null OR (gradshash?keyname) =false THEN
			--gradshash=hash||tmphash;
			IF gradshash is null THEN
				select keyname||'=>'||val into gradshash;
			ELSE
				select keyname||'=>'||val into tmphash;
				gradshash = gradshash||tmphash;
			END IF;

		ELSE
			val2 = gradshash->keyname;
			select keyname||'=>'||val||'^&^'||val2 into tmphash;
			gradshash = gradshash||tmphash;
		END IF;
	END LOOP;

	return gradshash;
END;

$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",V1.0.1.0357__C_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id	int,
	gradshash 	hstore,
	agenthash 	hstore
) returns FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		IF rakeback_id = tmp_rb_id THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id	int,
	gradshash 	hstore,
	agenthash 	hstore
) returns FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		IF rakeback_id = tmp_rb_id THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	FLOAT;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;

				IF tmp_back_water > 0 THEN
					IF tmp_back_water > max_back_water THEN
						max_back_water = tmp_back_water;
					END IF;
				ELSE
					max_back_water = 0.0;
				END IF;
			END IF;
		END IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",1_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	FLOAT;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;

				IF tmp_back_water > 0 THEN
					IF tmp_back_water > max_back_water THEN
						max_back_water = tmp_back_water;
					END IF;
				ELSE
					max_back_water = 0.0;
				END IF;
			END IF;
		END IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash 	hstore,
	agenthash 	hstore,
	volume 		float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	max_back_water 	float:=0.00;	--最大返水上限
	tmp_back_water 	float:=0.00;
	tmp_rb_id		int;
  	tmp_rb_volume 	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];
		val = gradshash->keyname;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
 		tmp_rb_volume = (hash->'valid_value')::FLOAT;

		IF rakeback_id = tmp_rb_id  THEN
			IF volume >= (tmp_rb_volume::float) THEN
				tmp_back_water = (hash->'max_rakeback')::float;
				IF tmp_back_water > max_back_water THEN
					max_back_water = tmp_back_water;
				end IF;
			end IF;
		end IF;

	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION gamebox_rakeback_limit(
	rakeback_id int,
	gradshash hstore,
	agenthash hstore,
	volume 	float
) RETURNS FLOAT as $$
DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';
	hash 		hstore;
	--最大返水上限
	max_back_water 	float:=0.00;
	key 		text:='';
	tmp_rb_id	int;
  	tmp_rb_volume 	int;
BEGIN
	keys = akeys(gradshash);
	FOR i IN 1..array_length(keys, 1)
	LOOP
		subkeys = regexp_split_to_array(keys[i], '_');
		keyname = keys[i];

		val = gradshash->keyname;
		IF subkeys IS NOT NULL THEN
			key = subkeys[0];
		END IF;
		SELECT * FROM strToHash(val) INTO hash;
		tmp_rb_id = hash->'id';
		max_back_water = 0.00;
		tmp_rb_volume = hash->'valid_value';
		IF rakeback_id = tmp_rb_id AND volume >= (tmp_rb_volume::float) THEN
			max_back_water = (hash->'max_rakeback')::float;
			EXIT;
		END IF;
	END LOOP;
	RETURN max_back_water;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"CREATE OR REPLACE FUNCTION getCheckAndItems(exam_no varchar) RETURNS text AS $$
    DECLARE
        data        record;
        tmp         text[];
    BEGIN
     FOR data IN
        SELECT
        DEP.department_name,
        I.item_name, EX_I.item_value, EX_I.exception_arrow, EX_I.reference_description, I.examination_unit,
        EX_CK.diagnose_result,
        DEP.doctor_sign, M.previous_name username, mm.previous_name
        FROM examination EX
        LEFT JOIN examination_checkup EX_CK ON EX.examination_no = EX_CK.examination_no
        LEFT JOIN checkup CK ON EX_CK.checkup_code = CK.checkup_code
        LEFT JOIN department DEP ON CK.department_code = DEP.department_code
        LEFT JOIN examination_item EX_I ON EX.examination_no = EX_I.examination_no AND EX_CK.checkup_code = EX_I.checkup_code
        LEFT JOIN item I ON EX_I.item_code = I.item_code
        LEFT JOIN manager M ON EX_CK.diagnose_manager_code = M.manager_code
        LEFT JOIN MANAGER mm ON EX_CK.check_manager_code = mm.manager_code
        WHERE EX_CK.checkup_code IS NOT NULL
        AND EX_CK.checkup_status = 2
        AND EX.examination_no = exam_no
        AND (
	        (
		        I.validate_type = 1
		        AND EX_I.item_value IS NOT NULL
	        )
	        OR I.validate_type = 0
        )
        AND EX_CK.department_code NOT IN ('63')
        ORDER BY DEP.department_code, CK.order_position, I.item_code
        LOOP
            select array_append(tmp, arrayToObjStr(ARRAY[checkNull(data.department_name), checkNull(data.item_name),
            checkNull(data.item_value), checkNull(data.exception_arrow), checkNull(data.reference_description),
            checkNull(data.examination_unit), checkNull(data.diagnose_result), checkNull(data.doctor_sign),
            checkNull(data.username), checkNull(data.previous_name)]::text[])) into tmp;
        END LOOP;

        return arrayToArrStr(tmp);

    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getCheckAndItems(exam_no varchar) RETURNS text AS $$
    DECLARE
        data        record;
        tmp         text[];
    BEGIN
     FOR data IN
        SELECT
        DEP.department_name,
        I.item_name, EX_I.item_value, EX_I.exception_arrow, EX_I.reference_description, I.examination_unit,
        EX_CK.diagnose_result,
        DEP.doctor_sign, M.previous_name username, mm.previous_name,
        CK.checkup_type_code, CK.department_code
        FROM examination EX
        LEFT JOIN examination_checkup EX_CK ON EX.examination_no = EX_CK.examination_no
        LEFT JOIN checkup CK ON EX_CK.checkup_code = CK.checkup_code
        LEFT JOIN department DEP ON CK.department_code = DEP.department_code
        LEFT JOIN examination_item EX_I ON EX.examination_no = EX_I.examination_no AND EX_CK.checkup_code = EX_I.checkup_code
        LEFT JOIN item I ON EX_I.item_code = I.item_code
        LEFT JOIN manager M ON EX_CK.diagnose_manager_code = M.manager_code
        LEFT JOIN MANAGER mm ON EX_CK.check_manager_code = mm.manager_code
        WHERE EX_CK.checkup_code IS NOT NULL
        and CK.checkup_type_code IN ('0', '1')
        AND EX_CK.checkup_status = 2
        AND EX.examination_no = exam_no
        AND (
	        (
		        I.validate_type = 1
		        AND EX_I.item_value IS NOT NULL
	        )
	        OR I.validate_type = 0
        )
        AND EX_CK.department_code NOT IN ('63')
        ORDER BY DEP.department_code, ck.checkup_code, i.order_position, I.item_code
        LOOP
            select array_append(tmp, arrayToObjStr(ARRAY[checkNull(data.department_name), checkNull(data.item_name),
            checkNull(data.item_value), checkNull(data.exception_arrow), checkNull(data.reference_description),
            checkNull(data.examination_unit), checkNull(data.diagnose_result), checkNull(data.doctor_sign),
            checkNull(data.username), checkNull(data.previous_name),
            checkNull(data.checkup_type_code), checkNull(data.department_code)]::text[])) into tmp;
        END LOOP;

        return arrayToArrStr(tmp);

    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getCheckupStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        ret  text[];
    BEGIN
        FOR data IN
        SELECT
            C.checkup_name, d.department_name, ec.checkup_status
        FROM examination T
        LEFT JOIN examination_checkup ec ON T .examination_no = ec.examination_no
        LEFT JOIN checkup C ON ec.checkup_code = C .checkup_code
        LEFT JOIN department d ON ec.department_code = d.department_code
        WHERE T .examination_no = exam_no AND C .is_valid = 1
        ORDER BY ec.checkup_status, d.department_code, C.order_position
   		LOOP
            select array_append(ret,  arrayToObjStr(ARRAY[data.checkup_name, data.department_name, data.checkup_status]::text[])) into ret;
   		END LOOP;

   		RETURN arrayToArrStr(ret);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getCheckupStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        ret  text[];
    BEGIN
        FOR data IN
        SELECT
            C.checkup_name, d.department_name, ec.checkup_status
        FROM examination T
        LEFT JOIN examination_checkup ec ON T .examination_no = ec.examination_no
        LEFT JOIN checkup C ON ec.checkup_code = C .checkup_code
        LEFT JOIN department d ON ec.department_code = d.department_code
        WHERE T .examination_no = exam_no AND C .is_valid = 1
        ORDER BY ec.checkup_status, ec.checkup_code, d.department_code, C.order_position
   		LOOP
            select array_append(ret,  arrayToObjStr(ARRAY[data.checkup_name, data.department_name, data.checkup_status]::text[])) into ret;
   		END LOOP;

   		RETURN arrayToArrStr(ret);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getDayQuadrantForGivenTime(config_time varchar) RETURNS integer
    AS $$
DECLARE
    minutes integer;
    temp_minutes integer;
    from_date timestamp;
    to_date timestamp;
    ref_date varchar;
BEGIN
	ref_date := '01 01 2000 ';
	from_date := to_timestamp('01 01 2000 ' ||  config_time, 'DD MM YYYY HH12:MI AM');
	to_date := to_timestamp('01 01 2000 ' || '12:00 AM', 'DD MM YYYY HH12:MI AM');
    minutes := to_char(from_date - to_date, 'HH24') ;
    minutes := minutes * 60;
    temp_minutes := to_char(from_date - to_date, 'MI') ;
    minutes := minutes + temp_minutes;
    RETURN minutes;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getDayQuadrantForGivenTime(config_time varchar) RETURNS integer
    AS $$
DECLARE 
    minutes integer;
    temp_minutes integer;
    from_date timestamp;
    to_date timestamp;
    ref_date varchar;
BEGIN	
	ref_date := '01 01 2000 ';
	from_date := to_timestamp('01 01 2000 ' ||  config_time, 'DD MM YYYY HH12:MI AM');
	to_date := to_timestamp('01 01 2000 ' || '12:00 AM', 'DD MM YYYY HH12:MI AM');
    minutes := to_char(from_date - to_date, 'HH24') ;
    minutes := minutes * 60;
    temp_minutes := to_char(from_date - to_date, 'MI') ;
    minutes := minutes + temp_minutes;
    RETURN minutes;   
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getFinalDiagoseStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data        record;
        tmp         text[];
    BEGIN
    FOR DATA IN
        SELECT
                C .checkup_name,
                T .analyzse_doctor,
        		T .analyse_advice,
				ec.diagnose_result

			FROM
				examination_analyse T
			LEFT JOIN checkup C ON T .checkup_code = C .checkup_code
			LEFT JOIN examination_checkup ec ON (
				T .checkup_code = ec.checkup_code
				AND T .examination_no = ec.examination_no
			)
			WHERE
				T .examination_no = exam_no
			AND T .department_code <> '63'
			AND (
				analyse_advice IS NOT NULL
				AND analyse_advice <> ' '
				AND analyse_advice <> ''
			)
			ORDER BY
				C .order_position
    LOOP
        SELECT array_append(tmp, arrayToObjStr(ARRAY[data.checkup_name, data.analyzse_doctor, data.analyse_advice, data.diagnose_result]::text[]))
        INTO tmp;
    END LOOP;

    return arrayToArrStr(tmp);
    END;

$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getGroupIdFromProfileNoAndTenantId(profile_no bigint, tenant_id bigint) RETURNS integer
    AS $$
DECLARE
    group_no bigint := 0;
BEGIN
	--Raise Notice 'Details % => %', $1, $2;
	IF ($2::bigint is NULL) THEN
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and g.tenant_id is null;
	ELSE
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and g.tenant_id = $2;
    END IF;
	return group_no;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getGroupIdFromProfileNoAndTenantId(profile_no bigint, tenant_id bigint) RETURNS integer
    AS $$
DECLARE 
    group_no bigint := 0;
BEGIN
	--Raise Notice 'Details % => %', $1, $2;
	IF ($2::bigint is NULL) THEN
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and g.tenant_id is null;
	ELSE
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and g.tenant_id = $2;
    END IF;
	return group_no;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getGroupIdFromProfileNoAndTenantId(profile_no bigint, tenant_id bigint) RETURNS integer
    AS $$
DECLARE 
    group_no bigint := 0;
BEGIN
	--Raise Notice 'Details % => %', $1, $2;
	IF ($2::bigint is NULL) THEN
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and tenant_id is null;
	ELSE
		SELECT id INTO group_no FROM groups g WHERE g.profile_no = $1::smallint and tenant_id = $2;
    END IF;
	return group_no;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getImageStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;

        tmp text[];
    BEGIN
        FOR data IN
            SELECT ec.checkup_code, ec.diagnose_result, ec.image_url, c.checkup_name
            FROM examination_checkup ec
            LEFT JOIN checkup c ON ec.checkup_code = c.checkup_code
            WHERE ec.examination_no = exam_no and ec.image_url is not null
            AND EC.checkup_code NOT IN (
            SELECT regexp_split_to_table(key_value,',') from con_global_config where  key_name = 'not_print_code' OR  key_name = 'single_print_code'
            )

        LOOP
            select array_append(tmp, arrayToObjStr(ARRAY[data.checkup_name, data.diagnose_result, data.image_url, getItemStr(exam_no, data.checkup_code)])) into tmp;
        END LOOP;

        RETURN arrayToArrStr(tmp);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getImageStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;

        tmp text[];
    BEGIN
        FOR data IN
            SELECT ec.checkup_code, ec.diagnose_result, ec.image_url, c.checkup_name,
            d.doctor_sign, m.previous_name, ARRAY_LENGTH(STRING_TO_ARRAY(ec.image_url, ';'), 1) AS img_count
            FROM examination_checkup ec
            LEFT JOIN checkup c ON ec.checkup_code = c.checkup_code
            LEFT JOIN manager m ON ec.diagnose_manager_code=m.manager_code
            LEFT JOIN department d ON d.department_code = ec.department_code
            WHERE ec.examination_no = exam_no and ec.image_url is not null
            AND EC.checkup_code NOT IN (
            SELECT regexp_split_to_table(key_value,',') from con_global_config where  key_name = 'not_print_code' OR  key_name = 'single_print_code'
            )
            ORDER BY img_count DESC
        LOOP
            select array_append(tmp, arrayToObjStr(ARRAY[data.checkup_name, data.diagnose_result, data.image_url, getItemStr(exam_no, data.checkup_code), data.doctor_sign, data.previous_name])) into tmp;
        END LOOP;

        RETURN arrayToArrStr(tmp);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getItemStr(exam_no varchar, ck_code varchar) RETURNS text AS $$
    DECLARE
        data record;
        tmp text[];
    BEGIN
        FOR data IN
             SELECT i.item_name, ei.item_value FROM examination_item ei, item i
             WHERE ei.item_code = i.item_code AND ei.checkup_code = ck_code AND ei.examination_no = exam_no
             ORDER BY i.order_position
             LOOP
                SELECT array_append(tmp, arrayToObjStr2(ARRAY[data.item_name, data.item_value])) into tmp;
             END LOOP;
        RETURN arrayToArrStr2(tmp);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getItemStr(exam_no varchar, ck_code varchar) RETURNS text AS $$
    DECLARE
        data record;
        tmp text[];
    BEGIN
        FOR data IN
             select item_name, item_value from examination_item where checkup_code = ck_code and examination_no = exam_no
             LOOP
                SELECT array_append(tmp, arrayToObjStr2(ARRAY[data.item_name, data.item_value])) into tmp;
             END LOOP;
        RETURN arrayToArrStr2(tmp);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getMinLightLevelForFixture(fixture_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN
	level := 0;
	--- Let's calculate the type of day

	profile_id := getProfileByFixtureGroupId($1, $2, 0, $3);

	level := min_level from profile where id = profile_id;
    RETURN level;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getMinLightLevelForFixture(fixture_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN	
	level := 0;
	--- Let's calculate the type of day
	
	profile_id := getProfileByFixtureGroupId($1, $2, 0, $3);
	      
	level := min_level from profile where id = profile_id;
    RETURN level;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getOnLightLevelForFixture(fixture_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN
	level := 0;
	--- Let's calculate the type of day

	profile_id := getProfileByFixtureGroupId($1, $2, 0, $3);

	level := on_level from profile where id = profile_id;
    RETURN level;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getOnLightLevelForFixture(fixture_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN	
	level := 0;
	--- Let's calculate the type of day
	
	profile_id := getProfileByFixtureGroupId($1, $2, 0, $3);
	      
	level := on_level from profile where id = profile_id;
    RETURN level;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileByFixtureGroupId(fixture_id bigint, dayOfWeek integer, group_id bigint,  currentMinutes integer) RETURNS integer
    AS $$
DECLARE
    day_type varchar;
    profile_id bigint := 0;
    quadrant_type varchar;
    sortedQuad int[] = '{}';
    sortedType varchar[] = '{}';
    w int := 0;
    x int := 0;
    y int := 0;
    z int := 0;
BEGIN

	IF $1 > 0 THEN

		--- Let's calculate the type of day
		day_type := wd.type from fixture f, groups g, profile_configuration pc, profile_handler pr, weekday wd
		             where wd.profile_configuration_id = pc.id and
		                   pc.id = pr.profile_configuration_id and
		                   pr.id = g.profile_handler_id and
		                   f.group_id = g.id and
		                   wd.short_order = $2 and f.id = $1;

		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from fixture f, groups g, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and
		                             g.profile_handler_id = pr.id  and f.group_id = g.id and f.id = $1;

		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;

		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;


		IF day_type = 'weekday'
		   THEN
		    IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id := evening_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id :=  evening_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    END IF;
		END IF;

	ELSEIF $3 > 0 THEN
		--- Let's calculate the type of day
		day_type := wd.type from groups g, profile_configuration pc, profile_handler pr, weekday wd
		             where wd.profile_configuration_id = pc.id and
		                   pc.id = pr.profile_configuration_id and
		                   pr.id = g.profile_handler_id and
		                   wd.short_order = $2 and g.id = $3;

		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from groups g, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and
		                             g.profile_handler_id = pr.id  and g.id = $3;

		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;

		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;


		IF day_type = 'weekday'
		   THEN
		    IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id := evening_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id :=  evening_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		END IF;
	END IF;

    RETURN profile_id;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileByFixtureGroupId(fixture_id bigint, dayOfWeek integer, group_id bigint,  currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    day_type varchar;
    profile_id bigint := 0;
    quadrant_type varchar;
    sortedQuad int[] = '{}';
    sortedType varchar[] = '{}';
    w int := 0;
    x int := 0;
    y int := 0;
    z int := 0;
BEGIN	
	
	IF $1 > 0 THEN
	
		--- Let's calculate the type of day
		day_type := wd.type from fixture f, groups g, profile_configuration pc, profile_handler pr, weekday wd 
		             where wd.profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = g.profile_handler_id and
		                   f.group_id = g.id and
		                   wd.short_order = $2 and f.id = $1;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from fixture f, groups g, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             g.profile_handler_id = pr.id  and f.group_id = g.id and f.id = $1;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_id from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_weekend from  fixture f, groups g, profile_handler pr where g.profile_handler_id = pr.id and f.group_id = g.id and f.id = $1;
		    END IF;
		END IF;
		
	ELSEIF $3 > 0 THEN
		--- Let's calculate the type of day
		day_type := wd.type from groups g, profile_configuration pc, profile_handler pr, weekday wd 
		             where wd.profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = g.profile_handler_id and
		                   wd.short_order = $2 and g.id = $3;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from groups g, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             g.profile_handler_id = pr.id  and g.id = $3;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		END IF;
	END IF;
	      
    RETURN profile_id;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileByFixtureGroupId(fixture_id bigint, dayOfWeek integer, group_id bigint,  currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    day_type varchar;
    profile_id bigint := 0;
    quadrant_type varchar;
    sortedQuad int[] = '{}';
    sortedType varchar[] = '{}';
    w int := 0;
    x int := 0;
    y int := 0;
    z int := 0;
BEGIN	
	
	IF $1 > 0 THEN
	
		--- Let's calculate the type of day
		day_type := wd.type from fixture f, profile_configuration pc, profile_handler pr, weekday wd 
		             where wd.profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = f.profile_handler_id and
		                   wd.short_order = $2 and f.id = $1;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from fixture f, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             f.profile_handler_id = pr.id  and f.id = $1;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_id from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    ELSE
		        profile_id := night_profile_weekend from  fixture f, profile_handler pr where f.profile_handler_id = pr.id and f.id = $1;
		    END IF;
		END IF;
		
	ELSEIF $3 > 0 THEN
		--- Let's calculate the type of day
		day_type := wd.type from groups g, profile_configuration pc, profile_handler pr, weekday wd 
		             where wd.profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = g.profile_handler_id and
		                   wd.short_order = $2 and g.id = $3;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from groups g, profile_configuration pc, profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             g.profile_handler_id = pr.id  and g.id = $3;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_id from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_weekend from  groups g, profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		END IF;
	END IF;
	      
    RETURN profile_id;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileByPlugloadGroupId(plugload_id bigint, dayOfWeek integer, group_id bigint,  currentMinutes integer) RETURNS integer
    AS $$
DECLARE
    day_type varchar;
    profile_id bigint := 0;
    quadrant_type varchar;
    sortedQuad int[] = '{}';
    sortedType varchar[] = '{}';
    w int := 0;
    x int := 0;
    y int := 0;
    z int := 0;
BEGIN

	IF $1 > 0 THEN

		--- Let's calculate the type of day
		day_type := wd.type from plugload p, plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr, weekday_plugload wd
		             where wd.plugload_profile_configuration_id = pc.id and
		                   pc.id = pr.profile_configuration_id and
		                   pr.id = g.profile_handler_id and
		                   p.group_id = g.id and
		                   wd.short_order = $2 and p.id = $1;

		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from plugload p, plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr where pc.id = pr.profile_configuration_id and
		                             g.profile_handler_id = pr.id  and p.group_id = g.id and p.id = $1;

		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;

		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;


		IF day_type = 'weekday'
		   THEN
		    IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id := evening_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSE
		        profile_id := night_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id :=  evening_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSE
		        profile_id := night_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    END IF;
		END IF;

	ELSEIF $3 > 0 THEN
		--- Let's calculate the type of day
		day_type := wd.type from plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr, weekday_plugload wd
		             where wd.plugload_profile_configuration_id = pc.id and
		                   pc.id = pr.profile_configuration_id and
		                   pr.id = g.profile_handler_id and
		                   wd.short_order = $2 and g.id = $3;

		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr where pc.id = pr.profile_configuration_id and
		                             g.profile_handler_id = pr.id  and g.id = $3;

		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;

		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;


		IF day_type = 'weekday'
		   THEN
		    IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id := evening_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning'
		       THEN  profile_id := morning_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day'
		       THEN  profile_id := day_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening'
		       THEN  profile_id :=  evening_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		END IF;
	END IF;

    RETURN profile_id;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileByPlugloadGroupId(plugload_id bigint, dayOfWeek integer, group_id bigint,  currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    day_type varchar;
    profile_id bigint := 0;
    quadrant_type varchar;
    sortedQuad int[] = '{}';
    sortedType varchar[] = '{}';
    w int := 0;
    x int := 0;
    y int := 0;
    z int := 0;
BEGIN	
	
	IF $1 > 0 THEN
	
		--- Let's calculate the type of day
		day_type := wd.type from plugload p, plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr, weekday_plugload wd 
		             where wd.plugload_profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = g.profile_handler_id and
		                   p.group_id = g.id and
		                   wd.short_order = $2 and p.id = $1;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from plugload p, plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             g.profile_handler_id = pr.id  and p.group_id = g.id and p.id = $1;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSE
		        profile_id := night_profile_id from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    ELSE
		        profile_id := night_profile_weekend from  plugload p, plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and p.group_id = g.id and p.id = $1;
		    END IF;
		END IF;
		
	ELSEIF $3 > 0 THEN
		--- Let's calculate the type of day
		day_type := wd.type from plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr, weekday_plugload wd 
		             where wd.plugload_profile_configuration_id = pc.id and 
		                   pc.id = pr.profile_configuration_id and 	                   
		                   pr.id = g.profile_handler_id and
		                   wd.short_order = $2 and g.id = $3;
		 
		 select into w,x,y,z
		 				getDayQuadrantForGivenTime(morning_time), getDayQuadrantForGivenTime(day_time), getDayQuadrantForGivenTime(evening_time), getDayQuadrantForGivenTime(night_time)
		 		from plugload_groups g, plugload_profile_configuration pc, plugload_profile_handler pr where pc.id = pr.profile_configuration_id and 
		                             g.profile_handler_id = pr.id  and g.id = $3;
		                             
		 if w < x and w < y and w < z THEN
		 	sortedQuad[1] := w;
		 	sortedQuad[2] := x;
		 	sortedQuad[3] := y;
		 	sortedQuad[4] := z;
		 	sortedType[1] := 'morning';
		 	sortedType[2] := 'day';
		 	sortedType[3] := 'evening';
		 	sortedType[4] := 'night';
		 elseif x < w and x < y and x < z THEN
		 	sortedQuad[4] := w;
		 	sortedQuad[1] := x;
		 	sortedQuad[2] := y;
		 	sortedQuad[3] := z;
		 	sortedType[4] := 'morning';
		 	sortedType[1] := 'day';
		 	sortedType[2] := 'evening';
		 	sortedType[3] := 'night';
		 elseif y < w and y < x and y < z THEN
		 	sortedQuad[3] := w;
		 	sortedQuad[4] := x;
		 	sortedQuad[1] := y;
		 	sortedQuad[2] := z;
		 	sortedType[3] := 'morning';
		 	sortedType[4] := 'day';
		 	sortedType[1] := 'evening';
		 	sortedType[2] := 'night';
		 else
		 	sortedQuad[2] := w;
		 	sortedQuad[3] := x;
		 	sortedQuad[4] := y;
		 	sortedQuad[1] := z;
		 	sortedType[2] := 'morning';
		 	sortedType[3] := 'day';
		 	sortedType[4] := 'evening';
		 	sortedType[1] := 'night';
		end if;
		
		if currentMinutes < sortedQuad[1] then
			quadrant_type := sortedType[4];
		elseif currentMinutes < sortedQuad[2] then
			quadrant_type := sortedType[1];
		elseif currentMinutes < sortedQuad[3] then
			quadrant_type := sortedType[2];
		else
			quadrant_type := sortedType[3];
		end if;
	
		 
		IF day_type = 'weekday'
		   THEN 
		    IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id := evening_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_id from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		ELSE
		     IF quadrant_type = 'morning' 
		       THEN  profile_id := morning_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'day' 
		       THEN  profile_id := day_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSEIF quadrant_type = 'evening' 
		       THEN  profile_id :=  evening_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    ELSE
		        profile_id := night_profile_weekend from  plugload_groups g, plugload_profile_handler pr where g.profile_handler_id = pr.id and g.id = $3;
		    END IF;
		END IF;
	END IF;
	      
    RETURN profile_id;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileModeForPlugload(plugload_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN
	level := 0;
	--- Let's calculate the type of day

	profile_id := getProfileByPlugloadGroupId($1, $2, 0, $3);

	level := mode from plugload_profile where id = profile_id;
    RETURN level;
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileModeForPlugload(plugload_id bigint, dayOfWeek integer, currentMinutes integer) RETURNS integer
    AS $$
DECLARE 
    level integer;
    day_type varchar;
    profile_id bigint;
    quadrant_type varchar;
BEGIN	
	level := 0;
	--- Let's calculate the type of day
	
	profile_id := getProfileByPlugloadGroupId($1, $2, 0, $3);
	      
	level := mode from plugload_profile where id = profile_id;
    RETURN level;    
END;
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileNoForFixture(fixture_id bigint) RETURNS integer
    AS $$
DECLARE
    profile_no bigint := 0;
BEGIN
	profile_no := g.profile_no from groups g, fixture f where f.group_id = g.id and f.id = $1;
	return profile_no;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getProfileNoForFixture(fixture_id bigint) RETURNS integer
    AS $$
DECLARE 
    profile_no bigint := 0;
BEGIN
	profile_no := g.profile_no from groups g, fixture f where f.group_id = g.id and f.id = $1;
	return profile_no;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION getSelectedStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        selecteds text[];
    BEGIN
        FOR data IN
            SELECT P.selected_code
	        FROM personal_health_info P, examination b
	        WHERE P.person_code = b.person_code
	        AND b.examination_no = exam_no
	        ORDER BY P.person_code
        LOOP
            SELECT array_append(selecteds, data.selected_code::text) into selecteds;
        END LOOP;

        RETURN arrayToArrStr(selecteds);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getSelectedStr(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        selecteds text[];
    BEGIN
        FOR data IN
            SELECT P.selected_code
	        FROM personal_health_info P, examination b
	        WHERE P.person_code = b.person_code
	        AND b.examination_no = exam_no
        LOOP
            SELECT array_append(selecteds, data.selected_code::text) into selecteds;
        END LOOP;

        RETURN arrayToArrStr(selecteds);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getSingles(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        tmp text[];
    BEGIN
        FOR data IN
            SELECT DISTINCT C.checkup_name, T.image_url
            FROM examination_imageinformation T
            LEFT JOIN checkup C ON T.checkup_code = C.checkup_code
            WHERE T.examination_no = exam_no AND T.image_url IS NOT NULL
            AND T.checkup_code IN (SELECT regexp_split_to_table(key_value, ',') FROM con_global_config WHERE key_name = 'single_print_code')
        LOOP
          SELECT array_append(tmp, arrayToObjStr(ARRAY[data.checkup_name, data.image_url])) into tmp;
        END LOOP;
        RETURN arrayToArrStr(tmp);
    END;

$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION getSingles(exam_no varchar) RETURNS text AS $$
    DECLARE
        data record;
        tmp text[];
    BEGIN
        FOR data IN
        SELECT image_url
        FROM examination_imageinformation T
        WHERE T.examination_no = exam_no
        AND T.image_url IS NOT NULL
        AND T.checkup_code IN ( SELECT regexp_split_to_table(key_value, ',') FROM con_global_config WHERE key_name = 'single_print_code')
        ORDER BY  checkup_code,t.createtime
    LOOP
        SELECT array_append(tmp, arrayToObjStr(ARRAY[data.image_url])) into tmp;
        END LOOP;
        RETURN arrayToArrStr(tmp);
    END;
$$ LANGUAGE plpgsql;",db.go
"CREATE OR REPLACE FUNCTION get_allavailableuserinfo(bigint, bigint)
  RETURNS SETOF character varying AS
$BODY$
DECLARE
	v_user_id	BIGINT;
	v_user_priority	INT;
BEGIN
	SELECT US.user_id FROM coincomo_user_system_table AS US WHERE US.system_id = $2 INTO v_user_id;

	SELECT U.priority FROM coincomo_user_table AS U WHERE U.user_id = $1 INTO v_user_priority;
	
	IF v_user_priority=0 THEN
	
		RETURN QUERY 	SELECT	S.user_login_id
			FROM coincomo_user_table AS S
			WHERE S.user_login_id not in (
				SELECT G.user_login_id
				FROM coincomo_group_table AS G
				WHERE system_id = $2
			) and s.user_id <> $1 and s.priority <> 0 and s.user_id <> v_user_id
			ORDER BY S.user_id ASC;
	END IF;
			
	IF v_user_id <> $1 THEN
		RETURN;
	ELSE 
		RETURN QUERY 	SELECT	S.user_login_id
			FROM coincomo_user_table AS S
			WHERE S.user_login_id not in (
				SELECT G.user_login_id
				FROM coincomo_group_table AS G
				WHERE system_id = $2
			) and s.user_id <> $1 and s.priority <> 0 
			ORDER BY S.user_id ASC;
	END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION get_allsystems(IN bigint)
  RETURNS TABLE(system_id bigint, _system_name character varying, sloc bigint, cost numeric, staff numeric, effort numeric, schedule numeric) AS
$BODY$
DECLARE
	v_priority BIGINT;
BEGIN
	SELECT priority FROM coincomo_user_table WHERE user_id = $1 INTO v_priority;

	IF v_priority = 0 THEN
	
	RETURN QUERY 	SELECT	S.system_id,
				S._system_name,
				S.sloc,
				S.cost,
				S.staff,
				S.effort,
				S.schedule
			FROM coincomo_systems_table AS S
			ORDER BY S.system_id ASC;
			
	ELSE
	
	RETURN QUERY 	SELECT	S.system_id,
				S._system_name,
				S.sloc,
				S.cost,
				S.staff,
				S.effort,
				S.schedule
			FROM coincomo_systems_table AS S
			WHERE S.system_id in (

			select US.system_id
			FROM coincomo_user_system_table AS US
			WHERE  US.user_id = $1 

			UNION
			
			SELECT	G.system_id
			FROM coincomo_group_table AS G, coincomo_user_table as U
			WHERE  U.user_id = $1 and U.user_login_id = G.user_login_id
			)
			ORDER BY S.system_id ASC;

	END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION get_alluserinfo()
  RETURNS SETOF character varying AS
$BODY$
BEGIN
	RETURN QUERY 	SELECT	S.user_login_id
			FROM coincomo_user_table AS S
			ORDER BY S.user_id ASC;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION get_assigneduserinfo(bigint, bigint)
  RETURNS SETOF character varying AS
$BODY$
DECLARE
	v_user_id	BIGINT;
BEGIN
	SELECT US.user_id FROM coincomo_user_system_table AS US WHERE US.system_id = $2 INTO v_user_id;

	IF v_user_id <> $1 THEN
		RETURN;
	ELSE
		RETURN QUERY 	SELECT G.user_login_id
				FROM coincomo_group_table AS G
				WHERE system_id = $2
				ORDER BY G.user_id ASC;

	END IF;
	
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION get_hijos_unidad(id_unidad_param integer)
  RETURNS SETOF unidad AS
$BODY$
declare
    results record;
    entry   record;
    recs    record;
begin
    select into results * from unidad where id_unidad = $1;
    if found then
        for entry in select id_unidad from unidad where id_unidad_padre = $1 order by id_unidad desc loop
            for recs in select * from get_hijos_unidad(entry.id_unidad)   loop
                return next recs;
            end loop;
        end loop;
    end if;
    return next results;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",procedim_13-02-2017.sql
"CREATE OR REPLACE FUNCTION get_impuestos_compuesto (IN in_barcode_product bigint,
       	  	  	   			    OUT iva_out double precision,
						    OUT otros_out double precision,
						    OUT ganancia_out double precision,
       	  	  	   			    OUT iva_percent_out double precision,
						    OUT otros_percent_out double precision,
						    OUT ganancia_percent_out double precision)
RETURNS setof record AS $$
DECLARE
	l record;
	query varchar;

	compuesta_l int4;

	-- Datos para la mercadería madre
	costo_madre double precision;
	precio_madre double precision;

	precio_gm double precision;
	costo_gm double precision;

	-- Datos para mercadería
	-- Precio proporcional
	precio_prop double precision;
BEGIN
	-- Id tipo de mercadería (materia prima)
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';

	-- Se inicializan algunas variables
	SELECT costo INTO costo_gm FROM obtener_costo_promedio_desde_barcode (in_barcode_product);
	SELECT precio INTO precio_gm FROM producto WHERE barcode = in_barcode_product;
	precio_madre := precio_gm;
	costo_madre := costo_gm;
	iva_out := 0;
	otros_out := 0;
	ganancia_out := 0;

	-- Consulta recursiva, obtiene todos los componentes y sub componentes de la mercadería compuesta o derivada
	query :=$S$ WITH RECURSIVE compuesta (barcode_complejo, tipo_complejo, barcode_componente, tipo_componente, cant_mud) AS
      	      	    (
		      SELECT barcode_complejo, tipo_complejo, barcode_componente, tipo_componente, cant_mud
       		      FROM componente_mc WHERE barcode_complejo = $S$ || in_barcode_product || $S$
        	      UNION ALL
        	      SELECT componente_mc.barcode_complejo, componente_mc.tipo_complejo,
		      	     componente_mc.barcode_componente, componente_mc.tipo_componente,
           	      	     componente_mc.cant_mud * compuesta.cant_mud
              	      FROM componente_mc, compuesta
       		      WHERE componente_mc.barcode_complejo = compuesta.barcode_componente
      		    )
      		    SELECT c.barcode_complejo, c.tipo_complejo, c.barcode_componente, c.tipo_componente, c.cant_mud,
		    	   (SELECT precio FROM producto WHERE barcode = c.barcode_componente) AS precio_componente,
			   (SELECT costo FROM obtener_costo_promedio_desde_barcode (c.barcode_componente)) AS costo_componente,
			   (SELECT valor FROM get_iva (c.barcode_componente))/100 AS iva,
			   (SELECT valor FROM get_otro_impuesto (c.barcode_componente))/100 AS otros
      		    FROM compuesta c $S$;

	FOR l IN EXECUTE query LOOP	-- NOTA: cuidado con las materias primas vendibles como madre
	    -- PRECIO PROPORCIONAL (proporcion del COSTO componente con respecto a madre) * PRECIO madre
	    precio_prop := (l.costo_componente/costo_madre) * precio_madre;

	    -- Si el componente actual es compuesto (sera la proxima madre)
	    IF (l.tipo_componente = compuesta_l OR l.tipo_componente = derivada_l) THEN
	       precio_madre := precio_prop;
	       SELECT costo INTO costo_madre FROM obtener_costo_promedio_desde_barcode (l.barcode_componente);
	    ELSE
	       -- GANANCIA ((PRECIO NETO -> precio de venta sin impuestos) - costo del producto) * cantidad_requerida
	       ganancia_out := ganancia_out + ((precio_prop / (l.iva + l.otros + 1)) - l.costo_componente) * l.cant_mud;
	       -- IVA ((PRECIO NETO -> precio de venta sin impuestos) * iva)  * cantidad_requerida
	       iva_out := iva_out + ((precio_prop / (l.iva + l.otros + 1)) * l.iva) * l.cant_mud;
	       -- OTROS ((PRECIO NETO -> precio de venta sin impuestos) * otros) * cantidad_requerida
	       otros_out := otros_out + ((precio_prop / (l.iva + l.otros + 1)) * l.otros) * l.cant_mud;
	    END IF;
	END LOOP;

	--                 ((iva madre) / (Precio neto madre)) * 100 = %IVA
	iva_percent_out := (iva_out / (precio_gm - (iva_out+otros_out))) * 100;
	--                 ((otros madre) / (Precio neto madre)) * 100 = %OTROS
	otros_percent_out := (otros_out / (precio_gm - (iva_out+otros_out))) * 100;
	--                 (ganancia_madre / costo_madre) * 100 = % ganancia
	ganancia_percent_out := (ganancia_out / costo_gm) * 100;

	-- retorna el total acumulado
	RETURN NEXT;
RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION get_iva (IN barcode_in bigint,
		  	   	    OUT valor double precision)
RETURNS double precision AS $$
BEGIN
		SELECT impuesto.monto INTO valor
		FROM producto, impuesto
		WHERE producto.barcode=barcode_in
		AND producto.impuestos='true'
		AND impuesto.id=1;

                IF valor IS NULL THEN
                   valor := 0;
                END if;

END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION get_otro_impuesto (IN barcode_in bigint,
		  	   		      OUT valor double precision)
RETURNS double precision AS $$
BEGIN
		SELECT impuesto.monto INTO valor
		FROM producto, impuesto
		WHERE producto.barcode = barcode_in
		AND impuesto.id = producto.otros;

		IF valor IS NULL THEN
                   valor := 0;
                END if;

END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION get_report_event_type_ids2(report_name varchar(100)) RETURNS integer[] AS
$BODY$
DECLARE
b integer[];
BEGIN
b = ARRAY[1,2,56,3141];
RETURN b;
END;
$BODY$ LANGUAGE 'plpgsql' VOLATILE;",postgres.md
"CREATE OR REPLACE FUNCTION get_sale_detail (IN sale_id int,
       	  	  	   		    IN solo_componentes boolean,
          	  	   		    OUT barcode bigint,
					    OUT tipo int,
        				    OUT price double precision,
        				    OUT amount double precision)
RETURNS SETOF record AS $$
DECLARE
	-----------------
        l1 record;
	l2 record;
        q1 varchar (255);
	q2 varchar;
	-----------------
	corriente_l int4;     -- id tipo corriente
	compuesta_l int4;     -- id compuesta
	materia_prima_l int4; -- id tipo materia prima
	derivada_l int4;      -- id tipo derivada
BEGIN
	SELECT id INTO corriente_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'CORRIENTE';
	SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';
	SELECT id INTO derivada_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'DERIVADA';
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';

	q1 := $S$SELECT barcode, precio, cantidad, tipo FROM venta_detalle WHERE id_venta=$S$||sale_id;

      	FOR l1 IN EXECUTE q1 LOOP
            barcode := l1.barcode;
	    tipo := l1.tipo;
            price := l1.precio;
            amount := l1.cantidad;

	    -- Si es una mercadería compuesta, se retornan sus componentes (si solo_componentes = TRUE)
	    IF ((l1.tipo = compuesta_l OR l1.tipo = derivada_l) AND solo_componentes = TRUE) THEN
	       q2 := $S$
	       WITH RECURSIVE compuesta (id_venta, barcode_complejo, id_mh, tipo_complejo,
	     	  	    	     	 barcode_componente, tipo_componente, cantidad, precio) AS
      	       (
	         SELECT id_venta_vd, barcode_complejo, id_mh, tipo_complejo,
		      	barcode_componente, tipo_componente, cantidad, precio_proporcional
       	       	 FROM venta_mc_detalle
	       	 WHERE barcode_complejo = $S$||l1.barcode||$S$
		       AND venta_mc_detalle.id_venta_vd = $S$||sale_id||$S$
                 UNION ALL
               	 SELECT vmcd.id_venta_vd, vmcd.barcode_complejo, vmcd.id_mh, vmcd.tipo_complejo,
	      	      	vmcd.barcode_componente, vmcd.tipo_componente, vmcd.cantidad, precio_proporcional
                 FROM venta_mc_detalle vmcd, compuesta
       	       	 WHERE vmcd.barcode_complejo = compuesta.barcode_componente AND
		       vmcd.id_venta_vd = compuesta.id_venta AND
		       vmcd.id_mh[1] = compuesta.id_mh[2]
	      )
	      SELECT barcode_componente AS barcode, tipo_componente AS tipo, cantidad, precio
	      FROM compuesta
	      WHERE tipo_componente = $S$||corriente_l||$S$
	      OR tipo_componente = $S$||materia_prima_l;

	      FOR l2 IN EXECUTE q2 LOOP
	      	  barcode := l2.barcode;
	    	  tipo := l2.tipo;
            	  price := l2.precio;
            	  amount := l2.cantidad;
	      	  RETURN NEXT;
	      END LOOP;
	    ELSE -- Si es una mercadería corriente o materia prima (o cualquiera, en caso que solo_componentes = FALSE)
	      RETURN NEXT;
	    END IF;
	END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION get_stock_lsegs() RETURNS void AS $$
BEGIN
END;
$$ LANGUAGE plpgsql;",fb.sql
"CREATE OR REPLACE FUNCTION get_user_record(in_user TEXT) RETURNS setof
users as $BODY$
DECLARE
temprec users;
BEGIN
for temprec in SELECT * FROM users WHERE username = in_user LOOP
RETURN next temprec;
END loop;
RETURN;
END;
$BODY$ language plpgsql SECURITY DEFINER;",index6c6f.php
"CREATE OR REPLACE FUNCTION gpGetDirectoryEdiName(
       OUT Directory             TVarChar, 
       OUT isEDISaveLocal        Boolean, 
        IN inSession             TVarChar       -- ������� ������������
      )
RETURNS RECORD
AS
$BODY$
DECLARE
   DECLARE vbUserId Integer;
BEGIN
   -- vbUserId:= lpCheckRight(inSession, zc_Enum_Process_...());
   vbUserId:= lpGetUserBySession (inSession);

   Directory := '\\192.168.0.234\local-error\';
   isEDISaveLocal := zc_isEDISaveLocal();
      
END;
$BODY$
  LANGUAGE plpgsql VOLATILE;",gpGetDirectoryEdiName.sql
"CREATE OR REPLACE FUNCTION gps_preferences() RETURNS VOID AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'gps_preferences') THEN

        execute 
		'Create table gps_preferences (
                    id integer DEFAULT nextval(''gps_preferences_id_seq''::regclass)NOT NULL,
                    id_thesaurus character varying NOT NULL,
                    id_user integer NOT NULL,
                    gps_integrertraduction boolean DEFAULT true,
                    gps_reemplacertraduction boolean DEFAULT true,
                    gps_alignementautomatique boolean DEFAULT true,
                    id_alignement_source integer,
                    CONSTRAINT gps_preferences_pkey PRIMARY KEY (id_thesaurus, id_user, id_alignement_source)
                     );';
    END IF;
END;
$$ LANGUAGE plpgsql;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION hex_to_int(hexval varchar) RETURNS integer AS $$
DECLARE
   result  int;
BEGIN
 EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;  RETURN result;
END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION hex_to_int(hexval varchar) RETURNS integer AS $$
DECLARE
   result  int;
BEGIN
 EXECUTE 'SELECT x''' || hexval || '''::int' INTO result;  RETURN result;
END;
$$ 
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION info_abonos (IN in_rut_cliente int4,
					OUT out_fecha timestamp,
					OUT out_id_venta integer,
					OUT out_monto_deuda integer,
					OUT out_abono integer,
					OUT out_deuda_total integer)
RETURNS SETOF RECORD AS $$
DECLARE
   l1 record;
   q1 varchar;
   l2 record;
   q2 varchar;
   deuda_total integer;
   fecha_abono_anterior timestamp;

BEGIN

   deuda_total := 0;
   out_deuda_total := 0;

   q1 := $S$ SELECT o_id AS id, o_rut_cliente AS rut_cliente,
      	     	    o_monto_abonado AS monto_abonado, o_fecha_abono AS fecha_abono
    	     FROM select_abonos ( $S$ || in_rut_cliente || $S$ )
	     ORDER BY o_fecha_abono ASC $S$;

   FOR l1 IN EXECUTE q1 LOOP

       q2 := $S$ SELECT id, monto, fecha
     	     	 FROM search_deudas_cliente ($S$ ||in_rut_cliente|| $S$, false) $S$;

       IF fecha_abono_anterior IS NULL THEN
	  q2 := q2 || $S$ WHERE fecha < $S$ || quote_literal (l1.fecha_abono);
	  fecha_abono_anterior := l1.fecha_abono;
       ELSE
          q2 := q2 || $S$ WHERE fecha > $S$ || quote_literal (fecha_abono_anterior) || $S$
	     	      	  AND fecha < $S$ || quote_literal (l1.fecha_abono);
	  fecha_abono_anterior := l1.fecha_abono;
       END IF;

       q2 := q2 || $S$ ORDER BY fecha ASC $S$;

       deuda_total := out_deuda_total;
       FOR l2 IN EXECUTE q2 LOOP
       	   deuda_total := deuda_total + l2.monto;
      	   out_fecha := l2.fecha;
	   out_id_venta := l2.id;
	   out_monto_deuda := l2.monto;
	   out_abono := 0;
	   out_deuda_total := deuda_total;
           RETURN NEXT;
       END LOOP;

       out_fecha := l1.fecha_abono;
       out_id_venta := 0;
       out_monto_deuda := deuda_total;
       out_abono := l1.monto_abonado;
       out_deuda_total := deuda_total - l1.monto_abonado;

       RETURN NEXT;
   END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION informacion_producto( IN codigo_barras bigint,
		IN in_codigo_corto varchar(16),
		OUT codigo_corto varchar(16),
                OUT barcode bigint,
		OUT descripcion varchar(50),
		OUT marca varchar(35),
		OUT contenido varchar(10),
		OUT unidad varchar(10),
		OUT stock double precision,
		OUT precio double precision,
		OUT precio_neto double precision,
		OUT costo_promedio double precision,
		OUT stock_min double precision,
		OUT dias_stock double precision,
		OUT margen_promedio double precision,
		OUT contrib_agregada double precision,
		OUT ventas_dia double precision,
		OUT vendidos double precision,
		OUT venta_neta double precision,
		OUT canje boolean,
		OUT stock_pro double precision,
		OUT tasa_canje double precision,
		OUT precio_mayor double precision,
		OUT cantidad_mayor double precision,
		OUT mayorista boolean,
		OUT unidades_merma double precision,
		OUT stock_day double precision,
                OUT total_vendido double precision,
		OUT estado boolean,
		OUT tipo int4)
RETURNS SETOF record AS $$
declare
	days double precision;
	datos record;
	query varchar;
	codbar int8;
	corriente int4;
	materia_prima int4;
BEGIN

query := $S$ SELECT *,
      	     	    (SELECT SUM ((cantidad * precio) - (iva + otros + (fifo * cantidad))) FROM venta_detalle WHERE barcode=producto.barcode) as contrib_agregada,
		    (stock::float / select_ventas_dia(producto.barcode, TRUE)::float) AS stock_day,
		    COALESCE ((dias_stock * select_ventas_dia(producto.barcode, TRUE)::float), 0) AS stock_min,
		    (SELECT SUM ((cantidad * precio) - (iva + otros)) FROM venta_detalle WHERE barcode=producto.barcode) AS total_vendido,
		    select_merma (producto.barcode) AS unidades_merma, dias_stock,
		    select_ventas_dia(producto.barcode, FALSE) AS ventas_dia
		FROM producto WHERE $S$;

-- check if must use the barcode or the short code
IF codigo_barras != 0 THEN
   query := query || $S$ barcode=$S$ || codigo_barras;
ELSE
   query := query || $S$ codigo_corto=$S$ || quote_literal(in_codigo_corto);
END IF;

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

FOR datos IN EXECUTE query LOOP
    codigo_corto := datos.codigo_corto;
    barcode := datos.barcode;
    descripcion := datos.descripcion;
    marca := datos.marca;
    contenido := datos.contenido;
    unidad := datos.unidad;

    IF datos.tipo = corriente OR datos.tipo = materia_prima THEN
       stock := datos.stock;
    ELSE
       stock := (SELECT disponible FROM obtener_stock_desde_barcode (datos.barcode));
    END IF;

    precio := datos.precio;
    precio_neto := datos.precio;

    -- Costo_promedio de los compuestos debería estar en el producto mismo?
    IF datos.tipo != corriente AND datos.tipo != materia_prima THEN
        costo_promedio := (SELECT costo FROM obtener_costo_promedio_desde_barcode (datos.barcode));
    ELSE
	costo_promedio := datos.costo_promedio;
    END IF;

    stock_min := datos.stock_min;
    dias_stock := datos.dias_stock;
    stock_day := datos.stock_day;
    margen_promedio := datos.margen_promedio;
    contrib_agregada := round(datos.contrib_agregada);
    unidades_merma := datos.unidades_merma;
    mayorista := datos.mayorista;
    total_vendido := datos.total_vendido;
    precio_mayor := datos.precio_mayor;
    cantidad_mayor := datos.cantidad_mayor;
    ventas_dia := datos.ventas_dia;
    estado := datos.estado;
    tipo := datos.tipo;
    RETURN NEXT;
END LOOP;

RETURN;
END;
$$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION informacion_producto_venta(IN in_codigo varchar(16),
						      OUT codigo_corto varchar(16),
                				      OUT barcode bigint,
						      OUT descripcion varchar(50),
						      OUT marca varchar(35),
						      OUT contenido varchar(10),
						      OUT unidad varchar(10),
						      OUT stock double precision,
						      OUT precio double precision,
						      OUT precio_mayor double precision,
						      OUT cantidad_mayor double precision,
						      OUT mayorista boolean,
						      OUT stock_day double precision,
						      OUT estado boolean,
						      OUT tipo integer)
RETURNS SETOF record AS $$
declare
	days double precision;
	datos record;
	query varchar;
	codigo varchar;
	corriente int4;
	materia_prima int4;
	codigo_only_numeric boolean;
BEGIN

SELECT TRIM (in_codigo) INTO codigo;

-- Comprueba si es un valor numerico
SELECT CASE
	WHEN LENGTH(SUBSTRING(codigo FROM '[0-9]+')) != LENGTH(codigo) THEN FALSE
	ELSE TRUE
       END INTO codigo_only_numeric;

-- Id tipos de producto
corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

query := $S$ SELECT *,
		    (stock::float / select_ventas_dia(producto.barcode, TRUE)::float) AS stock_day
		FROM producto WHERE $S$;

-- check if must use the barcode or the short code
IF codigo_only_numeric = TRUE THEN
   query := query||$S$ barcode=$S$||codigo||$S$ OR codigo_corto LIKE $S$||quote_literal(codigo);
ELSE
   query := query||$S$ codigo_corto=$S$||quote_literal(codigo);
END IF;

FOR datos IN EXECUTE query LOOP
    codigo_corto := datos.codigo_corto;
    barcode := datos.barcode;
    descripcion := datos.descripcion;
    marca := datos.marca;
    contenido := datos.contenido;
    unidad := datos.unidad;
        -- Su la mercadería es derivada, calcula su stock de acuerdo a sus componentes
    IF datos.tipo != corriente AND datos.tipo != materia_prima THEN
	stock := (SELECT * FROM obtener_stock_desde_barcode (datos.barcode));
    ELSE
	stock := datos.stock;
    END IF;

    precio := datos.precio;
    stock_day := datos.stock_day;
    mayorista := datos.mayorista;
    precio_mayor := datos.precio_mayor;
    cantidad_mayor := datos.cantidad_mayor;
    estado := datos.estado;
    tipo := datos.tipo;
    RETURN NEXT;
END LOOP;

RETURN;
END;
$$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION is_caja_abierta ()
RETURNS boolean AS $$
DECLARE
	current_caja int;
	fecha_ter timestamp;
BEGIN

	SELECT MAX(id) INTO current_caja FROM caja;

	IF current_caja IS NULL then
	   return FALSE;
	END IF;

	SELECT fecha_termino INTO fecha_ter FROM caja WHERE id=current_caja;

	IF (fecha_ter IS NULL) THEN
	   return TRUE;
	ELSE
	   return FALSE;
	END IF;

END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION is_valid_date(char, char) RETURNS boolean AS $$
DECLARE
     result BOOL;
BEGIN
     SELECT TO_CHAR(TO_DATE($1,$2),$2) = $1
     INTO result;
     RETURN result;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION json_agg_build_vd(VARIADIC valor character varying[])
  RETURNS character varying AS
$BODY$
DECLARE
	d_parameters record;
	d_length integer;
	jsons json;
	error_MESSAGE_TEXT varchar;
	validated json;
	query text default 'Select ';
	d_return json;
	d_clave varchar;
	d_type varchar;
BEGIN
	/*
	Hecho por: Vlade Párica - Dey
	Fecha: 08-06-2018
	Resumen:

	Para probarlo:
					select json_agg_build_vd('15','{""hola"":""hola""}','HOLA','hola','prueba','1','boolean','true','array','[]','nulos','null')
	*/

	d_length = array_length(valor,1);



	if d_length % 2 = 0 then -- solo si es par es porque estan completos sus (clave : valor)

		for d_parameters in 1 .. d_length
		loop

			if not d_parameters % 2 = 0 then

				-- validando que no esten erroneas las claves
				select
					'{}' into validated
				where
					valor[d_parameters] like '%[%' or
					valor[d_parameters] like '%]%' or
					valor[d_parameters] like '%{%' or
					valor[d_parameters] like '%}%' or
					valor[d_parameters] like '%:%';


				if validated::varchar = '{}' then

					 return replace(json_build_object('ERROR','la sintaxis de entrada no es válida para la clave: '||valor[d_parameters]||' ')::varchar,(CHR(92)||'""'),'""');
				end if;

			end if;

			--raise notice 'd_parameters %', valor[d_parameters];

			IF (d_parameters % 2 = 0) THEN
				d_type = typeof_vd(valor[d_parameters]::text);

				IF ( d_type = 'text' or d_type = 'json' or d_type = 'date') THEN

					query :=  query || '''' || trim(valor[d_parameters],'""') || '''' || '::' || d_type || ' AS '|| '""' || d_clave || '"", ';

				ELSEIF (d_type = 'null') THEN

					query :=  query || valor[d_parameters]|| '::' || d_type || ' AS '|| '""' || d_clave || '"", ';

				ELSE
					query :=  query || valor[d_parameters]|| ' AS '|| '""' || d_clave || '"", ';
				END IF;
			ELSE
				--raise notice '1';
				d_clave :=  valor[d_parameters];
			END IF;

		end loop;
			--raise notice 'query %', query;

		query := rtrim(query::text,', ');

		execute 'SELECT json_agg(a.*) FROM ( '
			|| query ||
		') a' into d_return;
	else

		return json_build_object('ERROR','la sintaxis de entrada no es válida cantidad de parametros incongruentes');

	end if;

	RETURN d_return;

	EXCEPTION
	WHEN others THEN
	GET STACKED DIAGNOSTICS
	error_MESSAGE_TEXT = MESSAGE_TEXT;

	jsons = json_build_object('ERROR',error_MESSAGE_TEXT);

	return jsons;

END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",json_agg_build_vd.sql
"CREATE OR REPLACE FUNCTION json_push_vd(
    i_json json,
    i_clave character varying,
    i_value character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	d_new_json json;
	string text default '';
	d_record record;
	d_constructor text;
	d_aux text;
BEGIN
	/*
	Hecho por: Dey
	Fecha: 09-05-2018
	Resumen: Agrega un valor a un objeto

	Para probarlo:

		-- Object
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','ta');
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','2018-05-11');
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','2');
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','true');
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','{""hola"":""hola"",""otrcosa"":0,""otracosa2"":true}');
			select json_push_vd('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','Prueba','[{""hola"":""hola"",""otrcosa"":0,""otracosa2"":true}]');

		-- Array
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','true');
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','2018-05-11');
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','2');
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','true');
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','{""hola"":""hola"",""otrcosa"":0,""otracosa2"":true}');
			select json_push_vd('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','Prueba','[{""hola"":""hola"",""otrcosa"":0,""otracosa2"":true}]');
	*/

	IF (json_typeof(i_json) = 'object') THEN
		BEGIN
			IF (i_value::boolean) THEN
				-- raise notice 'Soy un boolean';

				FOR d_record IN SELECT * FROM json_each(i_json) LOOP
					string = string || replace(d_record.value::varchar, '""' ,'''') || ' as ""' || d_record.key || '"" , ';
				END LOOP;

				string = translate(RTRIM(string, ', '),'""','');
				string = string || ',' || i_value::boolean  || ' as ' || i_clave;

				execute 'select to_json(a.*) from ( select ' || string || ')a' into d_new_json;
				RETURN d_new_json;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::int) IS NOT NULL THEN
				-- raise notice 'Soy un integer';
				FOR d_record IN SELECT * FROM json_each(i_json) LOOP
					string = string || replace(d_record.value::varchar, '""' ,'''') || ' as ""' || d_record.key || '"" , ';
				END LOOP;

				string = translate(RTRIM(string, ', '),'""','');
				string = string || ',' || i_value::integer  || ' as ' || i_clave;

				execute 'select to_json(a.*) from ( select ' || string || ')a' into d_new_json;

				RETURN d_new_json;
			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::date) IS NOT NULL THEN
				-- raise notice 'Soy un date';
				FOR d_record IN SELECT * FROM json_each(i_json) LOOP
					string = string || replace(d_record.value::varchar, '""' ,'''') || ' as ""' || d_record.key || '"" , ';
				END LOOP;

				string = translate(RTRIM(string, ', '),'""','');
				string = string || ',''' || i_value::Date  || ''' as ' || i_clave;

				execute 'select to_json(a.*) from ( select ' || string || ')a' into d_new_json;
				RETURN d_new_json;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (json_typeof(i_value::json) = 'object' or json_typeof(i_value::json) = 'array') THEN
				-- raise notice 'Soy un %',json_typeof(i_value::json);

				FOR d_record IN SELECT * FROM json_each(i_json) LOOP
					IF (d_record.value::varchar like '[%' or d_record.value::varchar like '%]') THEN
						string = string || replace(replace(d_record.value::varchar,'[','''['),']',']''') || ' as ""' || d_record.key || '"" , ';
					ELSE
						string = string || replace(d_record.value::varchar, '""' ,'''') || ' as ""' || d_record.key || '"" , ';
						string = translate(string,'""','');
					END IF;
				END LOOP;

				string = RTRIM(string, ', ');
				string = string || ',''' || i_value::json  || '''::json as ' || i_clave;
				execute 'select to_json(a.*) from ( select ' || string || ')a' into d_new_json;
				-- RETURN d_new_json;
				RETURN replace(replace(translate(d_new_json::text,chr(92),''),'""[','['),']""',']');

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::varchar) IS NOT NULL THEN
				-- raise notice 'Soy un varchar';

				FOR d_record IN SELECT * FROM json_each(i_json) LOOP
					string = string || replace(d_record.value::varchar, '""' ,'''') || ' as ""' || d_record.key || '"" , ';
				END LOOP;

				string = translate(RTRIM(string, ', '),'""','');
				string = string || ',''' || i_value::text  || ''' as ' || i_clave;

				execute 'select to_json(a.*) from ( select ' || string || ')a' into d_new_json;
				RETURN d_new_json;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

	ELSIF (json_typeof(i_json) = 'array') THEN

		BEGIN
			IF (i_value::boolean) THEN
				-- raise notice 'Soy un boolean';

				execute 'select to_json(a.*) from ( select ' || i_value::boolean || ' as ' || i_clave || ')a' into d_new_json;

				d_aux := i_json::text;
				d_aux := substring(d_aux from 0 for length(d_aux));
				d_aux := d_aux || ',' || d_new_json || ']';

				RETURN d_aux;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::int) IS NOT NULL THEN
				-- raise notice 'Soy un integer';

				execute 'select to_json(a.*) from ( select ' || i_value::int || ' as ' || i_clave || ')a' into d_new_json;

				d_aux := i_json::text;
				d_aux := substring(d_aux from 0 for length(d_aux));
				d_aux := d_aux || ',' || d_new_json || ']';

				RETURN d_aux;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::date) IS NOT NULL THEN
				-- raise notice 'Soy un date';

				execute 'select to_json(a.*) from ( select ''' || i_value::date || ''' as ' || i_clave || ')a' into d_new_json;

				d_aux := i_json::text;
				d_aux := substring(d_aux from 0 for length(d_aux));
				d_aux := d_aux || ',' || d_new_json || ']';

				RETURN d_aux;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (json_typeof(i_value::json) = 'object' or json_typeof(i_value::json) = 'array') THEN

				execute 'select to_json(a.*) from ( select ''' || i_value::json || '''::json as ' || i_clave || ')a' into d_new_json;

				d_aux := i_json::text;
				d_aux := substring(d_aux from 0 for length(d_aux));
				d_aux := d_aux || ',' || d_new_json || ']';

				RETURN d_aux::json;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

		BEGIN
			IF (i_value::varchar) IS NOT NULL THEN
				-- raise notice 'Soy un varchar';

				execute 'select to_json(a.*) from ( select ''' || i_value::text || ''' as ' || i_clave || ')a' into d_new_json;

				d_aux := i_json::text;
				d_aux := substring(d_aux from 0 for length(d_aux));
				d_aux := d_aux || ',' || d_new_json || ']';

				RETURN d_aux;

			END IF;
			EXCEPTION WHEN others THEN NULL;
		END;

	END IF;

	RETURN 'Ingrese un tipo de dato valido';
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",json_push_vd.sql
"CREATE OR REPLACE FUNCTION lague_coeff(NUMERIC)
  RETURNS SETOF NUMERIC AS
$BODY$
DECLARE
  i NUMERIC;
BEGIN
  FOR i IN 1..$1 LOOP
  RETURN NEXT i - .5;
END loop;
RETURN;
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE STRICT
COST 100
ROWS 1000;",election_algorithm.sql
"CREATE OR REPLACE FUNCTION lerp(x0 INT, x INT, x1 INT, y0 INT, y1 INT) RETURNS INT AS $$
BEGIN
    RETURN y0 + (y1 - y0) * (x - x0) / (x1 - x0);
END;
$$ LANGUAGE plpgsql;",fb.sql
"CREATE OR REPLACE FUNCTION localgisDatamodelInstall() RETURNS VOID AS
$Q$
BEGIN
	
ALTER TABLE civil_work_document_thumbnail DROP CONSTRAINT civil_work_document_thumbnail_fk;
	exception when others then
		RAISE NOTICE 'No se puede borrar la constraint civil_work_document_thumbnail_fk.';
END;
$Q$
LANGUAGE plpgsql;",2.%202_1%20a%20MODELO.sql
"CREATE OR REPLACE FUNCTION localgisDatamodelInstall() RETURNS VOID AS
$Q$
BEGIN
	
CREATE ROLE consultas LOGIN NOSUPERUSER INHERIT NOCREATEDB NOCREATEROLE;
	exception when others then
		RAISE NOTICE 'No se puede crear el role de consultas';
END;
$Q$
LANGUAGE plpgsql;",2.%202_1%20a%20MODELO.sql
"CREATE OR REPLACE FUNCTION localgisDatamodelInstall() RETURNS VOID AS
$Q$
BEGIN
	IF EXISTS (SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'civil_work_id_document_sequence') THEN
		ALTER TABLE civil_work_id_document_sequence RENAME TO seq_civil_work_documents;
		ALTER TABLE civil_work_id_warning_sequence RENAME TO seq_civil_work_warnings;
	END IF;
	
END;
$Q$
LANGUAGE plpgsql;",2.%202_1%20a%20MODELO.sql
"CREATE OR REPLACE FUNCTION localgisDatamodelInstall() RETURNS VOID AS
$Q$
DECLARE
	result   NUMERIC DEFAULT 0;
BEGIN
	IF EXISTS (SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'session_app') THEN	
		ALTER TABLE ""public"".""session_app"" ALTER COLUMN ""id"" TYPE varchar(40);
	END IF;
	IF EXISTS (SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'iusercnt') THEN	
		ALTER TABLE ""public"".""iusercnt"" ALTER COLUMN ""id"" TYPE varchar(40);
	END IF;
END;
$Q$
LANGUAGE plpgsql;",2.%202_1%20a%20MODELO.sql
"CREATE OR REPLACE FUNCTION localgisDatamodelInstall() RETURNS VOID AS
$Q$
DECLARE
	result   NUMERIC DEFAULT 0;
BEGIN

	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'credito_derecho_fkey' ) THEN	
		ALTER TABLE credito_derecho DROP CONSTRAINT credito_derecho_fkey;
	END IF;	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'derechosreales_fk') THEN	
		ALTER TABLE derechos_reales DROP CONSTRAINT  derechosreales_fk;
	END IF;	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'inmuebles_fkey') THEN	
		ALTER TABLE inmuebles DROP CONSTRAINT inmuebles_fkey;
	END IF;	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'mejoras_inventario_fkey') THEN	
		ALTER TABLE mejoras_inventario DROP CONSTRAINT mejoras_inventario_fkey;
	END IF;	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'muebles_fkey') THEN	
		ALTER TABLE muebles DROP CONSTRAINT muebles_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'observaciones_inventario_fkey') THEN	
		ALTER TABLE observaciones_inventario DROP CONSTRAINT observaciones_inventario_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'refcatastrales_inventario_fkey') THEN	
		ALTER TABLE refcatastrales_inventario DROP CONSTRAINT refcatastrales_inventario_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'refcatastrales_inventario_fkey') THEN	
		ALTER TABLE refcatastrales_inventario DROP CONSTRAINT refcatastrales_inventario_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'semoviente_fkey') THEN	
		ALTER TABLE semoviente DROP CONSTRAINT semoviente_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'usos_funcionales_inventario_fkey') THEN	
		ALTER TABLE usos_funcionales_inventario DROP CONSTRAINT usos_funcionales_inventario_fkey;
	END IF;	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'valor_mobiliario_fkey') THEN	
		ALTER TABLE valor_mobiliario DROP CONSTRAINT valor_mobiliario_fkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'vehiculo_fkey') THEN	
		ALTER TABLE vehiculo DROP CONSTRAINT vehiculo_fkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'vias_inventario_fkey') THEN	
		ALTER TABLE vias_inventario DROP CONSTRAINT vias_inventario_fkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'bien_revertible_bien_fkey') THEN	
		ALTER TABLE bien_revertible_bien DROP CONSTRAINT bien_revertible_bien_fkey;
	END IF;
	
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'lote_bien_fkey2') THEN	
		ALTER TABLE lote_bien DROP CONSTRAINT lote_bien_fkey2;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'inmuebles_rusticos_pkey') THEN	
		ALTER TABLE inmuebles_rusticos DROP CONSTRAINT inmuebles_rusticos_pkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'refcatastrales_inventario_pkey') THEN	
		ALTER TABLE refcatastrales_inventario DROP CONSTRAINT refcatastrales_inventario_pkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'usos_funcionales_inventario_pkey') THEN	
		ALTER TABLE usos_funcionales_inventario DROP CONSTRAINT usos_funcionales_inventario_pkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'inmuebles_urbanos_pkey') THEN	
		ALTER TABLE inmuebles_urbanos DROP CONSTRAINT inmuebles_urbanos_pkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'obs_pkey') THEN	
		ALTER TABLE observaciones_bien_revertible drop constraint obs_pkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'obs_inventario_fkey') THEN	
		ALTER TABLE observaciones_bien_revertible drop constraint  obs_inventario_fkey;
	END IF;
	
	IF EXISTS (SELECT conname FROM pg_constraint WHERE conname = 'bien_revertible_pkey') THEN	
		ALTER TABLE bien_revertible DROP CONSTRAINT bien_revertible_pkey;
	END IF;
	
END;
$Q$
LANGUAGE plpgsql;",2.%202_1%20a%20MODELO.sql
"CREATE OR REPLACE FUNCTION lsmb__create_role(in_role text) RETURNS bool
LANGUAGE PLPGSQL AS 
$$
BEGIN
  PERFORM * FROM pg_roles WHERE rolname = lsmb__role(in_role);
  IF FOUND THEN
     RETURN TRUE;
  END IF;

  EXECUTE 'CREATE ROLE ' || quote_ident(lsmb__role(in_role)) 
  || ' WITH INHERIT NOLOGIN';

  RETURN TRUE;
END;
$$ SECURITY INVOKER;",Roles.sql
"CREATE OR REPLACE FUNCTION lsmb__grant_exec(in_role text, in_func text)
RETURNS BOOL LANGUAGE PLPGSQL SECURITY INVOKER AS
$$
BEGIN
   EXECUTE 'GRANT EXECUTE ON FUNCTION ' || in_func || ' TO ' 
   || quote_ident(lsmb__role(in_role));
   RETURN TRUE;
END;
$$;",Roles.sql
"CREATE OR REPLACE FUNCTION lsmb__grant_role(in_child text, in_parent text)
RETURNS BOOL LANGUAGE PLPGSQL SECURITY INVOKER AS 
$$
BEGIN
   EXECUTE 'GRANT ' || quote_ident(lsmb__role(in_parent)) || ' TO ' 
   || quote_ident(lsmb__role(in_child));
   RETURN TRUE;
END;
$$;",Roles.sql
"CREATE OR REPLACE FUNCTION makeuid
(
  r int
)
RETURNS TEXT AS $$
DECLARE
  buff TEXT;
  rem int;
  div int;
  BEGIN
  buff = '';
  div = r;
  rem = 0;
while div>0 Loop
if div >92 then
	rem = div%93;
	buff = chr(rem+34)||buff;
	div = div / 93;
else 
	buff = chr(div+34)||buff;
	div = 0;
end if;
end loop;  
RETURN buff;
End
$$ LANGUAGE plpgsql;",cmdOut.txt
"CREATE OR REPLACE FUNCTION match_user(character varying, character varying)
  RETURNS bigint AS
$BODY$
DECLARE
	v_user_id	BIGINT;
BEGIN
	select user_id from coincomo_user_table where user_login_id = $1 and password = md5($2) INTO v_user_id;

	IF FOUND THEN
		RETURN v_user_id;
	ELSE
		RETURN -1;
	END IF;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",coincomo_all_in_one_postgres.sql
"CREATE OR REPLACE FUNCTION mid_cnv_display_class(road_class integer,fc smallint,link_type smallint)
  RETURNS smallint AS
$BODY$
BEGIN
    IF (link_type = 1) THEN 
        return 14;  --100; 
    END IF;
    
    IF (fc = 6) THEN
        return 3;  --6;
    END IF;
 
    IF (road_class = 41000) THEN 
        return 12;  --1; 
    END IF;
        
    IF (road_class = 43000) THEN 
        return 13;  --11; 
    END IF;
 
    IF (road_class = 42000) THEN 
        return 9;  --2; 
    END IF;
    
    IF (road_class = 51000) THEN 
        return 8;  --3; 
    END IF;
 
    IF (road_class = 44000) THEN 
        return 7;  --31; 
    END IF;
 
    IF (road_class = 52000) THEN 
        return 6;  --4; 
    END IF;
 
    IF (road_class = 53000) THEN 
        return 6;  --4; 
    END IF;
 
    IF (road_class = 54000) THEN 
        return 5;  --5; 
    END IF;
 
    IF (road_class = 45000) THEN 
        return 5;  --5; 
    END IF;
 
    IF (road_class = 47000) THEN 
        return 5;  --5; 
    END IF;
 
    RETURN 3;  --6;
 
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cnv_function_class( 
fc smallint
)
  RETURNS smallint 
  LANGUAGE plpgsql
  AS
$$
BEGIN

    IF fc = 1 THEN
    	return 1;
    ELSEIF fc = 2 THEN
    	return 2;
    ELSEIF fc = 3 THEN
    	return 3;
    ELSEIF fc = 4 THEN
    	return 4;
    ELSEIF fc = 5 or fc = 6 THEN
    	return 5;
    ELSE
    	return 5;
    END IF;
    
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cnv_link_type( 
form_way smallint
)
  RETURNS smallint 
  LANGUAGE plpgsql
  AS
$$
BEGIN

    IF form_way = 4 THEN
    	return 0;
    ELSEIF form_way = 1 THEN
    	return 2;
    ELSEIF form_way in (3, 8, 53, 58) THEN
    	return 3;
    ELSEIF form_way = 2 THEN
    	return 4;
    ELSEIF form_way in (6, 9, 10) THEN
    	return 5;
    ELSEIF form_way = 7 THEN
    	return 6;
    ELSEIF form_way in (5, 56) THEN
    	return 7;
    ELSEIF form_way = 11 or form_way = 12 THEN
    	return 8;
    ELSEIF form_way = 13 or form_way = 14 THEN
    	return 9;
    ELSE
    	return 1;
    END IF;
    
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cnv_node_kind
(
nodetype smallint
)
  RETURNS character varying
  LANGUAGE plpgsql VOLATILE
AS $$

BEGIN
	IF nodetype is null THEN
		return null;
	END IF;
	
	IF nodetype = 2 or nodetype = 4 or nodetype = 5 THEN
		return '1301';
	ELSE
		return null;
	END IF;
	
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cnv_road_type(
road_class integer,
form_way smallint,
link_type smallint,
status smallint,
ownership smallint,
name_chn character varying,
direction smallint
)
RETURNS smallint
LANGUAGE plpgsql
AS
$$

BEGIN

    IF link_type = 1 THEN 
    	return 10;
	ELSEIF status = 1 or status = 2 THEN
		return 9;
    ELSEIF ownership = 3 THEN 
    	return 7;
    ELSEIF direction = 4 THEN
    	return 8;
	ELSEIF road_class = 41000 THEN
		return 0;
	ELSEIF road_class = 43000 THEN
		return 1;
    ELSEIF road_class = 42000 THEN 
    	return 2;
    ELSEIF road_class = 51000 THEN
    	return 3;
    ELSEIF road_class = 52000 THEN
    	return 4;
    ELSEIF road_class = 44000 THEN
    	return 5;
    ELSEIF road_class = 49 THEN
    	return 8;
    ELSEIF road_class in (45000, 47000) and ownership = 1 THEN
    	return 14;
    ELSEIF road_class in (45000, 47000, 53000, 54000) THEN
    	return 6;
    ELSE
    	return 9;
    END if;

END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cvt_tw_guideattr(sp_type smallint, cont_type smallint)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	
BEGIN
	if cont_type = 7 then  -- SA
		return 3;
	end if;

	if cont_type = 8 then  -- PA
		return 4;
	end if;
	
	return 
	case 
	when sp_type = 1 then 5 -- direction
	when sp_type = 2 then 1 -- Enter
	when sp_type = 3 then 2 -- Exit
	when sp_type = 4 then 0 -- default
	else 0
	end;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_cvt_tw_namekind(sp_type smallint, cont_type smallint)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	
BEGIN
	IF sp_type = 2 then return 5; end if;  -- Enter
	IF sp_type = 3 then return 6; end if;  -- Exit

	return 
	case
	when cont_type = 1 then 4 -- Location directions
	when cont_type = 2 then 4 -- Route Name
	when cont_type = 3 then 4 -- Street Name
	when cont_type = 4 then 0 -- Tourist attractions Name
	when cont_type = 5 then 0 -- Service Facility Name
	when cont_type = 6 then 0 -- Service Facility Icon
	when cont_type = 7 then 2 -- SA
	when cont_type = 8 then 3 -- PA
	else 0
	end;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_findInnerPath(nMeshID integer, nFromLink integer, nToLink integer, nTargetCross integer)
	RETURNS varchar[]
	LANGUAGE plpgsql
AS $$ 
DECLARE
	rstPathArray		varchar[];
	rstPathCount		integer;
	rstPath				varchar;
	
	tmpPathArray		varchar[];
	tmpLastNodeArray	bigint[];
	tmpLastLinkArray	bigint[];
	tmpPathCount		integer;
	tmpPathIndex		integer;
	
	nStartNode			integer;
	nEndNode			integer;
	
	nNewFromLink		bigint;
	nNewToLink			bigint;
	
	rec        			record;
BEGIN
	-- init
	execute
	'
	 select (
		 case
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
			)
		 then fnode
		 else tnode
		 end
		)as curnode
	 from org_roadsegment
	 where meshid = '||nMeshID||' and road = ' ||nFromLink|| '
	'
	into nStartNode
	;
	
	execute
	'
	 select (
		 case
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
			)
		 then fnode
		 else tnode
		 end
		)as curnode
	 from org_roadsegment
	 where meshid = '||nMeshID||' and road = ' ||nToLink|| '
	'
	into nEndNode
	;
	
	execute
	'
	 select new_road
	 from temp_link_mapping
	 where meshid = '||nMeshID||' and road = ' ||nFromLink|| '
	'
	into nNewFromLink
	;
	
	execute
	'
	 select new_road
	 from temp_link_mapping
	 where meshid = '||nMeshID||' and road = ' ||nToLink|| '
	'
	into nNewToLink
	;
	
	--rstPathArray
	rstPathCount		:= 0;
	tmpPathArray		:= ARRAY[cast(nNewFromLink as varchar)];
	tmpLastNodeArray	:= ARRAY[nStartNode];
	tmpLastLinkArray	:= ARRAY[nNewFromLink];
	tmpPathCount		:= 1;
	tmpPathIndex		:= 1;

	-- search
	WHILE tmpPathIndex <= tmpPathCount LOOP
		--raise INFO '%', cast(tmpPathArray as varchar);
		if tmpLastNodeArray[tmpPathIndex] = nEndNode then
			rstPathCount		:= rstPathCount + 1;
			rstPath				:= cast(tmpPathArray[tmpPathIndex]||'|'||nNewToLink as varchar);
			rstPath				:= replace(rstPath, '(2)', '');
			rstPath				:= replace(rstPath, '(3)', '');
			if rstPathCount = 1 then
				rstPathArray	:= ARRAY[rstPath];
			else
				rstPathArray	:= array_append(rstPathArray, rstPath);
			end if;
		else
			for rec in execute
				'
				 select b.new_road as nextroad, a.dir, a.nextnode
				 from
				 (
					 select meshid, road as nextroad, ''(2)'' as dir, tnode as nextnode
					 from org_roadsegment
					 where	(meshid = '||nMeshID||') and
					 		(fnode = ' ||tmpLastNodeArray[tmpPathIndex]|| ') and 
							(direction in (1,2)) and
							(
							tnode in
								(
								 select node
								 from org_roadnode
								 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
								)
							)
					 union
					 
					 select meshid, road as nextroad, ''(3)'' as dir, fnode as nextnode
					 from org_roadsegment
					 where	(meshid = '||nMeshID||') and
					 		(tnode = ' ||tmpLastNodeArray[tmpPathIndex]|| ') and
							(direction in (1,3)) and
							(
							fnode in
								(
								 select node
								 from org_roadnode
								 where meshid = '||nMeshID||' and comp_node = '||nTargetCross||'
								)
							)
				 )as a
				 left join temp_link_mapping as b
				 on a.meshid = b.meshid and a.nextroad = b.road
				'
			loop
				if 		not (rec.nextroad in (nNewFromLink, nNewToLink, tmpLastLinkArray[tmpPathIndex]))
					and	not ((rec.nextroad||rec.dir) = ANY(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+')))
				then
					tmpPathCount		:= tmpPathCount + 1;
					tmpPathArray		:= array_append(tmpPathArray, cast(tmpPathArray[tmpPathIndex]||'|'||rec.nextroad||rec.dir as varchar));
					tmpLastNodeArray	:= array_append(tmpLastNodeArray, cast(rec.nextnode as bigint));
					tmpLastLinkArray	:= array_append(tmpLastLinkArray, cast(rec.nextroad as bigint));
				end if;
			end loop;
		end if;
		tmpPathIndex := tmpPathIndex + 1;
	END LOOP;

	return rstPathArray;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_findTargetNodeIndex(fnode_array bigint[], tnode_array bigint[], nTargetNode bigint)
    RETURNS smallint
    LANGUAGE plpgsql
AS $$
DECLARE
	nCount					integer;
	nIndex					integer;
BEGIN
	nCount	:= array_upper(fnode_array, 1);
	for nIndex in 1..(nCount-1) loop
		if (fnode_array[nIndex] = nTargetNode) or (tnode_array[nIndex] = nTargetNode) then
			return nIndex;
		end if;
	end loop;
	raise INFO 'signpost wrong: target node is not on the path';
	return 0;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_access(vehicle varchar, rule_type smallint)
	RETURNS smallint
    LANGUAGE plpgsql
AS $$
DECLARE
	x			smallint;
	nVehicle	integer;
BEGIN
	x = 0;
	execute 'select cast(X''' || vehicle || ''' as integer)' into nVehicle;
	-- not local
	if rule_type in (2,3,6,7) then
		--modified on 20120817 for deleting ecdemic car restriction
		--x	:= x | 1;
		return 0;
	end if;
	-- all car type
	if (nVehicle&(1<<31)) != 0 then
		x	:= x | -2;
	end if;
	-- car
	if (nVehicle&(1<<30)) != 0 then
		x	:= x | (1<<13);
	end if;
	-- small car
	if (nVehicle&(1<<29)) != 0 then
		x	:= x | (1<<12);
	end if;
	-- small truck
	if (nVehicle&(1<<28)) != 0 then
		x	:= x | (1<<6);
	end if;
	-- large truck
	if (nVehicle&(1<<27)) != 0 then
		x	:= x | (1<<14);
	end if;
	-- tow truck
	if (nVehicle&(1<<26)) != 0 then
		x	:= x | ((cast(1 as smallint))<<15);
	end if;
	-- small passenger car
	if (nVehicle&(1<<25)) != 0 then
		x	:= x | (1<<10);
	end if;
	-- large passenger car
	if (nVehicle&(1<<24)) != 0 then
		x	:= x | (1<<7);
	end if;
	-- passerby
	if (nVehicle&(1<<0)) != 0 then
		x	:= x | (1<<4);
	end if;
	return x;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_connect_node(nFromLink integer, nTargetCross integer, _meshid integer)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	connect_node		integer;
	--new_connect_node        bigint;
BEGIN
	select (
		 case
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where comp_node = nTargetCross and meshid = _meshid
			) and 
			tnode in 
		 	(
			 select node
			 from org_roadnode
			 where comp_node = nTargetCross and meshid = _meshid
			)
		 then null
		 when fnode in
			(
			 select node
			 from org_roadnode
			 where comp_node = nTargetCross and meshid = _meshid
			)
		 then fnode
		 when tnode in 
		 	(
			 select node
			 from org_roadnode
			 where comp_node = nTargetCross and meshid = _meshid
			)
		 then tnode
		 else NULL
		 end
		)as curnode
	 into connect_node
	 from org_roadsegment
	 where road = nFromLink and meshid = _meshid;

	---- get new node id
	--SELECT new_node into new_connect_node from temp_node_mapping where node = connect_node and meshid = _meshid;
	
	--return new_connect_node;
	
	return connect_node;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_connected_nodeid(fromnodeid1 integer, tonodeid1 integer, fromnodeid2 integer, tonodeid2 integer)
  RETURNS integer 
  LANGUAGE plpgsql
  AS
$$ 
BEGIN
	IF fromnodeid1 = fromnodeid2 THEN
		return fromnodeid1;
	END IF;
	
	IF fromnodeid1 = tonodeid2 THEN
		return fromnodeid1;
	END IF;

	IF tonodeid1 = fromnodeid2 THEN
		return tonodeid1;
	END IF;

	IF tonodeid1 = tonodeid2 THEN
		return tonodeid1;
	END IF;
	
	return NULL;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_highway_ic_node()
	RETURNS smallint
	LANGUAGE plpgsql volatile
AS $$
DECLARE
	curs1            refcursor;
	curs2            refcursor;
	
	temprs1          bigint;
	temprs2          bigint;
	
	temp_ic          bigint;
	temp_newnode     bigint;
	temp_name_id     bigint;
	temp_gateinfo    character varying;
	gateinfoArray    smallint[];
	mark_ic          smallint;
	toga_type        smallint;
	temp_count       bigint;
	i                integer;
	j                integer;
 
BEGIN	
	i        := 1;
	j        := 1;	
	OPEN curs1 FOR select ic, new_node   
		from org_interchange as a
		left join mesh_mapping_tbl as b 
		on a.mesh = b.meshid_str 
		left join temp_node_mapping as c
		on globl_mesh_id = c.meshid and a.node = c.node
		left join temp_interchange_name as d
		on a.gid=d.gid 
		where  a.ic_type = 8;
	-- Get the first record        
	FETCH curs1 INTO temp_ic, temp_newnode;

	while temp_ic is not null LOOP
		temprs1 = mid_research_highway_ic_node(temp_ic, temp_newnode, 1);
		temprs2 = mid_research_highway_ic_node(temp_ic, temp_newnode, 2);
		FETCH curs1 INTO temp_ic, temp_newnode;
	END LOOP;
	close curs1;
	
	return 1;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_hwy_in_out_type(nNodeID bigint, junction smallint, sapa smallint)
	RETURNS smallint
	LANGUAGE plpgsql volatile
AS $$
DECLARE
	s_node_array         bigint[];
	e_node_array         bigint[];
	one_way_code_array   bigint[];
	road_type_array      bigint[];
	link_type_array      bigint[];
	i                    integer;
	j                    integer;
BEGIN
	 
	SELECT array_agg(s_node), array_agg(e_node), array_agg(one_way_code), 
	       array_agg(road_type), array_agg(link_type)
	  into s_node_array, e_node_array, one_way_code_array, road_type_array, link_type_array
	  FROM (
		SELECT 1 as gid, s_node, e_node, one_way_code, road_type, link_type
		FROM link_tbl
		where s_node = nNodeID or e_node = nNodeID
	  ) AS A
	  group by gid;
	  
	i            := 1;
	--raise info 's_node_array: %', s_node_array;
	while i <= array_upper(s_node_array, 1) loop
		-- JCT
		if junction = 1 and link_type_array[i] in (3) then
			if one_way_code_array[i] in (1, 4) then
				raise info 'sa node_id: %', nNodeID;
				return NULL;
			end if;
			--raise info 'nNodeID: %, s_node: %, e_node: %, one_way_code: %', nNodeID, s_node_array[i], e_node_array[i], one_way_code_array[i];
			-- In
			if (nNodeID = s_node_array[i] and 3 = one_way_code_array[i]) 
			  or (nNodeID = e_node_array[i] and 2 = one_way_code_array[i]) then
				return 0;
			else -- Out
				return 1;
			end if;
		end if;
		
		-- SAPA
		if sapa = 1 and link_type_array[i] in (7, 3) then
			if one_way_code_array[i] in (4) then
				raise info 'sa node_id: %', nNodeID;
				return NULL;
			end if;
			-- In
			if (nNodeID = s_node_array[i] and 3 = one_way_code_array[i]) 
			  or (nNodeID = e_node_array[i] and 2 = one_way_code_array[i]) then
				return 0;
			else -- Out
				return 1;
			end if;
		end if;
		i := i + 1;
	end loop;

	if junction = 1 then
		-- NODE JCT
		--i    := 1;
		--while i <= array_upper(s_node_array, 1) loop
			-- JCT
		--	if link_type_array[i] not in (2) then
		--		raise info 'Do not exist JCT LINK, node_id: %', nNodeID;
		--		return NULL;
		--	end if;
		--	i    := i + 1;
		--end loop;
		-- It is a NODE JCT
		--return 1;
		raise info 'Do not exist JCT LINK, node_id: %', nNodeID;
		return NULL;
	end if;

	if sapa = 1 then
		raise info 'Do not exist SAPA LINK, node_id: %', nNodeID;
	end if;
	
	return NULL;	
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_ic_tpye(ic_type integer,interchange_no integer)
 RETURNS  smallint[]
    LANGUAGE plpgsql
    AS  
$$ 
DECLARE
	curs1           	refcursor;
	temp_array   		smallint[];
	temp_typeflag 		integer[];
	sp           		integer;
	pa_flag      		smallint;
	i           	 	integer;
BEGIN
	pa_flag 	:= 0;
	if ic_type is null then
		return null;
	end if;
     
	IF ic_type = 2 THEN
		OPEN curs1 FOR SELECT  array_agg(type_flag) as tflags from org_sapa where ic_no=interchange_no;
	-- Get the first record        
		FETCH curs1 INTO temp_typeflag;
	END IF;
	
	IF ic_type = 4 or ic_type = 32 THEN 
		temp_array[1] := 1;
	ELSE temp_array[1] := 0;
	END IF;
	
	IF ic_type = 2 THEN 
	        i := 1;
		while i <= array_upper(temp_typeflag, 1)  LOOP
			if temp_typeflag[i] = 2 then
				pa_flag = 1;
			END IF;
			i = i + 1;
		END LOOP; 
		if pa_flag=1 then
			temp_array[2] := 1;
		ELSE temp_array[2] := 0;
		END IF;
	ELSE temp_array[2] := 0;
	END IF;
	IF ic_type = 2 THEN 
		if pa_flag != 1 then
			temp_array[3] := 1;
		ELSE temp_array[3] := 0;
		END IF;
	ELSE temp_array[3] := 0;
	END IF;
	IF ic_type = 8 THEN 
		temp_array[4] := 1;
	ELSE temp_array[4] := 0;
	END IF;
	IF ic_type = 16 THEN 
		temp_array[5] := 1;
	ELSE temp_array[5] := 0;
	END IF;
	IF temp_array[2] = 1 or temp_array[3] = 1 THEN 
		temp_array[6] := 1;
	ELSE temp_array[6] := 0;
	END IF;
	-- Get the first record        
	--FETCH curs1 INTO ic, new_node, new_name_id, junction, pa, sa, ic_t, tollgate, gate_info, service_info_flag;
	
    return temp_array;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_lanecount_downflow(direction smallint, max_lanes smallint)
RETURNS smallint 
LANGUAGE plpgsql
AS
$$
BEGIN
	IF max_lanes is null THEN
		return 0;
	END IF;
	RETURN CASE
		WHEN direction in (1,2,4) THEN max_lanes
		ELSE 0
	END;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_lanecount_upflow(direction smallint, max_lanes smallint)
RETURNS smallint 
LANGUAGE plpgsql
AS
$$
BEGIN
	IF max_lanes is null THEN
		return 0;
	END IF;
	RETURN CASE
		WHEN direction in (1,3,4) THEN max_lanes
		ELSE 0
	END;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_next_sapa_idx(sapa_array integer[], curr_idx integer)
	RETURNS integer
	LANGUAGE plpgsql volatile
AS $$
DECLARE
	i   integer;
BEGIN
	if curr_idx > 0 then
		i := curr_idx;
	else
		i := 1;
	end if;

	while i <= array_upper(sapa_array, 1) loop
		if sapa_array[i] is not null and sapa_array[i] > 0 then
			return i;
		end if;
		i := i + 1;
	end loop;
	return NUll;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_pass_lid(link_lid character varying, split_char character)
	RETURNS character varying
	LANGUAGE plpgsql
AS $$ 
DECLARE
	first_pos integer;
	last_pos integer;
	i integer;
BEGIN
	first_pos := 0;
	last_pos  := 0;
	IF link_lid IS NULL or split_char is null THEN 
		RETURN NULL;
	END IF;

	first_pos = strpos(link_lid, split_char);
	last_pos  = first_pos;
	i = first_pos + 1;
	while i <= length(link_lid) loop
		if substr(link_lid, i, 1) = split_char then
			last_pos = i;
		end if;
		i := i + 1;
	end loop;

	IF first_pos = last_pos THEN
		RETURN NULL;
	END IF;
	
	return substr(link_lid, first_pos + 1, last_pos - first_pos -1);
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_shield_id(route_no character varying, road_class integer)
 RETURNS smallint
    LANGUAGE plpgsql
    AS  
$$
BEGIN
    IF (position('G' in route_no) > 0)AND(road_class IN (41000,43000)) THEN
        return 494;
    END IF;
   
    IF (position('S' in route_no) > 0)AND(road_class IN (41000,43000)) THEN
        return 495;
    END IF;
   
    IF (position('G' in route_no) > 0) THEN
        RETURN 496;
    END IF;
   
    IF (position('S' in route_no) > 0) THEN
        RETURN 497;
    END IF;
 
    IF (position('X' in route_no) > 0) THEN
        RETURN 500;
    END IF;
   
    RETURN 506;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_specific_char_num(org_str varchar, find_char char)
returns int
LANGUAGE plpgsql
AS
$$ 
DECLARE
	rtn_cnt int;
	str_length int;
	ipos int;
BEGIN
	ipos := 1;
	rtn_cnt := 0;
	str_length := char_length(org_str);
	while ipos <= str_length loop
		if substring(org_str,ipos, 1) = find_char then
			rtn_cnt := rtn_cnt + 1;
		end if;
		ipos := ipos +1;
	end loop;
	
	return rtn_cnt;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_toll_type(gate_info character varying)
 RETURNS  smallint[]
    LANGUAGE plpgsql
    AS  
$$ 
DECLARE
	temp         smallint[];
	cnt          integer;
	sp           integer;
	tollgatetype integer;
	mark         integer;            
BEGIN
	mark := 1;
	if gate_info is null then
		temp[1] := 0;
		temp[2] := 0;
		return temp;
	end if;
	tollgatetype := 0;
	sp = 1;
	-- Get the first record        
	--FETCH curs1 INTO ic, new_node, new_name_id, junction, pa, sa, ic_t, tollgate, gate_info, service_info_flag;
	while sp <= length(gate_info)  LOOP
		IF substring(gate_info from sp for 1) = '6' THEN 
			tollgatetype := tollgatetype | 7;
			mark := 0;
		ELSEIF substring(gate_info , sp, 1) = '5' THEN
			tollgatetype := tollgatetype | 5;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '4' THEN
			tollgatetype := tollgatetype | 3;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '3' THEN
			tollgatetype := tollgatetype | 6;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '2' THEN
			tollgatetype := tollgatetype | 4;
			mark := 0;
		ELSEIF substring(gate_info, sp, 1) = '1' THEN
			tollgatetype := tollgatetype | 2;
		ELSEIF substring(gate_info, sp, 1) = '0' THEN
			tollgatetype := tollgatetype | 1;
			mark := 0;
		ELSE tollgatetype := tollgatetype | 1;
		    mark := 0;
		END IF;
		sp          := sp + 1;
        
	END LOOP;
	temp[1] := tollgatetype ;
	temp[2] := mark;
    return temp;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_width
(
width double precision
)
RETURNS smallint
LANGUAGE plpgsql VOLATILE
AS 
$$
BEGIN
	
	IF width is null THEN
		return 4;
	END IF;
	
	IF width > 0 and width <= 3.0 THEN
		return 0;
	ELSEIF width <= 5.5 THEN
		return 1;
	ELSEIF width <= 13 THEN
		return 2;
	ELSEIF width > 13 THEN
		return 3;
	ELSE
		return 4;
	END IF;

END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_width_downflow
(
direction smallint,
width double precision
)
RETURNS smallint
LANGUAGE plpgsql VOLATILE
AS 
$$
BEGIN
	IF direction is null OR width = 0 THEN
		return 4;
	END IF;
	
    IF direction in (1, 2, 4) THEN
		return mid_get_width(width);
    ELSE 
    	return 4; 
    END IF;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_get_width_upflow
(
direction smallint,
width double precision
)
RETURNS smallint
LANGUAGE plpgsql VOLATILE
AS 
$$
BEGIN
	IF direction is null OR width = 0 THEN
		return 4;
	END IF;
	
    IF direction in (1, 3, 4) THEN
		return mid_get_width(width);
    ELSE 
    	return 4; 
    END IF;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_getregulationspeed
(
oneway smallint,
speed_limit_posted integer[],
speed_limit integer,
speedclass integer,
dir boolean
)
  RETURNS double precision
  LANGUAGE plpgsql VOLATILE
  AS $$
DECLARE
	rtnvalue INT;
BEGIN

	IF      (oneway = 2 and dir = false) 
		or (oneway = 3 and dir = true)
		or oneway = 4 THEN
			return 0;
	ELSE

		IF oneway in (2,3) and speed_limit_posted is not null THEN
			RETURN speed_limit_posted[1];
		ELSEIF oneway = 1 and dir is true and speed_limit_posted[1] is not null THEN
			RETURN speed_limit_posted[1];
		ELSEIF oneway = 1 and dir is false and speed_limit_posted[2] is not null THEN
			RETURN speed_limit_posted[2];
		ELSE
			IF speed_limit is not null and speed_limit > 0 THEN
				IF speed_limit > 200 THEN
					RETURN -1;
				ELSE
					return speed_limit;
				END IF;
			ELSE
				RETURN CASE 	WHEN speedclass=1 THEN 160
						WHEN speedclass=2 THEN 130
						WHEN speedclass=3 THEN 100
						WHEN speedclass=4 THEN 90
						WHEN speedclass=5 THEN 70
						WHEN speedclass=6 THEN 50
						WHEN speedclass=7 THEN 30
						WHEN speedclass=8 THEN 11
						ELSE 0
				END;
			END IF;  
		END IF;
	END IF;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_getregulationspeed_source
(
oneway smallint,
speed_limit_posted int[],
speed_limit integer,
speedclass integer,
dir boolean
)
  RETURNS double precision
  LANGUAGE plpgsql VOLATILE
  AS $$
DECLARE
	rtnvalue INT;
BEGIN
	
	IF      (oneway = 2 and dir = false) 
		or (oneway = 3 and dir = true)
		or oneway = 4 THEN
			return 0;
	ELSE

		IF speed_limit_posted is not null THEN
			RETURN 1;
		ELSE
			IF speed_limit is not null and speed_limit > 0 THEN
				return 2;
			ELSE
				RETURN 3;
			END IF;  
		END IF;
	END IF;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_getspeedclass
(
road_class integer
)
  RETURNS smallint
  LANGUAGE plpgsql VOLATILE
  AS $$
DECLARE
	rtnvalue INT;
BEGIN
    RETURN CASE 
        WHEN road_class = 41000 THEN 3
        WHEN road_class in (42000, 43000) THEN 4
        WHEN road_class in (44000, 51000) THEN 5
        WHEN road_class in (45000, 47000, 52000) THEN 6
        WHEN road_class = 53000 THEN 7
        WHEN road_class in (54000, 49) THEN 8
        ELSE 0 
    END;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_has_additional_lane(all_lane_info varchar) -- return 0: not, 1: right-side has, 2:left-side has, 3: both-has
RETURNS smallint
LANGUAGE plpgsql
AS
$$ 
DECLARE 
	lanecount smallint;
	itor	smallint;
	current_char char;
	left_increase boolean;
	right_increase boolean;

BEGIN
	left_increase := false;
	right_increase := false;
	
	itor := 1;
	lanecount := length(all_lane_info);
	
	WHILE itor <= lanecount LOOP
		current_char := substring(all_lane_info, itor, 1);
		if current_char >= 'G' and current_char <= 'O' then
			left_increase := true;
		end if;

		if current_char >= 'R' and current_char <= 'Z' then
			right_increase := true;
		end if;

		itor := itor + 1;
	END LOOP;

	if (left_increase and right_increase) then
		return 3;
	elsif left_increase then
		return 2;
	elsif right_increase then
		return 1;
	else 
		return 0;
	end if;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_judge_highway_link(ic_node bigint, dir integer)
  RETURNS integer 
LANGUAGE plpgsql volatile
AS $$
DECLARE
	result                   integer;	
	temp_road_type_array     bigint[];
	temp_link_type_array     bigint[];
	j                        integer;
	
BEGIN	
	result = 0;
	j = 1;
	if dir is null then
		select	array_agg(link_type), array_agg(road_type)
		into temp_link_type_array, temp_road_type_array
		from link_tbl
		where s_node = ic_node
		      or
		      e_node = ic_node;
		      
	else
		select	array_agg(link_type), array_agg(road_type)
		into temp_link_type_array, temp_road_type_array
		from link_tbl
		where(
				(
					(dir = 1)
					and
					(
						(s_node = ic_node and one_way_code in (1,2))
						or
						(e_node = ic_node and one_way_code in (1,3))
					)
				)
				or
				(
					(dir = 2)
					and
					(
						(s_node = ic_node and one_way_code in (1,3))
						or
						(e_node = ic_node and one_way_code in (1,2))
					)
				)
			);
        end if;
	
	while j <= array_upper(temp_link_type_array, 1) loop
		if temp_link_type_array[j] in (0, 1, 2) and temp_road_type_array[j] in (0, 1) then
			result = result+1;
		end if;
		j = j + 1;
	end loop;
	
	return result;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_string_count(link_lid character varying, split_char character)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	cnt integer;
	i integer;
BEGIN
	IF link_lid IS NULL or split_char is null THEN 
		RETURN 0;
	END IF;
	
	cnt = 0;
	i = 1;
	while i <= length(link_lid) loop
		if substr(link_lid, i, 1) = split_char then
			cnt := cnt + 1;
		end if;
		i := i + 1;
	end loop;

	return cnt;
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION mid_translate(_name character varying)
  RETURNS character varying 
  LANGUAGE plpgsql 
  AS $$
begin
	return translate(_name, '���£ãģţƣǣȣɣʣˣ̣ͣΣϣУѣңӣԣأ٣ڣգ֣ף�������������������', 'ABCDEFGHIJKLMNOPQRSTXYZUVW1234567890');
END;
$$;",create_function.sql
"CREATE OR REPLACE FUNCTION migration.MigrateAll()
  RETURNS void AS $$
DECLARE
BEGIN
  PERFORM migration.MigrateEstablishments();
  PERFORM migration.MigrateUsers();
  PERFORM migration.MigrateWorkers();
  PERFORM migration.worker_bulk_training();
  PERFORM migration.worker_bulk_qualifications();
END;
$$ LANGUAGE plpgsql;",migration_ddl.sql
"CREATE OR REPLACE FUNCTION migration.Validate()
  RETURNS void AS $$
DECLARE
  NumberOfUsers INTEGER;
  NumberOfReadOnlyLogins INTEGER;
  NumberOfEditLogins INTEGER;
  NumberOfEstablishments INTEGER;
  NumberOfEstablishmentServices INTEGER;
  NumberOfEstablishmentCapacities INTEGER;
  NumberOfEstablishmentServiceUsers INTEGER;
  NumberOfEstablishmentLocalAuthorities INTEGER;
  NumberOfEstablishmentJobs INTEGER;
  NumberOfWorkers INTEGER;
  NumberOfWorkersQualifications INTEGER;
  NumberOfWorkersTraining INTEGER;
  NumberOfServiceCapacities INTEGER;
  NumberOfQualifications INTEGER;
  NumberOfQualificationsWithNullLevel INTEGER;
  NumberOfCountries INTEGER;
BEGIN
  select count(0)
  from cqc.""Establishment""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishments;

  select count(0)
  from cqc.""EstablishmentServices""
    inner join cqc.""Establishment"" on ""EstablishmentServices"".""EstablishmentID"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishmentServices;

  select count(0)
  from cqc.""EstablishmentCapacity""
    inner join cqc.""Establishment"" on ""EstablishmentCapacity"".""EstablishmentID"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishmentCapacities;

  select count(0)
  from cqc.""EstablishmentServiceUsers""
    inner join cqc.""Establishment"" on ""EstablishmentServiceUsers"".""EstablishmentID"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishmentServiceUsers;

  select count(0)
  from cqc.""EstablishmentLocalAuthority""
    inner join cqc.""Establishment"" on ""EstablishmentLocalAuthority"".""EstablishmentID"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishmentLocalAuthorities;

  select count(0)
  from cqc.""EstablishmentJobs""
    inner join cqc.""Establishment"" on ""EstablishmentJobs"".""EstablishmentID"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfEstablishmentJobs;


  select count(0)
  from cqc.""User""
    inner join cqc.""Establishment"" on ""Establishment"".""EstablishmentID"" = ""User"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    and ""User"".""TribalPasswordAnswer"" IS NOT NULL
    into NumberOfUsers;

  select count(0)
  from cqc.""Login""
    inner join cqc.""User""
      inner join cqc.""Establishment"" on ""Establishment"".""EstablishmentID"" = ""User"".""EstablishmentID""
      on ""User"".""RegistrationID"" = ""Login"".""RegistrationID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    and ""Login"".""TribalHash"" is not null
    and ""User"".""UserRoleValue"" = 'Read'
    into NumberOfReadOnlyLogins;

  select count(0)
  from cqc.""Login""
    inner join cqc.""User""
      inner join cqc.""Establishment"" on ""Establishment"".""EstablishmentID"" = ""User"".""EstablishmentID""
      on ""User"".""RegistrationID"" = ""Login"".""RegistrationID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    and ""Login"".""TribalHash"" is not null
    and ""User"".""UserRoleValue"" = 'Edit'
    into NumberOfEditLogins;

  select count(0)
  from cqc.""Worker""
    inner join cqc.""Establishment"" on ""Worker"".""EstablishmentFK"" = ""Establishment"".""EstablishmentID""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    into NumberOfWorkers;


  select count(0)
  from cqc.""WorkerTraining""
    inner join cqc.""Worker""
      inner join cqc.""Establishment"" on ""Establishment"".""EstablishmentID"" = ""Worker"".""EstablishmentFK""
      on ""Worker"".""ID"" = ""WorkerTraining"".""WorkerFK""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    and ""WorkerTraining"".""TribalID"" IS NOT NULL
    into NumberOfWorkersTraining;

  select count(0)
  from cqc.""WorkerQualifications""
    inner join cqc.""Worker""
      inner join cqc.""Establishment"" on ""Establishment"".""EstablishmentID"" = ""Worker"".""EstablishmentFK""
      on ""Worker"".""ID"" = ""WorkerQualifications"".""WorkerFK""
  where ""Establishment"".""TribalID"" in (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485, 15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926, 196840, 144133, 215263, 170258, 217893, 231842)
    and ""WorkerQualifications"".""TribalID"" IS NOT NULL
    into NumberOfWorkersQualifications;


  IF (NumberOfEstablishments = 43) THEN
    RAISE INFO 'Establishment count matches';
  ELSE
    RAISE WARNING 'Establishment count fails match: %', NumberOfEstablishments;
  END IF;

  IF (NumberOfEstablishmentServices = 47) THEN
    RAISE INFO 'Establishment Services count matches';
  ELSE
    RAISE WARNING 'Establishment Services count fails match: %', NumberOfEstablishmentServices;
  END IF;
  IF (NumberOfEstablishmentCapacities = 83) THEN
    RAISE INFO 'Establishment Capacities count matches';
  ELSE
    RAISE WARNING 'Establishment Capacities count fails match: %', NumberOfEstablishmentCapacities;
  END IF;
  IF (NumberOfEstablishmentServiceUsers = 311) THEN
    RAISE INFO 'Establishment Service Users count matches';
  ELSE
    RAISE WARNING 'Establishment Service Users count fails match: %', NumberOfEstablishmentServiceUsers;
  END IF;
  IF (NumberOfEstablishmentLocalAuthorities = 51) THEN
    RAISE INFO 'Establishment Local Authorities count matches';
  ELSE
    RAISE WARNING 'Establishment Local Authorities count fails match: %', NumberOfEstablishmentLocalAuthorities;
  END IF;
  IF (NumberOfEstablishmentJobs = 249) THEN
    RAISE INFO 'Establishment Jobs count matches';
  ELSE
    RAISE WARNING 'Establishment Jobs count fails match: %', NumberOfEstablishmentJobs;
  END IF;


  IF (NumberOfUsers = 87) THEN
    RAISE INFO 'User count matches';
  ELSE
    RAISE WARNING 'User count fails match: %', NumberOfUsers;
  END IF;
  IF (NumberOfReadOnlyLogins = 9) THEN
    RAISE INFO 'Read Only Logins count matches';
  ELSE
    RAISE WARNING 'Read Only Logins count fails match: %', NumberOfReadOnlyLogins;
  END IF;
  IF (NumberOfEditLogins = 77) THEN
    RAISE INFO 'Edit Logins count matches';
  ELSE
    RAISE WARNING 'Edit Logins count fails match: %', NumberOfEditLogins;
  END IF;
  IF (NumberOfWorkers = 2257) THEN
    RAISE INFO 'Worker count matches';
  ELSE
    RAISE WARNING 'Worker count fails match: %', NumberOfWorkers;
  END IF;
  IF (NumberOfWorkersTraining = 18899) THEN
    RAISE INFO 'Worker Training count matches';
  ELSE
    RAISE WARNING 'Worker Training count fails match: %', NumberOfWorkersTraining;
  END IF;
  IF (NumberOfWorkersQualifications = 2050) THEN
    RAISE INFO 'Worker Qualifications count matches';
  ELSE
    RAISE WARNING 'Worker Qualifications count fails match: %', NumberOfWorkersQualifications;
  END IF;



  -- these counts double check the patch has been applied (two new service capacities, two new qualifications, six new qualifications without levels)
  select count(0)
  from cqc.""ServicesCapacity""
    into NumberOfServiceCapacities;
  select count(0)
  from cqc.""Qualifications""
    into NumberOfQualifications;
  select count(0)
  from cqc.""Qualifications""
  where ""Level"" IS NULL
    into NumberOfQualificationsWithNullLevel;
  select count(0)
  from cqc.""Country""
    into NumberOfCountries;

  IF (NumberOfServiceCapacities = 18) THEN
    RAISE INFO 'Capacities count matches';
  ELSE
    RAISE WARNING 'Capacities count fails match: %', NumberOfServiceCapacities;
  END IF;
  IF (NumberOfQualifications = 127) THEN
    RAISE INFO 'Qualifications count matches';
  ELSE
    RAISE WARNING 'Qualifications count fails match: %', NumberOfQualifications;
  END IF;
  IF (NumberOfQualificationsWithNullLevel = 23) THEN
    RAISE INFO 'Qualifications with no level count matches';
  ELSE
    RAISE WARNING 'Qualifications with no level count fails match: %', NumberOfQualificationsWithNullLevel;
  END IF;
  IF (NumberOfCountries = 246) THEN
    RAISE INFO 'Countries with no level count matches';
  ELSE
    RAISE WARNING 'Countries with no level count fails match: %', NumberOfCountries;
  END IF;

END;
$$ LANGUAGE plpgsql;",migration_ddl.sql
"CREATE OR REPLACE FUNCTION migration.loop_estbid_users(n integer DEFAULT 100)
    RETURNS void
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE 
AS $BODY$
DECLARE
Allestbid  REFCURSOR;
currentestbid record;
Begin 
OPEN Allestbid  for 
select establishment_id from establishment_user where establishment_id not in  (156182, 59, 248, 669, 187078, 215842, 162286, 2533, 2952, 200560, 225586, 3278, 60682, 5228, 12937, 232842, 10121, 10757, 216264, 12041, 17047, 177958, 136485,15000, 20876, 233642, 17661, 168369, 40762, 205162, 154806, 42683, 45882, 196119, 85603, 181062, 218926,196840, 144133, 215263, 170258, 217893, 231842) limit n;
Loop
Begin
FETCH Allestbid INTO currentestbid;
EXIT WHEN NOT FOUND;
PERFORM  migration.MigrateUsers(currentestbid.establishment_id);            
--  RAISE NOTICE ' %', current_establishment_id.id;
END;
END LOOP;
END;
$BODY$;",migration_ddl.sql
"CREATE OR REPLACE FUNCTION movimiento_en_fecha (IN fecha_inicio timestamp,
       	  	  	   		        IN barcode_in bigint,
						OUT barcode_out varchar,
       						OUT movimiento_out double precision,
						OUT costo_promedio_en_fecha_out double precision)
RETURNS SETOF record AS $$
DECLARE
	q text;
	l record;
	corriente int4;
	materia_prima int4;
BEGIN

SELECT id INTO corriente FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE';
SELECT id INTO materia_prima FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA';

--SELECT SUM (COALESCE(cantidad_ingresada,0) - COALESCE(cantidad_c_anuladas,0) - COALESCE(cantidad_vendida,0) - COALESCE(cantidad_vmcd,0) - COALESCE(unidades_merma,0) + COALESCE(cantidad_anulada,0) - COALESCE(cantidad_devolucion,0) - COALESCE(cantidad_envio,0) + COALESCE(cantidad_recibida,0)) AS movimiento
q := $S$ SELECT p.barcode, cantidad_ingresada, cantidad_c_anuladas, cantidad_vendida, cantidad_vmcd, unidades_merma, cantidad_anulada, cantidad_devolucion, cantidad_envio, cantidad_recibida,
     	 	(SELECT fcd.costo_promedio
			FROM factura_compra_detalle fcd
			INNER JOIN factura_compra fc
			ON fcd.id_factura_compra = fc.id

			WHERE fc.fecha < $S$ ||quote_literal (fecha_inicio+'1 days')|| $S$
			AND barcode = p.barcode
			ORDER BY fcd.id_factura_compra DESC
			LIMIT 1) AS costo_fecha
       	 	FROM producto p

	 	-- Las compras ingresadas hechas hasta la fecha determinada
	 	LEFT JOIN (SELECT SUM(fcd.cantidad) AS cantidad_ingresada, fcd.barcode AS barcode
		          	  FROM factura_compra_detalle fcd
       		     	          INNER JOIN factura_compra fc
       		     	          ON fc.id = fcd.id_factura_compra

       		     	          WHERE fc.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND fc.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
                     	          AND fcd.cantidad > 0
                     	          GROUP BY barcode) AS cantidad_ingresada
                ON p.barcode = cantidad_ingresada.barcode

	        -- Las anulaciones de compras hechas hasta la fecha determinada
		LEFT JOIN (SELECT SUM(cad.cantidad_anulada) AS cantidad_c_anuladas, cad.barcode AS barcode
		       	          FROM compra_anulada ca
				  INNER JOIN compra_anulada_detalle cad
				  ON ca.id = cad.id_compra_anulada

				  WHERE ca.fecha_anulacion >= $S$ || quote_literal (fecha_inicio) || $S$ AND ca.fecha_anulacion < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
				  GROUP BY barcode) AS compras_anuladas
	        ON p.barcode = compras_anuladas.barcode

       		-- Las Ventas hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_vendida, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	      	  INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  WHERE v.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND v.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			  	  GROUP BY barcode) AS ventas
		ON p.barcode = ventas.barcode

       	        -- Las anulaciones de venta hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_anulada, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	          INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  INNER JOIN venta_anulada va
			    	  ON va.id_sale = v.id

				  WHERE va.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND va.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			          GROUP BY barcode) AS ventas_anuladas
                ON p.barcode = ventas_anuladas.barcode

		-- Las Ventas (de compuestos) menos sus anulaciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vmcd.cantidad) AS cantidad_vmcd, vmcd.barcode_componente AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta_mc_detalle vmcd
				  INNER JOIN venta v ON vmcd.id_venta_vd = v.id

			  	  WHERE vmcd.id_venta_vd NOT IN (SELECT id_sale FROM venta_anulada)
				  AND v.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND v.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			  	  GROUP BY barcode_componente) AS ventas_mcd
		ON p.barcode = ventas_mcd.barcode

	        -- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT barcode, SUM(unidades) AS unidades_merma
       	     	                  FROM merma m

		         	  WHERE m.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND m.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			          GROUP BY barcode) AS merma
	        ON p.barcode = merma.barcode

		-- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT mmcd.barcode_componente AS barcode, SUM(mmcd.cantidad) AS unidades_merma_mcd
       	     	                  FROM merma m
				  INNER JOIN merma_mc_detalle mmcd
				  ON m.id = mmcd.id_merma

		         	  WHERE m.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND m.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			          GROUP BY barcode_componente) AS merma_mcd
	        ON p.barcode = merma_mcd.barcode

                -- Las devoluciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT dd.barcode AS barcode, SUM(dd.cantidad) AS cantidad_devolucion
       	     	                  FROM devolucion d
		 	          INNER JOIN devolucion_detalle dd
			 	  ON d.id = dd.id_devolucion

			          WHERE d.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND d.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
			          GROUP BY barcode) AS devolucion
                ON p.barcode = devolucion.barcode

	        -- Los traspasos enviados hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND t.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
				  AND t.origen = 1
			          GROUP BY barcode) AS traspaso_envio
                ON p.barcode = traspaso_envio.barcode

		-- Los traspasos enviados (a traves de un compuesto) hasta la fecha determinada
		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND t.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
				  AND t.origen = 1
			          GROUP BY barcode_componente) AS traspaso_mc_envio
                ON p.barcode = traspaso_mc_envio.barcode

	        -- Los traspasos recibidos hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND t.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
				  AND t.origen != 1
			          GROUP BY barcode) AS traspaso_recibido
                ON p.barcode = traspaso_recibido.barcode

		-- Los traspasos recibidos (a traves de un compuesto) hasta la fecha determinada
       		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha >= $S$ || quote_literal (fecha_inicio) || $S$ AND t.fecha < $S$ || quote_literal (fecha_inicio+'1 days') || $S$
				  AND t.origen != 1
			          GROUP BY barcode_componente) AS traspaso_mc_recibido
                ON p.barcode = traspaso_mc_recibido.barcode

                WHERE p.estado = true
		AND (p.tipo = $S$ || corriente || $S$
		     OR p.tipo = $S$ || materia_prima || $S$ ) $S$ ;

IF barcode_in != 0 THEN
    q := q || $S$ AND p.barcode = $S$ || barcode_in;
END IF;

FOR l IN EXECUTE q LOOP
    barcode_out := l.barcode;
    movimiento_out := COALESCE(l.cantidad_ingresada,0) - COALESCE(l.cantidad_c_anuladas,0) - COALESCE(l.cantidad_vendida,0) - COALESCE(l.cantidad_vmcd,0) - COALESCE(l.unidades_merma,0) + COALESCE(l.cantidad_anulada,0) - COALESCE(l.cantidad_devolucion,0) - COALESCE(l.cantidad_envio,0) + COALESCE(l.cantidad_recibida,0);
    costo_promedio_en_fecha_out := COALESCE(l.costo_fecha,0);
    RETURN NEXT;
END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION movimiento_en_periodo (IN fecha_inicio_in timestamp,
       	  	  	   	      	     	  IN fecha_final_in timestamp,
					          IN barcode_in bigint,
       					     	  OUT fecha_out timestamp,
       					     	  OUT stock_fecha_out double precision,
						  OUT valor_stock_fecha_out double precision,
						  OUT cantidad_vendida_fecha_out double precision,
						  OUT monto_venta_fecha_out double precision)
RETURNS SETOF record AS $$
DECLARE
	q text;
	l record;
	costo_fecha double precision;
BEGIN
	fecha_out := fecha_inicio_in;
	stock_fecha_out := 0;
	valor_stock_fecha_out := 0;
	cantidad_vendida_fecha_out := 0;
	monto_venta_fecha_out := 0;
	costo_fecha := 0;

	--TODO: buscar la forma de usar producto_en_fecha una sola vez y los demás días usar movimiento_en_fecha
	-- Se recorre día a día el rango de fecha
	WHILE fecha_out <= fecha_final_in LOOP
	      -- q := $S$ SELECT barcode_out, movimiento_out, costo_promedio_en_fecha_out FROM movimiento_en_fecha ($S$||quote_literal(fecha_out)||$S$,$S$||barcode_in||$S$)$S$;
	      q := $S$ SELECT barcode, costo_fecha, COALESCE (cantidad_fecha,0) AS cantidad_fecha, COALESCE (cantidad_vendida_out,0) AS c_vendido, COALESCE (precio_vendido_out,0) AS m_vendido
	      	       FROM producto_en_fecha2 ($S$||quote_literal(fecha_out+'1 days')||$S$,$S$||barcode_in||$S$) AS pf
		       LEFT JOIN ventas_en_fecha ($S$||quote_literal(fecha_out)||$S$,$S$||barcode_in||$S$) AS vf
		       ON pf.barcode::bigint = vf.barcode_out $S$;

   	      FOR l IN EXECUTE q LOOP
		  stock_fecha_out := l.cantidad_fecha;

		  -- Se obtiene el costo promedio del producto a esa fecha
		  -- SELECT COALESCE (fcd.costo_promedio, 0) INTO costo_fecha
		  -- 	 FROM factura_compra_detalle fcd
		  -- 	 INNER JOIN factura_compra fc
		  -- 	       ON fcd.id_factura_compra = fc.id
		  -- 	 WHERE fc.fecha < fecha_out+'1 days'
		  -- 	       AND fcd.barcode = l.barcode::bigint
		  -- 	 ORDER BY fcd.id_factura_compra DESC
		  -- 	 LIMIT 1;

		  costo_fecha := l.costo_fecha;

		  valor_stock_fecha_out := COALESCE (stock_fecha_out*costo_fecha, 0);

		  -- SELECT INTO cantidad_vendida_fecha_out, monto_venta_fecha_out
		  --     	      COALESCE (cantidad_vendida_out,0), COALESCE (precio_vendido_out,0)
                  -- FROM ventas_en_fecha (fecha_out, l.barcode::bigint);

		  cantidad_vendida_fecha_out := l.c_vendido;
		  monto_venta_fecha_out := l.m_vendido;
		  RETURN NEXT;
	    END LOOP;

    	fecha_out := fecha_out + '1 days';
	END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION mustan.f1() RETURNS DATE AS $$
BEGIN
	return '20080101';
END;
$$LANGUAGE plpgsql;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f1() RETURNS DATE AS $$
BEGIN
	return '20080101';
END;
$$LANGUAGE plpgsql;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f2() RETURNS DATE AS $$
BEGIN
	return '20080101';
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f2() RETURNS DATE AS $$
BEGIN
	return '20080101';
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f3() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT '20080101' INTO out_dt;
	return '20080101';
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f3() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT '20080101' INTO out_dt;
	return '20080101';
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f4() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT '20080101' INTO out_dt FROM mustan.test WHERE id=2;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f4() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT '20080101' INTO out_dt FROM mustan.test WHERE id=2;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f5() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE id=2;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f5() RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE id=2;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f6( n int ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE id=n;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f6( n int ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE id=n;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f7( d date ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE d=d;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f7( d date ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE d=d;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d date ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d date ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d text ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	-- SELECT d INTO out_dt FROM mustan.test WHERE d=cast( in_d as date );
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d::date;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d text ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	-- SELECT d INTO out_dt FROM mustan.test WHERE d=cast( in_d as date );
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d::date;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d text ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	---SELECT d INTO out_dt FROM mustan.test WHERE d=cast( in_d as date );
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d::date;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras.out
"CREATE OR REPLACE FUNCTION mustan.f7( in_d text ) RETURNS DATE AS $$
DECLARE
	out_dt date;
BEGIN
	---SELECT d INTO out_dt FROM mustan.test WHERE d=cast( in_d as date );
	SELECT d INTO out_dt FROM mustan.test WHERE d=in_d::date;
	return out_dt;
END;
$$LANGUAGE plpgsql immutable;",qp_misc_jiras_optimizer.out
"CREATE OR REPLACE FUNCTION net_manip.id_tag()
RETURNS VARCHAR AS $$
BEGIN
	RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_base
	(
	p_ip_address		in		inet,
	p_bits			in		integer
	)
RETURNS inet AS $$
DECLARE
	host inet;
BEGIN
	host = set_masklen(p_ip_address, p_bits);
	return network(host);
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_bits_to_mask
	(
	p_bits				in integer
	)
RETURNS inet AS $$
BEGIN
	IF p_bits > 32 OR p_bits < 0 THEN
		RAISE EXCEPTION 'Value for p_bits must be between 0 and 32';
	END IF;
		
	RETURN( netmask(cast('0.0.0.0/' || p_bits AS inet)) );
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_dbtop
(
	p_ip_address			in inet
)
RETURNS inet AS $$
BEGIN
	return( host(p_ip_address) );
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_is_private
	(
	p_ip_address		in		inet
	)
RETURNS boolean AS $$
BEGIN
	IF( family(p_ip_address) = 4) THEN
		IF ('192.168/16' >> p_ip_address) THEN
			RETURN(true);
		END IF;
		IF ('10/8' >> p_ip_address) THEN
			RETURN(true);
		END IF;
		IF ('172.16/12' >> p_ip_address) THEN
			RETURN(true);
		END IF;
	else
		IF ('FC00::/7' >> p_ip_address) THEN
			RETURN(true);
		END IF;
	END IF;

	RETURN(false);
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_is_private_yn
	(
	p_ip_address		  in		  inet
	)
RETURNS char AS $$
BEGIN
	IF (net_manip.inet_is_private(p_ip_address)) THEN
		RETURN 'Y';
	ELSE
		RETURN 'N';
	END IF;
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_mask_to_bits
	(
	p_netmask			in inet
	)
RETURNS integer AS $$
BEGIN
	IF family(p_netmask) = 6 THEN
		RAISE EXCEPTION 'Netmask is not supported for IPv6 addresses';
	END IF;
	RETURN (32-log(2, 4294967296 - net_manip.inet_dbton(p_netmask)))::integer;
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_ptodb
(
	p_ip_address			in inet
)
RETURNS inet AS $$
BEGIN
	return(p_ip_address);
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION net_manip.inet_ptodb
(
	p_ip_address			in inet,
	p_netmask_bits			in integer
)
RETURNS inet AS $$
BEGIN
	return(set_masklen(p_ip_address, p_netmask_bits));
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_id(
	in_IpAddress netblock.ip_address%type,
	in_Netmask_Bits netblock.NETMASK_BITS%type,
	in_netblock_type netblock.netblock_type%type,
	in_ip_universe_id ip_universe.ip_universe_id%type,
	in_is_single_address netblock.is_single_address%type
) RETURNS netblock.netblock_id%type AS $$
DECLARE
	par_nbid	netblock.netblock_id%type;
BEGIN
	in_IpAddress := set_masklen(in_IpAddress, in_Netmask_Bits);
	select  Netblock_Id
	  into	par_nbid
	  from  ( select Netblock_Id, Ip_Address, Netmask_Bits
		    from netblock
		   where
		   	in_IpAddress <<= ip_address
		    and is_single_address = 'N'
			and netblock_type = in_netblock_type
			and ip_universe_id = in_ip_universe_id
		    and (
				(in_is_single_address = 'N' AND netmask_bits < in_Netmask_Bits)
				OR
				(in_is_single_address = 'Y' AND netmask_bits = in_Netmask_Bits)
			)
		order by netmask_bits desc
	) subq LIMIT 1;

	return par_nbid;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;",v28tov29.sql
"CREATE OR REPLACE FUNCTION netblock_utils.find_best_parent_id(
	in_netblock_id netblock.netblock_id%type
) RETURNS netblock.netblock_id%type AS $$
DECLARE
	nbrec		RECORD;
BEGIN
	SELECT * INTO nbrec FROM netblock WHERE netblock_id = in_netblock_id;

	RETURN netblock_utils.find_best_parent_id(
		nbrec.ip_address,
		nbrec.netmask_bits,
		nbrec.netblock_type,
		nbrec.ip_universe_id,
		nbrec.is_single_address
	);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;",v28tov29.sql
"CREATE OR REPLACE FUNCTION netblock_utils.find_rvs_zone_from_netblock_id(
	in_netblock_id	netblock.netblock_id%type
) RETURNS dns_domain.dns_domain_id%type AS $$
DECLARE
	v_rv	dns_domain.dns_domain_id%type;
	v_domid	dns_domain.dns_domain_id%type;
	v_lhsip	netblock.ip_address%type;
	v_rhsip	netblock.ip_address%type;
	nb_match CURSOR ( in_nb_id netblock.netblock_id%type) FOR
		-- The query used to include this in the where clause, but
		-- oracle was uber slow 
		--	net_manip.inet_base(nb.ip_address, root.netmask_bits) =  
		--		net_manip.inet_base(root.ip_address, root.netmask_bits) 
		select  rootd.dns_domain_id,
				 net_manip.inet_base(nb.ip_address, root.netmask_bits),
				 net_manip.inet_base(root.ip_address, root.netmask_bits)
		  from  netblock nb,
			netblock root
				inner join dns_record rootd
					on rootd.netblock_id = root.netblock_id
					and rootd.dns_type = 'REVERSE_ZONE_BLOCK_PTR'
		 where
		  	nb.netblock_id = in_nb_id;
BEGIN
	v_rv := NULL;
	OPEN nb_match(in_netblock_id);
	LOOP
		FETCH  nb_match INTO v_domid, v_lhsip, v_rhsip;
		if NOT FOUND THEN
			EXIT;
		END IF;

		if v_lhsip = v_rhsip THEN
			v_rv := v_domid;
			EXIT;
		END IF;
	END LOOP;
	CLOSE nb_match;
	return v_rv;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;",v28tov29.sql
"CREATE OR REPLACE FUNCTION netblock_utils.id_tag()
RETURNS VARCHAR AS $$
BEGIN
	RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION new_sof_sol_des(id_des integer,search_ text,order_ integer,start_ integer,length_ integer)
  RETURNS json AS
$BODY$
begin 
	return (SELECT COALESCE(array_to_json(array_agg(row_to_json(p))), '[]') from (
		select s.id,sf.nombre,u.first_name||' '||u.last_name as nom, u.email,case when s.estado = false then
		  'Solicitado' 
		  else
		   'Comfirmado' 
		   end as estado from bee_software as sf 

		 join bee_solicitud as s on (s.software_id=sf.id and sf.desarrollador_id=id_des)
		 join usr_cliente as c on(c.usuario_id=s.cliente_id) 
		 join auth_user as u on(u.id = c.usuario_id)
		 
		left join bee_desarrollos_softwares as ds on (sf.id=sf.id) 
		left join bee_desarrollos as d on(ds.software_id = sf.id) 
		where sf.nombre like '%'||search_||'%' or u.first_name like '%'||search_||'%' or u.last_name like '%'||search_||'%' or u.email  like '%'||search_||'%' order by s.estado limit length_ offset start_
	) p);
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",covi.sql
"CREATE OR REPLACE FUNCTION notaDePelicula(idPeliculap int) RETURNS int AS 
$$
DECLARE	
	numeroTotal int default 0;
	porcentaje int default 0;
	numeroNegativos int default 0;
	r record;
	c CURSOR FOR SELECT * FROM 
			(select * from dbLink('host = localhost user= postgres password= 12345 dbname= multimedia',
			'SELECT descripcion FROM comentario  where idPelicula = '''||idPeliculap||'''')
			as estudiantes(descripcion varchar(500)))as comentarios;	
BEGIN	
	FOR r IN c LOOP		
		numeroTotal= numeroTotal + 1;
		
		RAISE NOTICE 'descripcion: %', r.descripcion;			
		if r.descripcion similar to '%esta bien fe%' 			or r.descripcion similar to '%no esta para nada bonit%' 	or r.descripcion similar to '%esta fe%' 
			or r.descripcion similar to '%esta bien fe%'    	or r.descripcion similar to '%esta aburrid%'			or r.descripcion similar to '%estuvo aburrid%'
			or r.descripcion similar to '%esta horrible%'   	or r.descripcion similar to '%estuvo horrible%' 		or r.descripcion similar to '%no me gusto%' 
			or r.descripcion similar to '%no me encanto%'   	or r.descripcion similar to '%no es atractiv%' 			or r.descripcion similar to '%no es genial%' 
			or r.descripcion similar to '%no es para nada genial%'  or r.descripcion similar to '%no es en lo absoluto genial%' 
			or r.descripcion similar to '%no posee nada atractiv%'  or r.descripcion similar to '%no estaba bueno%'
			
			THEN
			numeroNegativos= numeroNegativos + 1;
		end if;

		porcentaje = ((numeroTotal-numeroNegativos) * 100) / numeroTotal;
				
	END LOOP;
	RETURN porcentaje;
END;
$$ LANGUAGE plpgsql;",postgresProyecto.sql
"CREATE OR REPLACE FUNCTION obtener_costo_promedio_desde_barcode ( IN codigo_barras bigint,
       	  	  	   			      		  OUT costo double precision)
RETURNS double precision AS $$
DECLARE
	list record;
	sub_list record;
	query text;

	corriente_l int4;
	compuesta_l int4;
	derivada_l int4;
	materia_prima_l int4;
	tipo_l int4;
	costo_l double precision;
BEGIN
	SELECT id INTO corriente_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'CORRIENTE';
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';
	SELECT id INTO derivada_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'DERIVADA';
	SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';
	SELECT tipo INTO tipo_l FROM producto WHERE barcode = codigo_barras;

	costo := 0;

	-- PROCEDIMIENTOS SEGÚN EL TIPO DE LA MERCADERIA
	-- SI ES COMPUESTA O DERIVADA
	IF (tipo_l = compuesta_l OR tipo_l = derivada_l) THEN
	   WITH RECURSIVE compuesta (barcode_complejo, barcode_componente, tipo_componente, cant_mud) AS
		(
		  SELECT barcode_complejo, barcode_componente, tipo_componente, cant_mud
		  FROM componente_mc WHERE barcode_complejo = codigo_barras
	 	  UNION ALL
	 	  SELECT componente_mc.barcode_complejo, componente_mc.barcode_componente,
		         componente_mc.tipo_componente,
		      	 componente_mc.cant_mud * compuesta.cant_mud
	          FROM componente_mc, compuesta
		  WHERE componente_mc.barcode_complejo = compuesta.barcode_componente
		)
	   SELECT SUM((SELECT * FROM obtener_costo_promedio_desde_barcode (barcode_componente))
	   	      	      	     					  * compuesta.cant_mud) INTO costo_l
	   FROM compuesta
	   WHERE tipo_componente != compuesta_l
	   AND tipo_componente != derivada_l;

	-- SI ES CORRIENTE
	ELSIF (tipo_l = corriente_l OR tipo_l = materia_prima_l) THEN
	   SELECT costo_promedio INTO costo_l FROM producto WHERE barcode = codigo_barras;
	END IF;

	costo := costo_l;

RETURN; -- Retorna el costo del producto
END; $$ language plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION obtener_stock_desde_barcode ( IN codigo_barras bigint,
       	  	  	   		   	         OUT disponible double precision)
RETURNS double precision AS $$
DECLARE
	list record;
	query text;

	menor_l double precision;
	contador_l int4;
	unidades_l int4;

	tipo_l int4;
	derivada_l int4;
	compuesta_l int4;
	corriente_l int4;
	materia_prima_l int4;

	cant_mud_l double precision;
	stock_l double precision;
	disponible_l double precision;
BEGIN
	SELECT id INTO derivada_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'DERIVADA';
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';
	SELECT id INTO corriente_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'CORRIENTE';
	SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';
	SELECT tipo INTO tipo_l FROM producto WHERE barcode = codigo_barras;

	disponible := 0;
	contador_l := 0;

	-- SI LA MERCADERÍA ES COMPUESTA
	IF (tipo_l = compuesta_l OR tipo_l = derivada_l) THEN
	   -- SE OBTIENE LA CANTIDAD QUE REQUERIDA DE TODOS LOS PRODUCTOS SIMPLES (CORRIENTES) O MATERIAS PRIMAS
	   query := $S$
	   	    WITH RECURSIVE compuesta (barcode_complejo, barcode_componente, tipo_componente, cant_mud) AS
		    (
		     SELECT barcode_complejo, barcode_componente, tipo_componente, cant_mud
		     FROM componente_mc WHERE barcode_complejo = $S$ || codigo_barras || $S$
	 	     UNION ALL
	 	     SELECT componente_mc.barcode_complejo, componente_mc.barcode_componente,
		     	    componente_mc.tipo_componente,
		    	    componente_mc.cant_mud * compuesta.cant_mud
	             FROM componente_mc, compuesta
		     WHERE componente_mc.barcode_complejo = compuesta.barcode_componente
		    )
		    SELECT barcode_componente, tipo_componente, SUM(compuesta.cant_mud) AS cantidad
		    FROM compuesta
		    WHERE tipo_componente != $S$ || compuesta_l || $S$ AND tipo_componente != $S$ || derivada_l || $S$
		    GROUP BY barcode_componente, tipo_componente$S$;

	   -- OBTENER EL STOCK DE SUS COMPONENTES Y VER PARA CUANTOS COMPUESTOS ALCANZAN
	   FOR list IN EXECUTE query LOOP
	       -- Calcula las unidades disponibles de la mercadería para este compuesto
	       IF (list.tipo_componente = corriente_l OR list.tipo_componente = materia_prima_l) THEN
	       	  stock_l := (SELECT * FROM obtener_stock_desde_barcode (list.barcode_componente));
	       	  unidades_l := TRUNC (stock_l / list.cantidad);
	       END IF;

	       -- Elige la cantidad menor como su stock
	       IF (contador_l = 0 OR menor_l > unidades_l) THEN
	       	  menor_l := unidades_l;
	       END IF;

	       contador_l := contador_l + 1;
	   END LOOP;

	   IF (menor_l >= 0) THEN
	      disponible_l := menor_l;
           END IF;

	-- SI ES UNA MERCADERÍA CORRIENTE
	ELSIF (tipo_l = corriente_l  OR tipo_l = materia_prima_l) THEN
	   disponible_l := (SELECT stock FROM producto WHERE barcode = codigo_barras);
	END IF;

	disponible := disponible_l;

RETURN; -- Retorna el valor de ""disponible""
END; $$ language plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION oid_to_bytea(val oid)
returns bytea as $$
declare merged bytea;
declare arr bytea;
 BEGIN
   FOR arr IN SELECT data from pg_largeobject WHERE loid = val ORDER BY pageno LOOP
     IF merged IS NULL THEN
       merged := arr;
     ELSE
       merged := merged || arr;
     END IF;
   END LOOP;
  RETURN merged;

END
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION oid_to_bytea(val oid) 
returns bytea as $$
declare merged bytea;
declare arr bytea;
 BEGIN  
   FOR arr IN SELECT data from pg_largeobject WHERE loid = val ORDER BY pageno LOOP
     IF merged IS NULL THEN
       merged := arr;
     ELSE
       merged := merged || arr;
     END IF;
   END LOOP;
  RETURN merged;

END  
$$ LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION parse_explain(IN query text, 
-- http://stackoverflow.com/questions/7682102/putting-explain-results-into-a-table
OUT startup numeric,
OUT totalcost numeric, 
OUT planrows numeric, 
OUT planwidth numeric,
OUT type text)
AS
$BODY$
DECLARE
    query_explain  text;
    explanation       xml;
    nsarray text[][];
BEGIN
nsarray := ARRAY[ARRAY['x', 'http://www.postgresql.org/2009/explain']];
query_explain :=e'EXPLAIN(FORMAT XML) ' || query;
EXECUTE query_explain INTO explanation;
startup := (xpath('/x:explain/x:Query/x:Plan/x:Startup-Cost/text()', explanation, nsarray))[1];
totalcost := (xpath('/x:explain/x:Query/x:Plan/x:Total-Cost/text()', explanation, nsarray))[1];
planrows := (xpath('/x:explain/x:Query/x:Plan/x:Plan-Rows/text()', explanation, nsarray))[1];
planwidth := (xpath('/x:explain/x:Query/x:Plan/x:Plan-Width/text()', explanation, nsarray))[1];
type      := (xpath('/x:explain/x:Query/x:Plan/x:Node-Type/text()', explanation, nsarray))[1];
RETURN;
END;
$BODY$
LANGUAGE plpgsql;",index.html
"CREATE OR REPLACE FUNCTION paymentallocated(
    p_c_payment_id integer,
    p_c_currency_id integer)
  RETURNS numeric AS
$BODY$
BEGIN
    RETURN paymentallocated(p_c_payment_id, p_c_currency_id, null::timestamp);
END;

$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION paymentavailable(
    p_c_payment_id integer,
    dateto timestamp without time zone)
  RETURNS numeric AS
$BODY$
DECLARE
v_Currency_ID INTEGER;
v_AvailableAmt NUMERIC := 0;
  v_IsReceipt CHARACTER(1);
  v_Amt NUMERIC := 0;
  r RECORD;
v_Charge_ID INTEGER;
v_ConversionType_ID INTEGER;
v_allocatedAmt NUMERIC; -- candida alocada total convertida a la moneda de la linea
v_DateAcct timestamp without time zone;
BEGIN
BEGIN

SELECT C_Currency_ID, PayAmt, IsReceipt,
C_Charge_ID,C_ConversionType_ID, DateAcct
INTO STRICT
v_Currency_ID, v_AvailableAmt, v_IsReceipt,
v_Charge_ID,v_ConversionType_ID, v_DateAcct
FROM C_Payment
WHERE C_Payment_ID = p_C_Payment_ID;
EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE 'PaymentAvailable - %', SQLERRM;
RETURN NULL;
END;

IF (v_Charge_ID > 0 ) THEN
RETURN 0;
END IF;

v_allocatedAmt := 0;
FOR r IN
SELECT a.AD_Client_ID, a.AD_Org_ID, al.Amount, a.C_Currency_ID, a.DateTrx
FROM C_AllocationLine al
INNER JOIN C_AllocationHdr a ON (al.C_AllocationHdr_ID=a.C_AllocationHdr_ID)
WHERE al.C_Payment_ID = p_C_Payment_ID
  AND a.IsActive='Y'
  AND (dateTo IS NULL OR a.dateacct::date <= dateTo::date)
LOOP
v_Amt := currencyConvert(r.Amount, r.C_Currency_ID, v_Currency_ID,
v_DateAcct, v_ConversionType_ID, r.AD_Client_ID, r.AD_Org_ID);
v_allocatedAmt := v_allocatedAmt + v_Amt;
END LOOP;

-- esto supone que las alocaciones son siempre no negativas; si esto no pasa, se van a retornar valores que no van a tener sentido
v_AvailableAmt := ABS(v_AvailableAmt) - abs(v_allocatedAmt);
-- v_AvailableAmt aca DEBE ser NO Negativo si admeas, las suma de las alocaciones nunca superan el monto del pago
-- de cualquiera manera, por ""seguridad"", si el valor es negativo, se corrige a cero
IF (v_AvailableAmt < 0) THEN
RAISE NOTICE 'Payment Available negative, correcting to zero - %',v_AvailableAmt ;
v_AvailableAmt := 0;
END IF;

v_AvailableAmt := currencyRound(v_AvailableAmt,v_Currency_ID,NULL);
RETURN v_AvailableAmt;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION paymentavailable(
  p_c_payment_id integer,
  dateto timestamp without time zone)
  RETURNS numeric AS
$BODY$
DECLARE
v_Currency_ID INTEGER;
v_AvailableAmt NUMERIC := 0;
  v_IsReceipt CHARACTER(1);
  v_Amt NUMERIC := 0;
  r RECORD;
v_Charge_ID INTEGER;
v_ConversionType_ID INTEGER;
v_allocatedAmt NUMERIC; -- candida alocada total convertida a la moneda de la linea
v_DateAcct timestamp without time zone;
BEGIN
BEGIN

SELECT C_Currency_ID, PayAmt, IsReceipt,
C_Charge_ID,C_ConversionType_ID, DateAcct
INTO STRICT
v_Currency_ID, v_AvailableAmt, v_IsReceipt,
v_Charge_ID,v_ConversionType_ID, v_DateAcct
FROM C_Payment
WHERE C_Payment_ID = p_C_Payment_ID;
EXCEPTION
WHEN OTHERS THEN
  RAISE NOTICE 'PaymentAvailable - %', SQLERRM;
RETURN NULL;
END;

IF (v_Charge_ID > 0 ) THEN
RETURN 0;
END IF;

v_allocatedAmt := 0;
FOR r IN
SELECT a.AD_Client_ID, a.AD_Org_ID, al.Amount, a.C_Currency_ID, a.DateTrx
FROM C_AllocationLine al
INNER JOIN C_AllocationHdr a ON (al.C_AllocationHdr_ID=a.C_AllocationHdr_ID)
WHERE al.C_Payment_ID = p_C_Payment_ID
  AND a.IsActive='Y'
  AND (dateTo IS NULL OR a.dateacct::date <= dateTo::date)
LOOP
v_Amt := currencyConvert(r.Amount, r.C_Currency_ID, v_Currency_ID,
v_DateAcct, v_ConversionType_ID, r.AD_Client_ID, r.AD_Org_ID);
v_allocatedAmt := v_allocatedAmt + v_Amt;
END LOOP;

-- esto supone que las alocaciones son siempre no negativas; si esto no pasa, se van a retornar valores que no van a tener sentido
v_AvailableAmt := ABS(v_AvailableAmt) - v_allocatedAmt;
-- v_AvailableAmt aca DEBE ser NO Negativo si admeas, las suma de las alocaciones nunca superan el monto del pago
-- de cualquiera manera, por ""seguridad"", si el valor es negativo, se corrige a cero
IF (v_AvailableAmt < 0) THEN
RAISE NOTICE 'Payment Available negative, correcting to zero - %',v_AvailableAmt ;
v_AvailableAmt := 0;
END IF;

v_AvailableAmt := currencyRound(v_AvailableAmt,v_Currency_ID,NULL);
RETURN v_AvailableAmt;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION plproxy.get_cluster_config(
    in cluster_name text,
    out key text,
    out val text)
RETURNS SETOF record AS $$
BEGIN
    -- lets use same config for all clusters
    key := 'connection_lifetime';
    val := 30*60; -- 30m
    RETURN NEXT;
    RETURN;
END;
$$ LANGUAGE plpgsql;",plproxy
"CREATE OR REPLACE FUNCTION plproxy.get_cluster_version(cluster_name text)
RETURNS int4 AS $$
BEGIN
    IF cluster_name = 'MyCluster' THEN
        RETURN 1;
    END IF;
    RAISE EXCEPTION 'Unknown cluster';
END;
$$ LANGUAGE plpgsql;",plproxy.txt
"CREATE OR REPLACE FUNCTION plproxy.get_cluster_version(cluster_name text)
RETURNS int4 AS $$
BEGIN
    IF cluster_name = 'science_cluster' THEN
        RETURN 1;
    END IF;
    RAISE EXCEPTION 'Unknown cluster';
END;
$$ LANGUAGE plpgsql;",plproxy
"CREATE OR REPLACE FUNCTION pmt_purge_activities(a_id int[]) RETURNS boolean AS $$
DECLARE
  record_id int;
  error_msg text;
BEGIN 
  -- no parameter is provided, exit
  IF $1 IS NULL THEN    
    RETURN FALSE;
  END IF;
 
  IF array_length(a_id,1)>0 THEN
    -- loop through all the activity_ids and purge each activity
    FOREACH record_id IN ARRAY a_id LOOP
      EXECUTE 'SELECT * FROM pmt_purge_activity(' || record_id || ')';
    END LOOP;
  ELSE
    -- exit if array is empty
    RETURN FALSE;
  END IF;
  -- success
  RETURN TRUE;

EXCEPTION
  -- some type of error occurred, return unsuccessful
     WHEN others THEN 
       GET STACKED DIAGNOSTICS error_msg = MESSAGE_TEXT;
       RAISE NOTICE 'Error: %', error_msg;
       RETURN FALSE;
END;  
$$ LANGUAGE 'plpgsql';",cs_.3.0.10.4.sql
"CREATE OR REPLACE FUNCTION pmt_user_salt(username text) RETURNS text AS $$
DECLARE 
  salt text;
BEGIN 
  SELECT INTO salt substring(_password from 1 for 29) from users where _username = $1;
  RETURN salt;
END; 
$$ LANGUAGE 'plpgsql';",cs_.3.0.10.4.sql
"CREATE OR REPLACE FUNCTION pr_next_id(OUT next_number character varying)
RETURNS character varying AS
$BODY$
declare  myyear char(4);
declare  ii integer;
declare  tmp1 varchar(10);
declare  tmp2 char(10);
BEGIN
   MYYEAR = CAST(EXTRACT(YEAR FROM LOCALTIMESTAMP) AS CHAR(4));
   select CAST(nextval('NUMGEN') AS varchar(10)) into TMP1;
   TMP2 = '0000000000';
   II = length(TMP1);
   NEXT_NUMBER = SSUBSTR(MYYEAR,3,4) || SSUBSTR(TMP2,1,10 - II) || TMP1;
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE
COST 100;",2008-September.txt
"CREATE OR REPLACE FUNCTION prunedata() RETURNS void
    AS $$
DECLARE
BEGIN
	PERFORM prunedatabase();

	PERFORM pruneplugloaddatabase();

	PERFORM pruneemsaudit();

	PERFORM prune_ems_user_audit();

	PERFORM pruneeventsfault();

END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION prunedata() RETURNS void
    AS $$
DECLARE 	
BEGIN
	PERFORM prunedatabase();
	
	--PERFORM pruneplugloaddatabase();

	PERFORM pruneemsaudit();
	
	PERFORM prune_ems_user_audit();
	
	PERFORM pruneeventsfault();

END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION prunedata() RETURNS void
    AS $$
DECLARE 	
BEGIN
	PERFORM prunedatabase();
	
	PERFORM pruneplugloaddatabase();

	PERFORM pruneemsaudit();
	
	PERFORM prune_ems_user_audit();
	
	PERFORM pruneeventsfault();

END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION prunedata() RETURNS void
    AS $$
DECLARE 	
BEGIN
	PERFORM prunedatabase();

	PERFORM pruneemsaudit();
	
	PERFORM prune_ems_user_audit();
	
	PERFORM pruneeventsfault();

END;
$$
LANGUAGE plpgsql;",upgradeSQL.sql
"CREATE OR REPLACE FUNCTION public.Odoo9_to_Odoo11(
	)
    RETURNS interval
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE 
AS $BODY$

 DECLARE cnt INT DEFAULT 0;
 DECLARE max_id INT DEFAULT 0; 
 DECLARE age_value interval ;
 DECLARE ret_val interval ;
 DECLARE start_time TIME ;
 DECLARE end_time TIME ;
BEGIN
start_time:=CLOCK_TIMESTAMP();


ret_val=public.fdw_connect_setup('192.168.0.181', '5432', 'odoo9_14062018', 'postgres', 'root123', 'public', 'odoo9');
RAISE NOTICE 'Postgres_FDW executed successfully in the span of : % ',ret_val;
IF ret_val IS NOT NULL  THEN 
	ret_val=public.emp_module_function();
	RAISE NOTICE 'Employee module function completed in the span of : % ',ret_val;
	ret_val=public.leaves_module_function();
	RAISE NOTICE 'Leave module function completed  in the span of : % ',ret_val;
	ret_val=public.sprint_module_function();
	RAISE NOTICE 'Sprint module function completed in the span of : % ',ret_val;
END IF;




select max(id)+1 into max_id from  public.mail_alias;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_alias_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_alias, now start with %\n',max_id;
END IF;

select max(id)+1 into max_id from  public.res_users;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.res_users_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for res_users, now start with %\n',max_id;
END IF;

select max(id)+1 into max_id from  public.hr_department;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_department_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_department, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.hr_employee;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_employee_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_employee, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.resource_resource;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.resource_resource_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for resource_resource, now start with %',max_id;
END IF;

 select max(id)+1 into max_id from  public.res_partner;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.res_partner_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for res_partner, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.hr_job;	
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_job_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_job, now start with %',max_id+1;
END IF;


select max(id)+1 into max_id from  public.hr_employee_category;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_employee_category_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.res_company;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.res_company_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for res_company, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.account_analytic_line;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.account_analytic_line_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for account_analytic_line, now start with %',max_id+1;
END IF;


select max(id)+1 into max_id from  public.res_config_settings;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.res_config_settings_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for res_config_settings, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.calendar_event;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.calendar_event_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for calendar_event, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.calendar_contacts;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.calendar_contacts_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for calendar_contacts, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.bus_presence;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.bus_presence_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for bus_presence, now start with %',max_id+1;
END IF;

RAISE NOTICE '******************** EMP_MODULE SEQUENCE CONFIGURATION COMPLETED **********************';

select max(id)+1 into max_id from  public.hr_holidays;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_holidays_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_holidays, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.hr_compoff;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_compoff_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_compoff, now start with %',max_id+1;
END IF;


select max(id)+1 into max_id from  public.hr_holidays_status;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_holidays_status_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_holidays_status, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.hr_holidays_summary_dept;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_holidays_summary_dept_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_holidays_summary_dept, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.hr_holidays_summary_employee;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.hr_holidays_summary_employee_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for hr_holidays_summary_employee, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.resource_calendar_leaves;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.resource_calendar_leaves_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for resource_calendar_leaves, now start with %',max_id+1;
END IF;

select max(id)+1 into max_id from  public.account_analytic_account;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.account_analytic_account_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for account_analytic_account, now start with %',max_id+1;
END IF;

RAISE NOTICE '******************** LEAVE MODULE SEQUENCE CONFIGURATION COMPLETED **********************';

select max(id)+1 into max_id from  public.resource_calendar;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.resource_calendar_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for resource_calendar, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.ir_attachment;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.ir_attachment_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for ir_attachment, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.project_task_type;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_task_type_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_task_type, now start with %',max_id;
END IF;


select max(id)+1 into max_id from  public.project_task;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_task_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_task, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.project_sprint;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_sprint_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_sprint, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.project_scrum_team;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_scrum_team_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_scrum_team, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.mail_template;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_template_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_template, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.project_tags;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_tags_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_tags, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.project_project;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.project_project_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for project_project, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.mail_message;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_message_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_message, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.mail_message_subtype;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_message_subtype_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_message_subtype, now start with %',max_id;
END IF;

RAISE NOTICE '******************** SPRINT AND PROJECT MODULE SEQUENCE CONFIGURATION COMPLETED **********************';

select max(id)+1 into max_id from  public.website_support_ticket;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.website_support_ticket_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for website_support_ticket, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.website_support_ticket_categories;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.website_support_ticket_categories_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for website_support_ticket_categories, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.website_support_ticket_priority;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.website_support_ticket_priority_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for website_support_ticket_priority, now start with %',max_id;
END IF;


RAISE NOTICE '******************** WEBSITE MODULE SEQUENCE CONFIGURATION COMPLETED **********************';
/*select max(id)+1 into max_id from  public.bus_bus;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.bus_bus_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for bus_bus, now start with %',max_id;
END IF;

select max(id)+1 into max_id from  public.mail_tracking_value;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_tracking_value_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_tracking_value, now start with %',max_id;
END IF;


select max(id)+1 into max_id from  public.mail_mail;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_mail_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_mail, now start with %',max_id;
END IF;


select max(id)+1 into max_id from  public.mail_followers;
IF max_id>1 THEN
	EXECUTE 'ALTER SEQUENCE public.mail_followers_id_seq RESTART WITH '||max_id
	USING max_id;
	RAISE NOTICE 'Sequence changed for mail_followers, now start with %',max_id;
END IF;
RAISE NOTICE '******************** EXTRA TABLES SEQUENCE CONFIGURATION COMPLETED **********************';
*/

DROP schema odoo9 CASCADE;

end_time:=CLOCK_TIMESTAMP();
age_value:=end_time-start_time;
	RETURN age_value;
	
	exception 
    when others then
        RAISE INFO 'Error Name:%',SQLERRM;
        RAISE INFO 'Error State:%', SQLSTATE;
        return age_value;
END

$BODY$;",HR_SEA9_to_SEA11_Migration.sql
"CREATE OR REPLACE FUNCTION public.check_predict(  
IN ov integer,   --  校验哪条记录  
OUT rv numeric,  --  真实值  
OUT pv numeric,  --  预测值  
OUT dev numeric, --  误差  
OUT zv numeric,  --  自变量  
OUT v_slope numeric, --  斜率  
OUT v_inter numeric, --  截距  
OUT v_r2  numeric  --  相关性  
)  
 RETURNS record  
 LANGUAGE plpgsql  
AS $function$  
declare   
  r2_1 numeric := 0; -- 相关性  
  r2_2 numeric := 0; -- 最大相关性  
  var int;           --  样本起点  
  inter_1 numeric;  --  截距  
  slope_1 numeric;  --  斜率  
  inter_2 numeric;  --  最大相关性截距  
  slope_2 numeric;  --  最大相关性斜率  
  realv numeric;    --  真实数据  
  predicv numeric;  --  预测数据  
  offset_var int := ov;   -- 倒数第?个值的预测值, 不停迭代, 最后计算所有的实际值和预测值的corr, 选择最佳相关?  
  v_cnt int8 := 0;  
  v_lmt int := 90;  --  使用的最大样本集, 影响预测准确度  
  v_min int := 5;   --  使用的最小样本数, 影响预测准确度  
  zcnt numeric := 0;    --  自变量  
begin  
  select count(*) into v_cnt from test;  
  
  --  自变量 t1  
  --  因变量 t2  
  
  --  筛选最大相关度的样本数, 并记录下储斜率, 截距.  
  for i in 0..v_lmt   
  loop  
    with t1 as (select row_number() over(order by id desc) as rn,* from (select id,lag(cnt,1) over(order by id) as zbl_cnt,cnt from test order by id desc offset offset_var limit v_lmt+v_min) t  
                where t.zbl_cnt is not null  
           )  
      select regr_intercept(t1.cnt,t1.zbl_cnt), regr_slope(t1.cnt,t1.zbl_cnt), regr_r2(t1.cnt,t1.zbl_cnt)   
        into inter_1,slope_1,r2_1  
      from t1  
      where t1.rn<=i+v_min;  
  
    if r2_1>r2_2 then   
      inter_2 := inter_1;  
      slope_2 := slope_1;  
      r2_2 := r2_1;  
      var := i+v_min;  
    end if;  
  end loop;  
  
  raise notice 'offset:%, 最大相关度样本数:%, 截距%, 斜率%, 相关性%', offset_var, var, round(inter_2,4), round(slope_2,4), round(r2_2,4);  
  select slope_2*cnt+inter_2, cnt into predicv,zcnt from test order by id desc offset offset_var limit 1;  
  
  --  offset_var=0的自变量, 表示最近一个值, 所以真实值还不存在, 那么realv=NULL  
  if  offset_var=0 then  
    realv := NULL;  
  else  
    select cnt into realv from test order by id desc offset offset_var-1 limit 1;  
  end if;  
  
  raise notice '自变量%, 真实数据%, 预测数据%, 本次预测偏差%%%', zcnt, realv, round(predicv,2), abs(1-round(predicv/realv,4))*100;  
  
  rv := realv;  
  pv := round(predicv,2);  
  dev := abs(1-round(predicv/realv,4));  
  zv  := zcnt;  
  v_slope := slope_2;  
  v_inter := inter_2;  
  v_r2 := r2_2;  
  
  return;  
end;  
$function$;",20150304_01.md
"CREATE OR REPLACE FUNCTION public.count_node(
    anyarray,
    node_id integer)
  RETURNS integer AS
$BODY$
                DECLARE
                  table_name text;
                  sel_count integer;
                  counter integer;
                BEGIN
                counter := 0;
                FOREACH table_name IN ARRAY $1
                LOOP
                  RAISE NOTICE 'processing table %',table_name;
                  EXECUTE format('
                 SELECT COUNT(*) FROM %I AS x
                    WHERE x.connection_node_start_id = %L
                    OR x.connection_node_end_id = %L'
                      , table_name, $2, $2)
                     INTO sel_count;
                  RAISE NOTICE 'counted % appearences of
                     connection_node_id % ', sel_count, $2;
                  counter := counter + sel_count;
                  IF counter > 1 THEN
                 EXIT;
                  END IF;
                END LOOP;
                RETURN counter;
                END
                $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",work_empty_schema_2018-12-21.sql
"CREATE OR REPLACE FUNCTION public.distancekm(
    lat1 double precision,
    lon1 double precision,
    lat2 double precision,
    lon2 double precision)
  RETURNS double precision AS
$BODY$
DECLARE                                                   
    x float = 111.12 * (lat2 - lat1);                           
    y float = 111.12 * (lon2 - lon1) * cos(lat1 / 92.215);        
BEGIN                                                     
    RETURN sqrt(x * x + y * y);                               
END  
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",createTables.txt
"CREATE OR REPLACE FUNCTION public.fdw_connect_setup(
	inhost text,
	infport text,
	infdb text,
	infuser text,
	infpwd text,
	infschema text,
	inlschema text)
    RETURNS interval
    LANGUAGE 'plpgsql'
    COST 100
    VOLATILE 
AS $BODY$

 DECLARE age_value interval ;
 DECLARE start_time TIME ;
 DECLARE end_time TIME ;
BEGIN

start_time:=CLOCK_TIMESTAMP();
	create schema odoo9;
    DROP EXTENSION  IF EXISTS  postgres_fdw CASCADE;
	CREATE EXTENSION postgres_fdw; 
	RAISE NOTICE ' Extension postgres_fdw created ';
	
    EXECUTE 'CREATE SERVER Odoo9_server
	FOREIGN DATA WRAPPER postgres_fdw
	OPTIONS (host ' ||quote_literal(inhost)||',port '||quote_literal(infport)||', dbname '||quote_literal(infdb)||')'
    USING inhost, infport,infdb;
    RAISE NOTICE ' Server Created Successfully ip: % ,port: % ,db: % ',inhost, infport,infdb;
	
    EXECUTE 'CREATE USER MAPPING FOR CURRENT_USER
	SERVER Odoo9_server
	OPTIONS (user '||quote_literal(infuser)||', password '||quote_literal(infpwd)||')'
	USING infuser, infpwd;
    RAISE NOTICE ' User Mapping Created Successfully user: % ,pwd: % ',infuser, infpwd;
	
	EXECUTE 'IMPORT FOREIGN SCHEMA '||infschema||'
	FROM SERVER Odoo9_server
	INTO '||inlschema
	USING infschema, inlschema;
	RAISE NOTICE ' Tables imported into : % from schema : % ',inlschema, infschema;
	
end_time:=CLOCK_TIMESTAMP();
age_value:=end_time-start_time;
	RETURN age_value;
END

$BODY$;",HR_SEA9_to_SEA11_Migration.sql
"CREATE OR REPLACE FUNCTION public.fun_nombreconstein (
  nom_constrin varchar
)
RETURNS varchar AS
$body$
declare
  tempo varchar;
  salida varchar;
  posuno integer;
  posdos integer;
  postres integer;  
  temp_nom_constrin1 varchar;
  temp_nom_constrin2 varchar;
begin
temp_nom_constrin1:=nom_constrin;
 tempo:='-1';
select   position('«' in nom_constrin) into posuno;
if (posuno>1) then
      select substring(temp_nom_constrin1 from position('«' in temp_nom_constrin1)+1 for length(temp_nom_constrin1)) into temp_nom_constrin2;
      temp_nom_constrin1:=temp_nom_constrin2;
      select   position('«' in temp_nom_constrin2) into postres;
      if (postres > 0) then
          posuno=postres;
          select substring(temp_nom_constrin1 from position('«' in temp_nom_constrin1)+1 for length(temp_nom_constrin1)) into temp_nom_constrin2;        
          temp_nom_constrin1:=temp_nom_constrin2;
      end if;
     select     position('»' in temp_nom_constrin1)    into posdos;  
     if (posdos>0) then          
      tempo=substring(temp_nom_constrin1 from 1 for posdos-1);
     end if;                
end if;

salida:=tempo;
/*
  if (posuno>0) then
     select     position('»' in nom_constrin)    into posdos;
  if (posdos>0) then
  posdos := posdos-posuno;          
           tempo=substring(nom_constrin from posuno+1 for posdos-1);
   else
           tempo:='-1';                     
    end if;     
       else  
       tempo:='-1';   
  end if; 
  */ 
 
 begin
   SELECT er.err_mensaje INTO STRICT salida 
   FROM public.g_erroresdb er
    where er.err_constrein=tempo;    
EXCEPTION
    WHEN NO_DATA_FOUND THEN
   salida:=nom_constrin;
     --  RAISE EXCEPTION 'NUM:%, DETAILS:%', SQLSTATE, SQLERRM;   
      
 end;  
      
   return salida;
    
   -- return '1'||tempo;
/*
  statements;
exception
when exception_name then
  statements;
  */
end;
$body$
LANGUAGE 'plpgsql'
VOLATILE
CALLED ON NULL INPUT
SECURITY INVOKER
PARALLEL UNSAFE
COST 100;",Modelo_BD
"CREATE OR REPLACE FUNCTION public.get_random_top_packages(integer)
    RETURNS SETOF record
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100    ROWS 1000 
AS $BODY$DECLARE 
    _type integer := $1;
    _k integer;
        _stepcount integer:=0;        
        rec record;              
BEGIN         
    FOR _k IN SELECT id FROM tops WHERE idtype=_type ORDER BY RANDOM()*7 LOOP                 
        _stepcount:=_stepcount+1;           
        FOR rec in SELECT _stepcount::integer, m.idmelody::integer, songername::text, songname::text, rating::integer, idtop::integer,
        code::text, path::text, m.isactive, m.idcategory, m.rbt_code 
        FROM melodies m 
        JOIN melodies_in_tops mt on m.idmelody = mt.idmelody
        WHERE (mt.idtop = _k) ORDER BY mt.rating LOOP               
        return NEXT  rec;        
        END LOOP;
    END LOOP;
END;
$BODY$;",SQL.sql
"CREATE OR REPLACE FUNCTION public.getf_common_data2()
    RETURNS TABLE(msisdn character varying, status text, datetimestarted text, datetimetrialended text, datetimestoped text, datepaiduntil text, datetimelastcharge text, datetimelastsuccesscharge text, langid integer, iddispatch integer, issubscribedatoperatorside integer)
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100    ROWS 1000 
AS $BODY$BEGIN

  RETURN query SELECT 
  a.msisdn, 
  a.status, 
  a.datetimeStarted, 
  a.datetimeTrialEnded, 
  a.datetimeStoped,
  (case WHEN a.idDispatch > 100 then a.datetimeTrialEnded else a.datePaidUntil end) as datePaidUntil,
  COALESCE(a.datetimeLastCharge, a.datetimeStarted) as datetimeLastCharge,
  (case WHEN a.idDispatch > 100 then a.datetimeStarted when a.datetimeLastSuccessCharge is null then a.datetimeStarted else a.datetimeLastSuccessCharge end) as datetimeLastSuccessCharge,
  a.langID, 
  a.idDispatch,
  (case WHEN a.idDispatch > 100 then 0 else 1  end) as isSubscribedAtOperatorSide
    FROM ( 
      SELECT s.msisdn, 
      case WHEN now() BETWEEN s.datesubscriber and s.dateunsubscriber then 'ACTIVE' else 'NOT_ACTIVE' end as status,
      to_char(s.datesubscriber, 'YYYY-MM-DD HH24:MI:SS') as datetimeStarted,
      case WHEN s.idDispatch > 100 then to_char(s.dateunsubscriber, 'YYYY-MM-DD') else null end as datetimeTrialEnded,
      to_char(s.dateunsubscriber, 'YYYY-MM-DD HH24:MI:SS') as datetimeStoped,
      to_char(now(), 'YYYY-MM-DD') as datePaidUntil,
      to_char(b2.date_service, 'YYYY-MM-DD HH24:MI:SS') as datetimeLastCharge,
      to_char(b1.date_service, 'YYYY-MM-DD HH24:MI:SS') as datetimeLastSuccessCharge,
      case when a.lang='ru' then 1 when a.lang='kg' then 3 end as langID,
      s.iddispatch as idDispatch
      FROM subscribers.dispatch_subscribers s      
      inner join public.accounts a on a.msisdn = s.msisdn  
      inner join billing.billing_stat_err be on a.msisdn = be.msisdn 
      inner join (
        select max(s2.id) as id, s2.msisdn,
        case when s2.iddispatch > 100 then s2.iddispatch-100 else s2.iddispatch end as iddispatch
        from subscribers.dispatch_subscribers s2
        group by s2.msisdn, case when s2.iddispatch > 100 then s2.iddispatch-100 else s2.iddispatch end
      ) s1 on s1.id = s.id    
      left outer join (
        select max(b11.date_service) as date_service, b11.msisdn, b11.content_id
        from billing.billing_stat_ok b11
        group by b11.msisdn, b11.content_id
      ) b1 on b1.msisdn = s.msisdn and b1.content_id = s.iddispatch
      left outer join (
        select max(b21.date_service) as date_service, b21.msisdn, b21.content_id
        from billing.billing_stat b21
        group by b21.msisdn, b21.content_id
      ) b2 on b2.msisdn = s.msisdn and b2.content_id = s.iddispatch     
      WHERE be.date_added > '2019-12-06 00:10:00' and be.billing_error IN (-200,-300,-6)
    ) a;
END;
$BODY$;",SQL.sql
"CREATE OR REPLACE FUNCTION public.isEmpty (
  p_variable VARCHAR
)
RETURNS BOOLEAN AS
$BODY$
BEGIN
  RETURN ( (p_variable IS NULL) OR (LENGTH(p_variable) = 0) );
END;
$BODY$
LANGUAGE 'plpgsql' VOLATILE
COST 100;",commonfunctions.sql
"CREATE OR REPLACE FUNCTION public.issue_uid()
  RETURNS text AS
$BODY$
DECLARE
    new_uid text;
BEGIN

    RETURN random_text_simple(11);
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",createTables.txt
"CREATE OR REPLACE FUNCTION public.json_pushVD(
	i_json json,
	i_clave varchar,
	i_value varchar)
RETURNS json AS
$BODY$
DECLARE
	d_record record;
	string varchar = '';
	string2 varchar = '';
	d_tipo_json varchar default 'to_json';
BEGIN
	/*
	Hecho por: Vlade Párica
	Fecha:
	Resumen:

	Para probarlo:
				select json_pushVD('[{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }]','""jajaja""','5')
				select json_pushVD('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','""jajaja""','[{""hola"":""hola"",""otrcosa"":0,""otracosa2"":true}]')
				select json_pushVD('{""idTipoTramiteDetallado"": 483, ""tipoLicencia"": ""No especificado"", ""idTipoLicencia"": 0, ""categorias"": null }','""jajaja""','hola')
	*/

	IF (i_value::varchar like '{%' and i_value::varchar like '%}' --and i_value::varchar != '{}'
		) THEN
	raise notice 'Entre';

		i_clave = trim(i_clave, '""');
		i_value = trim(i_value, '""');

		for d_record in select * from json_each(i_json)
			loop
				IF (d_record.value::text like '""%') THEN
					string = string || '''' || d_record.value::text|| '''' || ' ' ||'""'|| d_record.key ||'""'||', ';
				ELSE
					string = string || d_record.value::text || ' ' ||'""'|| d_record.key ||'""'||', ';
				END IF;
			end loop;

		for d_record in select * from json_each(i_value::json)
			loop
				string2 = string2 ||'""'|| d_record.key ||'""'||',' || d_record.value::text|| ',';
			end loop;
			string2 = replace(RTRIM(string2, ','), '""', '''');
			raise notice 'Segundo jsonv2 %', string2;
		IF ( json_typeof(i_value::json) = 'array' ) THEN
			execute 'select json_agg(a.*) from ( select ' || string || '(array_agg(b.*) as ' || i_clave || ' from ( select ' || string2 || ')b )' || ' )a' into i_json;
		ELSE
			execute 'select to_json(a.*) from ( select ' || string || 'json_build_object(' || string2 || ') as' || i_clave || ' )a' into i_json;
		END IF;

			i_json := replace(i_json::text,(CHR(92)||'""'),'');

	elsif i_json::varchar like '{%' and i_json::varchar like '%}' then

			i_clave = trim(i_clave, '""');
			i_value = trim(i_value, '""');

			for d_record in select * from json_each(i_json)
			loop

				string = string ||'""'|| d_record.key ||'""'||','|| d_record.value||',';

			end loop;

				string = string ||'""'|| i_clave ||'""'||','||'""'||i_value||'""'||',';
				string = replace(RTRIM(string, ','), '""', '''');

			execute 'select json_build_object('||string||')' into i_json;
		else
			return json_build_object('ERROR','Solo se puede agregar un elemento a un objecto');
		end if;

	RETURN i_json;
END;$BODY$
	LANGUAGE plpgsql VOLATILE
	COST 100;",json_pushVD%20varchar.sql
"CREATE OR REPLACE FUNCTION public.table_gps() RETURNS void AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'gps') THEN

        execute 
		'CREATE TABLE gps (
		id_concept character varying,
		id_theso character varying,
		latitude float,
		longitude float,
		CONSTRAINT gps_pkey PRIMARY KEY (id_concept, id_theso)
		);'
	;

    END IF;
END;

$$LANGUAGE plpgsql VOLATILE;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION public.zradar_at(
    real,
    real,
    real)
  RETURNS real AS
$BODY$
	DECLARE 
		ts    ALIAS for $1;
		vv    ALIAS for $2;
		rh    ALIAS for $3;

		es real;
		
        BEGIN
        
                es = 0.01 * rh * 6.112* exp (17.62 * ts/(243.12 + ts));

                RETURN( ts + 0.33*es - 0.70*vv - 4.00 );


		 	
        END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION public.zradar_humidex(
    real,
    real)
  RETURNS real AS
$BODY$
	DECLARE 
		tt    ALIAS for $1;
		rh    ALIAS for $2;

		humidex real;
		es real;
		e real;
		
        BEGIN
        case
            when rh > 0 then
		es = 6.1078 * 10^((7.5 * tt)/(237.3 + tt));
		e = es * rh / 100.;
		humidex = tt + 0.55556 * (e - 10.);
            else 
		humidex = null;
        end case;

                RETURN( humidex );


		 	
        END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION public.zradar_mslp(
    real,
    real,
    real,
    real)
  RETURNS real AS
$BODY$
	DECLARE 
		ps    ALIAS for $1;
		ts    ALIAS for $2;
		rh    ALIAS for $3;
		H0    ALIAS for $4;

                K  real;
                a  real;
                Ch real;

		es real;
		
        BEGIN
        
                K = 0.0148275;
                a = 0.0065;
                Ch = 0.12;
                
                es = 0.01 * rh * 6.112* exp (17.62 * ts/(243.12 + ts));

                RETURN(ps * 10^( (K * H0) / (273.15 + ts + a * H0 / 2 + es * Ch)) );


		 	
        END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION public.zradar_td(
    real,
    real)
  RETURNS real AS
$BODY$
	DECLARE 
		tt    ALIAS for $1;
		rh    ALIAS for $2;

		td real;
		
        BEGIN
        case
            when rh > 0 then
		td = 243.04*(log(rh/100)+((17.625*tt)/(243.04+tt)))/(17.625-log(rh/100)-((17.625*tt)/(243.04+tt)));
            else 
		td = null;
        end case;

                RETURN( td );


		 	
        END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION public.zradar_windchill(
    real,
    real)
  RETURNS real AS
$BODY$
	DECLARE 
		ts    ALIAS for $1;
		vv    ALIAS for $2;
		
        BEGIN

		RETURN(13.12 + 0.6215 * ts - 11.37 * (3.6 * vv) ^ 0.16 + 0.3965 * ts * (3.6 * vv) ^ 0.16 );
        END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION query_pk(IN i_userid int, OUT userid int, OUT info text)  
     RETURNS record  
     LANGUAGE plpgsql  
     STRICT  
    AS $function$  
      declare  
      begin  
        select t.userid,t.info into userid,info from userinfo t where t.userid=i_userid;  
        return;  
      end;  
    $function$;",20151220_03.md
"CREATE OR REPLACE FUNCTION query_smalltbl(IN i_userid int, OUT userid int, OUT info text)  
     RETURNS record  
     LANGUAGE plpgsql  
     STRICT  
    AS $function$  
      declare  
      begin  
        select t.userid,t.info into userid,info from tbl_small t where t.userid=i_userid;  
        return;  
      end;  
    $function$;",20151220_03.md
"CREATE OR REPLACE FUNCTION query_smalltbl(IN i_userid int, OUT userid int, OUT info text)  
     RETURNS record  
     LANGUAGE plpgsql  
     STRICT  
    AS $function$  
      declare  
      begin  
        select t.userid,t.info into userid,info from tbl_small t where t.userid=i_userid;  
        return;  
      end;  
    $function$;",index.html
"CREATE OR REPLACE FUNCTION r(errorMsg text) RETURNS VOID AS
$$
BEGIN
    RAISE NOTICE '%', errorMsg;
end;
$$
LANGUAGE plpgsql;",finalProject.sql
"CREATE OR REPLACE FUNCTION ranking_traspaso_comp (IN starts timestamp,
       	  	  	   		      	  IN ends timestamp,
						  IN barcode_mc varchar,
					      	  OUT barcode varchar,
					      	  OUT descripcion varchar,
					      	  OUT marca varchar,
					      	  OUT contenido varchar,
					      	  OUT unidad varchar,
					      	  OUT cantidad double precision,
					      	  OUT costo double precision)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	-------------
	derivada_l int4;  -- id tipo derivado
	corriente_l int4; -- id tipo corriente
	-------------
BEGIN
	SELECT id INTO derivada_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'DERIVADA';
	SELECT id INTO corriente_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'CORRIENTE';

	q := $S$
	     WITH RECURSIVE compuesta (id_traspaso, barcode_complejo, id_mh, tipo_complejo,
	     	  	    	       barcode_componente, tipo_componente, cantidad, costo_promedio) AS
      	      	(
		   SELECT id_traspaso, barcode_complejo, id_mh, tipo_complejo,
			  barcode_componente, tipo_componente, cantidad, costo_promedio
       		   FROM traspaso_mc_detalle
			INNER JOIN traspaso t
			ON traspaso_mc_detalle.id_traspaso = t.id
		   WHERE barcode_complejo = $S$ || barcode_mc || $S$
			 AND fecha>=$S$ || quote_literal(starts) || $S$ AND fecha <= $S$ || quote_literal(ends) || $S$
        	   UNION ALL
        	   SELECT tmcd.id_traspaso, tmcd.barcode_complejo, tmcd.id_mh, tmcd.tipo_complejo,
		      	  tmcd.barcode_componente, tmcd.tipo_componente, tmcd.cantidad, tmcd.costo_promedio
              	   FROM traspaso_mc_detalle tmcd, compuesta
       		   WHERE tmcd.barcode_complejo = compuesta.barcode_componente AND
			 tmcd.id_traspaso = compuesta.id_traspaso AND
			 tmcd.id_mh[1] = compuesta.id_mh[2]
      		)
		SELECT producto.barcode AS barcode,
     	    	       producto.descripcion AS descripcion,
       	    	       producto.marca AS marca,
	    	       producto.contenido AS contenido,
	    	       producto.unidad AS unidad,
	    	       producto.familia AS familia,
	    	       producto.impuestos AS impuestos,
	    	       SUM (c.cantidad) AS cantidad,
	    	       SUM (c.costo_promedio*c.cantidad) AS costo
      	        FROM compuesta c
      	   	     INNER JOIN producto
	   	     	   ON c.barcode_componente = producto.barcode
	             WHERE c.tipo_complejo = $S$ ||derivada_l|| $S$
		     	   OR c.tipo_componente = $S$ ||corriente_l|| $S$
      		     GROUP BY c.barcode_componente,1,2,3,4,5,6,7
      		     ORDER BY producto.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
    	    cantidad := l.cantidad;
    	    costo := l.costo;
    	    RETURN NEXT;
        END LOOP;
RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION ranking_traspaso_mc (IN starts timestamp,
       	  	  	   		        IN ends timestamp,
						IN traspaso_envio boolean,
					        OUT barcode varchar,
					      	OUT descripcion varchar,
					      	OUT marca varchar,
					      	OUT contenido varchar,
					      	OUT unidad varchar,
					      	OUT cantidad double precision,
					      	OUT costo double precision,
					      	OUT familia integer)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	-------------
	compuesta_l int4;
	-------------
	filtro text;
	-------------
BEGIN
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';

	-- Condición para obtener la información de las mercaderías enviadas y/o recibidas
	IF traspaso_envio = TRUE THEN
	   filtro := 't.origen = 1';
	ELSE
	   filtro := 't.origen != 1';
	END IF;

	q := $S$ SELECT p.barcode, t.origen, p.descripcion, p.marca, p.contenido, p.unidad, p.familia,
		        SUM (td.cantidad) AS cantidad,
			SUM (td.cantidad*td.precio) AS costo
		 FROM traspaso_detalle td
		 INNER JOIN traspaso t
		 ON t.id = td.id_traspaso
		 INNER JOIN producto p
		 ON p.barcode = td.barcode
		 WHERE fecha>=$S$ || quote_literal(starts) || $S$ AND fecha<=$S$ || quote_literal(ends) || $S$
		 AND td.tipo=$S$ || compuesta_l || $S$
		 AND $S$||filtro|| $S$
		 GROUP BY 1,2,3,4,5,6,7 ORDER BY p.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
	    familia := l.familia;
    	    cantidad := l.cantidad;
    	    costo := l.costo;
    	    RETURN NEXT;
        END LOOP;
RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION ranking_traspaso_mp (IN starts timestamp,
       	  	  	   		        IN ends timestamp,
					        IN traspaso_envio boolean,
					        OUT barcode varchar,
					        OUT descripcion varchar,
					        OUT marca varchar,
					        OUT contenido varchar,
					        OUT unidad varchar,
					        OUT cantidad double precision,
					        OUT costo double precision,
					        OUT familia integer)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	--------
	materia_prima_l int4;
	--------
	filtro text;
	--------
BEGIN
	SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';

	-- Condición para obtener la información de las mercaderías enviadas y/o recibidas
	IF traspaso_envio = TRUE THEN
	   filtro := 't.origen = 1';
	ELSE
	   filtro := 't.origen != 1';
	END IF;

	q := $S$ SELECT --CASE WHEN tmcd.tipo_hijo = $S$||materia_prima_l||$S$ THEN tmcd.barcode_hijo
	     	 	--     WHEN tmcd.tipo_madre = $S$||materia_prima_l||$S$ THEN tmcd.barcode_madre
			--END AS barcode,
			tmcd.barcode_componente AS barcode
	     	 	t.origen, p.descripcion, p.marca, p.contenido, p.unidad, p.familia,
		        SUM (tmcd.cantidad) AS cantidad,
			SUM (tmcd.cantidad*tmcd.costo_promedio) AS costo
		 FROM traspaso_mc_detalle tmcd
		      INNER JOIN traspaso t
		      	    ON t.id = tmcd.id_traspaso
		      INNER JOIN producto p
		      	    ON p.barcode = tmcd.barcode_componente
			       		   --CASE WHEN tmcd.tipo_hijo = $S$||materia_prima_l||$S$ THEN tmcd.barcode_hijo
	     	 	       		   --	WHEN tmcd.tipo_madre = $S$||materia_prima_l||$S$ THEN tmcd.barcode_madre
					   --END
		 WHERE fecha>=$S$ || quote_literal(starts) || $S$ AND fecha<= $S$ || quote_literal(ends) || $S$
		       --AND (tmcd.tipo_hijo = $S$||materia_prima_l||$S$ OR tmcd.tipo_madre = $S$||materia_prima_l||$S$)
		       AND tmcd.tipo_componente = $S$||materia_prima_l||$S$
		       AND $S$ ||filtro|| $S$
		 GROUP BY 1,2,3,4,5,6,7 ORDER BY p.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
	    familia := l.familia;
    	    cantidad := l.cantidad;
    	    costo := l.costo;
    	    RETURN NEXT;
        END LOOP;
RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION ranking_ventas_comp (IN starts timestamp,
       	  	  	   		      	IN ends timestamp,
						IN barcode_mc varchar,
					      	OUT barcode varchar,
					      	OUT descripcion varchar,
					      	OUT marca varchar,
					      	OUT contenido varchar,
					      	OUT unidad varchar,
					      	OUT cantidad double precision,
					      	OUT monto_vendido double precision,
					      	OUT costo double precision,
					      	OUT contribucion double precision)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	-------------
	derivada_l int4;  -- id tipo derivado
	corriente_l int4; -- id tipo corriente
        materia_prima_l int4; -- id tipo materia prima
	-------------
BEGIN
	SELECT id INTO derivada_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'DERIVADA';
	SELECT id INTO corriente_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'CORRIENTE';
        SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';

	q := $S$
	     WITH RECURSIVE compuesta (id_venta, barcode_complejo, id_mh, tipo_complejo,
	     	  	    	       barcode_componente, tipo_componente, cantidad,
				       precio, costo_promedio, iva, otros, ganancia) AS
      	      	(
		   SELECT id_venta_vd, barcode_complejo, id_mh, tipo_complejo,
			  barcode_componente, tipo_componente, cantidad,
			  precio_proporcional, costo_promedio, iva, otros, ganancia
       		   FROM venta_mc_detalle
			INNER JOIN venta v
			ON venta_mc_detalle.id_venta_vd = v.id
		   WHERE barcode_complejo = $S$ || barcode_mc || $S$
			 AND fecha>=$S$ || quote_literal(starts) || $S$ AND fecha <= $S$ || quote_literal(ends) || $S$
        	   UNION ALL
        	   SELECT vmcd.id_venta_vd, vmcd.barcode_complejo, vmcd.id_mh, vmcd.tipo_complejo,
		      	  vmcd.barcode_componente, vmcd.tipo_componente, vmcd.cantidad,
			  vmcd.precio_proporcional, vmcd.costo_promedio, vmcd.iva, vmcd.otros, vmcd.ganancia
              	   FROM venta_mc_detalle vmcd, compuesta
       		   WHERE vmcd.barcode_complejo = compuesta.barcode_componente AND
			 vmcd.id_venta_vd = compuesta.id_venta AND
			 vmcd.id_mh[1] = compuesta.id_mh[2]
      		)
		SELECT producto.barcode AS barcode,
     	    	       producto.descripcion AS descripcion,
       	    	       producto.marca AS marca,
	    	       producto.contenido AS contenido,
	    	       producto.unidad AS unidad,
	    	       producto.familia AS familia,
	    	       producto.impuestos AS impuestos,
	    	       SUM (c.cantidad) AS cantidad,
	    	       SUM (c.precio*c.cantidad) AS monto_vendido,
	    	       SUM (c.costo_promedio*c.cantidad) AS costo,
       	    	       SUM (c.ganancia) AS contribucion
      	        FROM compuesta c
      	   	     INNER JOIN producto
	   	     	   ON c.barcode_componente = producto.barcode
	             WHERE c.tipo_componente = $S$ ||derivada_l|| $S$
		     	   OR c.tipo_componente = $S$ ||corriente_l|| $S$
                           OR c.tipo_componente = $S$ ||materia_prima_l|| $S$
      		     GROUP BY c.barcode_componente,1,2,3,4,5,6,7
      		     ORDER BY producto.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
    	    cantidad := l.cantidad;
    	    monto_vendido := l.monto_vendido;
    	    costo := l.costo;
    	    contribucion := l.contribucion;
    	    RETURN NEXT;
        END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION ranking_ventas_mc (IN starts timestamp,
       	  	  	   		      IN ends timestamp,
					      OUT barcode varchar,
					      OUT descripcion varchar,
					      OUT marca varchar,
					      OUT contenido varchar,
					      OUT unidad varchar,
					      OUT cantidad double precision,
					      OUT monto_vendido double precision,
					      OUT costo double precision,
					      OUT contribucion double precision,
					      OUT familia integer)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	compuesta_l int4;
BEGIN
	SELECT id INTO compuesta_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'COMPUESTA';
	q := $S$ SELECT p.barcode, p.descripcion, p.marca, p.contenido, p.unidad, p.familia,
		        SUM (vd.cantidad) AS cantidad,
			SUM ((vd.cantidad*vd.precio)-(v.descuento*((vd.cantidad*vd.precio)/(v.monto+v.descuento)))) AS monto_vendido,
			SUM (vd.cantidad*vd.fifo) AS costo,
       			SUM ((vd.precio*vd.cantidad)-((vd.iva+vd.otros)+(vd.fifo*vd.cantidad))) AS contribucion
		 FROM venta_detalle vd
		 INNER JOIN venta v
		 ON v.id = vd.id_venta
		 INNER JOIN producto p
		 ON p.barcode = vd.barcode
		 WHERE fecha>=$S$ || quote_literal(starts) || $S$ AND fecha<=$S$ || quote_literal(ends) || $S$
		 AND vd.tipo=$S$ || compuesta_l || $S$
		 GROUP BY 1,2,3,4,5,6 ORDER BY p.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
	    familia := l.familia;
    	    cantidad := l.cantidad;
    	    monto_vendido := l.monto_vendido;
    	    costo := l.costo;
    	    contribucion := l.contribucion;
    	    RETURN NEXT;
        END LOOP;
RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION ranking_ventas_mp (IN starts timestamp,
       	  	  	   		      IN ends timestamp,
					      OUT barcode varchar,
					      OUT descripcion varchar,
					      OUT marca varchar,
					      OUT contenido varchar,
					      OUT unidad varchar,
					      OUT cantidad double precision,
					      OUT monto_vendido double precision,
					      OUT costo double precision,
					      OUT contribucion double precision,
					      OUT familia integer)
RETURNS SETOF RECORD AS $$
DECLARE
	q text;
	l record;
	materia_prima_l int4;
BEGIN
	SELECT id INTO materia_prima_l FROM tipo_mercaderia WHERE UPPER(nombre) LIKE 'MATERIA PRIMA';
	q := $S$ SELECT --CASE WHEN vmcd.tipo_componente = $S$||materia_prima_l||$S$ THEN vmcd.barcode_componente
	     	 	--     WHEN vmcd.tipo_complejo = $S$||materia_prima_l||$S$ THEN vmcd.barcode_complejo
			--END AS barcode,
			vmcd.barcode_componente AS barcode, --Ahora la materia prima es un componente base
	     	 	p.descripcion, p.marca, p.contenido, p.unidad, p.familia,
		        SUM (vmcd.cantidad) AS cantidad,
			SUM (vmcd.cantidad*vmcd.precio_proporcional) AS monto_vendido,
			SUM (vmcd.cantidad*vmcd.costo_promedio) AS costo,
       			SUM ((vmcd.precio_proporcional*vmcd.cantidad)-((vmcd.iva+vmcd.otros)+(vmcd.costo_promedio*vmcd.cantidad))) AS contribucion
		 FROM venta_mc_detalle vmcd
		      INNER JOIN venta v
		      	    ON v.id = vmcd.id_venta_vd
		      INNER JOIN producto p
		      	    ON p.barcode = vmcd.barcode_componente
			       		   --CASE WHEN vmcd.tipo_hijo = $S$||materia_prima_l||$S$ THEN vmcd.barcode_hijo
	     	 	       		   --	WHEN vmcd.tipo_madre = $S$||materia_prima_l||$S$ THEN vmcd.barcode_madre
					   --END
		 WHERE fecha>=$S$ || quote_literal(starts) || $S$ AND fecha <= $S$ || quote_literal(ends) || $S$
		       AND vmcd.tipo_componente = $S$||materia_prima_l||$S$ -- OR vmcd.tipo_complejo = $S$||materia_prima_l||$S$
		       AND v.id NOT IN (SELECT id_sale FROM venta_anulada)
		 GROUP BY 1,2,3,4,5,6 ORDER BY p.descripcion ASC $S$;

      	FOR l IN EXECUTE q loop
	    barcode := l.barcode;
            descripcion := l.descripcion;
	    marca := l.marca;
    	    contenido := l.contenido;
    	    unidad := l.unidad;
	    familia := l.familia;
    	    cantidad := l.cantidad;
    	    monto_vendido := l.monto_vendido;
    	    costo := l.costo;
    	    contribucion := l.contribucion;
    	    RETURN NEXT;
        END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION realtime.radian2cardinal(real)
  RETURNS text AS
$BODY$
declare
    degree numeric(5,2) := $1 / (2*pi()) *360;
    card text;
BEGIN
SELECT into card
    CASE
        WHEN degree BETWEEN  348.75 AND 360  THEN 'N'::text
	WHEN degree BETWEEN  0 AND 11.25  THEN 'N'::text
	WHEN degree BETWEEN  11.25 AND 33.75  THEN 'NNE'::text
	WHEN degree BETWEEN  33.75 AND 56.25  THEN 'NE'::text
	WHEN degree BETWEEN  56.25 AND 78.75   THEN 'ENE'::text
	WHEN degree BETWEEN  78.75 AND 101.25  THEN 'E'::text
	WHEN degree BETWEEN  101.25 AND 123.75  THEN 'ESE'::text
	WHEN degree BETWEEN  123.75 AND 146.25  THEN 'SE'::text
	WHEN degree BETWEEN  146.25 AND 168.75   THEN 'SSE'::text
	WHEN degree BETWEEN  168.75 AND 191.25  THEN 'S'::text
	WHEN degree BETWEEN  191.25 AND 213.75   THEN 'SSW'::text
	WHEN degree BETWEEN  213.75 AND 236.25   THEN 'SW'::text
	WHEN degree BETWEEN  236.25 AND 258.75   THEN 'WSW'::text
	WHEN degree BETWEEN  258.75 AND 281.25   THEN 'W'::text
	WHEN degree BETWEEN  281.25 AND 303.75   THEN 'WNW'::text
	WHEN degree BETWEEN  303.75 AND 326.25   THEN 'NW'::text
	WHEN degree BETWEEN  326.25 AND 348.75   THEN 'NNW'::text
            ELSE NULL::text
        END;
return card;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",create_functions_and_triggers.sql
"CREATE OR REPLACE FUNCTION relation_group() RETURNS void AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'relation_group') THEN

        execute 
		'CREATE TABLE relation_group
                ( id_group1 character varying NOT NULL,
                  id_thesaurus character varying NOT NULL,
                  relation character varying NOT NULL,
                  id_group2 character varying NOT NULL,
                  CONSTRAINT pk_relation_group PRIMARY KEY (id_group1, id_thesaurus, relation, id_group2)
                )'
	;

    END IF;
END;

$$LANGUAGE plpgsql VOLATILE;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION rev_to_forward_ipv4(ipv4 TEXT) RETURNS INET AS $$ 
DECLARE
	octets TEXT[4];
	octet TEXT;
	inet_string CITEXT := '';
	num_octets INTEGER := 0;
	n INTEGER;
BEGIN
	-- Regex for matching reversed ip address starting with octet and ending in "".in-addr.arpa.""
	-- All the \d+  are inside capture groups
	-- ^(\d+)\.       There should be at-least one octet at the start of the string
	-- (?:(\d+)\.)?   We use non-capturing groups for next 3 octets with ""?"" because they might not be present
	-- (?:(\d+)\.)?
	-- (?:(\d+)\.)?
	-- in-addr\.arpa\.
	-- e.g. '10.20.in-addr.arpa.' will produce array of {'10', '20', NULL, NULL}
	SELECT regexp_matches(ipv4, '^(\d+)\.(?:(\d+)\.)?(?:(\d+)\.)?(?:(\d+)\.)?in-addr\.arpa\.$') INTO octets;
	IF octets IS NULL THEN 
		RETURN NULL;
	END IF;
	-- Validated ipv4 is something like:
	-- 'x.x.x.x.in-addr.arpa.' cidr = 32
	-- 'x.x.x.in-addr.arpa.'   cidr = 24
	-- 'x.x.in-addr.arpa.'     cidr = 16
	-- 'x.in-addr.arpa.'       cidr = 8
	-- 'x' represents numbers from 0-255 inclusive (Actual number validation is done in the statements below)
	
	FOREACH octet IN ARRAY octets LOOP
		EXIT WHEN octet IS NULL;
		
		BEGIN
			num_octets := num_octets + 1;
			n = octet :: INTEGER;

            -- Ensure number is within valid range
            IF n > 255 THEN
                RETURN NULL;
            END IF;
		
		EXCEPTION 
			WHEN OTHERS THEN
				RETURN NULL;
		END;
		
		-- When appending, we add the old string last to reverse the order of octets
		inet_string :=  octet || '.' || inet_string;
  	END LOOP;

	-- Trim the leading dot we added in for loop and append CIDR
	inet_string := TRIM(BOTH '.' FROM INET_STRING) || '/' || num_octets * 8;
	
	BEGIN
		RETURN inet_string::INET;
	EXCEPTION 
		WHEN OTHERS THEN
			RETURN NULL;
	END;
END;

$$ LANGUAGE PLPGSQL IMMUTABLE;",2020-02-28-plpgsql-reverse-ip.md
"CREATE OR REPLACE FUNCTION schema_support.id_tag()
RETURNS VARCHAR AS $$
BEGIN
        RETURN('<-- $Id -->');
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE FUNCTION search_jsonvd(
    i_json json,
    i_object_json json)
  RETURNS integer AS
$BODY$
DECLARE
	d_data record;
	d_object varchar = 'object';
	d_array varchar = 'array';
	d_execute varchar;
	d_type_data varchar;
	broke integer;
BEGIN
	/*
	Hecho por: Vlade Párica
	Fecha:
	Resumen:

	Para probarlo:
					select public.search_jsonVD('[{""tramites"":[{""title"":""Actualización"",""id"":23,""tipostramites"":null},{""title"":""Autorización de"",""id"":41,""tipostramites"":[{""title"":""Cambio de Dirección"",""idTipoTramiteGeneral"":74,""clase"":null,""tipoLicencias"":[{""idTipoTramiteDetallado"":483,""tipoLicencia"":""No especificado"",""idTipoLicencia"":0,""categorias"":null}]}]},{""title"":""Certificación de"",""id"":38,""tipostramites"":[{""title"":""Horas de Vuelo"",""idTipoTramiteGeneral"":80,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":367,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":511,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":510,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":372,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":378,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":512,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":368,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":362,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":508,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":509,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":365,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":507,""tipoLicencia"":""Piloto de Dirigible"",""idTipoLicencia"":29,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":504,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":505,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":506,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":361,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":364,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":377,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":379,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":363,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":366,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":369,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]},{""title"":""Licencia y Certificado Médico"",""idTipoTramiteGeneral"":54,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":351,""tipoLicencia"":""Controlador de Tránsito Aéreo"",""idTipoLicencia"":17,""categorias"":null},{""idTipoTramiteDetallado"":484,""tipoLicencia"":""Despachador de Vuelo"",""idTipoLicencia"":19,""categorias"":null},{""idTipoTramiteDetallado"":347,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":502,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":500,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":352,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":350,""tipoLicencia"":""Instructor de Vuelo Instrumental Simulado"",""idTipoLicencia"":16,""categorias"":null},{""idTipoTramiteDetallado"":358,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":360,""tipoLicencia"":""Instructor de Vuelo RPA Ala Rotativa"",""idTipoLicencia"":36,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":503,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":348,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":486,""tipoLicencia"":""Operador de Estaciones Aeronáuticas"",""idTipoLicencia"":18,""categorias"":null},{""idTipoTramiteDetallado"":342,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":498,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":499,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":345,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":495,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":496,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":497,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":341,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":344,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":357,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":359,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":343,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":346,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":354,""tipoLicencia"":""Técnico en Mantenimiento de Aeronaves"",""idTipoLicencia"":28,""categorias"":null},{""idTipoTramiteDetallado"":349,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]}]},{""title"":""Convalidación de Licencia Aeronáutica"",""id"":18,""tipostramites"":null},{""title"":""Duplicado de Licencia Aeronáutica"",""id"":17,""tipostramites"":null},{""title"":""Emisión de Licencia Aeronáutica"",""id"":15,""tipostramites"":null},{""title"":""Otorgamiento de"",""id"":24,""tipostramites"":null},{""title"":""Otorgamiento de Habilitación Aeronáutica"",""id"":22,""tipostramites"":null},{""title"":""Renovación de Licencia Aeronáutica"",""id"":16,""tipostramites"":null}]}]','{""title"":""Duplicado de Licencia Aeronáutica"",""id"":17,""tipostramites"":null}')

					select search_jsonVD('{""idTipoTramiteDetallado"": 367, ""tipoLicencia"": ""Instructor de Vuelo Avión"", ""idTipoLicencia"": 12, ""categorias"": [{""idCategoria"": 2, ""categoria"": ""Avión""}]}','[{""idCategoria"": 2, ""categoria"": ""Avión""}]')
					*/

	--elimino los espacios en blanco

	i_json = replace(i_json::varchar, ' ', '');
	i_object_json = replace(i_object_json::varchar, ' ', '');
	i_json = i_json::jsonb;
	i_object_json = i_object_json::jsonb;

	if i_object_json::varchar like '[%' and i_object_json::varchar like '%]' then
		i_object_json = ltrim(rtrim(i_object_json::varchar , ']'), '[');
	end if;


	if i_json::varchar like '{%' and i_json::varchar like '%}' then
		i_json = '['||i_json||']';
	end if;

d_execute = 'with destructor_tmp as (

		  		select
		 			*
		 		from
		 			jsonb_array_elements($$'||i_json||'$$::jsonb) with ordinality arr(elem, position)
		  ), select_tmp as (

			  	select
			  		*,
			  		json_typeof(elem::json) as elems
			  	from
			  		destructor_tmp,
			  		json_each(elem::json)

		  ), search_json as (

		  	select
				elem,
				position,
				key,
				(select convert_array_jsonVD(elem::varchar)) as value,
			  	json_typeof(value::json) as datos,
			  	value as value_inicial
		  	from
		  		select_tmp
		  	where
		  	(elem::varchar = $$'||i_object_json||'$$::varchar) or (value::varchar = $$'||i_object_json||'$$::varchar)

		  	union all

		  	select
				elem,
				position,
				key,
				case
					WHEN json_typeof(value::json) = $$'||d_object||'$$ THEN (select (''[''||value||'']'')::json)
					ELSE value
				end,
		  		json_typeof(value::json) as datos,
		  		value as value_inicial
		  	from
		  		select_tmp
		  	where
		  	(json_typeof(value::json) like $$'||d_object||'$$ or
		  	json_typeof(value::json) like $$'||d_array||'$$)
		  	order by datos asc
		  )
		  	select
		  		*
		  	from
		  		search_json'
		  ;


	  for d_data in execute d_execute
	  loop

	  if ((replace(d_data.value::varchar, ' ', '') = replace('['||i_object_json||']'::varchar, ' ', '')) or (replace(d_data.elem::varchar, ' ', '') = replace(i_object_json::varchar, ' ', '')) or (replace(d_data.value_inicial::varchar, ' ', '') = replace(i_object_json::varchar, ' ', ''))) then

	  		return 1;
	  end if;

	  if not d_data.datos is null then
	  	broke = (select public.search_jsonVD(d_data.value,i_object_json));
	  end if;

	  if broke <> 0 then
	  	return broke;
	  end if;

	  end loop;

	RETURN 0;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",search_jsonVD.sql
"CREATE OR REPLACE FUNCTION search_positionvd(
    i_json json,
    i_object_json json)
  RETURNS character varying AS
$BODY$
DECLARE
	d_data varchar;
	d_json json;
BEGIN
	/*
	Hecho por: Vlade Párica
	Fecha:
	Resumen:

	Para probarlo:

		select search_positionVD('{""idTipoTramiteDetallado"": 367, ""tipoLicencia"": ""Instructor de Vuelo Avión"", ""idTipoLicencia"": 12, ""categorias"": [{""idCategoria"": 2, ""categoria"": ""Avión""}]}','[{""idCategoria"": 2, ""categoria"": ""Avión""}]')

		select public.search_positionVD('[{""tramites"":[{""title"":""Actualización"",""id"":23,""tipostramites"":null},{""title"":""Autorización de"",""id"":41,""tipostramites"":[{""title"":""Cambio de Dirección"",""idTipoTramiteGeneral"":74,""clase"":null,""tipoLicencias"":[{""idTipoTramiteDetallado"":483,""tipoLicencia"":""No especificado"",""idTipoLicencia"":0,""categorias"":null}]}]},{""title"":""Certificación de"",""id"":38,""tipostramites"":[{""title"":""Horas de Vuelo"",""idTipoTramiteGeneral"":80,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":367,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":511,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":510,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":372,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":378,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":512,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":368,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":362,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":508,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":509,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":365,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":507,""tipoLicencia"":""Piloto de Dirigible"",""idTipoLicencia"":29,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":504,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":505,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":506,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":361,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":364,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":377,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":379,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":363,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":366,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":369,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]},{""title"":""Licencia y Certificado Médico"",""idTipoTramiteGeneral"":54,""clase"":0,""tipoLicencias"":[{""idTipoTramiteDetallado"":351,""tipoLicencia"":""Controlador de Tránsito Aéreo"",""idTipoLicencia"":17,""categorias"":null},{""idTipoTramiteDetallado"":484,""tipoLicencia"":""Despachador de Vuelo"",""idTipoLicencia"":19,""categorias"":null},{""idTipoTramiteDetallado"":347,""tipoLicencia"":""Instructor de Vuelo Avión"",""idTipoLicencia"":12,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":502,""tipoLicencia"":""Instructor de Vuelo de Dirigible"",""idTipoLicencia"":30,""categorias"":[{""idCategoria"":4,""categoria"":""Dirigible""}]},{""idTipoTramiteDetallado"":500,""tipoLicencia"":""Instructor de Vuelo de Planeador"",""idTipoLicencia"":27,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":352,""tipoLicencia"":""Instructor de Vuelo Helicóptero"",""idTipoLicencia"":22,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":350,""tipoLicencia"":""Instructor de Vuelo Instrumental Simulado"",""idTipoLicencia"":16,""categorias"":null},{""idTipoTramiteDetallado"":358,""tipoLicencia"":""Instructor de Vuelo RPA Ala Fija"",""idTipoLicencia"":34,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":360,""tipoLicencia"":""Instructor de Vuelo RPA Ala Rotativa"",""idTipoLicencia"":36,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":503,""tipoLicencia"":""Instructor de Vuelo Ultraliviano"",""idTipoLicencia"":24,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":348,""tipoLicencia"":""Mecánico de a Bordo"",""idTipoLicencia"":13,""categorias"":null},{""idTipoTramiteDetallado"":486,""tipoLicencia"":""Operador de Estaciones Aeronáuticas"",""idTipoLicencia"":18,""categorias"":null},{""idTipoTramiteDetallado"":342,""tipoLicencia"":""Piloto Comercial - Avión"",""idTipoLicencia"":3,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":498,""tipoLicencia"":""Piloto Comercial de Globo Libre"",""idTipoLicencia"":23,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":499,""tipoLicencia"":""Piloto Comercial de Ultraliviano"",""idTipoLicencia"":11,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":345,""tipoLicencia"":""Piloto Comercial - Helicóptero"",""idTipoLicencia"":6,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":495,""tipoLicencia"":""Piloto de Globo Libre"",""idTipoLicencia"":9,""categorias"":[{""idCategoria"":6,""categoria"":""Globo Libre""}]},{""idTipoTramiteDetallado"":496,""tipoLicencia"":""Piloto de Planeador"",""idTipoLicencia"":8,""categorias"":[{""idCategoria"":7,""categoria"":""Planeador""}]},{""idTipoTramiteDetallado"":497,""tipoLicencia"":""Piloto de Ultraliviano"",""idTipoLicencia"":10,""categorias"":[{""idCategoria"":5,""categoria"":""Ultraliviano""}]},{""idTipoTramiteDetallado"":341,""tipoLicencia"":""Piloto Privado - Avión"",""idTipoLicencia"":2,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":344,""tipoLicencia"":""Piloto Privado - Helicóptero"",""idTipoLicencia"":5,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":357,""tipoLicencia"":""Piloto RPA Ala Fija"",""idTipoLicencia"":33,""categorias"":[{""idCategoria"":8,""categoria"":""RPA Ala Fija""}]},{""idTipoTramiteDetallado"":359,""tipoLicencia"":""Piloto RPA Ala Rotativa"",""idTipoLicencia"":35,""categorias"":[{""idCategoria"":9,""categoria"":""RPA Ala Rotativa""}]},{""idTipoTramiteDetallado"":343,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Avión"",""idTipoLicencia"":4,""categorias"":[{""idCategoria"":2,""categoria"":""Avión""}]},{""idTipoTramiteDetallado"":346,""tipoLicencia"":""Piloto Transporte de Línea Aérea - Helicóptero"",""idTipoLicencia"":7,""categorias"":[{""idCategoria"":3,""categoria"":""Helicóptero""}]},{""idTipoTramiteDetallado"":354,""tipoLicencia"":""Técnico en Mantenimiento de Aeronaves"",""idTipoLicencia"":28,""categorias"":null},{""idTipoTramiteDetallado"":349,""tipoLicencia"":""Tripulante de Cabina"",""idTipoLicencia"":14,""categorias"":null}]}]},{""title"":""Convalidación de Licencia Aeronáutica"",""id"":18,""tipostramites"":null},{""title"":""Duplicado de Licencia Aeronáutica"",""id"":17,""tipostramites"":null},{""title"":""Emisión de Licencia Aeronáutica"",""id"":15,""tipostramites"":null},{""title"":""Otorgamiento de"",""id"":24,""tipostramites"":null},{""title"":""Otorgamiento de Habilitación Aeronáutica"",""id"":22,""tipostramites"":null},{""title"":""Renovación de Licencia Aeronáutica"",""id"":16,""tipostramites"":null}]}]','{""idTipoTramiteDetallado"": 510, ""tipoLicencia"": ""Instructor de Vuelo de Planeador"", ""idTipoLicencia"": 27, ""categorias"": [{""idCategoria"": 7, ""categoria"": ""Planeador""}] }')
	*/

	d_data = (select extract_positionVD(i_json,i_object_json));

	if d_data = 'No se encuentra el objecto' then
		return d_data;
	end if;

	d_data = rtrim(d_data, '@');

	with position_tmp as (

		select * from regexp_split_to_table(d_data::varchar,'@') with ordinality

	), data_tmp as (

			select
				""clave"",
				""posicion""
			from
			position_tmp,
			json_to_record(regexp_split_to_table::json) as
			(
				""clave"" varchar,
				""posicion"" integer
			)
			order by ordinality desc
	)
		SELECT json_agg(a.*) into d_json FROM (
			select
				*
			from
				data_tmp
		) a

	;

	d_json = replace(d_json::varchar, '""clave"":null,', '');

	RETURN d_json::jsonb;
END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",search_positionVD.sql
"CREATE OR REPLACE FUNCTION select_abonos (IN in_rut_cliente int4,
					  OUT o_id integer,
					  OUT o_rut_cliente int4,
					  OUT o_monto_abonado integer,
					  OUT o_fecha_abono timestamp)
RETURNS SETOF RECORD AS $$
DECLARE
   l record;
   q varchar;

BEGIN
   q := $S$ SELECT id, rut_cliente, monto_abonado, fecha_abono
    	    FROM abono
	    WHERE rut_cliente = $S$ || in_rut_cliente || $S$
	    ORDER BY fecha_abono ASC $S$;

   FOR l IN EXECUTE q LOOP
       o_id := l.id;
       o_rut_cliente := l.rut_cliente;
       o_monto_abonado := l.monto_abonado;
       o_fecha_abono := l.fecha_abono;
       RETURN NEXT;
   END LOOP;

   o_id := 0;
   o_rut_cliente := l.rut_cliente;
   o_monto_abonado := 0;
   o_fecha_abono := now();
   RETURN NEXT;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION select_ventas_dia (IN codbar bigint,
       	  	  	   		      IN no_cero boolean)
RETURNS double precision AS $$
DECLARE
  oldest date;
  oldest_vd date;
  oldest_vmcd date;
  last_month date;
  passed_days interval;
  total double precision;
  subtotal double precision;

BEGIN
  last_month = now() - interval '1 month';

  -- Se selecciona la fecha de venta (en venta_detalle) más antigua dentro del último mes
  SELECT date_trunc ('day', fecha) INTO oldest_vd
  FROM venta, venta_detalle
  WHERE venta.id=id_venta
        AND barcode=codbar
        AND venta.fecha>=last_month
  ORDER BY fecha ASC LIMIT 1;
  -- Se asegura que la fecha no sea null (si es que no se ha vendido el producto)
  IF oldest_vd IS NULL THEN
     oldest_vd := date_trunc ('day', now());
  END IF;

  -- Se selecciona la fecha de venta (en venta_mc_detalle) más antigua dentro del último mes
  SELECT date_trunc ('day', fecha) INTO oldest_vmcd
  FROM venta, venta_mc_detalle
  WHERE venta.id=id_venta_vd
        AND barcode_componente=codbar
        AND venta.fecha>=last_month
  ORDER BY fecha ASC LIMIT 1;
  -- Se asegura que la fecha no sea null (si es que no se ha vendido el producto)
  IF oldest_vmcd IS NULL THEN
     oldest_vmcd := date_trunc ('day', now());
  END IF;

  -- Se elije la fecha más antigua
  IF oldest_vd < oldest_vmcd THEN
     oldest := oldest_vd;
  ELSE
     oldest := oldest_vmcd;
  END IF;

  passed_days = date_trunc ('day', now()) - oldest;

  IF passed_days < interval '1 days' THEN
     passed_days = interval '1 days';
  END IF;

  -- Cantidad en venta_detalle
  SELECT (SUM (cantidad)) INTO subtotal
  FROM venta_detalle, venta
  WHERE venta.fecha >= last_month
       AND barcode=codbar
       AND venta.id=id_venta;

  total := COALESCE (subtotal, 0);
  --RAISE NOTICE '----> subt1: %, tot1: %', subtotal, total;

  -- Cantidad en venta_mc_detalle
  SELECT (SUM (cantidad)) INTO subtotal
  FROM venta_mc_detalle, venta
  WHERE venta.fecha >= last_month
       AND barcode_componente=codbar
       AND venta.id=id_venta_vd;

  total := total + COALESCE (subtotal,0);
  --RAISE NOTICE '----> subt2: %, tot2: %', subtotal, total;

  -- Se calcula el promedio de acuerdo a los días pasados
  IF passed_days = interval '30 days' THEN
     total := (total / 30);
  ELSE
     total := (total / date_part('day', passed_days));
  END IF;

  IF total = 0 AND no_cero = TRUE THEN
     total := 1;
  END IF;

RETURN total;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION sf_helloworld()
RETURNS VARCHAR(30)
AS $hello$
DECLARE
	var VARCHAR(30):='Hola ';
	conter INTEGER:=1;
BEGIN
	LOOP
		IF(conter>4) THEN
			exit;
		END IF;
		var:=var||conter||' ';
		conter:=conter+1;
	END LOOP;
	return var;
END; $hello$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION sf_helloworld()
RETURNS VARCHAR(30)
AS $hello$
DECLARE
	var VARCHAR(30):='Hola ';
	conter INTEGER:=1;
BEGIN
   WHILE(conter<5) LOOP
		var:=var||conter||' ';
		conter:=conter+1;
	END LOOP;
   return var;
END; $hello$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION sf_helloworld()
RETURNS VARCHAR(30)
AS $hello$
DECLARE
	var VARCHAR(30):='Hola '||1;
BEGIN
	return var;
END; $hello$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION sf_lxu(usuarioCod INTEGER)
RETURNS VARCHAR(100)
AS $$
DECLARE
	nameUser VARCHAR(40);
	total INTEGER;
BEGIN
	SELECT USUARIO.nom_usuario, COUNT(PRESTAMO.cod_prestamo) AS total
	INTO nameUser,total
	FROM PRESTAMO, USUARIO
	WHERE USUARIO.cod_usuario=usuarioCod AND PRESTAMO.cod_usuario=USUARIO.cod_usuario
	GROUP BY USUARIO.nom_usuario;
	return nameUser||': '||total;
END; $$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION show_partition_info(p_child_table text
    , p_partition_interval text DEFAULT NULL
    , p_parent_table text DEFAULT NULL
    , OUT child_start_time timestamptz
    , OUT child_end_time timestamptz
    , OUT child_start_id bigint
    , OUT child_end_id bigint 
    , OUT suffix text)
RETURNS record
    LANGUAGE plpgsql STABLE SECURITY DEFINER
    AS $$
DECLARE

v_child_schema          text;
v_child_tablename       text;
v_control               text;
v_control_type          text;
v_datetime_string       text;
v_epoch                 text;
v_new_search_path       text := '@extschema@,pg_temp';
v_old_search_path       text;
v_parent_table          text;
v_partition_interval    text;
v_partition_type        text;
v_quarter               text;
v_suffix                text;
v_suffix_position       int;
v_year                  text;

BEGIN
/*
 * Show the data boundries for a given child table as well as the suffix that will be used.
 * Passing the parent table argument improves performance by avoiding a catalog lookup.
 * Passing an interval lets you set one different than the default configured one if desired.
 */

SELECT current_setting('search_path') INTO v_old_search_path;
EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_new_search_path, 'false');

SELECT n.nspname, c.relname INTO v_child_schema, v_child_tablename
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE n.nspname = split_part(p_child_table, '.', 1)::name
AND c.relname = split_part(p_child_table, '.', 2)::name;

IF v_child_tablename IS NULL THEN
    EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');
    RAISE EXCEPTION 'Child table given does not exist (%)', p_child_table;
END IF;

IF p_parent_table IS NULL THEN
    SELECT n.nspname||'.'|| c.relname INTO v_parent_table
    FROM pg_catalog.pg_inherits h
    JOIN pg_catalog.pg_class c ON c.oid = h.inhparent
    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    WHERE h.inhrelid::regclass = p_child_table::regclass;
ELSE
    v_parent_table := p_parent_table;
END IF;

IF p_partition_interval IS NULL THEN
    SELECT control, partition_interval, partition_type, datetime_string, epoch
    INTO v_control, v_partition_interval, v_partition_type, v_datetime_string, v_epoch
    FROM @extschema@.part_config WHERE parent_table = v_parent_table;
ELSE
    v_partition_interval := p_partition_interval;
    SELECT control, partition_type, datetime_string, epoch 
    INTO v_control, v_partition_type, v_datetime_string, v_epoch
    FROM @extschema@.part_config WHERE parent_table = v_parent_table;
END IF;

IF v_control IS NULL THEN
    RAISE EXCEPTION 'Parent table of given child not managed by pg_partman: %', v_parent_table;
END IF;

SELECT general_type INTO v_control_type FROM @extschema@.check_control_type(v_child_schema, v_child_tablename, v_control);

v_suffix_position := (length(v_child_tablename) - position('p_' in reverse(v_child_tablename))) + 2;
v_suffix := substring(v_child_tablename from v_suffix_position);

IF v_control_type = 'time' OR (v_control_type = 'id' AND v_epoch <> 'none') THEN

        IF v_partition_interval::interval <> '3 months' OR (v_partition_interval::interval = '3 months' AND v_partition_type = 'time-custom') THEN
           child_start_time := to_timestamp(v_suffix, v_datetime_string);
        ELSE
            -- to_timestamp doesn't recognize 'Q' date string formater. Handle it
            v_year := split_part(v_suffix, 'q', 1);
            v_quarter := split_part(v_suffix, 'q', 2);
            CASE
                WHEN v_quarter = '1' THEN
                    child_start_time := to_timestamp(v_year || '-01-01', 'YYYY-MM-DD');
                WHEN v_quarter = '2' THEN
                    child_start_time := to_timestamp(v_year || '-04-01', 'YYYY-MM-DD');
                WHEN v_quarter = '3' THEN
                    child_start_time := to_timestamp(v_year || '-07-01', 'YYYY-MM-DD');
                WHEN v_quarter = '4' THEN
                    child_start_time := to_timestamp(v_year || '-10-01', 'YYYY-MM-DD');
            END CASE;
        END IF;

        child_end_time := (child_start_time + v_partition_interval::interval) - '1 second'::interval;

ELSIF v_control_type = 'id' THEN

    child_start_id := v_suffix::bigint;
    child_end_id := (child_start_id + v_partition_interval::bigint) - 1;

ELSE
    RAISE EXCEPTION 'Invalid partition type encountered in show_partition_info()';
END IF;

suffix = v_suffix;

EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');

RETURN;

END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION show_partition_name(p_parent_table text, p_value text, OUT partition_table text, OUT suffix_timestamp timestamptz, OUT suffix_id bigint, OUT table_exists boolean) RETURNS record
    LANGUAGE plpgsql STABLE
    AS $$
DECLARE

v_child_exists          text;
v_control               text;
v_control_type          text;
v_datetime_string       text;
v_epoch                 text;
v_max_range             timestamptz;
v_min_range             timestamptz;
v_parent_schema         text;
v_parent_tablename      text;
v_partition_interval    text;
v_type                  text;

BEGIN
/*
 * Given a parent table and partition value, return the name of the child partition it would go in.
 * If using epoch time partitioning, give the text representation of the timestamp NOT the epoch integer value (use to_timestamp() to convert epoch values).
 * Also returns just the suffix value and true if the child table exists or false if it does not
 */

SELECT partition_type 
    , control
    , partition_interval
    , datetime_string
    , epoch
INTO v_type
    , v_control
    , v_partition_interval
    , v_datetime_string 
    , v_epoch
FROM @extschema@.part_config 
WHERE parent_table = p_parent_table;

IF v_type IS NULL THEN
    RAISE EXCEPTION 'Parent table given is not managed by pg_partman (%)', p_parent_table;
END IF;

SELECT n.nspname, c.relname INTO v_parent_schema, v_parent_tablename
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE n.nspname = split_part(p_parent_table, '.', 1)::name
AND c.relname = split_part(p_parent_table, '.', 2)::name;
IF v_parent_tablename IS NULL THEN
    RAISE EXCEPTION 'Parent table given does not exist (%)', p_parent_table;
END IF;

SELECT general_type INTO v_control_type FROM @extschema@.check_control_type(v_parent_schema, v_parent_tablename, v_control);

IF ( (v_control_type = 'time') OR (v_control_type = 'id' AND v_epoch <> 'none') )
     AND v_type <> 'time-custom' 
THEN
    CASE
        WHEN v_partition_interval::interval = '15 mins' THEN
            suffix_timestamp := date_trunc('hour', p_value::timestamptz) + 
                '15min'::interval * floor(date_part('minute', p_value::timestamptz) / 15.0);
        WHEN v_partition_interval::interval = '30 mins' THEN
            suffix_timestamp := date_trunc('hour', p_value::timestamptz) + 
                '30min'::interval * floor(date_part('minute', p_value::timestamptz) / 30.0);
        WHEN v_partition_interval::interval = '1 hour' THEN
            suffix_timestamp := date_trunc('hour', p_value::timestamptz);
        WHEN v_partition_interval::interval = '1 day' THEN
            suffix_timestamp := date_trunc('day', p_value::timestamptz);
        WHEN v_partition_interval::interval = '1 week' THEN
            suffix_timestamp := date_trunc('week', p_value::timestamptz);
        WHEN v_partition_interval::interval = '1 month' THEN
            suffix_timestamp := date_trunc('month', p_value::timestamptz);
        WHEN v_partition_interval::interval = '3 months' THEN
            suffix_timestamp := date_trunc('quarter', p_value::timestamptz);
        WHEN v_partition_interval::interval = '1 year' THEN
            suffix_timestamp := date_trunc('year', p_value::timestamptz);
    END CASE;
    partition_table := v_parent_schema||'.'||@extschema@.check_name_length(v_parent_tablename, to_char(suffix_timestamp, v_datetime_string), TRUE);

ELSIF v_control_type = 'id' AND v_type <> 'time-custom' THEN
    suffix_id := (p_value::bigint - (p_value::bigint % v_partition_interval::bigint));
    partition_table := v_parent_schema||'.'||@extschema@.check_name_length(v_parent_tablename, suffix_id::text, TRUE);

ELSIF v_type = 'time-custom' THEN

    SELECT child_table, lower(partition_range) INTO partition_table, suffix_timestamp FROM @extschema@.custom_time_partitions 
        WHERE parent_table = p_parent_table AND partition_range @> p_value::timestamptz;

    IF partition_table IS NULL THEN
        SELECT max(upper(partition_range)) INTO v_max_range FROM @extschema@.custom_time_partitions WHERE parent_table = p_parent_table;
        SELECT min(lower(partition_range)) INTO v_min_range FROM @extschema@.custom_time_partitions WHERE parent_table = p_parent_table;
        IF p_value::timestamptz >= v_max_range THEN
            suffix_timestamp := v_max_range;
            LOOP
                -- Keep incrementing higher until given value is below the upper range
                suffix_timestamp := suffix_timestamp + v_partition_interval::interval;
                IF p_value::timestamptz < suffix_timestamp THEN
                    -- Have to subtract one interval because the value would actually be in the partition previous 
                    --      to this partition timestamp since the partition names contain the lower boundary
                    suffix_timestamp := suffix_timestamp - v_partition_interval::interval;
                    EXIT;
                END IF;
            END LOOP;
        ELSIF p_value::timestamptz < v_min_range THEN
            suffix_timestamp := v_min_range;
            LOOP
                -- Keep decrementing lower until given value is below or equal to the lower range
                suffix_timestamp := suffix_timestamp - v_partition_interval::interval;
                IF p_value::timestamptz >= suffix_timestamp THEN
                    EXIT;
                END IF;
            END LOOP;
        ELSE
            RAISE EXCEPTION 'Unable to determine a valid child table for the given parent table and value';
        END IF;

        partition_table := v_parent_schema||'.'||@extschema@.check_name_length(v_parent_tablename, to_char(suffix_timestamp, v_datetime_string), TRUE);
    END IF;
END IF;

SELECT tablename INTO v_child_exists
FROM pg_catalog.pg_tables
WHERE schemaname = split_part(partition_table, '.', 1)::name
AND tablename = split_part(partition_table, '.', 2)::name;

IF v_child_exists IS NOT NULL THEN
    table_exists := true;
ELSE
    table_exists := false;
END IF;

RETURN;

END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION show_partitions (p_parent_table text, p_order text DEFAULT 'ASC') RETURNS TABLE (partition_schemaname text, partition_tablename text)
    LANGUAGE plpgsql STABLE SECURITY DEFINER 
    AS $$
DECLARE

v_control               text;
v_control_type          text;
v_datetime_string       text;
v_epoch                 text;
v_new_search_path       text := '@extschema@,pg_temp';
v_old_search_path       text;
v_parent_schema         text;
v_parent_tablename      text;
v_partition_interval    text;
v_quarter               text;
v_type                  text;
v_year                  text;

BEGIN
/*
 * Function to list all child partitions in a set in logical order.
 */

SELECT current_setting('search_path') INTO v_old_search_path;
EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_new_search_path, 'false');

IF upper(p_order) NOT IN ('ASC', 'DESC') THEN
    EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');
    RAISE EXCEPTION 'p_order paramter must be one of the following values: ASC, DESC';
END IF;

SELECT partition_type
    , partition_interval
    , datetime_string
    , control
    , epoch
INTO v_type
    , v_partition_interval
    , v_datetime_string
    , v_control
    , v_epoch
FROM @extschema@.part_config
WHERE parent_table = p_parent_table;

SELECT n.nspname, c.relname INTO v_parent_schema, v_parent_tablename
FROM pg_catalog.pg_class c
JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
WHERE n.nspname = split_part(p_parent_table, '.', 1)::name
AND c.relname = split_part(p_parent_table, '.', 2)::name;

SELECT general_type INTO v_control_type FROM @extschema@.check_control_type(v_parent_schema, v_parent_tablename, v_control);

IF v_control_type = 'time' OR (v_control_type = 'id' AND v_epoch <> 'none') THEN

    IF v_partition_interval::interval <> '3 months' OR (v_partition_interval::interval = '3 months' AND v_type = 'time-custom') THEN
        RETURN QUERY EXECUTE 
        format('SELECT n.nspname::text AS partition_schemaname, c.relname::text AS partition_name FROM
        pg_catalog.pg_inherits h
        JOIN pg_catalog.pg_class c ON c.oid = h.inhrelid
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE h.inhparent = ''%I.%I''::regclass
        ORDER BY to_timestamp(substring(c.relname from ((length(c.relname) - position(''p_'' in reverse(c.relname))) + 2) ), %L) %s'
            , v_parent_schema
            , v_parent_tablename
            , v_datetime_string
            , p_order);
    ELSE
        -- For quarterly, to_timestamp() doesn't recognize ""Q"" in datetime string. 
        -- First order by just the year, then order by the quarter number (should be last character in table name)
        RETURN QUERY EXECUTE 
        format('SELECT n.nspname::text AS partition_schemaname, c.relname::text AS partition_name FROM
        pg_catalog.pg_inherits h
        JOIN pg_catalog.pg_class c ON c.oid = h.inhrelid
        JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
        WHERE h.inhparent = ''%I.%I''::regclass
        ORDER BY to_timestamp(substring(c.relname from ((length(c.relname) - position(''p_'' in reverse(c.relname))) + 2) for 4), ''YYYY'') %s
            , substring(reverse(c.relname) from 1 for 1) %s'
            , v_parent_schema
            , v_parent_tablename
            , p_order
            , p_order);
    END IF;

ELSIF v_control_type = 'id' THEN
    RETURN QUERY EXECUTE 
    format('SELECT n.nspname::text AS partition_schemaname, c.relname::text AS partition_name FROM
    pg_catalog.pg_inherits h
    JOIN pg_catalog.pg_class c ON c.oid = h.inhrelid
    JOIN pg_catalog.pg_namespace n ON c.relnamespace = n.oid
    WHERE h.inhparent = ''%I.%I''::regclass
    ORDER BY substring(c.relname from ((length(c.relname) - position(''p_'' in reverse(c.relname))) + 2) )::bigint %s'
        , v_parent_schema
        , v_parent_tablename
        , p_order);

END IF;

EXECUTE format('SELECT set_config(%L, %L, %L)', 'search_path', v_old_search_path, 'false');

END
$$;",pg_partman--2.6.4--3.0.0.sql
"CREATE OR REPLACE FUNCTION somma( a int DEFAULT 0,
                                  b int DEFAULT 0 )
RETURNS INTEGER
AS
$BODY$
DECLARE
      c CONSTANT integer := 10;
BEGIN
        RETURN a + b + c;
END;
$BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION somma( a int DEFAULT 0,
                                  b int DEFAULT 0 )
RETURNS INTEGER
AS $BODY$
DECLARE
BEGIN
        RETURN a + b;
END;
$BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION somma( a int, b int )
RETURNS INTEGER
AS
$BODY$
DECLARE
BEGIN
        RETURN a + b;
END;
$BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION somma( int, int )
RETURNS INTEGER
AS
$BODY$
DECLARE
        a ALIAS FOR $1;
        b ALIAS FOR $2;
BEGIN
        RETURN a + b;
END;
$BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION somma( int, int )
RETURNS INTEGER
AS
$BODY$
DECLARE --nessun variabile
BEGIN
        RETURN $1 + $2;
END;
$BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION somma_sottrazione( INOUT a int ,
                                              INOUT b int )
AS $BODY$
DECLARE
BEGIN
        a = a + b;
        b = a - b;
END; $BODY$
LANGUAGE plpgsql;",postgresql-9.6-slides.org
"CREATE OR REPLACE FUNCTION sp_helloworld()
RETURNS void
AS $hello$
DECLARE
	var VARCHAR(30):='Hola '||1;
BEGIN
	RAISE NOTICE '%',var;
END; $hello$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION sp_lxc()
RETURNS void
AS $$
DECLARE
	cursor_sql CURSOR
	FOR
	SELECT CIUDAD.nom_ciudad, COUNT(PRESTAMO.cod_prestamo) AS total
	FROM PRESTAMO, CIUDAD, USUARIO
	WHERE CIUDAD.cod_ciudad=USUARIO.cod_ciudad AND PRESTAMO.cod_usuario=USUARIO.cod_usuario
	GROUP BY CIUDAD.nom_ciudad;
BEGIN
	FOR registro IN cursor_sql LOOP
		RAISE NOTICE '%: %',registro.nom_ciudad,registro.total;
	END LOOP;
END; $$
LANGUAGE plpgsql;",PLPGSQL.txt
"CREATE OR REPLACE FUNCTION sp_process_address1(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(sp_replace_vietnamese_char($1))),'');
	var_result := sp_process_data_char_after_number(var_result);

	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	
	var_result := sp_replace_common_phrase(var_result);

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_process_address2(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(sp_replace_vietnamese_char($1))),'');
	var_result := sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := sp_replace_common_phrase(var_result);

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	
	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_process_address3(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(sp_replace_vietnamese_char($1))),'');
	var_result := sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));
	var_result := sp_replace_common_phrase(var_result);	

	var_result := regexp_replace(var_result,'(^| )Ban Ql_Ct( |$)','\\1Ban Quản Lý Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Đ ','\\1Đường ','ig');
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));
	var_result := regexp_replace(var_result,'^Cxvh$','Cư Xá Văn Hóa','ig');
	var_result := regexp_replace(var_result,'^Cmt8$','Cách Mạng Tháng 8','ig');
	var_result := regexp_replace(var_result,'^bưởi$','Đường Bưởi','ig');
	var_result := regexp_replace(var_result,'^Khu Cty Cp Trúc Thôn$','Khu Công Ty Cổ Phần Trúc Thôn','ig');
	var_result := regexp_replace(var_result,'^\\( Tổ 9 \\)$','Tổ 9','ig');

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_process_address4(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
BEGIN
	var_result := COALESCE(TRIM(initcap(sp_replace_vietnamese_char($1))),'');
	var_result := sp_process_data_char_after_number(var_result);
	
	var_result := REGEXP_REPLACE(var_result,'[.;]',' ','g');	
	var_result := REPLACE(var_result,' , ',' ');	
	var_result := TRIM(REPLACE(var_result,',',', '));
	
	var_result := trim(REGEXP_REPLACE(var_result,'-',' - ','g'));	
	var_result := sp_replace_common_phrase(var_result);
	var_result := regexp_replace(var_result,'(^| )ii( |$)','\\1II\\2','ig');

	var_result := regexp_replace(var_result,'(^| )(P|F)( |[0-9]+)','\\1Phường \\3','ig');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'\\s+',' ','g'));

	var_result := replace(var_result,'Vn_Singapore','Việt Nam - Singapore');
	

	var_result := TRIM(REGEXP_REPLACE(var_result,'[-,/]+$',''));
	var_result := TRIM(REGEXP_REPLACE(var_result,'^0$',''));

	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_process_data_char_after_number(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
	var_character varchar[];
BEGIN
	var_result := $1;

	FOR var_character IN SELECT regexp_matches($1,'[0-9][a-z]','g')
	LOOP
		var_result = replace(var_result, var_character[1], upper(var_character[1]));

	END LOOP;

	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_replace_common_phrase(character varying)
  RETURNS character varying AS
$BODY$
DECLARE
	var_result varchar;
BEGIN

	var_result := COALESCE(TRIM($1),'');
	var_result := regexp_replace(var_result,'(^| )Kcn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kcx( |$)','\\1Khu Chế Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdc( |$)','\\1Khu Dân Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ksx( |$)','\\1Khu Sản Xuất\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kdl( |$)','\\1Khu Du Lịch\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Cụm Cn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Khu Cn( |$)','\\1Khu Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ccn( |$)','\\1Cụm Công Nghiệp\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp( |$)','\\1Khu Phố\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Nt( |$)','\\1Nhà Trọ\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Ct( |$)','\\1Công Trình\\2','ig');
	var_result := regexp_replace(var_result,'(^| )C/?C( |$)','\\1Chung Cư\\2','ig');
	var_result := regexp_replace(var_result,'(^| )Kp','\\1Khu Phố ','ig');
	var_result := regexp_replace(var_result,'(^| )Ql','\\1Quốc Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )Tl','\\1Tỉnh Lộ ','ig');
	var_result := regexp_replace(var_result,'(^| )tt','\\1Thị Trấn ','ig');
	var_result := regexp_replace(var_result,'(^| )tx','\\1Thị Xã ','ig');
	var_result := regexp_replace(var_result,'(^| )Kv','\\1Khu Vực ','ig');
	var_result := regexp_replace(var_result,'(^| )kđtm ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )K ?Đô Thị Mới ','\\1Khu Đô Thị Mới ','ig');
	var_result := regexp_replace(var_result,'(^| )kđt ','\\1Khu Đô Thị ','ig');
	var_result := regexp_replace(var_result,'(^| )tdp ','\\1Tổ Dân Phố ','ig');
	


	RETURN var_result;

END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION sp_replace_vietnamese_char(character varying)
  RETURNS character varying AS
$BODY$
DECLARE 
	var_result varchar;
BEGIN
	var_result := $1;
	var_result := replace(var_result,'Á','Á');
	var_result := replace(var_result,'À','À');
	var_result := replace(var_result,'Ả','Ả');
	var_result := replace(var_result,'Ã','Ã');
	var_result := replace(var_result,'Ạ','Ạ');
	var_result := replace(var_result,'Ắ','Ắ');
	var_result := replace(var_result,'Ằ','Ằ');
	var_result := replace(var_result,'Ẳ','Ẳ');
	var_result := replace(var_result,'Ẵ','Ẵ');
	var_result := replace(var_result,'Ặ','Ặ');
	var_result := replace(var_result,'Ấ','Ấ');
	var_result := replace(var_result,'Ầ','Ầ');
	var_result := replace(var_result,'Ẩ','Ẩ');
	var_result := replace(var_result,'Ẫ','Ẫ');
	var_result := replace(var_result,'Ậ','Ậ');
	var_result := replace(var_result,'É','É');
	var_result := replace(var_result,'È','È');
	var_result := replace(var_result,'Ẻ','Ẻ');
	var_result := replace(var_result,'Ẽ','Ẽ');
	var_result := replace(var_result,'Ẹ','Ẹ');
	var_result := replace(var_result,'Ế','Ế');
	var_result := replace(var_result,'Ề','Ề');
	var_result := replace(var_result,'Ể','Ể');
	var_result := replace(var_result,'Ễ','Ễ');
	var_result := replace(var_result,'Ệ','Ệ');
	var_result := replace(var_result,'Ó','Ó');
	var_result := replace(var_result,'Ò','Ò');
	var_result := replace(var_result,'Ỏ','Ỏ');
	var_result := replace(var_result,'Õ','Õ');
	var_result := replace(var_result,'Ọ','Ọ');
	var_result := replace(var_result,'Ố','Ố');
	var_result := replace(var_result,'Ồ','Ồ');
	var_result := replace(var_result,'Ổ','Ổ');
	var_result := replace(var_result,'Ỗ','Ỗ');
	var_result := replace(var_result,'Ộ','Ộ');
	var_result := replace(var_result,'Ớ','Ớ');
	var_result := replace(var_result,'Ờ','Ờ');
	var_result := replace(var_result,'Ở','Ở');
	var_result := replace(var_result,'Ỡ','Ỡ');
	var_result := replace(var_result,'Ợ','Ợ');
	var_result := replace(var_result,'Í','Í');
	var_result := replace(var_result,'Ì','Ì');
	var_result := replace(var_result,'Ỉ','Ỉ');
	var_result := replace(var_result,'Ĩ','Ĩ');
	var_result := replace(var_result,'Ị','Ị');
	var_result := replace(var_result,'Ú','Ú');
	var_result := replace(var_result,'Ù','Ù');
	var_result := replace(var_result,'Ủ','Ủ');
	var_result := replace(var_result,'Ũ','Ũ');
	var_result := replace(var_result,'Ụ','Ụ');
	var_result := replace(var_result,'Ứ','Ứ');
	var_result := replace(var_result,'Ừ','Ừ');
	var_result := replace(var_result,'Ử','Ử');
	var_result := replace(var_result,'Ữ','Ữ');
	var_result := replace(var_result,'Ự','Ự');
	
	return var_result;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",data-cleaning_latest.backup
"CREATE OR REPLACE FUNCTION subscribers.is_can_priv(_msisdn character varying,_dispatch integer)
    RETURNS boolean
    LANGUAGE 'plpgsql'
    VOLATILE
    PARALLEL UNSAFE
    COST 100
AS $BODY$
declare
  ret boolean=false;
BEGIN                                                                 
  select 
  <-- каждый count  фактически if который проверяет что-бы небыло совпадений по этим условиям -->
  (SELECT count(*) = 0 FROM subscribers.phone_priv p 
  inner join subscribers.dispatch_list d on p.iddispatch = d.id 
  WHERE p.msisdn = _msisdn and p.iddispatch = _dispatch 
  and p.date_end > (now() - d.no_free_period)) 
  
  AND
  
  (SELECT count(*) = 0 FROM blacklist p WHERE p.dst = _msisdn and p.""type"" = 3) 
  
  into ret;
    
  return ret;                         
END;

$BODY$;",SQL.sql
"CREATE OR REPLACE FUNCTION system.get_text_from_schema_only(schema_name character varying)
  RETURNS text AS
$BODY$
DECLARE
  table_rec record;
  total_script varchar default '';
  sql_part varchar;
  new_line_values varchar default '
';
BEGIN
  
  -- Drop schema if exists.
  sql_part = 'DROP SCHEMA IF EXISTS ' || schema_name || ' CASCADE;';        
  total_script = sql_part || new_line_values;  
  
  -- Make the schema empty.
  sql_part = 'CREATE SCHEMA ' || schema_name || ';';
  total_script = total_script || sql_part || new_line_values;  
  
  -- Loop through all tables in the schema
  for table_rec in select table_name from information_schema.tables where table_schema = schema_name loop

    -- Make the create statement for the table
    sql_part = (select 'create table ' || schema_name || '.' || table_rec.table_name || '(' || new_line_values
      || string_agg('  ' || col_definition, ',' || new_line_values) || ');'
    from (select column_name || ' ' 
      || udt_name 
      || coalesce('(' || character_maximum_length || ')', '') 
        || case when udt_name = 'numeric' then coalesce('(' || numeric_precision || ',' || numeric_scale  || ')', '') else '' end as col_definition
      from information_schema.columns
      where table_schema = schema_name and table_name = table_rec.table_name
      order by ordinal_position) as cols);
    total_script = total_script || sql_part || new_line_values;
  end loop;

  return total_script;
END;
$BODY$
  LANGUAGE plpgsql;",55-1411a_CONSOLIDATION.sql
"CREATE OR REPLACE FUNCTION table_hompage() RETURNS void AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'homepage') THEN

        execute 
	    'CREATE TABLE homepage (
            htmlcode character varying,
            lang character varying,
            CONSTRAINT homepage_lang_key UNIQUE (lang)
            );';
    END IF;
END;

$$LANGUAGE plpgsql VOLATILE;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION table_thesohompage() RETURNS void AS $$
BEGIN
    IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'thesohomepage') THEN

        execute 
	    'CREATE TABLE thesohomepage (
            htmlcode character varying,
            lang character varying,
            idtheso character varying,
            CONSTRAINT thesohomepage_idtheso_lang_key UNIQUE (idtheso, lang)
            );';
    END IF;
END;

$$LANGUAGE plpgsql VOLATILE;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;",pg_SAHSULAND.sql
"CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;",pg_USA_2014.sql
"CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;",pg_cb_2014_us_500k.sql
"CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;",postgres_load.md
"CREATE OR REPLACE FUNCTION tileMaker_tile2latitude(y INTEGER, zoom_level INTEGER)
RETURNS DOUBLE PRECISION AS
$BODY$
DECLARE
	n FLOAT;
	sinh FLOAT;
	E FLOAT = 2.7182818284;
BEGIN
    n = PI() - (2.0 * PI() * y) / POWER(2.0, zoom_level);
    sinh = (1 - POWER(E, -2*n)) / (2 * POWER(E, -n));
    RETURN DEGREES(ATAN(sinh));
END;
$BODY$
LANGUAGE plpgsql IMMUTABLE;",rif_pg_SAHSULAND.sql
"CREATE OR REPLACE FUNCTION tim_da(IN chuoi character varying)
RETURNS TABLE(question_id integer, question character varying, wrong_ans character varying[], true_ans character varying, topic_id integer) AS
$BODY$
begin
return query 
select
q.question_id,
q.question,
q.wrong_ans,
q.true_ans,
q.topic_id
from questions as q where (q.true_ans ilike concat('%',$1,'%') or q.wrong_ans[1] ilike concat('%',$1,'%') or
q.wrong_ans[2] ilike concat('%',$1,'%') or q.wrong_ans[3] ilike concat('%',$1,'%') or q.question_id = chuoi::integer);

end;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100
ROWS 1000;",index.html
"CREATE OR REPLACE FUNCTION tim_da(IN chuoi character varying)
RETURNS TABLE(question_id integer, question character varying, wrong_ans character varying[], true_ans character varying, topic_id integer) AS
$BODY$
begin
return query 
select
q.question_id,
q.question,
q.wrong_ans,
q.true_ans,
q.topic_id
from questions as q where (q.true_ans ilike concat('%',$1,'%') or q.wrong_ans[1] ilike concat('%',$1,'%') or
q.wrong_ans[2] ilike concat('%',$1,'%') or q.wrong_ans[3] ilike concat('%',$1,'%') or q.question_id = chuoi::integer);

end;
$BODY$
LANGUAGE plpgsql VOLATILE
COST 100
ROWS 1000;",index.md
"CREATE OR REPLACE FUNCTION to_json_build_vd(VARIADIC valor character varying[])
  RETURNS character varying AS
$BODY$
DECLARE
	d_parameters record;
	d_length integer;
	jsons json;
	error_MESSAGE_TEXT varchar;
	validated json;
	query text default 'Select ';
	d_return json;
	d_clave varchar;
	d_type varchar;
BEGIN
	/*
	Hecho por: Vlade Párica - Dey
	Fecha: 08-06-2018
	Resumen:

	Para probarlo:
					select to_json_build_vd('15','{""hola"":""hola""}','HOLA','hola','prueba','1','boolean','true','array','[]')
	*/

	d_length = array_length(valor,1);



	if d_length % 2 = 0 then -- solo si es par es porque estan completos sus (clave : valor)

		for d_parameters in 1 .. d_length
		loop

			if not d_parameters % 2 = 0 then

				-- validando que no esten erroneas las claves
				select
					'{}' into validated
				where
					valor[d_parameters] like '%[%' or
					valor[d_parameters] like '%]%' or
					valor[d_parameters] like '%{%' or
					valor[d_parameters] like '%}%' or
					valor[d_parameters] like '%:%';


				if validated::varchar = '{}' then

					 return replace(json_build_object('ERROR','la sintaxis de entrada no es válida para la clave: '||valor[d_parameters]||' ')::varchar,(CHR(92)||'""'),'""');
				end if;

			end if;

			--raise notice 'd_parameters %', valor[d_parameters];

			IF (d_parameters % 2 = 0) THEN

				d_type = typeof_vd(valor[d_parameters]::text);

				IF ( d_type = 'text' or d_type = 'json' or d_type = 'date') THEN

					query :=  query || '''' || trim(valor[d_parameters],'""') || '''' || '::' || d_type || ' AS '|| '""' || d_clave || '"", ';

				ELSEIF (d_type = 'null') THEN

					query :=  query || valor[d_parameters]|| '::' || d_type || ' AS '|| '""' || d_clave || '"", ';

				ELSE
					query :=  query || valor[d_parameters]|| ' AS '|| '""' || d_clave || '"", ';
				END IF;
			ELSE
				--raise notice '1';
				d_clave :=  valor[d_parameters];
			END IF;

		end loop;

		query := rtrim(query::text,', ');

		execute 'SELECT to_json(a.*) FROM ( '
			|| query ||
		') a' into d_return;
	else

		return json_build_object('ERROR','la sintaxis de entrada no es válida cantidad de parametros incongruentes');

	end if;

	RETURN d_return;

	EXCEPTION
	WHEN others THEN
	GET STACKED DIAGNOSTICS
	error_MESSAGE_TEXT = MESSAGE_TEXT;

	jsons = json_build_object('ERROR',error_MESSAGE_TEXT);

	return jsons;

END;$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",to_json_build_vd.sql
"CREATE OR REPLACE FUNCTION to_number(text)
-- From Postgres 9.3 on this replace is requred. We assume a german localization in the database
-- Older Versions of Postgres are treated as before
  RETURNS numeric AS
$BODY$
  DECLARE v_version CHARACTER VARYING;
BEGIN
    RETURN to_number(replace($1,'.',','), 'S99999999999999D999999');
END;
$BODY$
  LANGUAGE plpgsql IMMUTABLE
  COST 100;",commonfunctions.sql
"CREATE OR REPLACE FUNCTION tools.srid_utm(longitude double precision, latitude double precision)
RETURNS integer AS
$BODY$
DECLARE
  srid integer;
  lon float;
  lat float;
BEGIN
  lat := latitude;
  lon := longitude;

IF ((lon > 360 or lon < -360) or (lat > 90 or lat < -90)) THEN 
  RAISE EXCEPTION 'Longitude and latitude is not in a valid format (-360 to 360; -90 to 90)';
ELSEIF (longitude < -180)THEN 
  lon := 360 + lon;
ELSEIF (longitude > 180)THEN 
  lon := 180 - lon;
END IF;

IF latitude >= 0 THEN 
  srid := 32600 + floor((lon+186)/6); 
ELSE
  srid := 32700 + floor((lon+186)/6); 
END IF;

RETURN srid;
END;
$BODY$
LANGUAGE plpgsql VOLATILE STRICT
COST 100;",part2_spatial_data.md
"CREATE OR REPLACE FUNCTION truncate_tables(username IN VARCHAR) RETURNS void AS $$
DECLARE
    statements CURSOR FOR
        SELECT tablename FROM pg_tables
        WHERE tableowner = username AND schemaname = 'public';
BEGIN
    FOR stmt IN statements LOOP
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(stmt.tablename) || ' CASCADE;';
    END LOOP;
END;
$$ LANGUAGE plpgsql;",postgresql.md
"CREATE OR REPLACE FUNCTION truncate_tables(username IN VARCHAR) RETURNS void AS $$
DECLARE
statements CURSOR FOR
SELECT tablename FROM pg_tables
WHERE tableowner = username AND schemaname = 'public';
BEGIN
FOR stmt IN statements LOOP
EXECUTE 'TRUNCATE TABLE ' || quote_ident(stmt.tablename) || ' CASCADE;';
END LOOP;
END;
$$ LANGUAGE plpgsql;",2015-11-11-postgres-usage.md
"CREATE OR REPLACE FUNCTION unaccent_string(text)
  RETURNS text AS
$BODY$
DECLARE
input_string text := $1;
BEGIN

input_string := translate(input_string, 'âãäåāăąÁÂÃÄÅĀĂĄ', 'aaaaaaaaaaaaaaa');
input_string := translate(input_string, 'èééêëēĕėęěĒĔĖĘĚÉ', 'eeeeeeeeeeeeeeee');
input_string := translate(input_string, 'ìíîïìĩīĭÌÍÎÏÌĨĪĬ', 'iiiiiiiiiiiiiiii');
input_string := translate(input_string, 'óôõöōŏőÒÓÔÕÖŌŎŐ', 'ooooooooooooooo');
input_string := translate(input_string, 'ùúûüũūŭůÙÚÛÜŨŪŬŮ', 'uuuuuuuuuuuuuuuu');
input_string := translate(input_string, '-_/()', '     ');

return input_string;
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",maj_bdd_current.sql
"CREATE OR REPLACE FUNCTION v_dailysales_current_account_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	whereUserInvoices varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dt.isfiscaldocument = ''Y'' ' || 
			 ' AND (dt.isfiscal is null OR dt.isfiscal = ''N'' OR (dt.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dt.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dt.transactiontypefrontliva is null OR dt.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate;

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = 'SELECT ''CAI''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, ''CC'' AS tendertype, i.documentno, i.description, NULL::unknown AS info, (currencybase(i.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(20,2) - COALESCE(cobros.amount, 0::numeric))::numeric(20,2) AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, NULL::unknown AS c_pospaymentmedium_id, NULL::unknown AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dt.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   LEFT JOIN ( SELECT c.c_invoice_id, sum(c.amount) AS amount
         FROM ( SELECT 
                      CASE
                          WHEN (dt.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                          ELSE i.c_invoice_id
                      END AS c_invoice_id, currencybase(pjp.amount, i.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(20,2) as amount
                 FROM ' || posJournalPaymentsFrom || ' pjp
            JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
       JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal as pj on pj.c_posjournal_id = i.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) AND hdr.isactive = ''Y''::bpchar OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND hdr.isactive = ''N''::bpchar)) c
        GROUP BY c.c_invoice_id) cobros ON cobros.c_invoice_id = i.c_invoice_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND (cobros.amount IS NULL OR i.grandtotal <> cobros.amount) AND i.initialcurrentaccountamt > 0::numeric AND (dt.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND ""position""(dt.doctypekey::text, ''CDN''::text) < 1
UNION ALL 
         SELECT ''CAIA''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, ''CC'' AS tendertype, i.documentno, i.description, NULL::unknown AS info, (currencybase(i.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(20,2) - COALESCE(cobros.amount, 0::numeric))::numeric(20,2) * (-1)::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, NULL::integer AS c_pospaymentmedium_id, NULL::unknown AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dt.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   LEFT JOIN ( SELECT c.c_invoice_id, sum(c.amount) AS amount
         FROM ( SELECT 
                      CASE
                          WHEN (dt.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                          ELSE i.c_invoice_id
                      END AS c_invoice_id, currencybase(pjp.amount, i.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(20,2) as amount
                 FROM ' || posJournalPaymentsFrom || ' pjp
            JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
       JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal as pj on pj.c_posjournal_id = i.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) AND hdr.isactive = ''Y''::bpchar OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND hdr.isactive = ''N''::bpchar)) c
        GROUP BY c.c_invoice_id) cobros ON cobros.c_invoice_id = i.c_invoice_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND (cobros.amount IS NULL OR i.grandtotal <> cobros.amount) AND i.initialcurrentaccountamt > 0::numeric AND (dt.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND ""position""(dt.doctypekey::text, ''CDN''::text) < 1 AND (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar]));';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_current_account_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	whereUserInvoices varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dt.isfiscaldocument = ''Y'' ' || 
			 ' AND (dt.isfiscal is null OR dt.isfiscal = ''N'' OR (dt.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dt.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dt.transactiontypefrontliva is null OR dt.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate;

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = 'SELECT ''CAI''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, ''CC'' AS tendertype, i.documentno, i.description, NULL::unknown AS info, (i.grandtotal - COALESCE(cobros.amount, 0::numeric))::numeric(20,2) AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, NULL::unknown AS c_pospaymentmedium_id, NULL::unknown AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dt.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   LEFT JOIN ( SELECT c.c_invoice_id, sum(c.amount) AS amount
         FROM ( SELECT 
                      CASE
                          WHEN (dt.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                          ELSE i.c_invoice_id
                      END AS c_invoice_id, pjp.amount
                 FROM ' || posJournalPaymentsFrom || ' pjp
            JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
       JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal as pj on pj.c_posjournal_id = i.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) AND hdr.isactive = ''Y''::bpchar OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND hdr.isactive = ''N''::bpchar)) c
        GROUP BY c.c_invoice_id) cobros ON cobros.c_invoice_id = i.c_invoice_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND (cobros.amount IS NULL OR i.grandtotal <> cobros.amount) AND i.initialcurrentaccountamt > 0::numeric AND (dt.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND ""position""(dt.doctypekey::text, ''CDN''::text) < 1
UNION ALL 
         SELECT ''CAIA''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, ''CC'' AS tendertype, i.documentno, i.description, NULL::unknown AS info, (i.grandtotal - COALESCE(cobros.amount, 0::numeric))::numeric(20,2) * (-1)::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, NULL::integer AS c_pospaymentmedium_id, NULL::unknown AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dt.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   LEFT JOIN ( SELECT c.c_invoice_id, sum(c.amount) AS amount
         FROM ( SELECT 
                      CASE
                          WHEN (dt.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                          ELSE i.c_invoice_id
                      END AS c_invoice_id, pjp.amount
                 FROM ' || posJournalPaymentsFrom || ' pjp
            JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
       JOIN c_doctype dt ON i.c_doctypetarget_id = dt.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal as pj on pj.c_posjournal_id = i.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) AND hdr.isactive = ''Y''::bpchar OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND hdr.isactive = ''N''::bpchar)) c
        GROUP BY c.c_invoice_id) cobros ON cobros.c_invoice_id = i.c_invoice_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND (cobros.amount IS NULL OR i.grandtotal <> cobros.amount) AND i.initialcurrentaccountamt > 0::numeric AND (dt.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND ""position""(dt.doctypekey::text, ''CDN''::text) < 1 AND (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar]));';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_current_account_payments_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDatePayments varchar;
	wherePOSPayments varchar;
	whereUserPayments varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;

	-- Fechas para allocations y facturas
	whereDatePayments = '';
	if dateFrom is not null then
		whereDatePayments = ' AND date_trunc(''day'', pjp.allocationdate) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDatePayments = whereDatePayments || ' AND date_trunc(''day'', pjp.allocationdate) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSPayments = ' AND (' || posID || ' = -1 OR COALESCE(pjh.c_pos_id, pj.c_pos_id) = ' || posID || ')';

	-- Usuario
	whereUserPayments = ' AND (' || userID || ' = -1 OR COALESCE(pjh.ad_user_id, pj.ad_user_id) = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = 'SELECT ''PCA''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
            ELSE i.c_invoice_id
        END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
            ELSE pjp.c_invoice_credit_id
        END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, currencybase(pjp.amount, i.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(20,2) as amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
            ELSE p.c_pospaymentmedium_id
        END AS c_pospaymentmedium_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
            ELSE ppm.name
        END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
   FROM ' || posJournalPaymentsFrom || ' pjp
   JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
   LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND date_trunc(''day''::text, i.dateacct) <> date_trunc(''day''::text, pjp.allocationdateacct::timestamp with time zone) AND i.initialcurrentaccountamt > 0::numeric AND hdr.isactive = ''Y''::bpchar AND ((dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) OR (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL);';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_current_account_payments_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDatePayments varchar;
	wherePOSPayments varchar;
	whereUserPayments varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;

	-- Fechas para allocations y facturas
	whereDatePayments = '';
	if dateFrom is not null then
		whereDatePayments = ' AND date_trunc(''day'', pjp.allocationdate) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDatePayments = whereDatePayments || ' AND date_trunc(''day'', pjp.allocationdate) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSPayments = ' AND (' || posID || ' = -1 OR COALESCE(pjh.c_pos_id, pj.c_pos_id) = ' || posID || ')';

	-- Usuario
	whereUserPayments = ' AND (' || userID || ' = -1 OR COALESCE(pjh.ad_user_id, pj.ad_user_id) = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = 'SELECT ''PCA''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
            ELSE i.c_invoice_id
        END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
            ELSE pjp.c_invoice_credit_id
        END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, pjp.amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
            ELSE p.c_pospaymentmedium_id
        END AS c_pospaymentmedium_id, 
        CASE
            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
            ELSE ppm.name
        END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
   FROM ' || posJournalPaymentsFrom || ' pjp
   JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
   LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND date_trunc(''day''::text, i.dateacct) <> date_trunc(''day''::text, pjp.allocationdateacct::timestamp with time zone) AND i.initialcurrentaccountamt > 0::numeric AND hdr.isactive = ''Y''::bpchar AND ((dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) OR (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL);';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_invoices_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	whereUserInvoices varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate || whereDateInvoices || wherePOSInvoices || whereUserInvoices;

	-- Armar la consulta
	consulta = 'SELECT ''I''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, dtc.docbasetype AS tendertype, i.documentno, i.description, NULL::unknown AS info, currencybase(i.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(20,2) * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, dtc.c_doctype_id AS c_pospaymentmedium_id, dtc.name AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
   FROM c_invoice i
   LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd ||
  ' AND NOT (
  		EXISTS (
			SELECT * FROM (
				SELECT *
				FROM c_allocationline al
				WHERE i.c_invoice_id = al.c_invoice_id AND i.isvoidable = ''Y''::bpchar 
			) as FOO
			JOIN c_payment p ON p.c_payment_id = foo.c_payment_id
			JOIN c_cashline cl ON cl.c_payment_id = p.c_payment_id
		)
	);';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_invoices_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	whereUserInvoices varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate || whereDateInvoices || wherePOSInvoices || whereUserInvoices;

	-- Armar la consulta
	consulta = 'SELECT ''I''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::integer AS c_payment_id, NULL::integer AS c_cashline_id, NULL::integer AS c_invoice_credit_id, dtc.docbasetype AS tendertype, i.documentno, i.description, NULL::unknown AS info, i.grandtotal * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, dtc.c_doctype_id AS c_pospaymentmedium_id, dtc.name AS pospaymentmediumname, NULL::integer AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::integer AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
   FROM c_invoice i
   LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd ||
  ' AND NOT (
  		EXISTS (
			SELECT * FROM (
				SELECT *
				FROM c_allocationline al
				WHERE i.c_invoice_id = al.c_invoice_id AND i.isvoidable = ''Y''::bpchar 
			) as FOO
			JOIN c_payment p ON p.c_payment_id = foo.c_payment_id
			JOIN c_cashline cl ON cl.c_payment_id = p.c_payment_id
		)
	);';

-- raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_v2_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereDatePayments varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	wherePOSPayments varchar;
	whereUserInvoices varchar;
	whereUserPayments varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDatePayments = '';
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDatePayments = ' AND date_trunc(''day'', pjp.allocationdate) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDatePayments = whereDatePayments || ' AND date_trunc(''day'', pjp.allocationdate) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSPayments = ' AND (' || posID || ' = -1 OR COALESCE(pjh.c_pos_id, pj.c_pos_id) = ' || posID || ')';
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserPayments = ' AND (' || userID || ' = -1 OR COALESCE(pjh.ad_user_id, pj.ad_user_id) = ' || userID || ')';
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate;

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = '(        (         SELECT ''P''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                                    ELSE i.c_invoice_id
                                END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
                                    ELSE pjp.c_invoice_credit_id
                                END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, currencybase(pjp.amount, i.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(20,2) as amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
                                    WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
                                    WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
                                    ELSE p.c_pospaymentmedium_id
                                END AS c_pospaymentmedium_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
                                    WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
                                    WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
                                    ELSE ppm.name
                                END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                           FROM ' || posJournalPaymentsFrom || ' pjp
                      JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
                 LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
            JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
       JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND (date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) OR i.initialcurrentaccountamt = 0::numeric) AND ((dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) OR (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL) AND (pjp.c_invoice_credit_id IS NULL OR pjp.c_invoice_credit_id IS NOT NULL AND (cc.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar]))) AND NOT (EXISTS ( SELECT c2.c_payment_id
   FROM c_cashline c2
  WHERE c2.c_payment_id = pjp.c_payment_id AND i.isvoidable = ''Y''::bpchar))
                UNION ALL 
                         SELECT ''NCC''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::unknown AS c_payment_id, NULL::unknown AS c_cashline_id, NULL::unknown AS c_invoice_credit_id, 
                                CASE
                                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                                    ELSE i.paymentrule
                                END AS tendertype, i.documentno, i.description, NULL::unknown AS info, currencybase(i.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(20,2) * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                                CASE
                                    WHEN i.paymentrule::text = ''P''::text THEN NULL::integer
                                    ELSE ( SELECT ad_ref_list.ad_ref_list_id
                                       FROM ad_ref_list
                                      WHERE ad_ref_list.ad_reference_id = 195 AND ad_ref_list.value::text = i.paymentrule::text
                                     LIMIT 1)
                                END AS c_pospaymentmedium_id, 
                                CASE
                                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                                    WHEN i.paymentrule::text = ''P''::text THEN NULL::character varying
                                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                                    ELSE i.paymentrule
                                END AS pospaymentmediumname, NULL::unknown AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::unknown AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                           FROM c_invoice i
                      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
                 JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
            JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
       JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND dtc.docbasetype = ''ARC''::bpchar AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND (EXISTS ( SELECT al.c_allocationline_id
          FROM c_allocationline al
         WHERE al.c_invoice_id = i.c_invoice_id))) AND NOT (EXISTS ( SELECT al.c_allocationline_id
          FROM c_allocationline al
         WHERE al.c_invoice_credit_id = i.c_invoice_id)))
        UNION ALL 
                 SELECT ''PA''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                            ELSE i.c_invoice_id
                        END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
                            ELSE pjp.c_invoice_credit_id
                        END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, currencybase(pjp.amount, i.c_currency_id, pjp.dateacct, pjp.ad_client_id, pjp.ad_org_id)::numeric(20,2) * (-1)::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
                            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
                            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
                            ELSE p.c_pospaymentmedium_id
                        END AS c_pospaymentmedium_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
                            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
                            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
                            ELSE ppm.name
                        END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                   FROM ' || posJournalPaymentsFrom || ' pjp
              JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
         LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
    JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND (date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) OR i.initialcurrentaccountamt = 0::numeric) AND hdr.isactive = ''N''::bpchar AND NOT (EXISTS ( SELECT c2.c_payment_id
   FROM c_cashline c2
  WHERE c2.c_payment_id = pjp.c_payment_id AND i.isvoidable = ''Y''::bpchar)))
UNION ALL 
         SELECT ''ND''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::unknown AS c_payment_id, NULL::unknown AS c_cashline_id, NULL::unknown AS c_invoice_credit_id, 
                CASE
                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                    ELSE i.paymentrule
                END AS tendertype, i.documentno, i.description, NULL::unknown AS info, currencybase(i.grandtotal, i.c_currency_id, i.dateacct, i.ad_client_id, i.ad_org_id)::numeric(20,2) * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, ( SELECT ad_ref_list.ad_ref_list_id
                   FROM ad_ref_list
                  WHERE ad_ref_list.ad_reference_id = 195 AND ad_ref_list.value::text = i.paymentrule::text
                 LIMIT 1) AS c_pospaymentmedium_id, 
                CASE
                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                    ELSE i.paymentrule
                END AS pospaymentmediumname, NULL::unknown AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::unknown AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND ""position""(dtc.doctypekey::text, ''CDN''::text) = 1 AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND (EXISTS ( SELECT al.c_allocationline_id
   FROM c_allocationline al
  WHERE al.c_invoice_credit_id = i.c_invoice_id))) AND NOT (EXISTS ( SELECT al.c_allocationline_id
   FROM c_allocationline al
  WHERE al.c_invoice_id = i.c_invoice_id));';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_dailysales_v2_filtered(
    orgid integer,
    posid integer,
    userid integer,
    datefrom date,
    dateto date,
    invoicedatefrom date,
    invoicedateto date,
    addinvoicedate boolean)
  RETURNS SETOF v_dailysales_type AS
$BODY$
declare
	consulta varchar;
	whereDateInvoices varchar;
	whereDatePayments varchar;
	whereInvoiceDate varchar;
	wherePOSInvoices varchar;
	wherePOSPayments varchar;
	whereUserInvoices varchar;
	whereUserPayments varchar;
	whereOrg varchar;
	whereClauseStd varchar;
	posJournalPaymentsFrom varchar;
	dateFromPOSJournalPayments varchar;
	dateToPOSJournalPayments varchar;
	orgIDPOSJournalPayments integer;
	adocument v_dailysales_type;
BEGIN
	-- Armado de las condiciones en base a los parámetros
	-- Organización
	whereOrg = '';
	if orgID is not null AND orgID > 0 THEN
		whereOrg = ' AND i.ad_org_id = ' || orgID;
	END IF;
	
	-- Fecha de factura
	whereInvoiceDate = '';
	if addInvoiceDate then
		if invoiceDateFrom is not null then
			whereInvoiceDate = ' AND date_trunc(''day'', i.dateacct) >= date_trunc(''day'', '''|| invoiceDateFrom || '''::date)';
		end if;
		if invoiceDateTo is not null then
			whereInvoiceDate = whereInvoiceDate || ' AND date_trunc(''day'', i.dateacct) <= date_trunc(''day'', ''' || invoiceDateTo || '''::date) ';
		end if;
	end if;

	-- Fechas para allocations y facturas
	whereDatePayments = '';
	whereDateInvoices = '';
	if dateFrom is not null then
		whereDatePayments = ' AND date_trunc(''day'', pjp.allocationdate) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
		whereDateInvoices = ' AND date_trunc(''day''::text, i.dateinvoiced) >= date_trunc(''day'', ''' || dateFrom || '''::date)';
	end if;

	if dateTo is not null then
		whereDatePayments = whereDatePayments || ' AND date_trunc(''day'', pjp.allocationdate) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
		whereDateInvoices = whereDateInvoices || ' AND date_trunc(''day''::text, i.dateinvoiced) <= date_trunc(''day'', ''' || dateTo || '''::date) ';
	end if;
	
	-- TPV
	wherePOSPayments = ' AND (' || posID || ' = -1 OR COALESCE(pjh.c_pos_id, pj.c_pos_id) = ' || posID || ')';
	wherePOSInvoices = ' AND (' || posID || ' = -1 OR pj.c_pos_id = ' || posID || ')';

	-- Usuario
	whereUserPayments = ' AND (' || userID || ' = -1 OR COALESCE(pjh.ad_user_id, pj.ad_user_id) = ' || userID || ')';
	whereUserInvoices = ' AND (' || userID || ' = -1 OR pj.ad_user_id = ' || userID || ')';

	-- Condiciones básicas del reporte
	whereClauseStd = ' ( i.issotrx = ''Y'' ' ||
			 whereOrg || 
			 ' AND (i.docstatus = ''CO'' or i.docstatus = ''CL'' or i.docstatus = ''RE'' or i.docstatus = ''VO'' OR i.docstatus = ''??'') ' ||
			 ' AND dtc.isfiscaldocument = ''Y'' ' || 
			 ' AND (dtc.isfiscal is null OR dtc.isfiscal = ''N'' OR (dtc.isfiscal = ''Y'' AND i.fiscalalreadyprinted = ''Y'')) ' ||
			 ' AND dtc.doctypekey not in (''RTR'', ''RTI'', ''RCR'', ''RCI'') ' || 
			 ' AND (dtc.transactiontypefrontliva is null OR dtc.transactiontypefrontliva = ''S'') ' || 
			 ' ) ';

	-- Agregar las condiciones anteriores
	whereClauseStd = whereClauseStd || whereInvoiceDate;

	-- Armado del llamado a la función que ejecuta la vista filtrada c_posjournalpayments_v
	dateFromPOSJournalPayments = (CASE WHEN dateFrom is null THEN 'null::date' ELSE '''' || dateFrom || '''::date' END);
	dateToPOSJournalPayments = (CASE WHEN dateTo is null THEN 'null::date' ELSE '''' || dateTo || '''::date' END);
	orgIDPOSJournalPayments = (CASE WHEN orgID is null THEN -1 ELSE orgID END);
	posJournalPaymentsFrom = 'c_posjournalpayments_v_filtered(' || orgIDPOSJournalPayments || ', ' || dateFromPOSJournalPayments || ', ' || dateToPOSJournalPayments || ')';

	-- Armar la consulta
	consulta = '(        (         SELECT ''P''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                                    ELSE i.c_invoice_id
                                END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
                                    ELSE pjp.c_invoice_credit_id
                                END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, pjp.amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
                                    WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
                                    WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
                                    ELSE p.c_pospaymentmedium_id
                                END AS c_pospaymentmedium_id, 
                                CASE
                                    WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
                                    WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
                                    WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
                                    ELSE ppm.name
                                END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                           FROM ' || posJournalPaymentsFrom || ' pjp
                      JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
                 LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
            JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
       JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND (date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) OR i.initialcurrentaccountamt = 0::numeric) AND ((dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) OR (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL) AND (pjp.c_invoice_credit_id IS NULL OR pjp.c_invoice_credit_id IS NOT NULL AND (cc.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar]))) AND NOT (EXISTS ( SELECT c2.c_payment_id
   FROM c_cashline c2
  WHERE c2.c_payment_id = pjp.c_payment_id AND i.isvoidable = ''Y''::bpchar))
                UNION ALL 
                         SELECT ''NCC''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::unknown AS c_payment_id, NULL::unknown AS c_cashline_id, NULL::unknown AS c_invoice_credit_id, 
                                CASE
                                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                                    ELSE i.paymentrule
                                END AS tendertype, i.documentno, i.description, NULL::unknown AS info, i.grandtotal * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                                CASE
                                    WHEN i.paymentrule::text = ''P''::text THEN NULL::integer
                                    ELSE ( SELECT ad_ref_list.ad_ref_list_id
                                       FROM ad_ref_list
                                      WHERE ad_ref_list.ad_reference_id = 195 AND ad_ref_list.value::text = i.paymentrule::text
                                     LIMIT 1)
                                END AS c_pospaymentmedium_id, 
                                CASE
                                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                                    WHEN i.paymentrule::text = ''P''::text THEN NULL::character varying
                                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                                    ELSE i.paymentrule
                                END AS pospaymentmediumname, NULL::unknown AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::unknown AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                           FROM c_invoice i
                      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
                 JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
            JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
       JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND dtc.docbasetype = ''ARC''::bpchar AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND (EXISTS ( SELECT al.c_allocationline_id
          FROM c_allocationline al
         WHERE al.c_invoice_id = i.c_invoice_id))) AND NOT (EXISTS ( SELECT al.c_allocationline_id
          FROM c_allocationline al
         WHERE al.c_invoice_credit_id = i.c_invoice_id)))
        UNION ALL 
                 SELECT ''PA''::character varying AS trxtype, pjp.ad_client_id, pjp.ad_org_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN pjp.c_invoice_credit_id
                            ELSE i.c_invoice_id
                        END AS c_invoice_id, pjp.allocationdate AS datetrx, pjp.c_payment_id, pjp.c_cashline_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN i.c_invoice_id
                            ELSE pjp.c_invoice_credit_id
                        END AS c_invoice_credit_id, pjp.tendertype, pjp.documentno, pjp.description, pjp.info, pjp.amount * (-1)::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.c_doctype_id
                            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.c_doctype_id
                            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.c_pospaymentmedium_id
                            ELSE p.c_pospaymentmedium_id
                        END AS c_pospaymentmedium_id, 
                        CASE
                            WHEN (dtc.docbasetype = ANY (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dtc.docbasetype::character varying
                            WHEN (dtc.docbasetype <> ALL (ARRAY[''ARC''::bpchar, ''APC''::bpchar])) AND pjp.c_invoice_credit_id IS NOT NULL THEN dt.docbasetype::character varying
                            WHEN pjp.c_cashline_id IS NOT NULL THEN ppmc.name
                            ELSE ppm.name
                        END AS pospaymentmediumname, pjp.m_entidadfinanciera_id, ef.name AS entidadfinancieraname, ef.value AS entidadfinancieravalue, pjp.m_entidadfinancieraplan_id, efp.name AS planname, pjp.docstatus, i.issotrx, pjp.dateacct, i.dateacct::date AS invoicedateacct, COALESCE(pjh.c_posjournal_id, pj.c_posjournal_id) AS c_posjournal_id, COALESCE(pjh.ad_user_id, pj.ad_user_id) AS ad_user_id, COALESCE(pjh.c_pos_id, pj.c_pos_id) AS c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
                   FROM ' || posJournalPaymentsFrom || ' pjp
              JOIN c_invoice i ON i.c_invoice_id = pjp.c_invoice_id
         LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
    JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   JOIN c_allocationhdr hdr ON hdr.c_allocationhdr_id = pjp.c_allocationhdr_id
   LEFT JOIN c_posjournal pjh ON pjh.c_posjournal_id = hdr.c_posjournal_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
   LEFT JOIN c_payment p ON p.c_payment_id = pjp.c_payment_id
   LEFT JOIN c_pospaymentmedium ppm ON ppm.c_pospaymentmedium_id = p.c_pospaymentmedium_id
   LEFT JOIN c_cashline c ON c.c_cashline_id = pjp.c_cashline_id
   LEFT JOIN c_pospaymentmedium ppmc ON ppmc.c_pospaymentmedium_id = c.c_pospaymentmedium_id
   LEFT JOIN m_entidadfinanciera ef ON ef.m_entidadfinanciera_id = pjp.m_entidadfinanciera_id
   LEFT JOIN m_entidadfinancieraplan efp ON efp.m_entidadfinancieraplan_id = pjp.m_entidadfinancieraplan_id
   LEFT JOIN c_invoice cc ON cc.c_invoice_id = pjp.c_invoice_credit_id
   LEFT JOIN c_doctype dt ON cc.c_doctypetarget_id = dt.c_doctype_id
  WHERE ' || whereClauseStd || whereDatePayments || whereUserPayments || wherePOSPayments ||
  ' AND (date_trunc(''day''::text, i.dateacct) = date_trunc(''day''::text, pjp.dateacct::timestamp with time zone) OR i.initialcurrentaccountamt = 0::numeric) AND hdr.isactive = ''N''::bpchar AND NOT (EXISTS ( SELECT c2.c_payment_id
   FROM c_cashline c2
  WHERE c2.c_payment_id = pjp.c_payment_id AND i.isvoidable = ''Y''::bpchar)))
UNION ALL 
         SELECT ''ND''::character varying AS trxtype, i.ad_client_id, i.ad_org_id, i.c_invoice_id, date_trunc(''day''::text, i.dateinvoiced) AS datetrx, NULL::unknown AS c_payment_id, NULL::unknown AS c_cashline_id, NULL::unknown AS c_invoice_credit_id, 
                CASE
                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                    ELSE i.paymentrule
                END AS tendertype, i.documentno, i.description, NULL::unknown AS info, i.grandtotal * dtc.signo_issotrx::numeric AS amount, bp.c_bpartner_id, bp.name, bp.c_bp_group_id, bpg.name AS groupname, bp.c_categoria_iva_id, ci.name AS categorianame, ( SELECT ad_ref_list.ad_ref_list_id
                   FROM ad_ref_list
                  WHERE ad_ref_list.ad_reference_id = 195 AND ad_ref_list.value::text = i.paymentrule::text
                 LIMIT 1) AS c_pospaymentmedium_id, 
                CASE
                    WHEN i.paymentrule::text = ''T''::text OR i.paymentrule::text = ''Tr''::text THEN ''A''::character varying
                    WHEN i.paymentrule::text = ''B''::text THEN ''CA''::character varying
                    WHEN i.paymentrule::text = ''K''::text THEN ''C''::character varying
                    WHEN i.paymentrule::text = ''P''::text THEN ''CC''::character varying
                    WHEN i.paymentrule::text = ''S''::text THEN ''K''::character varying
                    ELSE i.paymentrule
                END AS pospaymentmediumname, NULL::unknown AS m_entidadfinanciera_id, NULL::unknown AS entidadfinancieraname, NULL::unknown AS entidadfinancieravalue, NULL::unknown AS m_entidadfinancieraplan_id, NULL::unknown AS planname, i.docstatus, i.issotrx, i.dateacct::date AS dateacct, i.dateacct::date AS invoicedateacct, pj.c_posjournal_id, pj.ad_user_id, pj.c_pos_id, dtc.isfiscal, i.fiscalalreadyprinted
           FROM c_invoice i
      LEFT JOIN c_posjournal pj ON pj.c_posjournal_id = i.c_posjournal_id
   JOIN c_doctype dtc ON i.c_doctypetarget_id = dtc.c_doctype_id
   JOIN c_bpartner bp ON bp.c_bpartner_id = i.c_bpartner_id
   JOIN c_bp_group bpg ON bpg.c_bp_group_id = bp.c_bp_group_id
   LEFT JOIN c_categoria_iva ci ON ci.c_categoria_iva_id = bp.c_categoria_iva_id
  WHERE ' || whereClauseStd || whereDateInvoices || whereUserInvoices || wherePOSInvoices ||
  ' AND ""position""(dtc.doctypekey::text, ''CDN''::text) = 1 AND ((i.docstatus = ANY (ARRAY[''CO''::bpchar, ''CL''::bpchar])) OR (i.docstatus = ANY (ARRAY[''VO''::bpchar, ''RE''::bpchar])) AND (EXISTS ( SELECT al.c_allocationline_id
   FROM c_allocationline al
  WHERE al.c_invoice_credit_id = i.c_invoice_id))) AND NOT (EXISTS ( SELECT al.c_allocationline_id
   FROM c_allocationline al
  WHERE al.c_invoice_id = i.c_invoice_id));';

--raise notice '%', consulta;
FOR adocument IN EXECUTE consulta LOOP
	return next adocument;
END LOOP;

END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION v_documents_org_filtered(
    bpartner integer,
    summaryonly boolean,
    condition character,
    dateto timestamp without time zone)
  RETURNS SETOF v_documents_org_type_condition AS
$BODY$
BEGIN
   return query select * from v_documents_org_filtered(bpartner, summaryonly, condition, dateto, 0, 'B', false);
END
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100
  ROWS 1000;",preinstall_from_17.05.sql
"CREATE OR REPLACE FUNCTION validar_usuario2(IN usuario text, IN clave text)
  RETURNS json AS
$BODY$ 
DECLARE
	rec RECORD;
BEGIN
	SELECT 0 as success, a.id_usuario as id, b.nombre, b.id_perfil as perfil, a.clave as nodata INTO rec FROM seguridad.claves AS a
	INNER JOIN seguridad.usuarios AS b ON a.id_usuario = b.gid
	WHERE a.login = md5($1) LIMIT 1;

	IF FOUND THEN
		IF (SELECT rec.nodata = crypt($2, rec.nodata)) THEN
			rec.success := 1;
		END IF;
		rec.nodata := null;
	ELSE
		rec.id := 0;
		rec.success := 0;
	END IF;	

	RETURN row_to_json(rec);
END;
 $BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",login.sql
"CREATE OR REPLACE FUNCTION ventas_en_fecha (IN fecha_in timestamp,
				            IN barcode_in bigint,
					    OUT barcode_out bigint,
					    OUT cantidad_vendida_out double precision,
       					    OUT costo_vendido_out double precision,
					    OUT precio_vendido_out double precision,
					    OUT ganancia_vendido_out double precision)
RETURNS SETOF record AS $$
DECLARE
	q text;
	l record;
BEGIN
	-- TODO: agregar tb venta_mc_detalle
	q := $S$ SELECT barcode, SUM (cantidad) AS cantidad, SUM (fifo*cantidad) AS sub_costo_venta, SUM (precio*cantidad) AS sub_venta, SUM (ganancia*cantidad) AS sub_ganancia
	         FROM venta_detalle vd
	     	 INNER JOIN venta v
	     	 ON vd.id_venta = v.id
	     	 WHERE v.fecha >= $S$ ||quote_literal (fecha_in)|| $S$ AND v.fecha < $S$ ||quote_literal (fecha_in+'1 days');

        IF barcode_in != 0 THEN
    	   q := q || $S$ AND barcode = $S$ || barcode_in;
	END IF;

	q := q || $S$ GROUP BY barcode $S$;

	EXECUTE q INTO l;

	FOR l IN EXECUTE q LOOP
	    cantidad_vendida_out := COALESCE (l.cantidad,0);
	    costo_vendido_out := COALESCE (l.sub_costo_venta);
	    precio_vendido_out := COALESCE (l.sub_venta);
	    ganancia_vendido_out := COALESCE (l.sub_ganancia);
	    barcode_out := l.barcode;
	    RETURN NEXT;
	END LOOP;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR REPLACE FUNCTION wait_for_lsn(lsn pg_lsn)
RETURNS VOID
LANGUAGE plpgsql
AS $$
BEGIN
  
    LOOP
        IF pg_last_wal_replay_lsn() IS NULL OR
           pg_last_wal_replay_lsn() >= lsn THEN
            RETURN;
        END IF;
        PERFORM pg_sleep(0.1);  /* 100ms */
    END LOOP;
END $$;",Chapter%2012.txt
"CREATE OR REPLACE FUNCTION zssi_isdateinrange(p_datetocheck timestamp with time zone, p_fromdate timestamp with time zone, p_todate timestamp with time zone)
  RETURNS character varying AS
$BODY$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): Frank Wohlers.
***************************************************************************************************************************************************/

  BEGIN
    
    IF((p_datetocheck <= p_todate) AND (p_datetocheck >= p_fromdate)) THEN
      RETURN 'Y';
    END IF;
	RETURN 'N';
END;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;",commonfunctions.sql
"CREATE OR REPLACE function net_manip.inet_dbton
	(
	p_ipaddr		in		inet
	)
RETURNS bigint AS $$
BEGIN
	IF (family(p_ipaddr) = 4) THEN
		RETURN p_ipaddr - '0.0.0.0';
	ELSE
		RETURN p_ipaddr - '::0';
	END IF;
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE function net_manip.inet_inblock
	(
	p_network		in		inet,
	p_bits			in		integer,
	p_ipaddr		in		inet
	)
RETURNS char AS $$
BEGIN
	RETURN(
		CAST(host(p_network) || '/' || p_bits AS inet) >> p_ipaddr
	);
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE function net_manip.inet_ntodb
	(
	p_ipaddr		in		bigint
	)
RETURNS inet AS $$
BEGIN
	IF p_ipaddr > 4294967296 OR p_ipaddr < 16777216 THEN
		RETURN inet('::0') + p_ipaddr;
	ELSE
		RETURN inet('0.0.0.0') + p_ipaddr;
	END IF;
END;
$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR REPLACE function net_manip.inet_ntodb
	(
	p_ipaddr		in		bigint,
	p_netmask_bits	in		integer
	)
RETURNS inet AS $$
BEGIN
	RETURN(set_masklen(net_manip.inet_ntodb(p_ipaddr), p_netmask_bits));
END;

$$ LANGUAGE plpgsql;",v28tov29.sql
"CREATE OR replace FUNCTION search_deudas_cliente (
       IN rut INT,
       IN solo_no_pagadas boolean,
       OUT id INT,
       OUT monto INT,
       OUT maquina INT,
       OUT vendedor INT,
       OUT tipo_venta INT,
       OUT tipo_complementario INT,
       OUT monto_complementario INT,
       OUT fecha TIMESTAMP WITHOUT TIME ZONE)
RETURNS setof record AS $$
DECLARE
        sale_amount INTEGER;
        sale_type INTEGER;
        query TEXT;
	l RECORD;
BEGIN
	--                       0      1             2            3       4       5
	--TIPO PAGO EN RIZOMA (CASH, CREDITO, CHEQUE_RESTAURANT, MIXTO, CHEQUE, TARJETA)
	--
	IF solo_no_pagadas = true THEN --Solo se listan las dedudas sin pago
	   query := $S$ SELECT v.id, v.monto, v.maquina, v.vendedor, v.fecha, v.tipo_venta,
	      	     	       pm.rut1, pm.rut2, pm.tipo_pago1, pm.tipo_pago2, pm.monto1, pm.monto2
	      	     	FROM venta v LEFT JOIN pago_mixto pm ON pm.id_sale = v.id
		     	WHERE v.id IN (SELECT id_venta FROM deuda WHERE rut_cliente=$S$||rut||$S$ AND pagada='f')
		     	AND v.id NOT IN (SELECT id_sale FROM venta_anulada)
		     	ORDER BY v.id DESC $S$;
	ELSE --Se listan todas las deudas (incluso las ya pagadas)
	   query := $S$ SELECT v.id, v.monto, v.maquina, v.vendedor, v.fecha, v.tipo_venta,
	      	     	       pm.rut1, pm.rut2, pm.tipo_pago1, pm.tipo_pago2, pm.monto1, pm.monto2
	      	        FROM venta v LEFT JOIN pago_mixto pm ON pm.id_sale = v.id
		     	WHERE v.id IN (SELECT id_venta FROM deuda WHERE rut_cliente=$S$||rut||$S$)
		     	AND v.id NOT IN (SELECT id_sale FROM venta_anulada)
		     	ORDER BY v.id DESC $S$;
	END IF;

        FOR l IN EXECUTE query loop
	      	id = l.id;
		maquina = l.maquina;
		vendedor = l.vendedor;
		fecha = l.fecha;
		tipo_venta = l.tipo_venta;

		-- Si es una venta mixta
		IF l.tipo_venta = 3 THEN

		   -- Si ambos pagos son credito y pertenecen a la misma cuenta
		   IF l.tipo_pago1 = 1 AND l.rut1 = rut AND l.tipo_pago2 = 1 AND l.rut2 = rut THEN
		      monto = l.monto1 + l.monto2;
		   ELSE
		      -- Si el primer pago fue a credito y pertenece a esta cuenta
		      IF l.tipo_pago1 = 1 AND l.rut1 = rut THEN
		         monto = l.monto1;
			 tipo_complementario = l.tipo_pago2;
			 monto_complementario = l.monto2;
		      ELSE -- Si el segundo pago fue a credito y pertenece a esta cuenta
			 monto = l.monto2;
			 tipo_complementario = l.tipo_pago1;
			 monto_complementario = l.monto1;
		      END IF;
		   END IF;

		ELSE
		   monto = l.monto;
		   tipo_complementario = -1;
		   monto_complementario = 0;
		END IF;
		RETURN NEXT;
        END loop;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE OR replace FUNCTION search_facturas_guias (IN rut_cliente_in INT,
						  IN solo_pendientes_in boolean,
						  IN tipo_guia_in INT,
						  IN tipo_factura_in INT,
						  IN tipo_documento_in INT, -- Tipo documento a mostrar (0 = guias y facturas)
						  IN filtro_in VARCHAR,
       						  OUT id_venta_out INT,
						  OUT id_documento_out INT,
						  OUT id_factura_out INT,
						  OUT rut_cliente_out INT,
       						  OUT monto_out INT,
       						  OUT maquina_out INT,
       						  OUT vendedor_out INT,
       						  OUT tipo_documento_out INT,
       						  OUT fecha_emision_out TIMESTAMP WITHOUT TIME ZONE,
						  OUT pagado_out BOOLEAN)
RETURNS setof record AS $$
DECLARE
        query TEXT;
	l RECORD;
BEGIN
	--
	--
	--
	IF solo_pendientes_in = TRUE THEN --Solo se listan guias sin facturar y las facturas sin pago (con sus guias (facturadas) respectivas en caso de tenerlas)
   	   CREATE TEMPORARY TABLE facturas_guias AS
		  WITH RECURSIVE facturas (id_venta, maquina, vendedor, id_documento, id_factura, fecha_emision, tipo_documento, monto, rut_cliente, pagado) AS
		  (
			SELECT COALESCE (de.id_venta,0) AS id_venta, COALESCE (maquina,0) AS maquina,
			       COALESCE(vendedor,0) AS vendedor, de.id AS id_documento, de.id_factura,
			       de.fecha_emision, de.tipo_documento, de.monto, de.rut_cliente, de.pagado
	   	  	FROM documentos_emitidos de
	          	LEFT JOIN venta v ON v.id = de.id_venta
	   	  	WHERE (de.tipo_documento = tipo_factura_in OR (de.tipo_documento = tipo_guia_in AND id_factura = 0))
	   	  	AND de.pagado = FALSE
		  	AND id_venta NOT IN (SELECT id_sale FROM venta_anulada)
		  	UNION ALL
		        SELECT v.id AS id_venta, v.maquina, v.vendedor, de.id AS id_documento, de.id_factura,
   	    	       	       de.fecha_emision, de.tipo_documento, de.monto, de.rut_cliente, de.pagado
	      	  	FROM venta v INNER JOIN documentos_emitidos de
		  	ON v.id = de.id_venta
		  	INNER JOIN facturas
		  	ON facturas.id_documento = de.id_factura
		  	AND v.id NOT IN (SELECT id_sale FROM venta_anulada)
		  )
		  SELECT * FROM facturas;
	ELSE --Se listan todas las deudas (incluso las ya pagadas)
   	   CREATE TEMPORARY TABLE facturas_guias AS
	   	  WITH RECURSIVE facturas (id_venta, maquina, vendedor, id_documento, id_factura, fecha_emision, tipo_documento, monto, rut_cliente, pagado) AS
		  (
			SELECT COALESCE (de.id_venta,0) AS id_venta, COALESCE (maquina,0) AS maquina,
			       COALESCE(vendedor,0) AS vendedor, de.id AS id_documento, de.id_factura,
			       de.fecha_emision, de.tipo_documento, de.monto, de.rut_cliente, de.pagado
	   	  	FROM documentos_emitidos de
	          	LEFT JOIN venta v ON v.id = de.id_venta
	   	  	WHERE id_venta NOT IN (SELECT id_sale FROM venta_anulada)
		  	UNION ALL
		        SELECT v.id AS id_venta, v.maquina, v.vendedor, de.id AS id_documento, de.id_factura,
   	    	       	       de.fecha_emision, de.tipo_documento, de.monto, de.rut_cliente, de.pagado
	      	  	FROM venta v INNER JOIN documentos_emitidos de
		  	ON v.id = de.id_venta
		  	INNER JOIN facturas
		  	ON facturas.id_documento = de.id_factura
		  	AND v.id NOT IN (SELECT id_sale FROM venta_anulada)
		  )
		  SELECT * FROM facturas;
	END IF;

	query := $S$ SELECT * FROM facturas_guias WHERE id_venta IS NOT NULL $S$;

	IF rut_cliente_in != 0 THEN
	   query := query || $S$ AND rut_cliente = $S$||rut_cliente_in;
	END IF;

	IF tipo_documento_in = tipo_factura_in THEN
	   query := query || $S$ AND (tipo_documento = $S$||tipo_factura_in||$S$ OR id_factura != 0) $S$;
	ELSIF tipo_documento_in = tipo_guia_in THEN
	   query := query || $S$ AND tipo_documento = $S$||tipo_guia_in;
	   IF solo_pendientes_in = TRUE THEN
	      query := query || $S$ AND id_factura = 0 $S$;
	   END IF;
	END IF;

	IF filtro_in != '' THEN
	   query := query || $S$ AND ($S$||filtro_in||$S$)$S$;
	END IF;

	query := query || $S$ ORDER BY id_venta DESC $S$;

        FOR l IN EXECUTE query loop
	      	id_venta_out := l.id_venta;
		id_documento_out := l.id_documento;
		id_factura_out := l.id_factura;
		rut_cliente_out := l.rut_cliente;
		maquina_out := l.maquina;
		vendedor_out := l.vendedor;
		fecha_emision_out := l.fecha_emision;
		tipo_documento_out := l.tipo_documento;
		monto_out := l.monto;
		pagado_out := l.pagado;
		RETURN NEXT;
        END loop;

	DROP TABLE facturas_guias;

RETURN;
END; $$ LANGUAGE plpgsql;",funciones.sql
"CREATE or REPLACE FUNCTION im_conf_item_nr_parent_list(integer)
RETURNS varchar as $body$
DECLARE
	p_conf_item_id		alias for $1;
BEGIN
	RETURN im_conf_item_nr_parent_list(p_conf_item_id, ' ', 0);
END; $body$ LANGUAGE 'plpgsql';",intranet-confdb-create.sql
"CREATE or REPLACE FUNCTION im_conf_item_nr_parent_list(integer, varchar, integer)
RETURNS varchar as $body$
DECLARE
	p_conf_item_id		alias for $1;
	p_spacer		alias for $2;
	p_level			alias for $3;

	v_result		varchar;
	v_conf_item_nr		varchar;
	v_parent_id		integer;
BEGIN
	-- End of recursion.
	IF p_conf_item_id is NULL THEN RETURN ''; END IF;

	-- Error checking to avoid infinite loops within the DB...
	IF p_level > 20 THEN RETURN '- infinite loop with conf_item_id='||p_conf_item_id; END IF;

	-- Get the NR of the current project plus the parent_id
	select	conf_item_nr, conf_item_parent_id
	into	v_conf_item_nr, v_parent_id
	from	im_conf_items
	where	conf_item_id = p_conf_item_id;

	-- Recurse for the parent projects
	v_result = im_conf_item_nr_parent_list(v_parent_id, p_spacer, p_level+1);
	IF v_result != '' THEN v_result := v_result || p_spacer; END IF;
	v_result := v_result || v_conf_item_nr;

	RETURN v_result;
END; $body$ LANGUAGE 'plpgsql';",intranet-confdb-create.sql
"CREATE or replace FUNCTION ad_RoleAccessOnlyOwnData(p_roleId varchar, p_windowID varchar) RETURNS varchar
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2013 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
**************************************************************************************************************************************************

Determine if this Role in This Window can see only its own data..

*/
v_return varchar;
BEGIN 
    select seesonlyowndata into v_return from ad_window_access where ad_role_id=p_roleId and ad_window_id=p_windowID;
    return coalesce(v_return,'N');
END; $_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE or replace FUNCTION c_getconfigoption(p_option character varying, p_org character varying) RETURNS character
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
******************************************************************************************************************************************************************************************************************************+
Stefan Zimmermann, 04/2011, sz@zimmermann-software.de
Check if Database - Dump is created out of an opensource instance
If ORG-ID exists, there may be customer-Data - Giva warning in that case
*****************************************************************************/
v_sql character varying;
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_return character;
BEGIN 

      v_sql:='select '||p_option||' as retval from c_orgconfiguration where isactive='||chr(39)||'Y'||chr(39)||' and ad_org_id='||chr(39)||coalesce(p_org,'0')||chr(39);
      OPEN v_cursor FOR EXECUTE v_sql;
      LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_return:=v_cur.retval;
      END LOOP;
      close v_cursor;
      if v_return is null then
         v_sql:='select '||p_option||' as retval from c_orgconfiguration where isactive='||chr(39)||'Y'||chr(39)||' and isstandard='||chr(39)||'Y'||chr(39);
         OPEN v_cursor FOR EXECUTE v_sql;
         LOOP
                  FETCH v_cursor INTO v_cur;
                  EXIT WHEN NOT FOUND;
                  v_return:=v_cur.retval;
         END LOOP;
         close v_cursor;
      end if;
      if v_return is null then
         select substr(column_default,2,1) into v_return from information_schema.columns where lower(table_name)='c_orgconfiguration' and lower(column_name)=p_option;
      end if;
      return v_return;
END;
$_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE or replace FUNCTION c_getconfigoption(p_option character varying, p_org character varying) RETURNS character
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
******************************************************************************************************************************************************************************************************************************+
Stefan Zimmermann, 04/2011, sz@zimmermann-software.de
Check if Database - Dump is created out of an opensource instance
If ORG-ID exists, there may be customer-Data - Giva warning in that case
*****************************************************************************/
v_sql character varying;
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_return character;
BEGIN 
    if coalesce(p_option,'')!='' then
      v_sql:='select '||p_option||' as retval from c_orgconfiguration where isactive='||chr(39)||'Y'||chr(39)||' and ad_org_id='||chr(39)||coalesce(p_org,'0')||chr(39);
      OPEN v_cursor FOR EXECUTE v_sql;
      LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_return:=v_cur.retval;
      END LOOP;
      close v_cursor;
      if v_return is null then
         v_sql:='select '||p_option||' as retval from c_orgconfiguration where isactive='||chr(39)||'Y'||chr(39)||' and isstandard='||chr(39)||'Y'||chr(39);
         OPEN v_cursor FOR EXECUTE v_sql;
         LOOP
                  FETCH v_cursor INTO v_cur;
                  EXIT WHEN NOT FOUND;
                  v_return:=v_cur.retval;
         END LOOP;
         close v_cursor;
      end if;
      if v_return is null then
         select substr(column_default,2,1) into v_return from information_schema.columns where lower(table_name)='c_orgconfiguration' and lower(column_name)=p_option;
      end if;
      return v_return;
    else
        return '';
    end if;
END;
$_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE or replace FUNCTION rand_query(
v_uid int, -- 客户ID
v_epoch int, -- 搜索开始时间
v_randts int,  -- 搜索interval seconds
v_randlog text,  -- 搜索query条件
v_cnt int  -- 返回若干行
) RETURNS void AS    
$func$    
DECLARE  
  tbl name := 'bptest_'||v_uid||'_'||to_char(('1970-01-01'::date+(v_epoch||' sec')::interval),'yyyymmdd');  
  sql text;
  cnt int;
BEGIN  
  -- 分页评估
  sql := format('select * from %I where ts between %L and %L and content ~ %L order by ts', tbl, '1970-01-01'::date+(v_epoch||' sec')::interval, '1970-01-01'::date+((v_epoch+v_randts)||' sec')::interval, v_randlog);

  select count_estimate(sql) into cnt;

  raise notice 'cnt: %', cnt;

  -- 如果页数较少时，使用count(*)返回精确页数

  -- 返回若干记录
  sql := format('select * from %I where ts between %L and %L and content ~ %L order by ts limit %L', tbl, '1970-01-01'::date+(v_epoch||' sec')::interval, '1970-01-01'::date+((v_epoch+v_randts)||' sec')::interval, v_randlog, v_cnt);

  execute sql;

  -- 用户可以将函数内代码转移到程序端，使用游标获取数据，确保每一页的感受一致
  
  -- 当用户需要返回最后一页时，使用逆序，重新拼接SQL (order by origin_time desc)。

  exception when others then
    return;
END    
$func$ LANGUAGE plpgsql;",20170522_01.md
"CREATE or replace FUNCTION rand_query(
v_uid int, -- 客户ID
v_epoch int, -- 搜索开始时间
v_randts int,  -- 搜索interval seconds
v_randlog text,  -- 搜索query条件
v_cnt int  -- 返回若干行
) RETURNS void AS    
$func$    
DECLARE  
  tbl name := 'bptest_'||v_uid||'_'||to_char(('1970-01-01'::date+(v_epoch||' sec')::interval),'yyyymmdd');  
  sql text;
  cnt int;
BEGIN  
  -- 分页评估
  sql := format('select * from %I where ts between %L and %L and content ~ %L order by ts', tbl, '1970-01-01'::date+(v_epoch||' sec')::interval, '1970-01-01'::date+((v_epoch+v_randts)||' sec')::interval, v_randlog);

  select count_estimate(sql) into cnt;

  raise notice 'cnt: %', cnt;

  -- 如果页数较少时，使用count(*)返回精确页数

  -- 返回若干记录
  sql := format('select * from %I where ts between %L and %L and content ~ %L order by ts limit %L', tbl, '1970-01-01'::date+(v_epoch||' sec')::interval, '1970-01-01'::date+((v_epoch+v_randts)||' sec')::interval, v_randlog, v_cnt);

  execute sql;

  -- 用户可以将函数内代码转移到程序端，使用游标获取数据，确保每一页的感受一致
  
  -- 当用户需要返回最后一页时，使用逆序，重新拼接SQL (order by origin_time desc)。

  exception when others then
    return;
END    
$func$ LANGUAGE plpgsql;",index.html
"CREATE or replace FUNCTION zsse_checkbansecure(p_ad_user_id character varying) RETURNS character varying
AS $_$
DECLARE
/*****************************************************+
Stefan Zimmermann, 04/2011, sz@zimmermann-software.de
Security Login Function
Bans a User for 10 minutes , if there where three 
failed Login Tries
*****************************************************/
-- Simple Types
v_message character varying;
v_count numeric;
BEGIN 
   select count(*) into v_count from ZSSE_SECURELOGIN where ad_user_id=p_ad_user_id and created > (now() - INTERVAL '10 minutes');
   if v_count>2 then
        RETURN 'BANNED';
   else
        RETURN 'OK';
   end if;
END;
$_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"CREATE or replace FUNCTION zsse_getmainfrompopup( p_key character varying, p_columnid character varying, p_desturl character varying, p_name character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): Danny Heuduk_____________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN
 
  RETURN '<a href=""#"" onclick=""getmainfrompopup('||chr(39)||p_key||chr(39)||',' ||chr(39)||p_columnid||chr(39)||',' ||chr(39)||p_desturl||chr(39)||');return false;"" class=""LabelLink"">'||p_name||'</a>';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmlLinkDirectKey(p_targetwindowurl character varying,p_key character varying,p_text character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  RETURN '<a href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink"">'||p_text||' </a>';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmlLinkDirectKeyGridView(p_targetwindowurl character varying,p_key character varying,p_text character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  RETURN '<a href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECTRELATION'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink"">'||p_text||' </a>';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmlLinkDirectKey_notblue(p_targetwindowurl character varying,p_key character varying,p_text character varying,p_color varchar) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  --RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_white"">'||p_text||' </a>';

if p_color='white' then
    RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_white"">'||rpad(p_text,16,'')||' </a>';
else
    RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_black"">'||rpad(p_text,16,'')||' </a>';
end if;
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmlLinkDirectKey_notblue_short(p_targetwindowurl character varying,p_key character varying,p_text character varying,p_color varchar) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  --RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_white"">'||p_text||' </a>';

if p_color='white' then
    RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_white"">'||'&nbsp;'||p_text||' </a>';
else
    RETURN '<a title=""'||zssi_2html(p_text)||'"" href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.inpDirectKey,'||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink_black"">'||'&nbsp;'||p_text||' </a>';
end if;
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmldirectlink(p_targetwindowurl character varying,p_fieldid character varying,p_key character varying,p_text character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  RETURN '<a href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||','||p_fieldid||','||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink"">'||p_text||' </a>';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_htmldirectlinkWithDummyField(p_targetwindowurl character varying,p_fieldid character varying,p_key character varying,p_text character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/

BEGIN 
  
  RETURN '<INPUT type=""hidden"" name=""'||p_fieldid||'""></INPUT><a href=""#"" onclick=""submitCommandFormParameter('||chr(39)||'DIRECT'||chr(39)||',document.frmMain.'||p_fieldid||','||chr(39)||p_key||chr(39)||', false, document.frmMain, '||chr(39)||p_targetwindowurl||chr(39)||', null, false, true);return false;"" class=""LabelLink"">'||p_text||' </a>';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zsse_instancesqlexecute(p_setoriginal character varying) returns character varying
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2011 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Execute individual Statements for the Custom Instance
*****************************************************/
 v_cur RECORD;
 v_name character varying;
BEGIN 
  select name into v_name from ad_client where ad_client_id='C726FEC915A54A0995C568555DA5BB3C';
  RAISE NOTICE '%', 'Setting '||case when p_setoriginal='Y' then 'default' else 'Instance specific' end ||' customizing for Client '||v_name; 
  for v_cur in (select * from zsse_executeondeploy where isstandard=p_setoriginal order by seqno)
  LOOP
     EXECUTE v_cur.sqlstmt;
     RAISE NOTICE '%', v_cur.sqlstmt;
  END LOOP;
  RAISE NOTICE '%', 'Execute finished for Client '||v_name; 
  RETURN 'Instance-Specific SQL-Statements Executed.';
END;
$_$  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zssi_countrowsfromtable(p_tablename character varying, p_key character varying,p_in character varying)    RETURNS character varying AS
$BODY$ DECLARE 
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2012 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
***************************************************************************************************************************************************
Example== SELECT zssi_countrowsfromtable('m_product','m_product_id','(''4A7491D578CE464988998F1084ECD672'',''785F4E237AB34D4A9723F76E348E3A61'',''556994838CDC4611BB0A2B038B246128'')');
*/
TYPE_Ref REFCURSOR;
v_cursor TYPE_Ref%TYPE;
v_cur RECORD;
v_sql character varying;
v_keycolumname character varying;
v_columnid character varying;
v_tablename character varying;
v_result character varying;
BEGIN
        if p_tablename is not null then
            if p_key is not null then
                if p_in is not null then
      --v_sql:='select count(*) as x from '||p_tablename||' where '||p_key||' in ('|| chr(39)||coalesce(p_in,'')||chr(39)||')';
      v_sql:='select count(*) as x from '||p_tablename||' where '||p_key||' in '||coalesce(p_in,'');
      OPEN v_cursor FOR EXECUTE v_sql;
        LOOP
            FETCH v_cursor INTO v_cur;
            EXIT WHEN NOT FOUND;
            v_result:=v_cur.x;
        END LOOP;
      close v_cursor;
                end if;
            end if;
        end if;   
  
  RETURN coalesce(v_result,'0');
exception when others then
    return '0';
END;
$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;",commonfunctions.sql
"CREATE or replace FUNCTION zssi_getLastDayOfQuarter(p_startdate timestamp,p_quarter varchar) RETURNS timestamp
AS $_$
DECLARE
/***************************************************************************************************************************************************
The contents of this file are subject to the Mozilla Public License Version 1.1 (the ""License""); you may not use this file except in
compliance with the License. You may obtain a copy of the License at http://www.mozilla.org/MPL/MPL-1.1.html
Software distributed under the License is distributed on an ""AS IS"" basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
License for the specific language governing rights and limitations under the License.
The Original Code is OpenZ. The Initial Developer of the Original Code is Stefan Zimmermann (sz@zimmermann-software.de)
Copyright (C) 2012 Stefan Zimmermann All Rights Reserved.
Contributor(s): ______________________________________.
**************************************************************************************************************************************************

Gives Back the Last Day in a Quarter Beginning from Startdate

p_quarter = 1Q : Last day in the 1st Quarter from startdate
p_quarter = 2Q
p_quarter = 3Q
p_quarter = 4Q: Last day in the fourth Quarter from startdate

*/
v_interval interval:=0;
v_enddate timestamp;
BEGIN 
   if p_quarter='2Q' then v_interval:= INTERVAL '3 month'; elsif p_quarter='3Q' then v_interval:= INTERVAL '6 month'; elsif p_quarter='4Q' then v_interval:= INTERVAL '9 month'; end if;
   v_enddate:=p_startdate + INTERVAL '3 month' + v_interval - INTERVAL '1 day';
   return v_enddate;
END; $_$  LANGUAGE 'plpgsql';",commonfunctions.sql
"Create function Haversine(lon1 float, lat1 float, lon2 float, lat2 float) returns float AS $$
BEGIN
	RETURN (2 * 3961 * asin(sqrt((sin(radians((lat2 - lat1) / 2))) ^ 2 + cos(radians(lat1)) * cos(radians(lat2)) * (sin(radians((lon2 - lon1) / 2))) ^ 2)));
	END;
$$ LANGUAGE plpgsql;",README.md
"Create or replace function public.ZeroFunc(int) Returns int as $BODY$
BEGIN
  RETURN 0;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning.out
"Create or replace function public.ZeroFunc(int) Returns int as $BODY$
BEGIN
  RETURN 0;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning.sql
"Create or replace function public.ZeroFunc(int) Returns int as $BODY$
BEGIN
  RETURN 0;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning_optimizer.out
"Create or replace function public.reverse(text) Returns text as $BODY$
DECLARE
   Original alias for $1;
   Reverse_str text;
   I int4;
BEGIN
   Reverse_str :='';
   For I in reverse length(original)..1 LOOP
   Reverse_str := reverse_str || substr(original,I,1);
END LOOP;
RETURN reverse_str;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning.out
"Create or replace function public.reverse(text) Returns text as $BODY$
DECLARE
   Original alias for $1;
   Reverse_str text;
   I int4;
BEGIN
   Reverse_str :='';
   For I in reverse length(original)..1 LOOP
   Reverse_str := reverse_str || substr(original,I,1);
END LOOP;
RETURN reverse_str;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning.sql
"Create or replace function public.reverse(text) Returns text as $BODY$
DECLARE
   Original alias for $1;
   Reverse_str text;
   I int4;
BEGIN
   Reverse_str :='';
   For I in reverse length(original)..1 LOOP
   Reverse_str := reverse_str || substr(original,I,1);
END LOOP;
RETURN reverse_str;
END;
$BODY$ LANGUAGE plpgsql IMMUTABLE;",partition_pruning_optimizer.out
"create OR replace function get_session_id() returns int8 AS $$     
declare res int8;     
begin    
SELECT currval('public.pg_session_id_sequence_oracle_comp') into res;     
return res;     
exception      
    WHEN sqlstate '55000' THEN      
SELECT nextval('public.pg_session_id_sequence_oracle_comp') into res;     
return res;      
    WHEN sqlstate '42P01' THEN      
create sequence public.pg_session_id_sequence_oracle_comp;    
SELECT nextval('public.pg_session_id_sequence_oracle_comp') into res;     
return res;     
end;     
$$ language plpgsql strict SET client_min_messages to error;",index.html
"create function U.assign( ¶a jsonb, ¶b jsonb ) returns jsonb immutable language plpgsql as $$
  begin
    if jsonb_typeof( ¶a ) != 'object' then raise exception 'expected a JSONb object, got %', ¶a; end if;
    if jsonb_typeof( ¶b ) != 'object' then raise exception 'expected a JSONb object, got %', ¶b; end if;
    return ¶a || ¶b; end; $$;",030-utilities-1.sql
"create function U.assign( ¶a jsonb, ¶b jsonb, variadic ¶tail jsonb[] )
  returns jsonb immutable language plpgsql as $$
  declare
    R         jsonb;
    ¶element  jsonb;
  begin
    R := U.assign( ¶a, ¶b );
    foreach ¶element in array ¶tail loop
      R := U.assign( R, ¶element );
      end loop;
    return R; end; $$;",030-utilities-1.sql
"create function U.choose_coalescent( anyarray, text[] )
  returns text immutable strict parallel safe language plpgsql as $$
  begin
    for i in 1 .. U.length_of( $1 ) loop
      if ( $1[ i ] is not null ) or ( $1[ i ] is distinct from null ) then
        return $2[ i ];
        end if;
      end loop;
    return null;
    end; $$;",030-utilities-1.sql
"create function U.count_jsonb_keys( diff jsonb )
returns integer immutable language plpgsql as $$
  begin
    select array_upper( array( select jsonb_object_keys( diff ) ), 1 );
    end;
    $$;",030-utilities-1.sql
"create function U.jsonb_diff( a jsonb, b jsonb )
returns jsonb immutable language plpgsql as $$
  declare
    R             jsonb;
    object_result jsonb;
    n             int;
    value         record;
  begin
    if jsonb_typeof(a) = 'null' then return b; end if;
    -- .....................................................................................................
    R = a;
    for value in select * from jsonb_each( a ) loop
      R = R || jsonb_build_object( value.key, null );
      end loop;
    -- .....................................................................................................
    for value in select * from jsonb_each( b ) loop
      -- ...................................................................................................
      if jsonb_typeof( a->value.key ) = 'object' and jsonb_typeof( b->value.key ) = 'object' then
        object_result = U.jsonb_diff( a->value.key, b->value.key );
        -- .................................................................................................
        /* check if R is not empty */
        n := ( select count(*) from jsonb_each( object_result ) );
        -- .................................................................................................
        if n = 0 then
          --if empty, remove:
          R := R - value.key;
        -- .................................................................................................
        else
          R := R || jsonb_build_object( value.key, object_result );
          end if;
      -- ...................................................................................................
      elsif a->value.key = b->value.key then
        R = R - value.key;
      else
        R = R || jsonb_build_object( value.key,value.value );
        end if;
      end loop;
    -- .....................................................................................................
    return R;
    end;
    $$;",030-utilities-1.sql
"create function U.truth( boolean )
returns text immutable language plpgsql as $$
  begin
    case $1
      when true   then  return 'true';
      when false  then  return 'false';
      else              return '∎';
      end case;
    end; $$;",030-utilities-1.sql
"create function U.unnest_2d_1d( anyarray, out a anyarray )
  returns setof anyarray immutable strict language plpgsql as $$
  begin
    foreach a slice 1 in array $1 loop
      return next;
      end loop;
    end $$;",030-utilities-1.sql
"create function avg_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$$ language plpgsql;",aggregates.out
"create function avg_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$$ language plpgsql;",aggregates_1.out
"create function avg_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$$ language plpgsql;",aggregates_optimizer.out
"create function f_test_11(a int, out b int) returns int as $$
begin
b = 1;
return;
end $$
language plpgsql;",2020-01-23-008_postgres_function_procedure_trigger.md
"create function f_test_12(a int, out b int, out c int) returns record as $$
begin
raise notice 'begin f';
a = 9;
b = a + 3;
c = a * 3;
raise notice 'c = %', c;
return;
end $$
language plpgsql;",2020-01-23-008_postgres_function_procedure_trigger.md
"create function halfsum_finalfn(state int4) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$$ language plpgsql;",aggregates.out
"create function halfsum_finalfn(state int4) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$$ language plpgsql;",aggregates_1.out
"create function halfsum_finalfn(state int4) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$$ language plpgsql;",aggregates_optimizer.out
"create function java_guid() returns varchar as $$
    BEGIN
        return uuid_in(md5(random()::text || now()::text)::cstring);
    END;
$$ LANGUAGE plpgsql;",create.sql
"create function monitor.pgbackrest_info()
    returns jsonb AS $$
declare
    data jsonb;
begin
    -- Create a temp table to hold the JSON data
    create temp table temp_pgbackrest_data (data jsonb);

    -- Copy data into the table directory from the pgBackRest into command
    copy temp_pgbackrest_data (data)
        from program
            'pgbackrest --output=json info | tr ''\n'' '' ''' (format text);

    select temp_pgbackrest_data.data
      into data
      from temp_pgbackrest_data;

    drop table temp_pgbackrest_data;

    return data;
end $$ language plpgsql;",user-guide.html
"create function my_op_cmp(a int, b int) returns int as
  $$begin return btint4cmp(a, b); end $$ language plpgsql;",influxdb_fdw_post.out
"create function my_op_cmp(a int, b int) returns int as
  $$begin return btint4cmp(a, b); end $$ language plpgsql;",postgres_fdw.out
"create function out_test2(a int, b int) returns int as $$
begin
b = 1;
return a + b;
end $$
language plpgsql;",2020-01-23-008_postgres_function_procedure_trigger.md
"create function pg_temp.array_lower(text[])
returns text[]
language plpgsql as
$$
BEGIN
RAISE EXCEPTION 'Bobby Tables Strikes Again';
return array['foo'::text];
END;
$$;",upgrade.out
"create function sum_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$$ language plpgsql;",aggregates.out
"create function sum_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$$ language plpgsql;",aggregates_1.out
"create function sum_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$$ language plpgsql;",aggregates_optimizer.out
"create or replace FUNCTION Suma_Precio(codPresentacion integer) returns decimal(12,2) as $$
begin
    return (select coalesce(sum(precio_unitario),0) from Presentacion_Servicio,Presentacion 
	        where Presentacion.cod_presentacion=Presentacion_Servicio.cod_presentacion and Presentacion_Servicio.cod_presentacion=codPresentacion);
end; $$
language plpgsql;",script.sql
"create or replace FUNCTION gamebox_rebate_map(
	url 		TEXT,
	start_time 	TEXT,
	end_time 	TEXT,
	category 	TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;	-- API
	maps 		hstore[];
	flag		TEXT:='Y';
BEGIN
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	-- raise info '返佣.梯度设置信息';
  	-- SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	-- raise info '返佣.代理默认方案';
  	-- SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	-- raise info '返佣.代理满足的梯度';
	-- SELECT gamebox_rebate_agent_check(rebate_grads_map, agent_map, stTime, edTime, flag) INTO agent_check_map;

	-- raise info '取得运营商各API占成';
	-- SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type, flag) INTO operation_occupy_map;

	-- SELECT gamebox_rebate_map(stTime, edTime, key_type, rebate_grads_map, agent_check_map, operation_occupy_map) INTO rebate_map;
	SELECT gamebox_rebate_map(stTime, edTime) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime, edTime, sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps, expense_map);

	return maps;
END
$$ language plpgsql;",3_gamebox_rebate.sql
"create or replace FUNCTION gamebox_rebate_map(
	url 		TEXT,
	start_time 	TEXT,
	end_time 	TEXT,
	category 	TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
	flag		TEXT:='Y';
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map, agent_map, stTime, edTime, flag) INTO agent_check_map;

	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type, flag) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime, edTime, key_type, rebate_grads_map, agent_check_map, operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime, edTime, sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps, expense_map);

	return maps;
END
$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace FUNCTION gamebox_rebate_map(
	url TEXT,
	start_time TEXT,
	end_time TEXT,
	category TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	vname 		TEXT:='v_site_game';
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.site_game临时视图';
  	perform gamebox_site_game(url,vname,sid,'C');

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) INTO agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);

	return maps;
END
$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace FUNCTION gamebox_rebate_map(
	url TEXT,
	start_time TEXT,
	end_time TEXT,
	category TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	vname 		TEXT:='v_site_game';
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.site_game临时视图';
  	perform gamebox_site_game(url,vname,sid,'C');

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) INTO agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);

	return maps;
END
$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace FUNCTION gamebox_rebate_map(
  url TEXT,
  start_time TEXT,
  end_time TEXT,
  category TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) INTO agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);

	return maps;
END
$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace FUNCTION gamebox_rebate_map(
  url TEXT,
  start_time TEXT,
  end_time TEXT,
  category TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) INTO agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);

	return maps;
END
$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace FUNCTION gamebox_rebate_map(
  url TEXT,
  start_time TEXT,
  end_time TEXT,
  category TEXT
) RETURNS hstore[] as $$

DECLARE
	sys_map 				hstore;--系统参数.
	rebate_grads_map 		hstore;--返佣梯度设置
	agent_map 				hstore;--代理默认方案
	agent_check_map 		hstore;--代理梯度检查
	operation_occupy_map 	hstore;--运营商占成.
	rebate_map 				hstore;--API占成.
	expense_map 			hstore;--费用分摊

	sid 		INT;--站点ID.
	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;
	is_max 		BOOLEAN:=true;
	key_type 	int:=5;--API
	maps 		hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') INTO sys_map;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() INTO rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() INTO agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) INTO agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	SELECT gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	SELECT gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);

	return maps;
END
$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace FUNCTION gamebox_rebate_map(
url TEXT
,start_time TEXT
,end_time TEXT
,category TEXT
)
RETURNS hstore[] as $$
DECLARE
	sys_map hstore;--系统参数.
	rebate_grads_map hstore;--返佣梯度设置
	agent_map hstore;--代理默认方案
	agent_check_map hstore;--代理梯度检查
	operation_occupy_map hstore;--运营商占成.
	rebate_map hstore;--API占成.
	expense_map hstore;--费用分摊

	sid INT;--站点ID.
	stTime TIMESTAMP;
	edTime TIMESTAMP;
	vname TEXT:='v_site_game';
	is_max BOOLEAN:=true;
	key_type int:=5;--API
	--category TEXT:='AGENT';
	maps hstore[];
BEGIN
	category='AGENT';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '占成.取得当前站点ID';
	select gamebox_current_site() INTO sid;

	raise info '占成.site_game临时视图';
  perform gamebox_site_game(url,vname,sid,'C');

	raise info '占成.系统各种分摊比例参数';
	select gamebox_sys_param('apportionSetting') into sys_map;

	raise info '返佣.梯度设置信息';
  select gamebox_rebate_api_grads() into rebate_grads_map;

	raise info '返佣.代理默认方案';
  select gamebox_rebate_agent_default_set() into agent_map;

  raise info '返佣.代理满足的梯度';
	select gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) into agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	select gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) INTO operation_occupy_map;

	select gamebox_rebate_map(stTime,edTime,key_type,rebate_grads_map,agent_check_map,operation_occupy_map) INTO rebate_map;
	--统计各种费费用.
	select gamebox_expense_map(stTime,edTime,sys_map) INTO expense_map;
	maps=array[rebate_map];
	maps=array_append(maps,expense_map);
	return maps;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function INFOSESIONES(p_usuario VARCHAR)
returns void as $$
declare
	v_numsesiones NUMERIC:=0;
	c_info cursor for
	select backend_start, client_addr, application_name
	from pg_stat_activity
	where usename = p_usuario;

begin
	select count(usename) into v_numsesiones
	from pg_stat_activity
	where usename = p_usuario;
	Raise Notice '%Nombre usuario: % | Num. sesiones: % %', chr(10),p_usuario,v_numsesiones,chr(10);
	for i in c_info loop
		Raise Notice 'Fecha y hora de comienzo: % Programa ejecutor: % Dirección IP ejecutor: %', i.backend_start, i.application_name, i.client_addr;
	end loop;
end;
$$ LANGUAGE plpgsql;",partegrupal_practicausuarios
"create or replace function NURand(A integer, x integer, y integer, C integer) returns integer as $$
declare
begin
	return (((floor(random() * (A+1))::integer
				| (x + floor(random() * ((y + 1) - x))::integer))
			+ C) % (y - x + 1)) + x;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function PRIVS (p_usuario1 VARCHAR,
				  p_usuario2 VARCHAR)
returns void as $$
declare
begin
		perform PRIVSINSERCION(p_usuario1, p_usuario2);
		perform PRIVSEJECUCION(p_usuario1, p_usuario2);
end;
$$ language plpgsql;",partegrupal_practicausuarios
"create or replace function PRIVSEJECUCION(p_usuario1 VARCHAR,
					  p_usuario2 VARCHAR)
returns void as $$
declare

	c_info cursor for
	select p.proname
	from pg_catalog.pg_namespace n
	join pg_catalog.pg_proc p
	on p.pronamespace = n.oid
	where n.nspowner = (select usesysid
			    from pg_user
			    where usename = p_usuario2);

begin
	for i in c_info loop
		Raise Notice 'GRANT EXECUTE ON % TO %', i.proname, p_usuario1;
	end loop;
end;
$$ LANGUAGE plpgsql;",partegrupal_practicausuarios
"create or replace function add_primary_keyalignement() returns void as $$
begin
	if not exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'PRIMARY KEY'
	and constraint_name ='alignement_pkey') then 
	execute
	'
            ALTER TABLE ONLY alignement
			ADD CONSTRAINT alignement_pkey PRIMARY KEY (id);
';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function add_primary_keyalignement_source() returns void as $$
begin
	if not exists (SELECT * from information_schema.table_constraints where table_name = 'alignement_source' and constraint_type = 'PRIMARY KEY'
	and constraint_name ='alignement_source_pkey') then 
	execute
	'
            ALTER TABLE ONLY alignement_source
			ADD CONSTRAINT alignement_source_pkey PRIMARY KEY (id);
';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function addconstraintto_alignement() returns void as $$
begin
    IF EXISTS(SELECT * FROM information_schema.constraint_table_usage where constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_id_alignem') THEN
        execute 'ALTER TABLE alignement DROP CONSTRAINT alignement_internal_id_concept_internal_id_thesaurus_id_alignem;';
    END IF;
    IF EXISTS(SELECT * FROM information_schema.constraint_table_usage where constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_id_ali_key') THEN
        execute 'ALTER TABLE alignement DROP CONSTRAINT alignement_internal_id_concept_internal_id_thesaurus_id_ali_key;';
    END IF;
    
   
    IF NOT EXISTS(SELECT * FROM information_schema.constraint_table_usage where constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_uri_ta_key') THEN
        execute 'alter TABLE ONLY alignement add CONSTRAINT alignement_internal_id_concept_internal_id_thesaurus_uri_ta_key
	UNIQUE (internal_id_concept, internal_id_thesaurus, uri_target);';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function adjouteconstraint_alignement_source() returns void as $$
begin
	if not exists (SELECT * from information_schema.table_constraints where table_name = 'alignement_source' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_source_source_key') then 
	execute
	'ALTER TABLE ONLY alignement_source
	  ADD CONSTRAINT alignement_source_source_key UNIQUE 
	  (source);';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function adjuteconstraintuser() returns void as $$
begin
	if not exists (SELECT * from information_schema.table_constraints where table_name = 'users' and constraint_type = 'UNIQUE'
	and constraint_name ='users_mail_key1') then 
	execute
	'ALTER TABLE ONLY users
	  ADD CONSTRAINT users_mail_key1 UNIQUE 
	  (mail);';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function alter_table_concept_group_addcolumn_id_handle() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.columns WHERE table_name='concept_group' AND column_name='id_handle' ) THEN
        execute 'ALTER TABLE concept_group ADD COLUMN id_handle character varying DEFAULT ''''::character varying;';
    END IF;
end;
$$language plpgsql;",maj_bdd_current.sql
"create or replace function alter_table_thesaurus_private() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.columns WHERE table_name='thesaurus' AND column_name='private' ) THEN
        execute 'ALTER TABLE thesaurus ADD COLUMN private boolean DEFAULT false;';
    END IF;
end;
$$language plpgsql;",maj_bdd_current.sql
"create or replace function athletesOfStadium(varchar(120), REFCURSOR) returns refcursor as 
$$
declare
   nameOfStadium varchar(120)   := $1;
   resultset   REFCURSOR := $2;
begin
   open resultset for 
      select p.firstName, p.lastName
      from   People p,
		MenAthletes ma
      where p.pid = ma.maid
      and ma.maid in (select mt.maid
		       from MenAthleteSports mt
		       where mt.sid in (select s.sid
					from Sports s
					where s.sid in (select sp.sid
							from SportStadium sp
							where sp.stid in (select st.stid
									  from Stadiums st
									  where st.nameOfStadium = nameOfStadium))));
					
   return resultset;
end;
$$ 
language plpgsql;",finalProject.sql
"create or replace function avg_transfn(state avg_state, n int) returns avg_state as
$$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates.out
"create or replace function avg_transfn(state avg_state, n int) returns avg_state as
$$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates_1.out
"create or replace function avg_transfn(state avg_state, n int) returns avg_state as
$$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates_optimizer.out
"create or replace function bench() returns boolean as $$  
declare  
  v_arr int8[];  
begin  
  -- 生成40个商品的数组，其中普通商品35个，热点商品5个  
  select array_agg(id) into v_arr from (select (500000+random()*9500000)::int8 id from generate_series(1,35) union all select (random()*500000)::int8 id from generate_series(1,5) ) t;  
    
  -- 调用ff, 并返回结果, overlap=35，即满足35个相似的为相似文本  
  return ff('overlap', 35, v_arr);  
end;  
$$ language plpgsql strict;",20170112_02.md
"create or replace function buscar_emisor(
       in pattern varchar(100),
       out id integer,
       out rut integer,
       out dv varchar(1),
       out razon_social varchar(100),
       out telefono varchar(100),
       out direccion varchar(100),
       out comuna varchar(100),
       out ciudad varchar(100),
       out giro varchar(100))
returns setof record as $$
declare
	q text;
	l record;
begin
q := 'SELECT id, rut, dv, razon_social, telefono, direccion, comuna, ciudad, giro
     	     FROM emisor_cheque WHERE lower(razon_social) LIKE lower('
	     || quote_literal($1) || ') '
	     || 'OR lower(rut::varchar) LIKE lower(' || quote_literal($1) || ') ORDER BY razon_social';

for l in execute q loop
    id = l.id;
    rut = l.rut;
    dv = l.dv;
    razon_social = l.razon_social;
    telefono = l.telefono;
    direccion = l.direccion;
    comuna = l.comuna;
    ciudad = l.ciudad;
    giro = l.giro;
    return next;
end loop;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function buscar_producto (IN expresion varchar(255),
	  	  	   		    IN columnas varchar[],
					    IN usar_like boolean,
        				    IN con_stock boolean,
       					    OUT barcode int8,
					    OUT codigo_corto varchar(16),
					    OUT marca varchar(35),
					    OUT descripcion varchar(50),
					    OUT contenido varchar(10),
					    OUT unidad varchar(10),
					    OUT stock float8,
					    OUT precio float8,
					    OUT precio_neto float8,
					    OUT costo_promedio float8,
					    OUT vendidos float8,
					    OUT impuestos bool,
					    OUT otros int4,
					    OUT familia int2,
					    OUT perecibles bool,
					    OUT stock_min float8,
					    OUT dias_stock float8,
					    OUT margen_promedio float8,
					    OUT fraccion bool,
					    OUT canje bool,
					    OUT stock_pro float8,
					    OUT tasa_canje float8,
					    OUT precio_mayor float8,
					    OUT cantidad_mayor float8,
					    OUT mayorista bool,
					    OUT tipo_id int4,
					    OUT tipo_mer varchar(20))
returns setof record as $$
declare
	list record;
	query text;
	i integer;
	corriente int4;
	materia_prima int4;
begin
	corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
	materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

	query := $S$ SELECT barcode, codigo_corto, marca, descripcion, contenido, unidad, stock, costo_promedio,
	      	     	    precio, precio_neto, vendidos, impuestos, otros, familia, perecibles,
			    (SELECT nombre FROM tipo_mercaderia WHERE id = tipo) AS tipo_mercaderia,
			    COALESCE ((dias_stock * select_ventas_dia(producto.barcode, TRUE)::float), 0) AS stock_min,
			    margen_promedio, fraccion, canje, stock_pro, dias_stock,
			    tasa_canje, precio_mayor, cantidad_mayor, mayorista, tipo FROM producto WHERE $S$;

        IF con_stock IS TRUE THEN
           query := query || $S$ (SELECT disponible FROM obtener_stock_desde_barcode (barcode)) > 0 and $S$;
        END IF;

        query := query || $S$($S$;

	FOR i IN 1..array_upper( columnas, 1) LOOP
	    IF usar_like IS TRUE THEN
	       IF i > 1 THEN
	       	  query := query || $S$ or  $S$;
	       END IF;
	       query := query || $S$ upper( $S$ || columnas[i] || $S$::varchar ) $S$ || $S$ like upper( '$S$ || expresion ||$S$%' ) $S$;
	    ELSE
	       IF i > 1 THEN
	       	  query := query || $S$ and $S$;
	       END IF;
	       query := query || columnas[i] || $S$ = upper( '$S$ || expresion || $S$' ) $S$;
	    END IF;
	END LOOP;

        query := query || $S$) and estado=true order by descripcion, marca$S$;

	FOR list IN EXECUTE query LOOP
	    barcode := list.barcode;
	    codigo_corto := list.codigo_corto;
	    marca := list.marca;
	    descripcion := list.descripcion;
	    contenido := list.contenido;
	    unidad := list.unidad;

	    IF list.tipo != corriente AND list.tipo != materia_prima THEN
		stock := (SELECT disponible FROM obtener_stock_desde_barcode (barcode));
	    ELSE
		stock := list.stock;
            END IF;

	    precio := list.precio;
	    precio_neto := list.precio_neto;

	    IF list.tipo != corriente AND list.tipo != materia_prima THEN
		costo_promedio := (SELECT costo FROM obtener_costo_promedio_desde_barcode (barcode));
	    ELSE
		costo_promedio := list.costo_promedio;
	    END IF;

	    vendidos := list.vendidos;
	    impuestos := list.impuestos;
	    otros := list.otros;
	    familia := list.familia;
	    perecibles := list.perecibles;
	    stock_min := list.stock_min;
	    dias_stock := list.dias_stock;
	    margen_promedio := list.margen_promedio;
	    fraccion := list.fraccion;
	    canje := list.canje;
	    stock_pro := list.stock_pro;
	    tasa_canje := list.tasa_canje;
	    precio_mayor := list.precio_mayor;
	    cantidad_mayor := list.cantidad_mayor;
	    mayorista := list.mayorista;
	    tipo_id := list.tipo;
	    tipo_mer := list.tipo_mercaderia;
	RETURN NEXT;
    END LOOP;

    RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function buscar_productos(IN expresion varchar(255),
       	  	  	   		    OUT barcode int8,
					    OUT codigo_corto varchar(16),
					    OUT marca varchar(35),
					    OUT descripcion varchar(50),
					    OUT contenido varchar(10),
					    OUT unidad varchar(10),
					    OUT stock float8,
					    OUT precio float8,
					    OUT precio_neto float8,
					    OUT costo_promedio float8,
					    OUT vendidos float8,
					    OUT impuestos bool,
					    OUT otros int4,
					    OUT familia int2,
					    OUT perecibles bool,
					    OUT stock_min float8,
					    OUT dias_stock float8,
					    OUT margen_promedio float8,
					    OUT fraccion bool,
					    OUT canje bool,
					    OUT stock_pro float8,
					    OUT tasa_canje float8,
					    OUT precio_mayor float8,
					    OUT cantidad_mayor float8,
					    OUT mayorista bool,
					    OUT tipo int4)
returns setof record as $$
declare
	list record;
	query text;
	corriente int4;
	materia_prima int4;
begin
query := $S$ SELECT barcode, codigo_corto, marca, descripcion, contenido,
      	     	    unidad, stock, precio, precio_neto, costo_promedio, vendidos, impuestos,
		    otros, familia, perecibles, margen_promedio,
		    COALESCE ((dias_stock * select_ventas_dia(producto.barcode, TRUE)::float), 0) AS stock_min,
		    fraccion, canje, stock_pro, tasa_canje, precio_mayor, dias_stock,
		    cantidad_mayor, mayorista, tipo
             FROM producto WHERE estado = true AND (lower(descripcion) LIKE lower($S$
	|| quote_literal(expresion) || $S$) OR lower(marca) LIKE lower($S$
	|| quote_literal(expresion) || $S$) OR upper(codigo_corto) LIKE upper($S$
	|| quote_literal(expresion) || $S$)) ORDER BY descripcion, marca $S$;

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

FOR list IN EXECUTE query LOOP
    barcode := list.barcode;
    codigo_corto := list.codigo_corto;
    marca := list.marca;
    descripcion := list.descripcion;
    contenido := list.contenido;
    unidad := list.unidad;

    -- Su la mercadería es derivada, calcula su stock de acuerdo a sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
	stock := (SELECT disponible FROM obtener_stock_desde_barcode (list.barcode));
    ELSE
	stock := list.stock;
    END IF;

    precio := list.precio;
    precio_neto := list.precio_neto;

    -- Si la mercadería es derivada, calcula su costo promedio a partir del costo de sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
        costo_promedio := (SELECT costo FROM obtener_costo_promedio_desde_barcode (list.barcode));
    ELSE
	costo_promedio := list.costo_promedio;
    END IF;

    vendidos := list.vendidos;
    impuestos := list.impuestos;
    otros := list.otros;
    familia := list.familia;
    perecibles := list.perecibles;
    stock_min := list.stock_min;
    dias_stock := list.dias_stock;
    margen_promedio := list.margen_promedio;
    fraccion := list.fraccion;
    canje := list.canje;
    stock_pro := list.stock_pro;
    tasa_canje := list.tasa_canje;
    precio_mayor := list.precio_mayor;
    cantidad_mayor := list.cantidad_mayor;
    mayorista := list.mayorista;
    tipo := list.tipo;
    RETURN NEXT;
END LOOP;

RETURN;
END; $$ language plpgsql;",funciones.sql
"create or replace function buscar_proveedor(
       in pattern varchar(100),
       out rut integer,
       out dv varchar(1),
       out nombre varchar(100),
       out direccion varchar(100),
       out ciudad varchar(100),
       out comuna varchar(100),
       out telefono varchar(100),
       out email varchar(300),
       out web varchar(300),
       out contacto varchar(100),
       out giro varchar(100),
       out lapso_reposicion integer)
returns setof record as $$
declare
	q text;
	l record;
begin
q := 'SELECT rut,dv,nombre,direccion,ciudad,comuna,telefono,email,web,contacto,giro,lapso_reposicion
     	     FROM proveedor WHERE lower(nombre) LIKE lower('
	     || quote_literal($1) || ') '
	     || 'OR lower(rut::varchar) LIKE lower(' || quote_literal($1) || ') ORDER BY nombre';

for l in execute q loop
    rut = l.rut;
    dv = l.dv;
    nombre = l.nombre;
    direccion = l.direccion;
    ciudad = l.ciudad;
    comuna = l.comuna;
    telefono = l.telefono;
    email = l.email;
    web = l.web;
    contacto = l.contacto;
    giro = l.giro;
    lapso_reposicion = l.lapso_reposicion;
    return next;
end loop;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function bytea_import(p_path text, p_result out bytea)
                   language plpgsql as $$
declare
  l_oid oid;
begin
  select lo_import(p_path) into l_oid;
  select lo_get(l_oid) INTO p_result;
  perform lo_unlink(l_oid);
end;$$;",metadataInsert.py
"create or replace function cal_affinity(OUT o_combo tid[], OUT affinity int8) returns setof record as $$  
declare  
  ccc int8;     -- tbl2总共多少条记录  
  v_tid tid[];  -- 行号组合  
  vv_tid tid;   -- 行号  
  i1 int := 1;  -- 正处于第几行  
  i2 int[];     -- 与tbl2.arr同类型的数组，存储所有元素  
  i3 int[];     -- 上一次元素出现在第几行，下标=i2 中元素的位置  
  i4 int[];     -- 每个元素的聚合度累计值  
  v_i4 int;     -- 每个元素单独的聚合度  
  sum_i4 int8;  -- i4的sum  
  x int;        -- 第几个循环  
  v_arr int[];  -- tbl2 数组  
  i_arr int;    -- tbl2 数组元素  
begin  
  select count(*) into ccc from tbl2;  
  select array(select distinct(unnest(arr)) from tbl2) into i2;  
  
-- 排列组合循环  
for v_tid in   
  WITH RECURSIVE cte AS (    
       SELECT array[ctid] AS combo, ctid, 1 AS ct   
       FROM tbl2  
     UNION ALL   
       SELECT array_append(cte.combo, t.ctid), t.ctid, ct + 1   
       FROM cte, tbl2 t  
       WHERE ct <= ccc  
         AND array_position(cte.combo, t.ctid) is null  
  )   
  SELECT combo FROM cte where ct=ccc limit 10   --  只计算10种组合  
  -- 3628800种组合实在太多了，我挑选一些进行计算，验证聚合度结果。  
loop  
    
  -- 按行号循环  
  foreach vv_tid in array v_tid   
  loop  
      
    -- 生成tbl2当前行的数组  
    select arr into v_arr from tbl2 where ctid=vv_tid;  
  
    -- 按tbl2数组元素循环，计算每个元素的聚合度累加  
    foreach i_arr in array v_arr  
    loop  
      -- 获取元素下标 array_position(i2, i_arr)  
      -- i1=1，处于第一行  
  
      -- 计算聚合度，真实场景应该改成数据块是否相邻，而不是行号  
      if i1=1 then  
	-- 第一行  
	i4[array_position(i2, i_arr)] := 0;  
      else  
        -- 不是第一行  
	if i4[array_position(i2, i_arr)] is null then  
          -- 该元素第一次出现  
	  i4[array_position(i2, i_arr)] := 0;  
	else  
	  -- 该元素不是第一次出现  
	  i4[array_position(i2, i_arr)] := i4[array_position(i2, i_arr)] + greatest((i1 - i3[array_position(i2, i_arr)] - 1), 0);  -- 防止单行元素重复计算错误  
	end if;  
      end if;  
        
      -- 元素最后一次出现在第几行  
      i3[array_position(i2, i_arr)] := i1;  
    end loop;  
  
    -- 行号+1  
    i1 := i1 + 1;  
  end loop;  
  
  -- 输出该排列组合的所有元素的聚合度，总聚合度  
  select sum(unnest) into sum_i4 from (select unnest(i4)) t;  
  raise notice 'combo: %, sum(affinity): %', v_tid, sum_i4;  
  x := 1;  
  foreach v_i4 in array i4  
  loop  
    raise notice 'elements: %, affinity: %', i2[x], v_i4;  
    x := x+1;  
  end loop;  
    
  -- 初始化变量  
  i1 := 1;  
  i3 := '{}';  
  i4 := '{}';  
end loop;  
-- 行号循环  
end;  
$$ language plpgsql strict;",20170614_01.md
"create or replace function calculate_fifo (
        in product_barcode bigint,
        in compra_id int)
returns double precision as $$
declare
        current_fifo double precision;
        current_stock double precision;
        costo double precision;
        stock_add double precision;
        suma double precision;
        fifo double precision;
begin

        select costo_promedio, stock into current_fifo, current_stock from producto where barcode=product_barcode;
        select precio, cantidad_ingresada into costo, stock_add from compra_detalle where barcode_product=product_barcode and id_compra=compra_id;

        if current_fifo is null then
            current_fifo = 0;
        end if;

        suma = current_stock * current_fifo;
        suma = suma + (stock_add * costo);

        current_stock = current_stock + stock_add;

	
	if current_stock > 0 AND suma > 0 then
            fifo = (suma / current_stock);
	else
	    fifo = current_fifo;
        end if;

        return fifo;
end; $$ language plpgsql;",funciones.sql
"create or replace function cash_box_report (
        in cash_box_id integer,
        out open_date timestamp,
        out close_date timestamp,
        out cash_box_start integer,
        out cash_box_end integer,
        out cash_sells integer,
        out cash_on_mixed_sell integer,
        out cash_outcome integer,
	out nullify_sell integer,
	out current_expenses integer,
        out cash_income integer,
        out cash_payed_money integer,
	out cash_loss_money integer,
	out bottle_return integer,
	out bottle_deposit integer,
	out cash_close_outcome integer
	)
returns setof record as $$
declare
        query varchar;
        dat record;
        sell_first_id integer;
        sell_last_id integer;
	perdida_egreso integer;
        first_cash_box_id integer;
        last_cash_box_id integer;
	open_date2 timestamp without time zone;
	close_date_now timestamp without time zone;
	close_date_back timestamp without time zone;
	monto1 bigint;
	monto2 bigint;
begin

        select id_venta_inicio, fecha_inicio, inicio, id_venta_termino, fecha_termino, termino, COALESCE(perdida,0)
        into sell_first_id, open_date, cash_box_start, sell_last_id, close_date, cash_box_end, cash_loss_money
        from caja
        where id = cash_box_id;

        -- select id_venta_inicio into sell_first_id, fecha_inicio into open_date, inicio into cintoh_box_start, id_venta_termino into sell_lintot_id, fecha_termino into close_date,
        --         termino into cintoh_box_end
        -- from caja
        -- where id = cintoh_box_id;

        if close_date is null then
                close_date := now();
        end if;

	-- ACLARACION: Si el id de apertura y cierre son iguales significa que no hubo venta
	-- La que la siguiente operación debería realizarse solo si hay venta en la primera apertura de caja

	-- To avoid problems with the first sell
        if sell_first_id = 1 AND sell_first_id != sell_last_id then
                sell_first_id := 0;
        end if;

	-- sell_first_id es el último id de venta antes de la apertura de caja
        -- Ve las ventas directas en efectivo y el efectivo de las ventas mixtas
        if sell_last_id = 0 or sell_last_id is null then
                --Cash sell
                select sum (monto) into cash_sells
                from venta
                where id > sell_first_id and tipo_venta = 0;
                --Cash on mixed sell
                select sum (pm.monto2) into cash_on_mixed_sell
                from pago_mixto pm
                where pm.id_sale > sell_first_id and pm.tipo_pago2 = 0;
        else
                --Cash sell
                select sum (monto) into cash_sells
                from venta
                where id > sell_first_id and id <= sell_last_id and tipo_venta = 0;
                --Cash on mixed sell
                select sum (pm.monto2) into cash_on_mixed_sell
                from pago_mixto pm
                where pm.id_sale > sell_first_id and pm.id_sale <= sell_last_id and pm.tipo_pago2 = 0;
        end if;

        if cash_sells is null then
                cash_sells := 0;
        end if;

        select sum (monto) into cash_outcome
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Retiro';

        if cash_outcome is null then
                cash_outcome := 0;
        end if;

	select sum (monto) into cash_close_outcome
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Retiro por cierre';

        if cash_close_outcome is null then
                cash_close_outcome := 0;
        end if;


	select sum (monto) into nullify_sell
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Nulidad de Venta';

        if nullify_sell is null then
                nullify_sell := 0;
        end if;

	select sum (monto) into current_expenses
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Gastos Corrientes';

        if current_expenses is null then
                current_expenses := 0;
        end if;

	select sum (monto) into perdida_egreso
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Perdida';

        if perdida_egreso is null then
                perdida_egreso := 0;
        end if;

	select sum (monto) into bottle_return
        from egreso e
	inner join tipo_egreso te
	on e.tipo = te.id
        where e.id_caja = cash_box_id
	and te.descrip = 'Devolucion envases';

        if bottle_return is null then
                bottle_return := 0;
        end if;

        select sum (monto) into cash_income
        from ingreso, tipo_ingreso
        where id_caja = cash_box_id
	and tipo = tipo_ingreso.id
	and tipo_ingreso.descrip != 'Deposito envases';

        if cash_income is null then
                cash_income := 0;
        end if;

	select sum (monto) into bottle_deposit
        from ingreso i
	inner join tipo_ingreso ti
	on i.tipo = ti.id
        where i.id_caja = cash_box_id
	and ti.descrip = 'Deposito envases';

        if bottle_deposit is null then
                bottle_deposit := 0;
        end if;

        select last_value into last_cash_box_id from caja_id_seq;

        select fecha_inicio into open_date2
               from caja where id = last_cash_box_id;

        close_date_now := now();

        select fecha_termino into close_date_back
               from caja where id = last_cash_box_id - 1;

        select sum (monto_abonado) into monto1
        from abono where fecha_abono > open_date and fecha_abono < close_date;

        if monto1 is null then
           monto1 := 0;
        end if;

        select sum (monto_abonado) into monto2
               from abono where fecha_abono > close_date_back and  fecha_abono < open_date;

        if monto2 is null then
           monto2 := 0;
        end if;

        cash_payed_money := monto1 + monto2;
	cash_loss_money := cash_loss_money + perdida_egreso;

return next;
return;

end; $$ language plpgsql;",funciones.sql
"create or replace function cb() returns void as   
$$  
declare  
  sql text := '';  
begin  
  for i in 1..10 loop  
    sql := sql||'c'||i||' int default random()*10000,';  
  end loop;  
  for i in 11..20 loop  
    sql := sql||'c'||i||' int default random()*1000,';  
  end loop;  
  for i in 21..40 loop  
    sql := sql||'c'||i||' int default random()*100,';  
  end loop;  
  for i in 41..70 loop  
    sql := sql||'c'||i||' int[] default gen_rand_int(100000,150,20),';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := 'create table test ('||sql||') with (APPENDONLY=true, ORIENTATION=column, COMPRESSTYPE=zlib, CHECKSUM=false, COMPRESSLEVEL=5) distributed randomly';  
  execute sql;  
end;  
$$ language plpgsql strict;",20170827_01.md
"create or replace function cb() returns void as   
$$  
declare  
  sql text := '';  
begin  
  for i in 1..10 loop  
    sql := sql||'c'||i||' int default random()*10000,';  
  end loop;  
  for i in 11..20 loop  
    sql := sql||'c'||i||' int default random()*1000,';  
  end loop;  
  for i in 21..40 loop  
    sql := sql||'c'||i||' int default random()*100,';  
  end loop;  
  for i in 41..70 loop  
    sql := sql||'c'||i||' int[] default gen_rand_int(100000,150,20),';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := 'create table test ('||sql||') with (APPENDONLY=true, ORIENTATION=column, COMPRESSTYPE=zlib, CHECKSUM=false, COMPRESSLEVEL=5) distributed randomly';  
  execute sql;  
end;  
$$ language plpgsql strict;",index.html
"create or replace function changeconstraintalignement() returns void as $$
begin
	if exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_uri_target_internal_id_thesaurus_internal_id_con_key') then 
	execute
	'
            alter table alignement
            drop constraint alignement_uri_target_internal_id_thesaurus_internal_id_con_key;
        alter table alignement 
            add constraint  alignement_internal_id_concept_internal_id_thesaurus_id_alignement_source_key unique 
            (internal_id_concept, internal_id_thesaurus, id_alignement_source, alignement_id_type)
        ';
        end if;
        if exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_id_alignem') then 
	execute
	'
            alter table alignement
            drop constraint alignement_internal_id_concept_internal_id_thesaurus_id_alignem;
        ';
        end if;
        if exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_id_alignement_source_key') then 
	execute
	'
            alter table alignement
            drop constraint alignement_internal_id_concept_internal_id_thesaurus_id_alignement_source_key;
        ';
        end if;

        if not exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_internal_id_concept_internal_id_thesaurus_id_alignement_source_key2') then 
	execute
	'
            alter table alignement
            add constraint  alignement_internal_id_concept_internal_id_thesaurus_id_alignement_source_key2 unique 
            (internal_id_concept, internal_id_thesaurus, id_alignement_source, alignement_id_type, uri_target)
        ';
        end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function codigo_corto_to_barcode
       	  	  	   (IN prod_codigo_corto varchar(16),
			   OUT barcode int8)
returns setof int8 as $$
declare
	contador int;
	list record;
	query varchar(255);
begin
contador := 0;
-- esta sentencia creo que se puede satisfacer con una anterior
query := 'select barcode from producto where codigo_corto = '
      	 	 || quote_literal(prod_codigo_corto);

FOR list IN EXECUTE query LOOP
    barcode := list.barcode;
    IF contador > 0 THEN
       RAISE NOTICE 'Retornando más de un barcode para el codigo corto: %',
       	     	    prod_codigo_corto;
    END IF;
    contador := contador + 1;
    RETURN NEXT;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function conn(    
  name,   -- dblink名字    
  text    -- 连接串,URL    
) returns void as $$      
declare      
begin      
  perform dblink_connect($1, $2);     
  return;      
exception when others then      
  return;      
end;      
$$ language plpgsql strict;",20180202_01.md
"create or replace function conn(      
  name,   -- dblink名字      
  text    -- 连接串,URL      
) returns void as $$        
declare        
begin        
  perform dblink_connect($1, $2);       
  return;        
exception when others then        
  return;        
end;        
$$ language plpgsql strict;",20180201_02.md
"create or replace function conn(      
  name,   -- dblink名字      
  text    -- 连接串,URL      
) returns void as $$        
declare        
begin        
  perform dblink_connect($1, $2);       
  return;        
exception when others then        
  return;        
end;        
$$ language plpgsql strict;",20180202_01.md
"create or replace function conn(      
  name,   -- dblink名字      
  text    -- 连接串,URL      
) returns void as $$        
declare        
begin        
  perform dblink_connect($1, $2);       
  return;        
exception when others then        
  return;        
end;        
$$ language plpgsql strict;",20180205_03.md
"create or replace function conn(        
  name,   -- dblink名字        
  text    -- 连接串,URL        
) returns void as $$          
declare          
begin          
  perform dblink_connect($1, $2);         
  return;          
exception when others then          
  return;          
end;          
$$ language plpgsql strict;",20180201_02.md
"create or replace function conn(        
  name,   -- dblink名字        
  text    -- 连接串,URL        
) returns void as $$          
declare          
begin          
  perform dblink_connect($1, $2);         
  return;          
exception when others then          
  return;          
end;          
$$ language plpgsql strict;",20180204_01.md
"create or replace function conn(        
  name,   -- dblink名字        
  text    -- 连接串,URL        
) returns void as $$          
declare          
begin          
  perform dblink_connect($1, $2);         
  return;          
exception when others then          
  return;          
end;          
$$ language plpgsql strict;",20180205_03.md
"create or replace function conn(        
  name,   -- dblink名字        
  text    -- 连接串,URL        
) returns void as $$          
declare          
begin          
  perform dblink_connect($1, $2);         
  return;          
exception when others then          
  return;          
end;          
$$ language plpgsql strict;",20180210_01.md
"create or replace function conn(        
  name,   -- dblink名字        
  text    -- 连接串,URL        
) returns void as $$          
declare          
begin          
  perform dblink_connect($1, $2);         
  return;          
exception when others then          
  return;          
end;          
$$ language plpgsql strict;",20180904_03.md
"create or replace function conn(          
  name,   -- dblink名字          
  text    -- 连接串,URL          
) returns void as $$            
declare            
begin            
  perform dblink_connect($1, $2);           
  return;            
exception when others then            
  return;            
end;            
$$ language plpgsql strict;",20181129_01.md
"create or replace function conn(          
  name,   -- dblink名字          
  text    -- 连接串,URL          
) returns void as $$            
declare            
begin            
  perform dis_conn($1);  
  perform dblink_connect($1, $2);           
  return;            
exception when others then            
  return;            
end;            
$$ language plpgsql strict;",20180427_03.md
"create or replace function conn(          
  name,   -- dblink名字          
  text    -- 连接串,URL          
) returns void as $$            
declare            
begin            
  perform dis_conn($1);  
  perform dblink_connect($1, $2);           
  return;            
exception when others then            
  return;            
end;            
$$ language plpgsql strict;",index.html
"create or replace function contarDetalle(nroIngreso integer) returns integer as $$
begin
     return (select count(*) from Detalle_Ingreso where Detalle_Ingreso.nro_ingreso=nroIngreso);
end; $$
language plpgsql;",script.sql
"create or replace function create_constraint_if_not_exists (
    c_name text, constraint_sql text
) 
returns void AS
$$
begin
    -- Look for our constraint
    if not exists (SELECT conname FROM pg_constraint WHERE conname = c_name) then
        execute constraint_sql;
    end if;
end;
$$ language 'plpgsql';",2.%202_1%20a%20MODELO.sql
"create or replace function create_domain2() returns void language plpgsql as $body$
begin
  begin
    execute($$create domain source.domain2 as source.domain1 default 1 not null$$);
  exception
    when datatype_mismatch then --v8.1
      execute($$create domain source.domain2 as int default 1 not null$$);
  end;
end;
$body$;",test_schema.sql
"create or replace function create_schemaless(target name) returns void as $$    
declare    
begin    
  execute format('create table if not exists %I (like bptest including all) inherits(bptest)', target);    
  -- 这里可以设置列的statistic  
exception when others then    
  return;    
end;    
$$ language plpgsql strict;",20170522_01.md
"create or replace function create_schemaless(target name) returns void as $$    
declare    
begin    
  execute format('create table if not exists %I (like bptest including all) inherits(bptest)', target);    
  -- 这里可以设置列的statistic  
exception when others then    
  return;    
end;    
$$ language plpgsql strict;",index.html
"create or replace function create_schemaless(target name) returns void as $$    
declare    
begin    
  execute format('create table if not exists %I (like bptest including all)', target);    
exception when others then    
  return;    
end;    
$$ language plpgsql strict;",20170522_01.md
"create or replace function create_schemaless(target name) returns void as $$ declare begin execute format('create table if not exists %I (content jsonb)', target); exception when others then return; end; $$ language plpgsql strict;",index.html
"create or replace function create_table_copyright() returns void as $$
begin
     IF NOT EXISTS (SELECT table_name FROM information_schema.tables WHERE table_name = 'copyright') THEN

        execute 
		'CREATE TABLE copyright
                ( id_thesaurus character varying NOT NULL,
                  copyright character varying,
                  CONSTRAINT copyright_pkey PRIMARY KEY (id_thesaurus)
                )';
        

    END IF;
end;
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_table_external_images() returns void as $$
    begin 
        IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='external_images') THEN
            execute 'CREATE TABLE external_images
                    (
                      id_concept character varying NOT NULL,
                      id_thesaurus character varying NOT NULL,
                      image_name character varying NOT NULL,
                      image_copyright character varying NOT NULL,
                      id_user integer,
                      external_uri character varying NOT NULL DEFAULT ''''::character varying,
                      CONSTRAINT external_images_pkey PRIMARY KEY (id_concept, id_thesaurus, external_uri)
                    );';

        end if;
    end;
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_table_preferences_sparql() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='preferences_sparql' ) THEN
        execute 'CREATE TABLE public.preferences_sparql
                    (
                        adresse_serveur character varying,
                        mot_de_passe character varying,
                        nom_d_utilisateur character varying,
                        graph character varying,
                        synchronisation boolean NOT NULL DEFAULT false,
                        thesaurus character varying NOT NULL,
                        heure time without time zone,
                        CONSTRAINT preferences_sparql_pkey PRIMARY KEY (thesaurus)
                      )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_table_routine_mail() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='routine_mail') THEN
        execute 'CREATE TABLE routine_mail 
                    ( id_thesaurus character varying PRIMARY KEY,
                      alert_cdt boolean DEFAULT true,
                      debut_env_cdt_propos DATE NOT NULL,
                      debut_env_cdt_valid DATE NOT NULL,
                      period_env_cdt_propos integer NOT NULL,
                      period_env_cdt_valid integer NOT NULL
                        )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_table_user_role_group() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='user_role_group' ) THEN
        execute 'CREATE TABLE user_role_group
                    (
                      id_user integer NOT NULL,
                      id_role integer NOT NULL,
                      id_group integer NOT NULL,
                      CONSTRAINT user_role_pkey PRIMARY KEY (id_user, id_role, id_group)
                    )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_table_user_role_only_on() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='user_role_only_on' ) THEN
        execute 'CREATE TABLE user_role_only_on
                    (
                      id_user integer NOT NULL,
                      id_role integer NOT NULL,
                      id_theso character varying NOT NULL,
                      id_theso_domain character varying NOT NULL DEFAULT ''all''::character varying,
                      CONSTRAINT user_role_only_on_pkey PRIMARY KEY (id_user, id_role, id_theso)
                    )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function create_test(int,int) returns void as $$
declare
begin
for i in $1..$2 loop
execute 'create table test'||i||' (like test including all)';
end loop;
end;
$$ language plpgsql strict;",20161012_01.md
"create or replace function create_test(int,int) returns void as $$
declare
begin
for i in $1..$2 loop
execute 'create table test'||i||' (like test including all)';
end loop;
end;
$$ language plpgsql strict;",index.html
"create or replace function crt_idx_tbl() returns setof record as $$      
declare      
begin      
  for i in 0..55 loop             
    perform conn('link'||i,  'hostaddr=127.0.0.1 port='||current_setting('port')||' user=postgres dbname=postgres');             
    perform 1 from dblink_get_result('link'||i) as t(res text);            
    perform dblink_send_query('link'||i, format('create index idx_ut%s_1 on ut%s (c1)', i, i));            
  end loop;         
  for i in 0..55 loop      
    return query select * from dblink_get_result('link'||i) as t(res text);      
  end loop;      
end;      
$$ language plpgsql strict;",20180427_03.md
"create or replace function crt_tbl(name, text, text) returns void as $$ declare sql text; begin sql := 'create table '||$1||'('; for i in 1..1000 loop sql := sql||'c'||i||' int8 default random()*10000,'; end loop; sql := rtrim(sql, ','); sql := sql||') with (APPENDONLY=true, ORIENTATION='||$2||', COMPRESSTYPE='||$3||')'; execute sql; end; $$ language plpgsql strict;",index.html
"create or replace function ct1 () returns void as $$  
declare  
  sql text := '';  
begin  
  sql := 'create table tbl_tag(uid int8,';  
  for i in 1..200 loop  
    sql := sql||'c'||i||' int2 default random()*32767,';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := sql||') with (APPENDONLY=true, ORIENTATION=column, COMPRESSTYPE=zlib, CHECKSUM=false)';  
  execute sql;  
end;  
$$ language plpgsql strict;",20170918_02.md
"create or replace function ct1 () returns void as $$  
declare  
  sql text := '';  
begin  
  sql := 'create table tbl_tag(uid int8,';  
  for i in 1..200 loop  
    sql := sql||'c'||i||' int2 default random()*32767,';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := sql||')';  
  execute sql;  
end;  
$$ language plpgsql strict;",20170918_02.md
"create or replace function ct1 () returns void as $$  
declare  
  sql text := '';  
begin  
  sql := 'create table tbl_tag(uid int8,';  
  for i in 1..200 loop  
    sql := sql||'c'||i||' int2 default random()*32767,';  
  end loop;  
  sql := rtrim(sql, ',');  
  sql := sql||')';  
  execute sql;  
end;  
$$ language plpgsql strict;",index.html
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	SELECT dblink_get_connections() into dbname;

	IF dbname IS NOT NULL THEN

		raise notice '当前所有跨数据库连接名称:%', dbname;

		dbname:=replace(dbname, '{', '');
		dbname:=replace(dbname, '}', '');
	  	dbnames:=regexp_split_to_array(dbname, ', ');

		IF array_length(dbnames, 1) > 0 THEN
			FOR i in 1..array_length(dbnames, 1)
			LOOP
				raise notice '名称:%', dbnames[i];
				perform dblink_disconnect(dbnames[i]);
			END LOOP;
		END IF;

	ELSE
		raise notice '当前没有连接';
	END IF;
END
$$ LANGUAGE plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	SELECT dblink_get_connections() into dbname;

	IF dbname IS NOT NULL THEN

		raise notice '当前所有跨数据库连接名称:%', dbname;

		dbname:=replace(dbname, '{', '');
		dbname:=replace(dbname, '}', '');
	  	dbnames:=regexp_split_to_array(dbname, ',');

		IF array_length(dbnames, 1) > 0 THEN
			FOR i in 1..array_length(dbnames, 1)
			LOOP
				raise notice '名称:%', dbnames[i];
				perform dblink_disconnect(dbnames[i]);
			END LOOP;
		END IF;

	ELSE
		raise notice '当前没有连接';
	END IF;
END

$$ LANGUAGE plpgsql;",4_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function dblink_close_all() returns void as $$
declare dbnames varchar[];
declare dbname varchar;
BEGIN
	select dblink_get_connections() into dbname;
	if dbname is not null THEN
	raise notice '当前所有跨数据库连接名称:%',dbname;
	dbname:=replace(dbname,'{','');
	dbname:=replace(dbname,'}','');
  dbnames:=regexp_split_to_array(dbname,',');
	if array_length(dbnames,1)>0 THEN
	for i in 1..array_length(dbnames,1) loop
		raise notice '名称:%',dbnames[i];
		--perform dblink_close(dbnames[i]);
		perform dblink_disconnect(dbnames[i]);
	end loop;
	end if;
	else
		raise notice '当前没有连接';
	end if;
END
$$ LANGUAGE plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function ddl_ine(sql text) returns int2 as $$ declare begin execute sql; return 0; -- 返回0表示正常 exception when duplicate_table then raise notice '%', SQLERRM; return 1; -- 返回1表示已存在 when others then raise notice '%ERROR: % %create table error: %', chr(10), SQLERRM, chr(10), sql; return 2; -- 返回2表示DDL其他错误 end; $$ language plpgsql strict;",index.html
"create or replace function debugger_test (i int) returns int as $$    
declare    
v_result int;    
begin    
v_result := 0;    
if i<0 then    
  raise notice 'Please enter i >=0.';    
  raise exception '';    
end if;    
for x in 0..i loop    
v_result := v_result + x;    
end loop;    
return v_result;    
exception    
when others then    
  v_result := 0;    
  return v_result;    
end;    
$$ language plpgsql;",20170424_02.md
"create or replace function dis_conn(name) returns void as $$      
declare      
begin      
  perform dblink_disconnect($1);      
  return;      
exception when others then      
  return;      
end;      
$$ language plpgsql strict;",20180427_03.md
"create or replace function drop_constraint_alignement_source() returns void as $$
begin
	if exists (SELECT * from information_schema.table_constraints where table_name = 'alignement' and constraint_type = 'UNIQUE'
	and constraint_name ='alignement_concept_target_thesaurus_target_alignement_id_ty_key') then 
	execute
	'ALTER TABLE ONLY alignement
	  DROP CONSTRAINT alignement_concept_target_thesaurus_target_alignement_id_ty_key ;';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function echo( text, anyelement ) returns anyelement volatile language plpgsql as $$
  begin raise notice '(%) %', $1, $2; return $2; end; $$;",030-utilities-1.sql
"create or replace function existeInsumo(codInsumo integer)returns boolean as 
$$
   declare cantInsumo integer=(select count(*) from Insumo where cod_insumo=codInsumo);
   begin 
      if(cantInsumo=1)then return(true);
	  else return(false);
	  end if;
   end;
$$
language plpgsql;",script.sql
"create or replace function existe_producto(prod_barcode int8)
returns boolean as $$
declare

	list record;
	query varchar(255);

begin
query := 'SELECT count(*) as suma FROM producto WHERE barcode='
      || quote_literal(prod_barcode) ;

FOR list IN EXECUTE query LOOP
	if list.suma > 0 then
		return TRUE;
	end if;
END LOOP;

RETURN FALSE;

END; $$ language plpgsql;",funciones.sql
"create or replace function existe_producto(prod_codigo_corto varchar(16))
returns boolean as $$
declare
	list record;
	query varchar(255);
begin
query := 'SELECT count(*) as suma FROM producto WHERE codigo_corto='
      || quote_literal(prod_codigo_corto) ;

FOR list IN EXECUTE query LOOP
	if list.suma > 0 then
		return TRUE;
	end if;
END LOOP;

RETURN FALSE;

END; $$ language plpgsql;",funciones.sql
"create or replace function f1(int) returns setof record as $$ declare begin set local statement_timeout='100ms'; return query select count(*) as cnt, id from a where id&lt;$1 group by id; end; $$ language plpgsql strict ;",index.html
"create or replace function f_add_col (t_name regclass,c_name text, sql text) returns void AS $$
begin
    IF EXISTS (
		SELECT 1 FROM pg_attribute
			WHERE  attrelid = t_name
			AND    attname = c_name
			AND    NOT attisdropped) THEN
			RAISE NOTICE 'Column % already exists in %', c_name, t_name;
	ELSE
		EXECUTE sql;
	END IF;
end;
$$ language 'plpgsql';",2.%202_1%20a%20MODELO.sql
"create or replace function fct1() returns int as $$
begin
    return 30;
end
$$
language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function fct1() returns int as $$
declare
    quantity int:=30;
begin
    raise notice 'Quantity here is %', quantity; -- prints 30
    quantity:=50;
    return quantity;
end; $$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function fct1() returns int as $$
declare
    quantity int:=30;
begin
    raise notice 'quantity is %', quantity+13;
    quantity:=50;
    return quantity;
end
$$
language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function ff(  
  v_type text,         -- 使用什么公式, tfidf or overlap or cosine  
  v_threshold float8,  -- 设置对应公式的阈值   
  v_arr int8[]         -- 要比较的数组  
) returns boolean as $$                                                  
declare  
begin   
  set enable_seqscan = off;                                 -- 关闭全表扫描, 强制使用索引  
  execute format('set smlar.type=%L', v_type);              -- 设置公式, overlap  
  -- threshold允许普通用户设置，会话之间互不干扰
  execute format('set smlar.threshold=%s', v_threshold);    -- 设置相交元素个数的阈值, 这个阈值可以程序计算，也可以程序提供一个百分比，在PG中计算。建议程序自己算，减少数据库开销。  
    
  perform 1 from test where arr % v_arr limit 1;            -- 搜索test表中arr字段与传入的v_arr值，判断是否有相似记录  
  if found then  
    set enable_seqscan = on;  -- 退出函数时，恢复设置  
    return false;             -- found similar array，表示找到了相似文章  
  else  
    set enable_seqscan = on;  -- 退出函数时，恢复设置  
    return true;              -- 表示没有找到相似文章  
  end if;  
end;  
$$ language plpgsql strict;",20170112_02.md
"create or replace function ff(int, int, int) returns setof t_age as $$  
declare  
  v t_age;  
  i int := 0;  
begin  
  set enable_seqscan=off;  
  set enable_indexscan=on;  
  set enable_bitmapscan=off;  
  for v in   
    select * from t_age order by age <-> $1   
  loop   
    if (v.age <-> $1) >= $2 or (i) >= $3 then return; end if;  
    i := i+1;   
    return next v;  
  end loop;  
  return;  
end;  
$$ language plpgsql strict;",20191218_02.md
"create or replace function ff(point, float8, int) returns setof record as $$                                                          
declare  
  v_rec record;  
  v_limit int := $3;  
begin  
  set local enable_seqscan=off;   -- 强制索引, 扫描行数够就退出.  
  for v_rec in   
    select *,  
    (pos <-> $1) as dist  
    from tbl   
    where   
    crt_time between '2017-07-22 17:59:34' and '2017-07-22 17:59:40'   
    and (   
      c1 in (1,2,3,4,100,200,99,88,77,66,55)  
        or  
      c2 < 10  
    )  
    order by pos <-> $1  
  loop  
    if v_limit <=0 then  
      -- raise notice '已经取足数据';  
      return;  
    end if;  
    if v_rec.dist > $2 then  
      -- raise notice '满足条件的点已输出完毕';  
      return;  
    else  
      return next v_rec;  
    end if;  
    v_limit := v_limit -1;  
  end loop;  
end;  
$$ language plpgsql strict volatile;",20170722_01.md
"create or replace function ff(point, float8, int) returns setof tid as $$                                                          
declare  
  v_rec record;  
  v_limit int := $3;  
begin  
  set local enable_seqscan=off;   -- 强制索引, 扫描行数够就退出.  
  for v_rec in   
    select *,  
    (pos <-> $1) as dist,  
    ctid  
    from tbl   
    order by pos <-> $1  
  loop  
    if v_limit <=0 then  
      -- raise notice '已经取足数据';  
      return;  
    end if;  
    if v_rec.dist > $2 then  
      -- raise notice '满足条件的点已输出完毕';  
      return;  
    else  
      return next v_rec.ctid;  
    end if;  
    v_limit := v_limit -1;  
  end loop;  
end;  
$$ language plpgsql strict volatile;",20170722_01.md
"create or replace function ff(polygon) returns setof record as $$                                                            
declare    
  v_rec record;    
  cir circle := circle(box($1));            -- 扩散边界    
  dist float8 := radius(circle(box($1)));   -- 求多边形外圆的半径    
  centrid point := point(circle(box($1)));  -- 求多边形外圆的中心点    
begin    
  set local enable_seqscan=off;             -- 强制空间索引, KNN搜索    
  for v_rec in     
    select * from pos order by pos <-> centrid     
  loop    
    if not cir @> v_rec.pos then    
      return;    
    elsif ($1 @> v_rec.pos) then    
      return next v_rec;    
    end if;    
  end loop;    
  return;    
end;    
$$ language plpgsql strict volatile;",20170802_02.md
"create or replace function ff1(geometry, float8, int) returns setof record as $$                                                          
declare  
  v_rec record;  
  v_limit int := $3;  
begin  
  set local enable_seqscan=off;   -- 强制索引, 扫描行数够就退出.  
  for v_rec in   
    select *,  
    ST_Distance ( $1, loc_box ) as dist   
    from cloudpoint_test_agg   
    -- where xxx1='1' and xxx2='xxx'
    order by loc_box <-> $1           -- 按距离顺序由近到远返回  
  loop  
    if v_limit <=0 then               -- 判断返回的记录数是否达到LIMIT的记录数  
      raise notice '已经取足limit设置的 % 条数据, 但是距离 % 以内的点可能还有.', $3, $2;  
      return;  
    end if;  
    if v_rec.dist > $2 then       -- 判断距离是否大于请求的距离   
      raise notice '距离 % 以内的点已输出完毕', $2;  
      return;  
    else  
      return next v_rec;  
    end if;  
    v_limit := v_limit - array_length(v_rec.loc_agg, 1);  -- 扣减grid内的point个数  
  end loop;  
end;  
$$ language plpgsql strict volatile;",20170620_01.md
"create or replace function find_high(int) returns text as $$    
declare    
  res text := $1;    
  tmp text := res;    
begin    
  loop    
    select pid into tmp from a where id = tmp::int;    
    if tmp is null then    
      exit;    
    end if;    
    res := tmp||'.'||res;   
  end loop;    
  return res;    
end;    
$$ language plpgsql strict;",20170923_01.md
"create or replace function find_low(int) returns int[] as $$    
declare    
  res int[] := array[$1];    
  tmp int[] := res;    
begin    
  loop    
    select array_agg(id) into tmp from a where pid = any (tmp);    
    res := array_cat(res,tmp);    
    if tmp is null then    
      exit;    
    end if;    
  end loop;    
  return res;    
end;    
$$ language plpgsql strict;",20170923_01.md
"create or replace function func1(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from pg_class' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras.out
"create or replace function func1(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from pg_class' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras_optimizer.out
"create or replace function func2(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from qp_misc_jiras.pg_foo' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras.out
"create or replace function func2(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from qp_misc_jiras.pg_foo' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras_optimizer.out
"create or replace function func3(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from (select count(distinct relname) from pg_class) a' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras.out
"create or replace function func3(int) returns int as $$
declare
	t1 int;
begin
	execute 'select count(*) from (select count(distinct relname) from pg_class) a' into t1;
	return t1;
end;
$$
language plpgsql;",qp_misc_jiras_optimizer.out
"create or replace function gamebox_agent_rakeback() returns hstore as $$
DECLARE
	hash hstore;
	rec record;
	param text:='';
BEGIN
	for rec in
		select a.user_id,a.rakeback_id from user_agent_rakeback a,sys_user u where a.user_id=u.id and u.user_type='22'
    loop
			param=param||rec.user_id||'=>'||rec.rakeback_id||',';
	end loop;
	if length(param)>0 THEN
		param=substring(param,1,length(param)-1);
	end IF;
	--raise info '结果:%',param;
	select param::hstore into hash;
	--测试引用值.
  --raise info '4:%',hash->'3';
	return hash;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_collect_site_infor(
	hostinfo text,
	site_id int
) returns json as $$
declare
	rec record;
BEGIN
	SELECT into rec * FROM
	dblink (
		hostinfo,
		'SELECT * from v_sys_site_info WHERE siteid='||site_id||''
	) AS s (
		--站点ID
		siteid 		int4,
		--站点名称
		sitename 	VARCHAR,
		--站长ID
		masterid 	int4,
		--站长名称
		mastername 	VARCHAR,
		--用户类型
		usertype 	VARCHAR,
		subsyscode 	VARCHAR,
		--运营商ID
		operationid int4,
		--运营商名称
		operationname 		VARCHAR,
		operationusertype 	VARCHAR,
		operationsubsyscode VARCHAR
	);

	IF FOUND THEN
		return row_to_json(rec);
	ELSE
	  return (SELECT '{""siteid"": -1}'::json);
	END IF;
END
$$ language plpgsql;",V1.0.1.0041__C_gamebox_operations_statement.sql
"create or replace function gamebox_collect_site_infor(
  hostinfo   text,
  site_id   int
) returns json as $$
declare
  rec record;
BEGIN
/*版本更新说明
  版本   时间        作者     内容
--v1.00  2015/01/01  Lins     创建此函数: 经营报表-收集站点相关信
--v1.10  2017/07/01  Leisure  修改DBLINK的连接方式
*/
  --v1.10  2017/07/01  Leisure
  perform dblink_connect_u('mainsite', hostinfo);

  SELECT into rec * FROM
  dblink (
    'mainsite',  -- hostinfo, --v1.01  2017/07/01  Leisure
    'SELECT * from v_sys_site_info WHERE siteid='||site_id||''
  ) AS s (
    siteid     int4,    --站点ID
    sitename   VARCHAR,    --站点名称
    masterid   int4,    --站长ID
    mastername   VARCHAR,    --站长名称
    usertype   VARCHAR,    --用户类型
    subsyscode   VARCHAR,
    operationid int4,    --运营商ID
    operationname     VARCHAR,    --运营商名称
    operationusertype   VARCHAR,
    operationsubsyscode VARCHAR
  );

  perform dblink_disconnect('mainsite');

  IF FOUND THEN
    return row_to_json(rec);
  ELSE
    return (SELECT '{""siteid"": -1}'::json);
  END IF;
END
$$ language plpgsql;",6_gamebox_operations_statement.sql
"create or replace function gamebox_collect_site_infor(hostinfo text,site_id int) returns json as $$
declare
	rec record;
BEGIN
	SELECT into rec * FROM
	dblink (
		hostinfo,
		'select * from v_sys_site_info where siteid='||site_id||''
	) AS s (
		--站点ID
		siteid int4,
		--站点名称
		sitename VARCHAR,
		--站长ID
		masterid int4,
		--站长名称
		mastername VARCHAR,
		--用户类型
		usertype VARCHAR,
		subsyscode VARCHAR,
		--运营商ID
		operationid int4,
		--运营商名称
		operationname VARCHAR,
		operationusertype VARCHAR,
		operationsubsyscode VARCHAR
	);

	IF FOUND THEN
		return row_to_json(rec);
	ELSE
	  return (select '{""siteid"": -1}'::json);
	END IF;
END
$$ language plpgsql;",V1.0.1.0231__C_gamebox_operations_statement.sql
"create or replace function gamebox_collect_site_infor(hostinfo text,site_id int) returns json as $$
declare
	rec record;
BEGIN
	SELECT into rec * FROM
	dblink (
		hostinfo,
		'select * from v_sys_site_info where siteid='||site_id||''
	) AS s (
		--站点ID
		siteid int4,
		--站点名称
		sitename VARCHAR,
		--站长ID
		masterid int4,
		--站长名称
		mastername VARCHAR,
		--用户类型
		usertype VARCHAR,
		subsyscode VARCHAR,
		--运营商ID
		operationid int4,
		--运营商名称
		operationname VARCHAR,
		operationusertype VARCHAR,
		operationsubsyscode VARCHAR
	);

	IF FOUND THEN
		return row_to_json(rec);
	ELSE
	  return (select '{""siteid"": -1}'::json);
	END IF;
END
$$ language plpgsql;",V1.0.1.0272__E_gamebox_operations_statement.sql
"create or replace function gamebox_collect_site_infor(hostinfo text,site_id int) returns json as $$
declare
	rec record;
BEGIN
	SELECT into rec * FROM
	dblink (
		hostinfo,
		'select * from v_sys_site_info where siteid='||site_id||''
	) AS s (
		--站点ID
		siteid int4,
		--站点名称
		sitename VARCHAR,
		--站长ID
		masterid int4,
		--站长名称
		mastername VARCHAR,
		--用户类型
		usertype VARCHAR,
		subsyscode VARCHAR,
		--运营商ID
		operationid int4,
		--运营商名称
		operationname VARCHAR,
		operationusertype VARCHAR,
		operationsubsyscode VARCHAR
	);

	IF FOUND THEN
		return row_to_json(rec);
	ELSE
	  return (select '{""siteid"": -1}'::json);
	END IF;
END
$$ language plpgsql;",V1.0.1.0297__E_gamebox_operations_statement.sql
"create or replace function gamebox_current_site() returns int as $$
DECLARE
	id int;
BEGIN
	select site_id from sys_user where site_id is not null LIMIT 1 INTO id;
	return id;
END;
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_expense_calculate(
	cost_map hstore,
	sys_map hstore,
	category TEXT
) returns hstore as $$

DECLARE
  	keys 		text[];
	mhash 		hstore;
	keyname 	text:='';
	val 		text:='';
	tmp 		TEXT:='';

	-- 返水
	backwater 				float:=0.00;
	backwater_apportion 	float:=0.00;

	-- 优惠 = (优惠 + 推荐 + 手动存入优惠)
	favourable 				float:=0.00;
  	recommend 				float:=0.00;
  	artificial_depositfavorable		float:=0.00;	-- 手动存入优惠
	favourable_apportion 	float:=0.00;

	-- 手续费
  	refund_fee 				float:=0.00;
	refund_fee_apportion 	float:=0.00;

	-- 返佣
  	rebate 					float:=0.00;
	rebate_apportion 		float:=0.00;

	-- 总分摊费用
	apportion 				FLOAT:=0.00;

	retio 					FLOAT:=0.00;
	retio2 					FLOAT:=0.00;

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';

BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	 IF cost_map is null THEN
		RETURN cost_map;
	 END IF;
	 keys = akeys(cost_map);
	 FOR i in 1..array_length(keys, 1)
	 LOOP
		keyname = keys[i];
		val = cost_map->keyname;
		tmp = val;
		--转换成hstore数据格式:key1=>value1, key2=>value2
		tmp = replace(tmp, rs,',');
	    tmp = replace(tmp, cs,'=>');
		SELECT tmp into mhash;

		backwater = 0.00;--返水
		IF exist(mhash, 'backwater') THEN
			backwater = (mhash->'backwater')::float;
		END IF;

		favourable = 0.00;--优惠
		IF exist(mhash, 'favourable') THEN
			favourable = (mhash->'favourable')::float;
		END IF;

		refund_fee = 0.00;--返手续费
		IF exist(mhash, 'refund_fee') THEN
			refund_fee = (mhash->'refund_fee')::float;
		END IF;

		recommend = 0.00;--推荐
		IF exist(mhash, 'recommend') THEN
			recommend = (mhash->'recommend')::float;
		END IF;

		artificial_depositfavorable = 0.00; -- 手动存入优惠
		IF exist(mhash, 'artificial_depositfavorable') THEN
			artificial_depositfavorable = (mhash->'artificial_depositfavorable')::float;
		END IF;

		rebate = 0.00;
		IF exist(mhash, 'rebate') THEN
			rebate=(mhash->'rebate')::float;
		END IF;

		backwater 	= COALESCE(backwater, 0);
		favourable 	= COALESCE(favourable, 0);
		recommend 	= COALESCE(recommend, 0);
		artificial_depositfavorable = COALESCE(artificial_depositfavorable, 0);
		refund_fee 	= COALESCE(refund_fee, 0);
		rebate 		= COALESCE(rebate, 0);

		--计算各种优惠.
		/*
			计算各种优惠.
			1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
			2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
			3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
		*/
		--优惠与推荐分摊
		retio2 = 0.00;
		retio = 0.00;

	  	IF isexists(sys_map, 'agent.preferential.percent') THEN
			retio2 = (sys_map->'agent.preferential.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.preferential.percent') THEN
			retio = (sys_map->'topagent.preferential.percent')::float;
		END IF;

		IF category = 'OCCUPY' THEN
			retio = (1 - retio2 / 100) * retio / 100;
		ELSE
			retio = retio2 / 100;
		END IF;

		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio;

		--返水分摊
		retio2 = 0.00;
		retio = 0.00;

		IF isexists(sys_map, 'agent.rakeback.percent') THEN
			retio2=(sys_map->'agent.rakeback.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.rakeback.percent') THEN
		retio=(sys_map->'topagent.rakeback.percent')::float;
		END IF;

		IF category='OCCUPY' THEN
			retio=(1-retio2/100)*retio/100;
		ELSE
			retio = retio2/100;
		END IF;

		backwater_apportion = backwater*retio;

		--手续费优惠分摊
		retio2 = 0.00;
		retio = 0.00;

		IF isexists(sys_map, 'agent.poundage.percent') THEN
			retio2=(sys_map->'agent.poundage.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.poundage.percent') THEN
			retio=(sys_map->'topagent.poundage.percent')::float;
		END IF;

		IF category='OCCUPY' THEN
			retio=(1-retio2/100)*retio/100;
		ELSE
			retio = retio2/100;
		END IF;

		refund_fee_apportion = refund_fee*retio;

		--返佣分摊
		rebate_apportion = 0;
		retio = 0.00;

		IF isexists(sys_map, 'topagent.rebate.percent') THEN
			retio=(sys_map->'topagent.rebate.percent')::float;
			rebate_apportion = rebate*retio/100;
		END IF;

		apportion = favourable_apportion + backwater_apportion + refund_fee_apportion;

		val = val||rs||'apportion'||cs||apportion;
		val = val||rs||'rebate_apportion'||cs||rebate_apportion;
		val = val||rs||'favourable_apportion'||cs||favourable_apportion;
		val = val||rs||'backwater_apportion'||cs||backwater_apportion;
		val = val||rs||'refund_fee_apportion'||cs||refund_fee_apportion;
		cost_map = cost_map||(SELECT (keyname||'=>'||val)::hstore);
	 END LOOP;

   	RETURN cost_map;
END

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_expense_calculate(
	cost_map hstore,
	sys_map hstore,
	category TEXT
) returns hstore as $$

DECLARE
  	keys 		text[];
	mhash 		hstore;
	keyname 	text:='';
	val 		text:='';
	tmp 		TEXT:='';

	-- 返水
	backwater 				float:=0.00;
	backwater_apportion 	float:=0.00;

	-- 优惠 = (优惠 + 推荐 + 手动存入优惠)
	favourable 				float:=0.00;
  	recommend 				float:=0.00;
  	artificial_depositfavorable		float:=0.00;	-- 手动存入优惠
	favourable_apportion 	float:=0.00;

	-- 手续费
  	refund_fee 				float:=0.00;
	refund_fee_apportion 	float:=0.00;

	-- 返佣
  	rebate 					float:=0.00;
	rebate_apportion 		float:=0.00;

	-- 总分摊费用
	apportion 				FLOAT:=0.00;

	retio 					FLOAT:=0.00;
	retio2 					FLOAT:=0.00;

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';

BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	 IF cost_map is null THEN
		RETURN cost_map;
	 END IF;
	 keys = akeys(cost_map);
	 FOR i in 1..array_length(keys, 1)
	 LOOP
		keyname = keys[i];
		val = cost_map->keyname;
		tmp = val;
		--转换成hstore数据格式:key1=>value1, key2=>value2
		tmp = replace(tmp, rs,',');
	    tmp = replace(tmp, cs,'=>');
		SELECT tmp into mhash;

		backwater = 0.00;--返水
		IF exist(mhash, 'backwater') THEN
			backwater = (mhash->'backwater')::float;
		END IF;

		favourable = 0.00;--优惠
		IF exist(mhash, 'favourable') THEN
			favourable = (mhash->'favourable')::float;
		END IF;

		refund_fee = 0.00;--返手续费
		IF exist(mhash, 'refund_fee') THEN
			refund_fee = (mhash->'refund_fee')::float;
		END IF;

		recommend = 0.00;--推荐
		IF exist(mhash, 'recommend') THEN
			recommend = (mhash->'recommend')::float;
		END IF;

		artificial_depositfavorable = 0.00; -- 手动存入优惠
		IF exist(mhash, 'artificial_depositfavorable') THEN
			artificial_depositfavorable = (mhash->'artificial_depositfavorable')::float;
		END IF;

		rebate = 0.00;
		IF exist(mhash, 'rebate') THEN
			rebate=(mhash->'rebate')::float;
		END IF;

		backwater 	= COALESCE(backwater, 0);
		favourable 	= COALESCE(favourable, 0);
		recommend 	= COALESCE(recommend, 0);
		artificial_depositfavorable = COALESCE(artificial_depositfavorable, 0);
		refund_fee 	= COALESCE(refund_fee, 0);
		rebate 		= COALESCE(rebate, 0);

		--计算各种优惠.
		/*
			计算各种优惠.
			1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
			2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
			3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
		*/
		--优惠与推荐分摊
		retio2 = 0.00;
		retio = 0.00;

	  	IF isexists(sys_map, 'agent.preferential.percent') THEN
			retio2 = (sys_map->'agent.preferential.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.preferential.percent') THEN
			retio = (sys_map->'topagent.preferential.percent')::float;
		END IF;

		IF category = 'OCCUPY' THEN
			retio = (1 - retio2 / 100) * retio / 100;
		ELSE
			retio = retio2 / 100;
		END IF;

		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio;

		--返水分摊
		retio2 = 0.00;
		retio = 0.00;

		IF isexists(sys_map, 'agent.rakeback.percent') THEN
			retio2=(sys_map->'agent.rakeback.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.rakeback.percent') THEN
		retio=(sys_map->'topagent.rakeback.percent')::float;
		END IF;

		IF category='OCCUPY' THEN
			retio=(1-retio2/100)*retio/100;
		ELSE
			retio = retio2/100;
		END IF;

		backwater_apportion = backwater*retio;

		--手续费优惠分摊
		retio2 = 0.00;
		retio = 0.00;

		IF isexists(sys_map, 'agent.poundage.percent') THEN
			retio2=(sys_map->'agent.poundage.percent')::float;--代理分摊比例
		END IF;

		IF isexists(sys_map, 'topagent.poundage.percent') THEN
			retio=(sys_map->'topagent.poundage.percent')::float;
		END IF;

		IF category='OCCUPY' THEN
			retio=(1-retio2/100)*retio/100;
		ELSE
			retio = retio2/100;
		END IF;

		refund_fee_apportion = refund_fee*retio;

		--返佣分摊
		rebate_apportion = 0;
		retio = 0.00;

		IF isexists(sys_map, 'topagent.rebate.percent') THEN
			retio=(sys_map->'topagent.rebate.percent')::float;
			rebate_apportion = rebate*retio/100;
		END IF;

		apportion = favourable_apportion + backwater_apportion + refund_fee_apportion;

		val = val||rs||'apportion'||cs||apportion;
		val = val||rs||'rebate_apportion'||cs||rebate_apportion;
		val = val||rs||'favourable_apportion'||cs||favourable_apportion;
		val = val||rs||'backwater_apportion'||cs||backwater_apportion;
		val = val||rs||'refund_fee_apportion'||cs||refund_fee_apportion;
		cost_map = cost_map||(SELECT (keyname||'=>'||val)::hstore);
	 END LOOP;

   	RETURN cost_map;
END

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_expense_calculate(
cost_map hstore
,sys_map hstore
,category TEXT
) returns hstore as $$
DECLARE
  keys text[];
	mhash hstore;
	keyname text:='';
	val text:='';
	tmp TEXT:='';
	--返水
  backwater float:=0.00;
  backwater_apportion float:=0.00;
	--优惠
	favourable float:=0.00;
	favourable_apportion float:=0.00;
	--手续费
  refund_fee float:=0.00;
	refund_fee_apportion float:=0.00;
	--推荐
  recommend float:=0.00;
	recommend_apportion float:=0.00;
	--返佣
  rebate float:=0.00;
	rebate_apportion float:=0.00;
	--分摊费用
	apportion FLOAT:=0.00;
	retio FLOAT:=0.00;
	retio2 FLOAT:=0.00;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';

		 IF cost_map is null THEN
				RETURN cost_map;
		 END IF;
		 keys=akeys(cost_map);
		 FOR i in 1..array_length(keys, 1) LOOP
				keyname=keys[i];
				val=cost_map->keyname;
				tmp=val;
				--转换成hstore数据格式:key1=>value1,key2=>value2
				tmp=replace(tmp,rs,',');
		    tmp=replace(tmp,cs,'=>');
				select tmp into mhash;
        --val=backwater=>20,favourable=>6,refund_fee=>18,recommend=>14,rebate=>-29.5
				backwater=0.00;--返水
				IF exist(mhash, 'backwater') THEN
					backwater=(mhash->'backwater')::float;
				END IF;
				favourable=0.00;--优惠
				IF exist(mhash, 'favourable') THEN
					favourable=(mhash->'favourable')::float;
				END IF;
				refund_fee=0.00;--返手续费
				IF exist(mhash, 'refund_fee') THEN
					refund_fee=(mhash->'refund_fee')::float;
				END IF;
				recommend=0.00;--推荐
				IF exist(mhash, 'recommend') THEN
					recommend=(mhash->'recommend')::float;
				END IF;

				rebate=0.00;
				IF exist(mhash, 'rebate') THEN
					rebate=(mhash->'rebate')::float;
				END IF;

				backwater=COALESCE(backwater,0);
				favourable=COALESCE(favourable,0);
				refund_fee=COALESCE(refund_fee,0);
				recommend=COALESCE(recommend,0);
				rebate=COALESCE(rebate,0);

			  --计算各种优惠.
				/*
				计算各种优惠.
				1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
				2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
				3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
			  */
			  --优惠与推荐分摊
				retio2=0.00;
				retio=0.00;
			  IF isexists(sys_map, 'agent.preferential.percent') THEN
					retio2=(sys_map->'agent.preferential.percent')::float;--代理分摊比例
				END IF;
				IF isexists(sys_map, 'topagent.preferential.percent') THEN
					retio=(sys_map->'topagent.preferential.percent')::float;
				END IF;
				IF category='OCCUPY' THEN
					retio=(1-retio2/100)*retio/100;
				ELSE
					retio=retio2/100;
				END IF;
				favourable_apportion=(favourable+recommend)*retio;

				--返水分摊
				retio2=0.00;
				retio=0.00;
			  IF isexists(sys_map, 'agent.rakeback.percent') THEN
					retio2=(sys_map->'agent.rakeback.percent')::float;--代理分摊比例
				END IF;
				IF isexists(sys_map, 'topagent.rakeback.percent') THEN
					retio=(sys_map->'topagent.rakeback.percent')::float;
				END IF;
				IF category='OCCUPY' THEN
					retio=(1-retio2/100)*retio/100;
				ELSE
					retio=retio2/100;
				END IF;
				backwater_apportion=backwater*retio;

				--手续费优惠分摊
				retio2=0.00;
				retio=0.00;
			  IF isexists(sys_map, 'agent.poundage.percent') THEN
					retio2=(sys_map->'agent.poundage.percent')::float;--代理分摊比例
				END IF;
				IF isexists(sys_map, 'topagent.poundage.percent') THEN
					retio=(sys_map->'topagent.poundage.percent')::float;
				END IF;
				IF category='OCCUPY' THEN
					retio=(1-retio2/100)*retio/100;
				ELSE
					retio=retio2/100;
				END IF;
				refund_fee_apportion=refund_fee*retio;

				--返佣分摊
				rebate_apportion=0;
				retio=0.00;
				IF isexists(sys_map, 'topagent.rebate.percent') THEN
					retio=(sys_map->'topagent.rebate.percent')::float;
					rebate_apportion=rebate*retio/100;
				END IF;

				--occupy=occupy-rebate-favourable-backwater-refund_fee;
				apportion=favourable_apportion+backwater_apportion+refund_fee_apportion;

				val=val||rs||'apportion'||cs||apportion;
				val=val||rs||'rebate_apportion'||cs||rebate_apportion;
				val=val||rs||'favourable_apportion'||cs||favourable_apportion;
				val=val||rs||'backwater_apportion'||cs||backwater_apportion;
				val=val||rs||'refund_fee_apportion'||cs||refund_fee_apportion;
				cost_map=cost_map||(SELECT (keyname||'=>'||val)::hstore);
		 END LOOP;
   RETURN cost_map;
END
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_expense_gather(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		 SELECT fund_type,
				SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater', 'favourable', 'recommend', 'refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time <= end_time
		   GROUP BY fund_type
		   UNION ALL
		  SELECT fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time <= end_time
		   GROUP BY fund_type, transaction_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
  		  FROM rakeback_api_base rab
 		 WHERE rab.rakeback_time >= start_time
   		   AND rab.rakeback_time <= end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_expense_gather(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	row_split 	text,
	col_split 	text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;

BEGIN
	FOR rec IN
		SELECT pt.*, su.owner_id FROM (
		  SELECT player_id,
				 fund_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater', 'favourable', 'recommend', 'refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time <= end_time
		   GROUP BY player_id, fund_type
		   UNION ALL
		  SELECT player_id,
				 fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time <= end_time
		   GROUP BY player_id, fund_type, transaction_type
		) pt
		LEFT JOIN sys_user su ON pt.player_id = su.""id""
		WHERE su.user_type = '24'
	 LOOP
		user_id = rec.player_id::text;
		money 	= rec.transaction_money;
		IF isexists(hash, user_id) THEN
			param = hash->user_id;
			param = param||row_split||rec.fund_type||col_split||money::text;
		ELSE
			param = rec.fund_type||col_split||money::text;
		END IF;

		IF position('agent_id' IN param) = 0  THEN
			param = param||row_split||'agent_id'||col_split||rec.owner_id::TEXT;
		END IF;

		SELECT user_id||'=>'||param into mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		SELECT fund_type,
			   sum(transaction_money) as transaction_money
		  FROM player_transaction
		 WHERE fund_type in ('backwater', 'favourable', 'recommend', 'refund_fee')
		   AND status = 'success'
		   AND create_time >= start_time
		   AND create_time < end_time
		 GROUP BY fund_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT count(DISTINCT o.player_id) 					as player_num,
			   sum(COALESCE(o.profit_amount,0.00)) 			as profit_amount,
  		  	   sum(COALESCE(o.effective_trade_amount,0.00)) as effective_trade_amount
  		  FROM player_game_order o
         WHERE o.create_time >= start_time
		   AND o.create_time < end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		SELECT fund_type,
			   sum(transaction_money) as transaction_money
		  FROM player_transaction
		 WHERE fund_type in ('backwater', 'favourable', 'recommend', 'refund_fee')
		   AND status = 'success'
		   AND create_time >= start_time
		   AND create_time < end_time
		 GROUP BY fund_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT count(DISTINCT o.player_id) 					as player_num,
			   sum(COALESCE(o.profit_amount,0.00)) 			as profit_amount,
  		  	   sum(COALESCE(o.effective_trade_amount,0.00)) as effective_trade_amount
  		  FROM player_game_order o
         WHERE o.create_time >= start_time
		   AND o.create_time < end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	category TEXT
) returns hstore as $$

DECLARE
	rec 	record;
	hash 	hstore;
	mhash 	hstore;
	param 	text:='';
	user_id text:='';
	money 	float:=0.00;
	name 	TEXT:='';
	cols 	TEXT;
  	tables 	TEXT;
	grups 	TEXT;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	IF category = 'TOP' THEN
		cols 	= 'u.topagent_id as id, u.topagent_name as name, ';
		tables	= ' player_transaction p, v_sys_user_tier u ';
		grups	= 'u.topagent_id, u.topagent_name ';
	ELSEIF category ='AGENT' THEN
		cols 	= 'u.agent_id as id, u.agent_name as name, ';
		tables 	= ' player_transaction p, v_sys_user_tier u ';
		grups 	= 'u.agent_id, u.agent_name ';
	ELSE
		cols 	= 'p.player_id as id, u.username as name, ';
		tables 	= ' player_transaction p, v_sys_user_tier u';
		grups 	= 'p.player_id, u.username ';
	END IF;
	FOR rec IN EXECUTE
		' SELECT '||cols||'
			 	 p.fund_type, SUM(p.transaction_money) as transaction_money
			FROM '||tables||'
		   WHERE p.fund_type IN (''backwater'', ''favourable'', ''recommend'', ''refund_fee'', ''artificial_deposit'',
		    	''company_deposit'', ''online_deposit'', ''artificial_withdraw'', ''player_withdraw'')
			 AND p.status = ''success''
		 	 AND p.create_time >= $1
		 	 AND p.create_time < $2
		   GROUP BY '||grups||', p.fund_type
		   UNION ALL
		  SELECT '||cols||'
				 p.fund_type||p.transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM '||tables||'
		   WHERE fund_type = ''artificial_deposit''
		     AND transaction_type = ''favorable''
			 AND status = ''success''
		 	 AND create_time >= $1
		 	 AND create_time < $2
		   GROUP BY '||grups||', fund_type, transaction_type'
		USING start_time, end_time
	LOOP
		user_id = rec.id::text;
		money 	= rec.transaction_money;
		name 	= rec.name;

		IF isexists(hash,user_id) THEN
			param = hash->user_id;
			param = param||rs||rec.fund_type||cs||money::text;
		ELSE
			param = 'user_name'||cs||name||rs||rec.fund_type||cs||money::text;
		END IF;

		SELECT user_id||'=>'||param INTO mhash;

		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	category TEXT
) returns hstore as $$

DECLARE
	rec 	record;
	hash 	hstore;
	mhash 	hstore;
	param 	text:='';
	user_id text:='';
	money 	float:=0.00;
	name 	TEXT:='';
	cols 	TEXT;
  	tables 	TEXT;
	grups 	TEXT;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	IF category = 'TOP' THEN
		cols 	= 'u.topagent_id as id, u.topagent_name as name, ';
		tables	= ' player_transaction p, v_sys_user_tier u ';
		grups	= 'u.topagent_id, u.topagent_name ';
	ELSEIF category ='AGENT' THEN
		cols 	= 'u.agent_id as id, u.agent_name as name, ';
		tables 	= ' player_transaction p, v_sys_user_tier u ';
		grups 	= 'u.agent_id, u.agent_name ';
	ELSE
		cols 	= 'p.player_id as id, u.username as name, ';
		tables 	= ' player_transaction p, v_sys_user_tier u';
		grups 	= 'p.player_id, u.username ';
	END IF;
	FOR rec IN EXECUTE
		' SELECT '||cols||'
			 	 p.fund_type, SUM(p.transaction_money) as transaction_money
			FROM '||tables||'
		   WHERE p.fund_type IN (''backwater'', ''favourable'', ''recommend'', ''refund_fee'', ''artificial_deposit'',
		    	''company_deposit'', ''online_deposit'', ''artificial_withdraw'', ''player_withdraw'')
			 AND p.status = ''success''
		 	 AND p.create_time >= $1
		 	 AND p.create_time < $2
		   GROUP BY '||grups||', p.fund_type
		   UNION ALL
		  SELECT '||cols||'
				 p.fund_type||p.transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM '||tables||'
		   WHERE fund_type = ''artificial_deposit''
		     AND transaction_type = ''favorable''
			 AND status = ''success''
		 	 AND create_time >= $1
		 	 AND create_time < $2
		   GROUP BY '||grups||', fund_type, transaction_type'
		USING start_time, end_time
	LOOP
		user_id = rec.id::text;
		money 	= rec.transaction_money;
		name 	= rec.name;

		IF isexists(hash,user_id) THEN
			param = hash->user_id;
			param = param||rs||rec.fund_type||cs||money::text;
		ELSE
			param = 'user_name'||cs||name||rs||rec.fund_type||cs||money::text;
		END IF;

		SELECT user_id||'=>'||param INTO mhash;

		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	category TEXT
) returns hstore as $$

DECLARE
	rec 	record;
	hash 	hstore;
	mhash 	hstore;
	param 	text:='';
	user_id text:='';
	money 	float:=0.00;
	name 	TEXT:='';
	cols 	TEXT;
  	tables 	TEXT;
	grups 	TEXT;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	IF category = 'TOP' THEN
		cols 	= 'u.topagent_id as id,u.topagent_name as name, ';
		tables	= ' player_transaction p,v_sys_user_tier u ';
		grups	= 'u.topagent_id,u.topagent_name ';
	ELSEIF category ='AGENT' THEN
		cols 	= 'u.agent_id as id,u.agent_name as name, ';
		tables 	= ' player_transaction p,v_sys_user_tier u ';
		grups 	= 'u.agent_id,u.agent_name ';
	ELSE
		cols 	= 'p.player_id as id,u.username as name, ';
		tables 	= ' player_transaction p,v_sys_user_tier u';
		grups 	= 'p.player_id,u.username ';
	END IF;
	FOR rec IN EXECUTE
		'SELECT '||cols||' p.fund_type, sum(p.transaction_money) as transaction_money
		   FROM '||tables||'
		  WHERE p.fund_type in (''backwater'', ''favourable'', ''recommend'', ''refund_fee'')
		    AND p.status = ''success''
			AND p.create_time >= $1 and p.create_time < $2
		  GROUP BY '||grups||',p.fund_type'
		USING start_time,end_time
	LOOP
		user_id = rec.id::text;
		money 	= rec.transaction_money;
		name 	= rec.name;
		IF isexists(hash,user_id) THEN
			param = hash->user_id;
			param = param||rs||rec.fund_type||cs||money::text;
		ELSE
			param = 'user_name'||cs||name||rs||rec.fund_type||cs||money::text;
		END IF;
		SELECT user_id||'=>'||param INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_expense_gather(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	category TEXT
) returns hstore as $$

DECLARE
	rec 	record;
	hash 	hstore;
	mhash 	hstore;
	param 	text:='';
	user_id text:='';
	money 	float:=0.00;
	name 	TEXT:='';
	cols 	TEXT;
  	tables 	TEXT;
	grups 	TEXT;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	IF category = 'TOP' THEN
		cols 	= 'u.topagent_id as id,u.topagent_name as name, ';
		tables	= ' player_transaction p,v_sys_user_tier u ';
		grups	= 'u.topagent_id,u.topagent_name ';
	ELSEIF category ='AGENT' THEN
		cols 	= 'u.agent_id as id,u.agent_name as name, ';
		tables 	= ' player_transaction p,v_sys_user_tier u ';
		grups 	= 'u.agent_id,u.agent_name ';
	ELSE
		cols 	= 'p.player_id as id,u.username as name, ';
		tables 	= ' player_transaction p,v_sys_user_tier u';
		grups 	= 'p.player_id,u.username ';
	END IF;
	FOR rec IN EXECUTE
		'SELECT '||cols||' p.fund_type, sum(p.transaction_money) as transaction_money
		   FROM '||tables||'
		  WHERE p.fund_type in (''backwater'', ''favourable'', ''recommend'', ''refund_fee'')
		    AND p.status = ''success''
			AND p.create_time >= $1 and p.create_time < $2
		  GROUP BY '||grups||',p.fund_type'
		USING start_time,end_time
	LOOP
		user_id = rec.id::text;
		money 	= rec.transaction_money;
		name 	= rec.name;
		IF isexists(hash,user_id) THEN
			param = hash->user_id;
			param = param||rs||rec.fund_type||cs||money::text;
		ELSE
			param = 'user_name'||cs||name||rs||rec.fund_type||cs||money::text;
		END IF;
		SELECT user_id||'=>'||param INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time 	TIMESTAMP,
  end_time 	TIMESTAMP,
  row_split 	text,
  col_split 	text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;

BEGIN
	FOR rec IN
		  SELECT player_id,
				 fund_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id,fund_type
		   UNION ALL
		  SELECT player_id,
				 fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id, fund_type, transaction_type
	 LOOP
		user_id = rec.player_id::text;
		money 	= rec.transaction_money;
		IF isexists(hash, user_id) THEN
			param = hash->user_id;
			param = param||row_split||rec.fund_type||col_split||money::text;
		ELSE
			param = rec.fund_type||col_split||money::text;
		END IF;

		SELECT user_id||'=>'||param into mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
		-- raise info 'gamebox_expense_gather hash = %', hash;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time 	TIMESTAMP,
  end_time 	TIMESTAMP,
  row_split 	text,
  col_split 	text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;

BEGIN
	FOR rec IN
		  SELECT player_id,
				 fund_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id,fund_type
		   UNION ALL
		  SELECT player_id,
				 fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id, fund_type, transaction_type
	 LOOP
		user_id = rec.player_id::text;
		money 	= rec.transaction_money;
		IF isexists(hash, user_id) THEN
			param = hash->user_id;
			param = param||row_split||rec.fund_type||col_split||money::text;
		ELSE
			param = rec.fund_type||col_split||money::text;
		END IF;

		SELECT user_id||'=>'||param into mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
		-- raise info 'gamebox_expense_gather hash = %', hash;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time 	TIMESTAMP,
  end_time 	TIMESTAMP,
  row_split 	text,
  col_split 	text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;

BEGIN
	FOR rec IN
		  SELECT player_id,
				 fund_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id,fund_type
		   UNION ALL
		  SELECT player_id,
				 fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY player_id, fund_type, transaction_type
	 LOOP
		user_id = rec.player_id::text;
		money 	= rec.transaction_money;
		IF isexists(hash, user_id) THEN
			param = hash->user_id;
			param = param||row_split||rec.fund_type||col_split||money::text;
		ELSE
			param = rec.fund_type||col_split||money::text;
		END IF;

		SELECT user_id||'=>'||param into mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
		-- raise info 'gamebox_expense_gather hash = %', hash;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time TIMESTAMP,
  end_time TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		 SELECT fund_type,
				SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type
		   UNION ALL
		  SELECT fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type, transaction_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
  		  FROM rakeback_api_base rab
 		 WHERE rab.rakeback_time >= start_time
   		   AND rab.rakeback_time < end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time TIMESTAMP,
  end_time TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		 SELECT fund_type,
				SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type
		   UNION ALL
		  SELECT fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type, transaction_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
  		  FROM rakeback_api_base rab
 		 WHERE rab.rakeback_time >= start_time
   		   AND rab.rakeback_time < end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
  start_time TIMESTAMP,
  end_time TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	money 		float:=0.00;
	key_name 	TEXT;

BEGIN
	FOR rec IN
		 SELECT fund_type,
				SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type in ('backwater','favourable','recommend','refund_fee', 'artificial_deposit',
				'company_deposit', 'online_deposit', 'artificial_withdraw', 'player_withdraw')
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type
		   UNION ALL
		  SELECT fund_type||transaction_type,
				 SUM(transaction_money) 	as transaction_money
			FROM player_transaction
		   WHERE fund_type = 'artificial_deposit'
		     AND transaction_type = 'favorable'
			 AND status = 'success'
		 	 AND create_time >= start_time
		 	 AND create_time < end_time
		   GROUP BY fund_type, transaction_type
	 LOOP
		key_name = rec.fund_type;
		money = rec.transaction_money;
		SELECT key_name||'=>'||money INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;
	END LOOP;

	FOR rec IN
		SELECT COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
  		  FROM rakeback_api_base rab
 		 WHERE rab.rakeback_time >= start_time
   		   AND rab.rakeback_time < end_time
	 LOOP
		param = 'profit_amount=>'||rec.profit_amount;
		param = param||',effective_trade_amount=>'||rec.effective_trade_amount;
		param = param||',player_num=>'||rec.player_num;
		IF hash is null THEN
			SELECT param INTO hash;
		ELSE
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;

	return hash;
END

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
start_time TIMESTAMP
,end_time TIMESTAMP
) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	money float:=0.00;
	key_name TEXT;
BEGIN
		FOR rec IN
			select fund_type,sum(transaction_money) as transaction_money
			from player_transaction
			where fund_type in ('backwater','favourable','recommend','refund_fee')
			and status='success'
			and create_time>=start_time and create_time<end_time
			group by fund_type
		 LOOP
			key_name=rec.fund_type;
			money=rec.transaction_money;
			select key_name||'=>'||money into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;

		FOR rec IN
			SELECT
			count(DISTINCT o.player_id) as player_num,
			sum(COALESCE(o.profit_amount,0.00)) as profit_amount,
      sum(COALESCE(o.effective_trade_amount,0.00)) AS effective_trade_amount
      from player_game_order o
	    where o.create_time>=start_time
			and o.create_time<end_time
		 LOOP
				param='profit_amount=>'||rec.profit_amount;
				param=param||',effective_trade_amount=>'||rec.effective_trade_amount;
				param=param||',player_num=>'||rec.player_num;
			IF hash is null THEN
				SELECT param INTO hash;
			ELSE
				hash=(SELECT param::hstore)||hash;
			END IF;
		END LOOP;

	return hash;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
start_time TIMESTAMP
,end_time TIMESTAMP
,category TEXT
) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	user_id text:='';
	money float:=0.00;
	name TEXT:='';
	cols TEXT;
  tables TEXT;
	grups TEXT;

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';

	IF category='TOP' THEN
			cols='u.topagent_id as id,u.topagent_name as name, ';
			tables=' player_transaction p,v_sys_user_tier u ';
			grups='u.topagent_id,u.topagent_name ';
	ELSEIF category='AGENT' THEN
			cols='u.agent_id as id,u.agent_name as name, ';
			tables=' player_transaction p,v_sys_user_tier u ';
			grups='u.agent_id,u.agent_name ';
	ELSE
			cols='p.player_id as id,u.username as name, ';
			tables=' player_transaction p,v_sys_user_tier u';
			grups='p.player_id,u.username ';
	END IF;
	FOR rec IN EXECUTE
			'SELECT '||cols||' p.fund_type,sum(p.transaction_money) as transaction_money
			from '||tables||'
			where p.fund_type in (''backwater'',''favourable'',''recommend'',''refund_fee'')
			and p.status=''success''
			and p.create_time>=$1 and p.create_time<$2
			group by '||grups||',p.fund_type'
			USING start_time,end_time
	LOOP
			user_id=rec.id::text;
			money=rec.transaction_money;
			name=rec.name;
			IF isexists(hash,user_id) THEN
				param=hash->user_id;
				--param=param||'^&^'||rec.fund_type||'^'||money::text;
				param=param||rs||rec.fund_type||cs||money::text;
			ELSE
				param='user_name'||cs||name||rs||rec.fund_type||cs||money::text;
			END IF;
			select user_id||'=>'||param into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;
	return hash;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_expense_gather(
start_time TIMESTAMP,end_time TIMESTAMP
,row_split text,col_split text) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	user_id text:='';
	money float:=0.00;
BEGIN
		FOR rec IN
			select player_id,fund_type,sum(transaction_money) as transaction_money
			from player_transaction
			where fund_type in ('backwater','favourable','recommend','refund_fee')
			and status='success'
			and create_time>=start_time and create_time<end_time
			group by player_id,fund_type
		 LOOP
			user_id=rec.player_id::text;
			money=rec.transaction_money;
			IF isexists(hash,user_id) THEN
				param=hash->user_id;
				--param=param||'^&^'||rec.fund_type||'^'||money::text;
				param=param||row_split||rec.fund_type||col_split||money::text;
			ELSE
				param=rec.fund_type||col_split||money::text;
			END IF;
			select user_id||'=>'||param into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;
	return hash;
END
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_expense_map(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	sys_map hstore
) returns hstore as $$

DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map = (SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_expense_map(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	sys_map hstore
) returns hstore as $$

DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map = (SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_expense_map(
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  sys_map hstore
) returns hstore as $$

DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map = (SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_expense_map(
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  sys_map hstore
) returns hstore as $$

DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map = (SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_expense_map(
  start_time TIMESTAMP,
  end_time TIMESTAMP,
  sys_map hstore
) returns hstore as $$

DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map = (SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_expense_map(
start_time TIMESTAMP
,end_time TIMESTAMP
,sys_map hstore
) returns hstore as $$
DECLARE
	cost_map hstore;
	share_map hstore;
	sid INT;
BEGIN
	SELECT gamebox_expense_gather(start_time,end_time) INTO cost_map;
	SELECT gamebox_expense_share(cost_map,sys_map) INTO share_map;
	SELECT gamebox_current_site() INTO sid;
	share_map=(SELECT ('site_id=>'||sid)::hstore)||share_map;
	RETURN cost_map||share_map;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
	cost_map 	hstore,
	sys_map 	hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;

	backwater 				FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;

	favourable 				FLOAT:=0.00;
	recommend 				FLOAT:=0.00;
	artificial_depositfavorable		FLOAT:=0.00;	-- 手动存入优惠
	favourable_apportion 	FLOAT:=0.00;

	refund_fee 				FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;

	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	artificial_depositfavorable = 0.00;
	IF exist(cost_map, 'artificial_depositfavorable') THEN
		artificial_depositfavorable = (cost_map->'artificial_depositfavorable')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio = (sys_map->'agent.preferential.percent')::float;
		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio / 100;
	ELSE
		favourable_apportion = 0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio = (sys_map->'agent.rakeback.percent')::float;
		backwater_apportion = backwater * retio / 100;
	ELSE
		backwater_apportion = 0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio = (sys_map->'agent.poundage.percent')::float;
		refund_fee_apportion = refund_fee * retio / 100;
	ELSE
		refund_fee_apportion = 0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion + refund_fee_apportion + favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",3_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
	cost_map hstore,
	sys_map hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;
	backwater 	FLOAT:=0.00;
	favourable 	FLOAT:=0.00;
	refund_fee 	FLOAT:=0.00;
	recommend 	FLOAT:=0.00;

	favourable_apportion 	FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;
	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio=(sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion=(favourable+recommend)*retio/100;
	ELSE
		favourable_apportion=0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio=(sys_map->'agent.rakeback.percent')::float;
		--raise info '返水分摊比例:%',retio;
		backwater_apportion=backwater*retio/100;
	ELSE
		backwater_apportion=0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio=(sys_map->'agent.poundage.percent')::float;
 		--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion=refund_fee*retio/100;
	ELSE
		refund_fee_apportion=0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion+refund_fee_apportion+favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_expense_share(
	cost_map hstore,
	sys_map hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;
	backwater 	FLOAT:=0.00;
	favourable 	FLOAT:=0.00;
	refund_fee 	FLOAT:=0.00;
	recommend 	FLOAT:=0.00;

	favourable_apportion 	FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;
	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio=(sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion=(favourable+recommend)*retio/100;
	ELSE
		favourable_apportion=0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio=(sys_map->'agent.rakeback.percent')::float;
		--raise info '返水分摊比例:%',retio;
		backwater_apportion=backwater*retio/100;
	ELSE
		backwater_apportion=0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio=(sys_map->'agent.poundage.percent')::float;
 		--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion=refund_fee*retio/100;
	ELSE
		refund_fee_apportion=0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion+refund_fee_apportion+favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
  cost_map hstore,
  sys_map hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;

	backwater 				FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;

	favourable 				FLOAT:=0.00;
	recommend 				FLOAT:=0.00;
	artificial_depositfavorable		FLOAT:=0.00;	-- 手动存入优惠
	favourable_apportion 	FLOAT:=0.00;

	refund_fee 				FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;

	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	artificial_depositfavorable = 0.00;
	IF exist(cost_map, 'artificial_depositfavorable') THEN
		artificial_depositfavorable = (cost_map->'artificial_depositfavorable')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio = (sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio / 100;
	ELSE
		favourable_apportion = 0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio = (sys_map->'agent.rakeback.percent')::float;
		--raise info '返水分摊比例:%',retio;
		backwater_apportion = backwater * retio / 100;
	ELSE
		backwater_apportion = 0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio = (sys_map->'agent.poundage.percent')::float;
 		--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion = refund_fee * retio / 100;
	ELSE
		refund_fee_apportion = 0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion + refund_fee_apportion + favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
  cost_map hstore,
  sys_map hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;

	backwater 				FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;

	favourable 				FLOAT:=0.00;
	recommend 				FLOAT:=0.00;
	artificial_depositfavorable		FLOAT:=0.00;	-- 手动存入优惠
	favourable_apportion 	FLOAT:=0.00;

	refund_fee 				FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;

	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	artificial_depositfavorable = 0.00;
	IF exist(cost_map, 'artificial_depositfavorable') THEN
		artificial_depositfavorable = (cost_map->'artificial_depositfavorable')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio = (sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio / 100;
	ELSE
		favourable_apportion = 0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio = (sys_map->'agent.rakeback.percent')::float;
		--raise info '返水分摊比例:%',retio;
		backwater_apportion = backwater * retio / 100;
	ELSE
		backwater_apportion = 0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio = (sys_map->'agent.poundage.percent')::float;
 		--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion = refund_fee * retio / 100;
	ELSE
		refund_fee_apportion = 0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion + refund_fee_apportion + favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
  cost_map hstore,
  sys_map hstore
) returns hstore as $$

DECLARE
	hash 		hstore;
	retio 		FLOAT:=0.00;

	backwater 				FLOAT:=0.00;
	backwater_apportion 	FLOAT:=0.00;

	favourable 				FLOAT:=0.00;
	recommend 				FLOAT:=0.00;
	artificial_depositfavorable		FLOAT:=0.00;	-- 手动存入优惠
	favourable_apportion 	FLOAT:=0.00;

	refund_fee 				FLOAT:=0.00;
	refund_fee_apportion 	FLOAT:=0.00;

	apportion 				FLOAT:=0.00;
BEGIN
	backwater = 0.00;
	IF exist(cost_map, 'backwater') THEN
		backwater = (cost_map->'backwater')::float;
	END IF;

	favourable = 0.00;
	IF exist(cost_map, 'favourable') THEN
		favourable = (cost_map->'favourable')::float;
	END IF;

	refund_fee = 0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee = (cost_map->'refund_fee')::float;
	END IF;

	recommend = 0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend = (cost_map->'recommend')::float;
	END IF;

	artificial_depositfavorable = 0.00;
	IF exist(cost_map, 'artificial_depositfavorable') THEN
		artificial_depositfavorable = (cost_map->'artificial_depositfavorable')::float;
	END IF;

	/*
		计算各种优惠.
		1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
		2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
		3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
	*/
 	--优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio = (sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion = (favourable + recommend + artificial_depositfavorable) * retio / 100;
	ELSE
		favourable_apportion = 0;
	END IF;

 	--返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio = (sys_map->'agent.rakeback.percent')::float;
		--raise info '返水分摊比例:%',retio;
		backwater_apportion = backwater * retio / 100;
	ELSE
		backwater_apportion = 0;
	END IF;

	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio = (sys_map->'agent.poundage.percent')::float;
 		--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion = refund_fee * retio / 100;
	ELSE
		refund_fee_apportion = 0;
	END IF;

	--分摊总费用
	apportion=backwater_apportion + refund_fee_apportion + favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_expense_share(
cost_map hstore
,sys_map hstore
) returns hstore as $$
DECLARE
	hash hstore;
	retio FLOAT:=0.00;
	backwater FLOAT:=0.00;
	favourable FLOAT:=0.00;
	refund_fee FLOAT:=0.00;
	recommend FLOAT:=0.00;
	favourable_apportion FLOAT:=0.00;

	backwater_apportion FLOAT:=0.00;
	refund_fee_apportion FLOAT:=0.00;
	apportion FLOAT:=0.00;
BEGIN
	backwater=0.00;
	IF exist(cost_map, 'backwater') THEN
	backwater=(cost_map->'backwater')::float;
	END IF;

	favourable=0.00;
	IF exist(cost_map, 'favourable') THEN
	favourable=(cost_map->'favourable')::float;
	END IF;
	refund_fee=0.00;
	IF exist(cost_map, 'refund_fee') THEN
		refund_fee=(cost_map->'refund_fee')::float;
	END IF;
	recommend=0.00;
	IF exist(cost_map, 'recommend') THEN
		recommend=(cost_map->'recommend')::float;
	END IF;

 /*
 	计算各种优惠.
 	1、返水承担费用=赠送给体系下玩家的返水 * 代理承担比例；
 	2、优惠承担费用=赠送给体系下玩家的优惠 * 代理承担比例；
 	3、返还手续费承担费用=返还给体系下玩家的手续费 * 代理承担比例；
 */
 --优惠与推荐分摊
	IF isexists(sys_map, 'agent.preferential.percent') THEN
		retio=(sys_map->'agent.preferential.percent')::float;
		--raise info '优惠与推荐分摊比例:%',retio;
		favourable_apportion=(favourable+recommend)*retio/100;
		--recommend_apportion=(recommend)*retio/100;
	ELSE
		favourable_apportion=0;
		--recommend_apportion=0;
	END IF;
 --返水分摊
	IF isexists(sys_map, 'agent.rakeback.percent') THEN
		retio=(sys_map->'agent.rakeback.percent')::float;
	--raise info '返水分摊比例:%',retio;
		backwater_apportion=backwater*retio/100;
	ELSE
		backwater_apportion=0;
	END IF;
	--手续费分摊
	IF isexists(sys_map, 'agent.poundage.percent') THEN
		retio=(sys_map->'agent.poundage.percent')::float;
 	--raise info '手续费优惠分摊比例:%',retio;
		refund_fee_apportion=refund_fee*retio/100;
	ELSE
		refund_fee_apportion=0;
	END IF;
	--分摊总费用
	apportion=backwater_apportion+refund_fee_apportion+favourable_apportion;
	SELECT 'apportion=>'||apportion INTO hash;
	return hash;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_generate_order_no(
trans_type TEXT
,site_code TEXT
,order_type TEXT
) returns TEXT as $$
DECLARE
	currentDate VARCHAR := (SELECT to_char(CURRENT_DATE, 'yyMMdd'));
	nextSeqNum	VARCHAR := '';
BEGIN
	site_code=lpad(site_code,4,'0');
	IF trans_type='B' THEN
		IF order_type = '01' THEN		-- 01-游戏API与总控的结算
			nextSeqNum := lpad((SELECT nextval('settlement_id_api_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '02' THEN	-- 02-总控与运营商的结算
			nextSeqNum := lpad((SELECT nextval('settlement_id_boss_seq'))::VARCHAR , 7, '0');
		ELSEIF order_type = '03' THEN	-- 03-运营商与站长的结算
			nextSeqNum := lpad((SELECT nextval('settlement_id_company_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '04' THEN	-- 04-站长与总代的结算
			nextSeqNum := lpad((SELECT nextval('settlement_id_generalagent_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '05' THEN	-- 05-站长与代理的结算
			nextSeqNum := lpad((SELECT nextval('settlement_id_agent_seq'))::VARCHAR, 7, '0');
		END IF;
	ELSEIF trans_type='T' THEN
		IF order_type = '01' THEN		-- 01-充值
			nextSeqNum := lpad((SELECT nextval('order_id_recharge_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '02' THEN	-- 02-优惠
			nextSeqNum := lpad((SELECT nextval('order_id_discount_seq'))::VARCHAR , 7, '0');
		ELSEIF order_type = '03' THEN	-- 03-游戏API
			nextSeqNum := lpad((SELECT nextval('order_id_gameapi_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '04' THEN	-- 04-返水
			nextSeqNum := lpad((SELECT nextval('order_id_backwater_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '05' THEN	-- 05-返佣
			nextSeqNum := lpad((SELECT nextval('order_id_rebate_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '06' THEN	-- 06-玩家取款
			nextSeqNum := lpad((SELECT nextval('order_id_withdraw_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '07' THEN	-- 07-代理提现
			nextSeqNum := lpad((SELECT nextval('order_id_agent_withdraw_seq'))::VARCHAR, 7, '0');
		ELSEIF order_type = '08' THEN	-- 08-转账
			nextSeqNum := lpad((SELECT nextval('order_id_transfers_seq'))::VARCHAR, 7, '0');
		END IF;
	END IF;
	RETURN trans_type||currentDate||site_code||order_type||nextSeqNum;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_generate_order_no(
trans_type TEXT
,site_code TEXT
,order_type TEXT
,url TEXT
) returns TEXT as $$
DECLARE
	order_no TEXT:='';
BEGIN
	SELECT INTO order_no seq FROM dblink(url,'select gamebox_generate_order_no(
  '''||trans_type||''','''||site_code||''' ,'''||order_type||''')') as p(seq TEXT);
	RETURN order_no;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_generate_order_no(
trans_type TEXT
,site_code TEXT
,order_type TEXT
,url TEXT
) returns TEXT as $$
DECLARE
	order_no TEXT:='';
BEGIN
	SELECT INTO order_no seq FROM dblink(url,'select gamebox_generate_order_no(
  '''||trans_type||''','''||site_code||''' ,'''||order_type||''')') as p(seq TEXT);
	RETURN order_no;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_occupy(
	name 		text,
	start_time 	text,
	end_time 	text,
	url 		text
) returns void as $$

DECLARE
	rec 					record;
	sys_map 				hstore;	--系统设置各种承担比例.
  	occupy_map 				hstore;	--各API的返佣设置
	operation_occupy_map 	hstore;	--运营商各API占成比例.
	rebate_grads_map 		hstore;	--返佣梯度设置.
	agent_map 				hstore;	--代理默认梯度.
	agent_check_map 		hstore;	--代理满足的梯度.
	cost_map 				hstore;	--费用分摊
	rakeback_map 			hstore;	--玩家API返水.
	numhash 				hstore;	--存储每个总代的玩家数.
	mhash 					hstore;	--临时
	occupy_value 			FLOAT;	--返佣值

	keyId 	int;
	tmp 	int;
	a1 		text;
	a2 		text;
	a3 		text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;

	pending_lssuing 	text:='pending_lssuing';
	pending_pay 		text:='pending_pay';
	row_split_char 		text:='^&^';	--分隔符
	col_split_char 		text:='^';

	-- vname 				text:='v_site_game';
	sid 				INT;--站点ID.
	bill_id 			INT;

	is_max 				BOOLEAN:=true;
	key_type 			int:=4;
	category 			TEXT:='AGENT';

	rakebackhash		hstore; -- 玩家返水
	rebatehash			hstore; -- 玩家返佣
BEGIN
	stTime = start_time::TIMESTAMP;
	edTime = end_time::TIMESTAMP;

	raise info '统计( % )的占成, 时间( %-% )', name, start_time, end_time;

	raise info '占成.玩家API返水';
	SELECT gamebox_rakeback_map(stTime, edTime, url, 'API') INTO rakeback_map;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() into rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() into agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map, agent_map, stTime, edTime) into agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  	SELECT gamebox_occupy_api_set() into occupy_map;

  	raise info '占成.总表新增';
	SELECT gamebox_occupy_bill(name, stTime, edTime, bill_id, 'I') into bill_id;
	raise info 'occupy_bill.键值:%', bill_id;

  	raise info '总代.玩家API贡献度';
	perform gamebox_occupy_api(bill_id, stTime, edTime, occupy_map, operation_occupy_map, rakeback_map, rebate_grads_map, agent_check_map);

	raise info '占成.各种分摊费用';
	SELECT gamebox_occupy_expense_gather(bill_id, stTime, edTime) into cost_map;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') into sys_map;

	raise info '各个玩家返水,从返水账单取值';
	SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;

	SELECT gamebox_occupy_rebate_map(stTime, edTime) INTO rebatehash;

  	raise info '占成.玩家贡献度.cost_map = %, sys_map = %, rakebackhash = %, rebatehash = %', cost_map, sys_map, rakebackhash, rebatehash;
	perform gamebox_occupy_player(bill_id, cost_map, sys_map, rakebackhash, rebatehash);

  	raise info '占成.代理贡献度.';
	perform gamebox_occupy_agent(bill_id);

	raise info '占成.总代明细';
	perform gamebox_occupy_topagent(bill_id);

	raise info '占成.总表更新';
	perform gamebox_occupy_bill(name, stTime, edTime, bill_id, 'U');

	--异常处理
	-- PG_EXCEPTION_DETAIL
	-- WHEN OTHERS THEN
	-- GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT, a2 = PG_EXCEPTION_DETAIL, a3 = PG_EXCEPTION_HINT;
	-- raise EXCEPTION '异常:%, %, %', a1, a2, a3;
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy(
	name 		text,
	start_time 	text,
	end_time 	text,
	url 		text
) returns void as $$

DECLARE
	rec 					record;
	sys_map 				hstore;	--系统设置各种承担比例.
  	occupy_map 				hstore;	--各API的返佣设置
	operation_occupy_map 	hstore;	--运营商各API占成比例.
	rebate_grads_map 		hstore;	--返佣梯度设置.
	agent_map 				hstore;	--代理默认梯度.
	agent_check_map 		hstore;	--代理满足的梯度.
	cost_map 				hstore;	--费用分摊
	rakeback_map 			hstore;	--玩家API返水.
	numhash 				hstore;	--存储每个总代的玩家数.
	mhash 					hstore;	--临时
	occupy_value 			FLOAT;	--返佣值

	keyId 	int;
	tmp 	int;
	a1 		text;
	a2 		text;
	a3 		text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;

	pending_lssuing 	text:='pending_lssuing';
	pending_pay 		text:='pending_pay';
	row_split_char 		text:='^&^';	--分隔符
	col_split_char 		text:='^';

	-- vname 				text:='v_site_game';
	sid 				INT;--站点ID.
	bill_id 			INT;

	is_max 				BOOLEAN:=true;
	key_type 			int:=4;
	category 			TEXT:='AGENT';

	rakebackhash		hstore; -- 玩家返水
	rebatehash			hstore; -- 玩家返佣
BEGIN
	stTime = start_time::TIMESTAMP;
	edTime = end_time::TIMESTAMP;

	raise info '统计( % )的占成, 时间( %-% )', name, start_time, end_time;

	raise info '占成.玩家API返水';
	SELECT gamebox_rakeback_map(stTime, edTime, url, 'API') INTO rakeback_map;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() into rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() into agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map, agent_map, stTime, edTime) into agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  	SELECT gamebox_occupy_api_set() into occupy_map;

  	raise info '占成.总表新增';
	SELECT gamebox_occupy_bill(name, stTime, edTime, bill_id, 'I') into bill_id;
	raise info 'occupy_bill.键值:%', bill_id;

  	raise info '总代.玩家API贡献度';
	perform gamebox_occupy_api(bill_id, stTime, edTime, occupy_map, operation_occupy_map, rakeback_map, rebate_grads_map, agent_check_map);

	raise info '占成.各种分摊费用';
	SELECT gamebox_occupy_expense_gather(bill_id, stTime, edTime) into cost_map;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') into sys_map;

	raise info '各个玩家返水,从返水账单取值';
	SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;

	SELECT gamebox_occupy_rebate_map(stTime, edTime) INTO rebatehash;

  	raise info '占成.玩家贡献度.cost_map = %, sys_map = %, rakebackhash = %, rebatehash = %', cost_map, sys_map, rakebackhash, rebatehash;
	perform gamebox_occupy_player(bill_id, cost_map, sys_map, rakebackhash, rebatehash);

  	raise info '占成.代理贡献度.';
	perform gamebox_occupy_agent(bill_id);

	raise info '占成.总代明细';
	perform gamebox_occupy_topagent(bill_id);

	raise info '占成.总表更新';
	perform gamebox_occupy_bill(name, stTime, edTime, bill_id, 'U');

	--异常处理
	-- PG_EXCEPTION_DETAIL
	-- WHEN OTHERS THEN
	-- GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT, a2 = PG_EXCEPTION_DETAIL, a3 = PG_EXCEPTION_HINT;
	-- raise EXCEPTION '异常:%, %, %', a1, a2, a3;
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy(
	name 		text,
	start_time 	text,
	end_time 	text,
	url 		text
) returns void as $$

DECLARE
	rec 					record;
	sys_map 				hstore;	--系统设置各种承担比例.
  	occupy_map 				hstore;	--各API的返佣设置
	operation_occupy_map 	hstore;	--运营商各API占成比例.
	rebate_grads_map 		hstore;	--返佣梯度设置.
	agent_map 				hstore;	--代理默认梯度.
	agent_check_map 		hstore;	--代理满足的梯度.
	cost_map 				hstore;	--费用分摊
	rakeback_map 			hstore;	--玩家API返水.
	numhash 				hstore;	--存储每个总代的玩家数.
	mhash 					hstore;	--临时
	occupy_value 			FLOAT;	--返佣值

	keyId 	int;
	tmp 	int;
	a1 		text;
	a2 		text;
	a3 		text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;

	pending_lssuing 	text:='pending_lssuing';
	pending_pay 		text:='pending_pay';
	row_split_char 		text:='^&^';	--分隔符
	col_split_char 		text:='^';

	-- vname 				text:='v_site_game';
	sid 				INT;--站点ID.
	bill_id 			INT;

	is_max 				BOOLEAN:=true;
	key_type 			int:=4;
	category 			TEXT:='AGENT';

	rakebackhash		hstore; -- 玩家返水
	rebatehash			hstore; -- 玩家返佣
BEGIN
	stTime = start_time::TIMESTAMP;
	edTime = end_time::TIMESTAMP;

	raise info '统计( % )的占成, 时间( %-% )', name, start_time, end_time;

	raise info '占成.玩家API返水';
	SELECT gamebox_rakeback_map(stTime, edTime, url, 'API') INTO rakeback_map;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '返佣.梯度设置信息';
  	SELECT gamebox_rebate_api_grads() into rebate_grads_map;

	raise info '返佣.代理默认方案';
  	SELECT gamebox_rebate_agent_default_set() into agent_map;

  	raise info '返佣.代理满足的梯度';
	SELECT gamebox_rebate_agent_check(rebate_grads_map, agent_map, stTime, edTime, 'Y') into agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  	SELECT gamebox_occupy_api_set() into occupy_map;

  	raise info '占成.总表新增';
	SELECT gamebox_occupy_bill(name, stTime, edTime, bill_id, 'I') into bill_id;
	raise info 'occupy_bill.键值:%', bill_id;

  	raise info '总代.玩家API贡献度';
	perform gamebox_occupy_api(bill_id, stTime, edTime, occupy_map, operation_occupy_map, rakeback_map, rebate_grads_map, agent_check_map);

	raise info '占成.各种分摊费用';
	SELECT gamebox_occupy_expense_gather(bill_id, stTime, edTime) into cost_map;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') into sys_map;

	raise info '各个玩家返水,从返水账单取值';
	SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;

	SELECT gamebox_occupy_rebate_map(stTime, edTime) INTO rebatehash;

  	-- raise info '占成.玩家贡献度.cost_map = %, sys_map = %, rakebackhash = %, rebatehash = %', cost_map, sys_map, rakebackhash, rebatehash;
	perform gamebox_occupy_player(bill_id, cost_map, sys_map, rakebackhash, rebatehash);

  	raise info '占成.代理贡献度.';
	perform gamebox_occupy_agent(bill_id);

	raise info '占成.总代明细';
	perform gamebox_occupy_topagent(bill_id);

	raise info '占成.总表更新';
	perform gamebox_occupy_bill(name, stTime, edTime, bill_id, 'U');

	--异常处理
	-- PG_EXCEPTION_DETAIL
	-- WHEN OTHERS THEN
	-- GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT, a2 = PG_EXCEPTION_DETAIL, a3 = PG_EXCEPTION_HINT;
	-- raise EXCEPTION '异常:%, %, %', a1, a2, a3;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_occupy(name text,start_time text,end_time text,url text) returns void as $$
DECLARE
	rec record;
	sys_map hstore;--系统设置各种承担比例.
  occupy_map hstore;--各API的返佣设置
	operation_occupy_map hstore;--运营商各API占成比例.
	rebate_grads_map hstore;--返佣梯度设置.
	agent_map hstore;--代理默认梯度.
	agent_check_map hstore;--代理满足的梯度.
	cost_map hstore;--费用分摊
	rakeback_map hstore;--玩家API返水.
	--存储每个总代的玩家数.
	numhash hstore;

	--临时
	mhash hstore;


	--返佣值
	occupy_value FLOAT;

	keyId int;
	tmp int;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;

	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	--分隔符
	row_split_char text:='^&^';
	col_split_char text:='^';

	vname text:='v_site_game';
	sid INT;--站点ID.
	bill_id INT;

	is_max BOOLEAN:=true;
	key_type int:=4;
	category TEXT:='AGENT';
BEGIN
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '统计( % )的占成,时间( %-% )',name,start_time,end_time;

	raise info '占成.玩家API返水';
	select gamebox_rakeback_map(stTime,edTime,url,'API') INTO rakeback_map;

	raise info '占成.取得当前站点ID';
	select gamebox_current_site() INTO sid;

	raise info '占成.site_game临时视图';
  perform gamebox_site_game(url,vname,sid,'C');


	raise info '占成.系统各种分摊比例参数';
	select gamebox_sys_param('apportionSetting') into sys_map;

	raise info '返佣.梯度设置信息';
  select gamebox_rebate_api_grads() into rebate_grads_map;

	raise info '返佣.代理默认方案';
  select gamebox_rebate_agent_default_set() into agent_map;

  raise info '返佣.代理满足的梯度';
	select gamebox_rebate_agent_check(rebate_grads_map,agent_map,stTime,edTime) into agent_check_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	select gamebox_operations_occupy(url,sid,stTime,edTime
	,category,is_max,key_type) into operation_occupy_map;


	raise info '取得当前返佣梯度设置信息';
  select gamebox_occupy_api_set() into occupy_map;

  raise info '占成.总表新增';
	select gamebox_occupy_bill(name,stTime,edTime,bill_id,'I') into bill_id;
	raise info 'occupy_bill.键值:%',bill_id;

  raise info '总代.玩家API贡献度';
	perform gamebox_occupy_api(bill_id,stTime,edTime,occupy_map,operation_occupy_map
	,rakeback_map,rebate_grads_map,agent_check_map);

	raise info '占成.各种分摊费用';
	select gamebox_occupy_expense_gather(bill_id,stTime,edTime) into cost_map;

  raise info '占成.玩家贡献度.';
	perform gamebox_occupy_player(bill_id,cost_map,sys_map);

  raise info '占成.代理贡献度.';
	perform gamebox_occupy_agent(bill_id);

	raise info '占成.总代明细';
	perform gamebox_occupy_topagent(bill_id);

	raise info '占成.总表更新';
	perform gamebox_occupy_bill(name,stTime,edTime,bill_id,'U');

	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');
		--异常处理
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,a2 = PG_EXCEPTION_DETAIL,a3 = PG_EXCEPTION_HINT;
		raise EXCEPTION '异常:%,%,%',a1,a2,a3;
END;
$$ language plpgsql;",V1.0.1.0249__A_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_calculator(
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore,
	owner_id 				INT,
	player_id 				INT,
	api_id 					INT,
	game_type 				TEXT,
	profit_amount 			FLOAT
)returns FLOAT as $$

DECLARE
	ratio 		float:=0.00;--占成比例
	api 		TEXT;--API
	player 		TEXT;--玩家ID
	owners 		text;--代理ID
	operation_occupy_value 	float:=0.00;--运营商API占成.
	occupy_value 			float:=0.00;	--占成金额
	keyname 	text:='';--键值
	col_split 	text:='_';--列分隔符

BEGIN
	api 	= api_id::TEXT;
	owners 	= owner_id::TEXT;
	player 	= player_id::TEXT;
	keyname = player||col_split||api||col_split||game_type;
	--raise info 'Hash健值:%', keyname;
	operation_occupy_value = 0.00;
	--raise info 'keyname=%, operation_occupy_map:%', keyname, operation_occupy_map;
	IF isexists(operation_occupy_map,  keyname) THEN
		operation_occupy_value = (operation_occupy_map->keyname)::FLOAT;
	END IF;
	--raise info 'operation_occupy_value:%', operation_occupy_value;

	keyname = owners||col_split||api||col_split||game_type;

	IF isexists(occupy_grads_map,  keyname) THEN
		ratio = (occupy_grads_map->keyname)::float;
		occupy_value = (profit_amount - operation_occupy_value) * ratio / 100;
		--raise info 'profit_amount=%, operation_occupy_value=%, ratio=%, API占成总额:%', profit_amount, operation_occupy_value, ratio, occupy_value;
	ELSE
		-- raise info '总代:%, 未设置当前API:%, GAME_TYPE:% 的梯度, 未设置的占成金额置为:0.请检查!', owners, api, game_type;
	END IF;

	return occupy_value;
END

$$ language plpgsql;",4_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_calculator(
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore,
	owner_id 				INT,
	player_id 				INT,
	api_id 					INT,
	game_type 				TEXT,
	profit_amount 			FLOAT
)returns FLOAT as $$

DECLARE
	ratio 		float:=0.00;--占成比例
	api 		TEXT;--API
	player 		TEXT;--玩家ID
	owners 		text;--代理ID
	operation_occupy_value 	float:=0.00;--运营商API占成.
	occupy_value 			float:=0.00;	--占成金额
	keyname 	text:='';--键值
	col_split 	text:='_';--列分隔符

BEGIN
	api 	= api_id::TEXT;
	owners 	= owner_id::TEXT;
	player 	= player_id::TEXT;
	keyname = player||col_split||api||col_split||game_type;
	--raise info 'Hash健值:%', keyname;
	operation_occupy_value = 0.00;
	--raise info 'keyname=%, operation_occupy_map:%', keyname, operation_occupy_map;
	IF isexists(operation_occupy_map,  keyname) THEN
		operation_occupy_value = (operation_occupy_map->keyname)::FLOAT;
	END IF;
	--raise info 'operation_occupy_value:%', operation_occupy_value;

	keyname = owners||col_split||api||col_split||game_type;

	IF isexists(occupy_grads_map,  keyname) THEN
		ratio = (occupy_grads_map->keyname)::float;
		occupy_value = (profit_amount - operation_occupy_value) * ratio / 100;
		--raise info 'profit_amount=%, operation_occupy_value=%, ratio=%, API占成总额:%', profit_amount, operation_occupy_value, ratio, occupy_value;
	ELSE
		-- raise info '总代:%, 未设置当前API:%, GAME_TYPE:% 的梯度, 未设置的占成金额置为:0.请检查!', owners, api, game_type;
	END IF;

	return occupy_value;
END

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_calculator(
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore,
	owner_id 				INT,
	player_id 				INT,
	api_id 					INT,
	game_type 				TEXT,
	profit_amount 			FLOAT
)returns FLOAT as $$

DECLARE
	ratio 		float:=0.00;--占成比例
	api 		TEXT;--API
	player 		TEXT;--玩家ID
	owners 		text;--代理ID
	operation_occupy_value 	float:=0.00;--运营商API占成.
	occupy_value 			float:=0.00;	--占成金额
	keyname 	text:='';--键值
	col_split 	text:='_';--列分隔符

BEGIN
	api 	= api_id::TEXT;
	owners 	= owner_id::TEXT;
	player 	= player_id::TEXT;
	keyname = player||col_split||api||col_split||game_type;
	--raise info 'Hash健值:%', keyname;
	operation_occupy_value = 0.00;
	--raise info 'keyname=%, operation_occupy_map:%', keyname, operation_occupy_map;
	IF isexists(operation_occupy_map,  keyname) THEN
		operation_occupy_value = (operation_occupy_map->keyname)::FLOAT;
	END IF;
	--raise info 'operation_occupy_value:%', operation_occupy_value;

	keyname = owners||col_split||api||col_split||game_type;

	IF isexists(occupy_grads_map,  keyname) THEN
		ratio = (occupy_grads_map->keyname)::float;
		occupy_value = (profit_amount - operation_occupy_value) * ratio / 100;
		--raise info 'profit_amount=%, operation_occupy_value=%, ratio=%, API占成总额:%', profit_amount, operation_occupy_value, ratio, occupy_value;
	ELSE
		-- raise info '总代:%, 未设置当前API:%, GAME_TYPE:% 的梯度, 未设置的占成金额置为:0.请检查!', owners, api, game_type;
	END IF;

	return occupy_value;
END

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_calculator(
occupy_grads_map hstore
,operation_occupy_map hstore
,owner_id INT
,player_id INT
,api_id INT
,game_type TEXT
,profit_amount FLOAT
)
returns FLOAT as $$
DECLARE
	ratio float:=0.00;--占成比例
	api TEXT;--API
	--game_type text;--游戏类型
	player TEXT;--玩家ID
	owners text;--代理ID
	operation_occupy_value float:=0.00;--运营商API占成.
	occupy_value float:=0.00;	--占成金额
	keyname text:='';--键值
	col_split text:='_';--列分隔符
BEGIN
			--api=rec->>'api_id';
			--game_type=rtrim(ltrim(rec->>'game_type'));
			--top_agent_id=rec->>'owner_id';
			api=api_id::TEXT;
			owners=owner_id::TEXT;
			player=player_id::TEXT;
		  keyname=player||col_split||api||col_split||game_type;
			--raise info 'Hash健值:%',keyname;
			operation_occupy_value=0.00;
		  --raise info 'keyname=%,operation_occupy_map:%',keyname,operation_occupy_map;
			IF isexists(operation_occupy_map, keyname) THEN
				operation_occupy_value=(operation_occupy_map->keyname)::FLOAT;
			END IF;
			--raise info 'operation_occupy_value:%',operation_occupy_value;

			keyname=owners||col_split||api||col_split||game_type;
			--raise info 'key2=%,map=%',keyname,occupy_grads_map;
			IF isexists(occupy_grads_map, keyname) THEN
				ratio=(occupy_grads_map->keyname)::float;
				occupy_value=(profit_amount-operation_occupy_value)*ratio/100;
				--raise info 'profit_amount=%,operation_occupy_value=%,ratio=%,API占成总额:%',profit_amount,operation_occupy_value,ratio,occupy_value;
			ELSE
				raise info '总代:%,未设置当前API:%,GAME_TYPE:% 的梯度,未设置的占成金额置为:0.请检查!',owners,api,game_type;
			END IF;
	return occupy_value;
END
$$ language plpgsql;",V1.0.1.0249__A_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 					record;
	key_name 				TEXT:='';
	col_split 				TEXT:='_';

	operation_occupy_value 	FLOAT:=0.00;--运营商API占成金额
	occupy_value 			FLOAT:=0.00;--占成金额
	profit_amount 			FLOAT:=0.00;--盈亏总和

	api 		INT;
	game_type 	TEXT;
	owner_id 	TEXT;
	name 		TEXT:='';
	retio 		FLOAT:=0.00;--占成比例

	api_map 	hstore;
	param 		TEXT:='';

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';

BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	-- raise info '------ operation_occupy_map = %', operation_occupy_map;

	FOR rec IN
		SELECT ut.""id""											as topagent_id,
			   ut.username										as topagent_name,
			   rab.api_id,
			   rab.game_type,
			   COALESCE(SUM(-rab.profit_loss), 0.00)			as profit_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		  LEFT JOIN sys_user ua ON su.owner_id = ua.id
		  LEFT JOIN sys_user ut ON ua.owner_id = ut.id
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		   AND ua.user_type = '23'
		   AND ut.user_type = '22'
		 GROUP BY ut.""id"", ut.username, rab.api_id, rab.game_type
  	LOOP
		raise info '------------------------ OFF LINE BEGIN ----------------------';
		api 			= rec.api_id;
		game_type 		= rec.game_type;
		owner_id 		= rec.topagent_id::TEXT;
		name 			= rec.topagent_name;
		profit_amount 	= rec.profit_amount;

		-- raise info '------ api_id = %, game_type = %, owner_id = %, name = %, profit_amount = %, ',
		-- 	api, game_type, owner_id, name, profit_amount;

		--取得运营商API占成.
		key_name = api||col_split||game_type;
		raise info '------ key_name1 = %', key_name;

		operation_occupy_value = 0.00;
		IF exist(operation_occupy_map, key_name) THEN
			operation_occupy_value = (operation_occupy_map->key_name)::FLOAT;
		END IF;

		raise info '------ operation_occupy_value = %', operation_occupy_value;

		--计算总代占成.
		key_name = owner_id||col_split||api||col_split||game_type;
		raise info '------ key_name2 = %', key_name;

		occupy_value 	= 0.00;
		retio 			= 0.00;

		-- raise info '------ occupy_grads_map = %', occupy_grads_map;
		IF exist(occupy_grads_map, key_name) THEN
			retio = (occupy_grads_map->key_name)::FLOAT;
			occupy_value = (profit_amount - operation_occupy_value) * retio / 100;
		ELSE
			raise info '总代ID = %, API = %, GAME_TYPE = % 未设置占成.', owner_id, api, game_type;
		END IF;

		raise info '------ retio = %, occupy_value = %', retio, occupy_value;

		--格式:id->'name@api^type^val~api^type^val^retio
		key_name = owner_id;
		raise info '------ key_name3 = %', key_name;
		raise info '------ api_map1 = %', api_map;
		IF api_map is null THEN
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			SELECT key_name||'=>'||param INTO api_map;
		ELSEIF exist(api_map, key_name) THEN
			param = api_map->key_name;
			param = param||rs||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;
		raise info '------ api_map2 = %', api_map;
		raise info '------------------------ OFF LINE END ------------------------';
	END LOOP;

	RETURN api_map;
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 					record;
	key_name 				TEXT:='';
	col_split 				TEXT:='_';

	operation_occupy_value 	FLOAT:=0.00;--运营商API占成金额
	occupy_value 			FLOAT:=0.00;--占成金额
	profit_amount 			FLOAT:=0.00;--盈亏总和

	api 		INT;
	game_type 	TEXT;
	owner_id 	TEXT;
	name 		TEXT:='';
	retio 		FLOAT:=0.00;--占成比例

	api_map 	hstore;
	param 		TEXT:='';

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';

BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	-- raise info '------ operation_occupy_map = %', operation_occupy_map;

	FOR rec IN
		SELECT ut.""id""											as topagent_id,
			   ut.username										as topagent_name,
			   rab.api_id,
			   rab.game_type,
			   COALESCE(SUM(-rab.profit_loss), 0.00)			as profit_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		  LEFT JOIN sys_user ua ON su.owner_id = ua.id
		  LEFT JOIN sys_user ut ON ua.owner_id = ut.id
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		   AND ua.user_type = '23'
		   AND ut.user_type = '22'
		 GROUP BY ut.""id"", ut.username, rab.api_id, rab.game_type
  	LOOP
		raise info '------------------------ OFF LINE BEGIN ----------------------';
		api 			= rec.api_id;
		game_type 		= rec.game_type;
		owner_id 		= rec.topagent_id::TEXT;
		name 			= rec.topagent_name;
		profit_amount 	= rec.profit_amount;

		-- raise info '------ api_id = %, game_type = %, owner_id = %, name = %, profit_amount = %, ',
		-- 	api, game_type, owner_id, name, profit_amount;

		--取得运营商API占成.
		key_name = api||col_split||game_type;
		raise info '------ key_name1 = %', key_name;

		operation_occupy_value = 0.00;
		IF exist(operation_occupy_map, key_name) THEN
			operation_occupy_value = (operation_occupy_map->key_name)::FLOAT;
		END IF;

		raise info '------ operation_occupy_value = %', operation_occupy_value;

		--计算总代占成.
		key_name = owner_id||col_split||api||col_split||game_type;
		raise info '------ key_name2 = %', key_name;

		occupy_value 	= 0.00;
		retio 			= 0.00;

		-- raise info '------ occupy_grads_map = %', occupy_grads_map;
		IF exist(occupy_grads_map, key_name) THEN
			retio = (occupy_grads_map->key_name)::FLOAT;
			occupy_value = (profit_amount - operation_occupy_value) * retio / 100;
		ELSE
			raise info '总代ID = %, API = %, GAME_TYPE = % 未设置占成.', owner_id, api, game_type;
		END IF;

		raise info '------ retio = %, occupy_value = %', retio, occupy_value;

		--格式:id->'name@api^type^val~api^type^val^retio
		key_name = owner_id;
		raise info '------ key_name3 = %', key_name;
		raise info '------ api_map1 = %', api_map;
		IF api_map is null THEN
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			SELECT key_name||'=>'||param INTO api_map;
		ELSEIF exist(api_map, key_name) THEN
			param = api_map->key_name;
			param = param||rs||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;
		raise info '------ api_map2 = %', api_map;
		raise info '------------------------ OFF LINE END ------------------------';
	END LOOP;

	RETURN api_map;
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	occupy_grads_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 					record;
	key_name 				TEXT:='';
	col_split 				TEXT:='_';

	operation_occupy_value 	FLOAT:=0.00;--运营商API占成金额
	occupy_value 			FLOAT:=0.00;--占成金额
	profit_amount 			FLOAT:=0.00;--盈亏总和

	api 		INT;
	game_type 	TEXT;
	owner_id 	TEXT;
	name 		TEXT:='';
	retio 		FLOAT:=0.00;--占成比例

	api_map 	hstore;
	param 		TEXT:='';

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';

BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	-- raise info '------ operation_occupy_map = %', operation_occupy_map;

	FOR rec IN
		SELECT ut.""id""									as topagent_id,
			   ut.username								as topagent_name,
			   rab.api_id,
			   rab.game_type,
			   COALESCE(SUM(-rab.profit_loss), 0.00)	as profit_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		  LEFT JOIN sys_user ua ON su.owner_id = ua.id
		  LEFT JOIN sys_user ut ON ua.owner_id = ut.id
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time <= end_time
		   AND su.user_type = '24'
		   AND ua.user_type = '23'
		   AND ut.user_type = '22'
		 GROUP BY ut.""id"", ut.username, rab.api_id, rab.game_type
  	LOOP
		api 			= rec.api_id;
		game_type 		= rec.game_type;
		owner_id 		= rec.topagent_id::TEXT;
		name 			= rec.topagent_name;
		profit_amount 	= rec.profit_amount;

		--取得运营商API占成.
		key_name = api||col_split||game_type;

		operation_occupy_value = 0.00;
		IF exist(operation_occupy_map, key_name) THEN
			operation_occupy_value = (operation_occupy_map->key_name)::FLOAT;
		END IF;

		--计算总代占成.
		key_name = owner_id||col_split||api||col_split||game_type;

		occupy_value = 0.00;
		retio 		 = 0.00;

  IF exist(occupy_grads_map, key_name) THEN
			retio = (occupy_grads_map->key_name)::FLOAT;
			occupy_value = (profit_amount - operation_occupy_value) * retio / 100;
		ELSE
			raise info '总代ID = %, API = %, GAME_TYPE = % 未设置占成.', owner_id, api, game_type;
		END IF;

		--格式:id->'name@api^type^val~api^type^val^retio
		key_name = owner_id;

		IF api_map is null THEN
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			SELECT key_name||'=>'||param INTO api_map;
		ELSEIF exist(api_map, key_name) THEN
			param = api_map->key_name;
			param = param||rs||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param = name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map = api_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;

	END LOOP;

	RETURN api_map;
END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_occupy_api_map(
start_time TIMESTAMP
,end_time TIMESTAMP
,occupy_grads_map hstore
,operation_occupy_map hstore
) returns hstore as $$
DECLARE
	rec record;
	key_name TEXT:='';
	col_split TEXT:='_';

	operation_occupy_value FLOAT:=0.00;--运营商API占成金额
	occupy_value FLOAT:=0.00;--占成金额
	profit_amount FLOAT:=0.00;--盈亏总和

	api INT;
	game_type TEXT;
	owner_id TEXT;
	name TEXT:='';
	retio FLOAT:=0.00;--占成比例

	api_map hstore;
	--rs TEXT:='~';--此值调用同步
	--cs TEXT:='^';--此值调用同步
	--sp TEXT:='@';--此值调用同步
	param TEXT:='';

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';

	FOR rec IN
		SELECT
		u.topagent_id,
		u.topagent_name,
		o.api_id,
		o.game_type,
		COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
		COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
		FROM player_game_order o,v_sys_user_tier u
		WHERE o.player_id=u.id
		AND o.create_time>=start_time
		AND o.create_time<end_time
		GROUP BY u.topagent_id,u.topagent_name,o.api_id,o.game_type
  LOOP
		api=rec.api_id;
		game_type=rec.game_type;
		owner_id=rec.topagent_id::TEXT;
		name=rec.topagent_name;
		profit_amount=rec.profit_amount;

		--取得运营商API占成.
		key_name=api||col_split||game_type;
		operation_occupy_value=0.00;
		IF exist(operation_occupy_map,key_name) THEN
			operation_occupy_value=(operation_occupy_map->key_name)::FLOAT;
		END IF;

		--计算总代占成.
		occupy_value=0.00;
		key_name=owner_id||col_split||api||col_split||game_type;
		retio=0.00;
		IF exist(occupy_grads_map,key_name) THEN
			retio=(occupy_grads_map->key_name)::FLOAT;
			occupy_value=(profit_amount-operation_occupy_value)*retio/100;
		ELSE
			raise info '总代ID:%,API:%,GAME_TYPE:%未设置占成.',owner_id,api,game_type;
		END IF;
		--格式:id->'name@api^type^val~api^type^val^retio

		key_name=owner_id;
		IF api_map is null THEN
			param=name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			SELECT key_name||'=>'||param INTO api_map;
		ELSEIF exist(api_map,key_name) THEN
			param=api_map->key_name;
			param=param||rs||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map=api_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param=name||sp||api||cs||game_type||cs||occupy_value||cs||retio||cs||profit_amount;
			api_map=api_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;

	END LOOP;
	RETURN api_map;
END;
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_set() returns hstore as $$
DECLARE
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	rec 		record;
	row_split 	text:='^&^';
	col_split 	text:='_';
BEGIN
	FOR rec in
		SELECT DISTINCT user_id,
			   api_id,
			   game_type,
			   ratio
		  FROM user_agent_api
 		 WHERE ratio IS NOT NULL
		 ORDER BY user_id, api_id, game_type
	LOOP
		param = rec.user_id||col_split||rec.api_id||col_split||rec.game_type||'=>'||rec.ratio;
		IF hash is NULL THEN
			SELECT param into hash;
		ELSE
			SELECT param into mhash;
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END;
$$ language plpgsql;",4_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_set() returns hstore as $$
DECLARE
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	rec 		record;
	row_split 	text:='^&^';
	col_split 	text:='_';
BEGIN
	FOR rec in
		SELECT DISTINCT user_id,
			   api_id,
			   game_type,
			   ratio
		  FROM user_agent_api
 		 WHERE ratio IS NOT NULL
		 ORDER BY user_id, api_id, game_type
	LOOP
		param = rec.user_id||col_split||rec.api_id||col_split||rec.game_type||'=>'||rec.ratio;
		IF hash is NULL THEN
			SELECT param into hash;
		ELSE
			SELECT param into mhash;
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_set() returns hstore as $$
DECLARE
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	rec 		record;
	row_split 	text:='^&^';
	col_split 	text:='_';
BEGIN
	FOR rec in
		SELECT DISTINCT user_id,
			   api_id,
			   game_type,
			   ratio
		  FROM user_agent_api
 		 WHERE ratio IS NOT NULL
		 ORDER BY user_id, api_id, game_type
	LOOP
		param = rec.user_id||col_split||rec.api_id||col_split||rec.game_type||'=>'||rec.ratio;
		IF hash is NULL THEN
			SELECT param into hash;
		ELSE
			SELECT param into mhash;
			hash = hash||mhash;
		END IF;
	END LOOP;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_api_set() returns hstore as $$
DECLARE
	hash hstore;
	mhash hstore;
	param text:='';
	rec record;
	row_split text:='^&^';
	col_split text:='_';
BEGIN
	FOR rec in
		select DISTINCT user_id,api_id,game_type,ratio from user_agent_api order by user_id,api_id,game_type
	LOOP
		param=rec.user_id||col_split||rec.api_id||col_split||rec.game_type||'=>'||rec.ratio;
		IF hash is NULL THEN
			SELECT param into hash;
		ELSE
			SELECT param into mhash;
			hash=hash||mhash;
		END IF;
	END LOOP;
	--raise info 'API占成信息:%',hash->'3_1_01';
	return hash;
END;
$$ language plpgsql;",V1.0.1.0249__A_gamebox_occupy.sql
"create or replace function gamebox_occupy_calculate(
    limit_values 	FLOAT[],
    retios 			FLOAT[],
    amount 			FLOAT,
    assume 			BOOLEAN
) returns FLOAT as $$
DECLARE
	val 		FLOAT;
	pre_value 	FLOAT:=0.00;
	occupy 		FLOAT:=0.00;
	cal_amount 	FLOAT:=0.00;
	o_val 		FLOAT;
	c_val 		FLOAT;	-- 当前上限值.
	retio 		FLOAT;	-- 当前占成比例.
BEGIN
	val = amount;
	IF assume AND val < 0 THEN
		amount = -amount;
	ELSEIF assume = false AND val < 0 THEN
		raise info '盈亏不共担, 盈亏为负时, 占成计0';
		RETURN 0.00;	-- 盈亏不共担, 计税金额为负时, 占成计0.
	END IF;

	raise info '各API盈亏 = %', amount;
	IF array_length(limit_values,  1) = array_length(retios,  1) THEN
		FOR i IN 1..array_length(limit_values,  1) LOOP
			IF amount < 0 THEN
			 	exit;
			END IF;

			c_val = limit_values[i];
			 -- raise info '------ val = %, c_val1 = %', val, c_val;
			-- 盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val < 0 AND c_val < 0 THEN
				c_val = -c_val;
			END IF;

			 -- raise info '------ c_val2 = %, amount = %', c_val, amount;
			retio = retios[i];
			cal_amount = c_val - pre_value;
			IF amount < cal_amount THEN
				cal_amount = amount;
				retio = retios[1];
			END IF;
			IF amount > 0 THEN
				amount = amount - cal_amount;
				o_val  = cal_amount * retio / 100;
				occupy = occupy + o_val;
				 -- raise info '------ 2 o_val = %, occupy = %', o_val, occupy;
				pre_value = c_val;
			END IF;
		END LOOP;
	END IF;

	 -- raise info '------ val = %, occupy1 = %, amount = %', val, occupy, amount;
	IF val < 0 THEN
		occupy = -occupy;
	END IF;
	-- raise info '------ occupy2 = %', occupy;

	-- raise info '各API盈亏 = %, 占成 = %', val, occupy;
	RETURN occupy;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_occupy_calculate(
  limit_values 	FLOAT[],
  retios 			FLOAT[],
  amount 			FLOAT,
  assume 			BOOLEAN
) returns FLOAT as $$
DECLARE
	val 		FLOAT;
	pre_value 	FLOAT:=0.00;
	occupy 		FLOAT:=0.00;
	cal_amount 	FLOAT:=0.00;
	o_val 		FLOAT;
	c_val 		FLOAT;	-- 当前上限值.
	retio 		FLOAT;	-- 当前占成比例.
BEGIN
	val = amount;
	IF assume AND val < 0 THEN
		amount = -amount;
	ELSEIF assume = false AND val < 0 THEN
		raise info '盈亏不共担, 盈亏为负时, 占成计0';
		RETURN 0.00;	-- 盈亏不共担, 计税金额为负时, 占成计0.
	END IF;

	raise info '各API盈亏 = %', amount;
	IF array_length(limit_values,  1) = array_length(retios,  1) THEN
		FOR i IN 1..array_length(limit_values,  1) LOOP
			IF amount < 0 THEN
			 	exit;
			END IF;

			c_val = limit_values[i];
			 -- raise info '------ val = %, c_val1 = %', val, c_val;
			-- 盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val < 0 AND c_val < 0 THEN
				c_val = -c_val;
			END IF;

			 -- raise info '------ c_val2 = %, amount = %', c_val, amount;
			retio = retios[i];
			cal_amount = c_val - pre_value;
			IF amount < cal_amount THEN
				cal_amount = amount;
				retio = retios[1];
			END IF;
			IF amount > 0 THEN
				amount = amount - cal_amount;
				o_val = cal_amount * retio / 100;
				occupy = occupy + o_val;
				 -- raise info '------ 2 o_val = %, occupy = %', o_val, occupy;
				pre_value = c_val;
			END IF;
		END LOOP;
	END IF;

	 -- raise info '------ val = %, occupy1 = %, amount = %', val, occupy, amount;
	IF val < 0 THEN
		occupy = -occupy;
	END IF;
	raise info '------ occupy2 = %', occupy;

	-- raise info '各API盈亏 = %, 占成 = %', val, occupy;
	RETURN occupy;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_occupy_expense_gather(
	bill_id 	INT,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 			record;
	hash 			hstore;
	mhash 			hstore;
	param 			text:='';
	player_id 		text:='';
	money 			float:=0.00;		--占成.

	issue_state 	text:='lssuing';	--发放状态
	col_split 		text:='^';
	row_split 		text:='^&^';
	trans 			FLOAT:=0.00;		--有效交易量
	loss 			FLOAT:=0.00;		--盈亏总和
	backwater 		FLOAT:=0.00;		--返水.
	rebate_value 	FLOAT:=0.00;		--返佣
	result_hash 	hstore;

BEGIN
	-- raise info '分摊费用[返水、优惠、推荐、返手续费]';
	SELECT gamebox_expense_gather(start_time, end_time, 'PLAYER') INTO hash;
	SELECT '' INTO result_hash;
  	-- 统计各代理返佣.
	FOR rec IN
		/*
		SELECT op.player_id,
			   op.player_name	username,
			   op.effective_transaction,
			   op.profit_loss,
			   op.occupy_total,
			   op.rebate
		  FROM occupy_player op
		 WHERE op.occupy_bill_id = bill_id
		*/
		SELECT oa.player_id,
			   su.username,
			   SUM(oa.effective_transaction) 	as effective_transaction,
			   SUM(oa.profit_loss) 				as profit_loss,
			   SUM(occupy_total) 				as occupy_total,
			   SUM(rebate) 						as rebate
		  FROM occupy_api oa, sys_user su, user_agent ua
 		 WHERE oa.player_id = su.id
	 	   AND su.owner_id = ua.""id""
	 	   AND oa.occupy_bill_id = bill_id
	 	   AND su.user_type = '24'
 	   	 GROUP BY oa.player_id, su.username

	LOOP
		player_id 	= rec.player_id::text;
		money 		= rec.occupy_total;
		trans 		= rec.effective_transaction;
		loss 		= rec.profit_loss;
		rebate_value = rec.rebate;

		IF isexists(hash, player_id) THEN
			param = hash->player_id;
			-- raise info 'param=%', param;
			param = param||row_split||'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		ELSE
			param = 'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		END IF;

		SELECT player_id||'=>'||param into mhash;

		result_hash = result_hash||mhash;

	END LOOP;
	RETURN result_hash;
END;

$$ language plpgsql;",4_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_gather(
	bill_id 	INT,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 			record;
	hash 			hstore;
	mhash 			hstore;
	param 			text:='';
	player_id 		text:='';
	money 			float:=0.00;--占成.
	--发放状态
	issue_state 	text:='lssuing';
	col_split 		text:='^';
	row_split 		text:='^&^';
	trans 			FLOAT:=0.00;--有效交易量
	loss 			FLOAT:=0.00;--盈亏总和
	backwater 		FLOAT:=0.00;--返水.
	rebate_value 	FLOAT:=0.00;--返佣
	result_hash 	hstore;

BEGIN
	-- raise info '分摊费用[返水、优惠、推荐、返手续费]';
	SELECT gamebox_expense_gather(start_time, end_time, 'PLAYER') INTO hash;
	SELECT '' INTO result_hash;
  	-- 统计各代理返佣.
	FOR rec IN
		/*
		SELECT op.player_id,
			   op.player_name	username,
			   op.effective_transaction,
			   op.profit_loss,
			   op.occupy_total,
			   op.rebate
		  FROM occupy_player op
		 WHERE op.occupy_bill_id = bill_id
		*/
		SELECT oa.player_id,
			   su.username,
			   SUM(oa.effective_transaction) 	as effective_transaction,
			   SUM(oa.profit_loss) 				as profit_loss,
			   SUM(occupy_total) 				as occupy_total,
			   SUM(rebate) 						as rebate
		  FROM occupy_api oa, sys_user su, user_agent ua
 		 WHERE oa.player_id = su.id
	 	   AND su.owner_id = ua.""id""
	 	   AND oa.occupy_bill_id = bill_id
	 	   AND su.user_type = '24'
 	   	 GROUP BY oa.player_id, su.username

	LOOP
		player_id 	= rec.player_id::text;
		money 		= rec.occupy_total;
		trans 		= rec.effective_transaction;
		loss 		= rec.profit_loss;
		rebate_value = rec.rebate;

		IF isexists(hash, player_id) THEN
			param = hash->player_id;
			-- raise info 'param=%', param;
			param = param||row_split||'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		ELSE
			param = 'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		END IF;

		SELECT player_id||'=>'||param into mhash;

		result_hash = result_hash||mhash;

	END LOOP;
	RETURN result_hash;
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_gather(
	bill_id 	INT,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 			record;
	hash 			hstore;
	mhash 			hstore;
	param 			text:='';
	player_id 		text:='';
	money 			float:=0.00;--占成.
	--发放状态
	issue_state 	text:='lssuing';
	col_split 		text:='^';
	row_split 		text:='^&^';
	trans 			FLOAT:=0.00;--有效交易量
	loss 			FLOAT:=0.00;--盈亏总和
	backwater 		FLOAT:=0.00;--返水.
	rebate_value 	FLOAT:=0.00;--返佣
	result_hash 	hstore;

BEGIN
	-- raise info '分摊费用[返水、优惠、推荐、返手续费]';
	SELECT gamebox_expense_gather(start_time, end_time, 'PLAYER') INTO hash;
	SELECT '' INTO result_hash;
  	-- 统计各代理返佣.
	FOR rec IN
		/*
		SELECT op.player_id,
			   op.player_name	username,
			   op.effective_transaction,
			   op.profit_loss,
			   op.occupy_total,
			   op.rebate
		  FROM occupy_player op
		 WHERE op.occupy_bill_id = bill_id
		*/
		SELECT oa.player_id,
			   su.username,
			   SUM(oa.effective_transaction) 	as effective_transaction,
			   SUM(oa.profit_loss) 				as profit_loss,
			   SUM(occupy_total) 				as occupy_total,
			   SUM(rebate) 						as rebate
		  FROM occupy_api oa, sys_user su, user_agent ua
 		 WHERE oa.player_id = su.id
	 	   AND su.owner_id = ua.""id""
	 	   AND oa.occupy_bill_id = bill_id
	 	   AND su.user_type = '24'
 	   	 GROUP BY oa.player_id, su.username

	LOOP
		player_id 	= rec.player_id::text;
		money 		= rec.occupy_total;
		trans 		= rec.effective_transaction;
		loss 		= rec.profit_loss;
		rebate_value = rec.rebate;

		IF isexists(hash, player_id) THEN
			param = hash->player_id;
			-- raise info 'param=%', param;
			param = param||row_split||'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		ELSE
			param = 'occupy_total'||col_split||money::text;
			param = param||row_split||'effective_transaction'||col_split||trans::TEXT;
			param = param||row_split||'profit_loss'||col_split||loss::TEXT;
			param = param||row_split||'rebate'||col_split||rebate_value::TEXT;
			param = param||row_split||'username'||col_split||rec.username;
		END IF;

		SELECT player_id||'=>'||param into mhash;

		result_hash = result_hash||mhash;

	END LOOP;
	RETURN result_hash;
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_gather(
bill_id INT
,start_time TIMESTAMP
,end_time TIMESTAMP
) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	player_id text:='';
	money float:=0.00;--占成.
	--发放状态
	issue_state text:='lssuing';
	col_split text:='^';
	row_split text:='^&^';
	trans FLOAT:=0.00;--有效交易量
	loss FLOAT:=0.00;--盈亏总和
	backwater FLOAT:=0.00;--返水.
	rebate_value FLOAT:=0.00;--返佣

BEGIN
		raise info '分摊费用[返水、优惠、推荐、返手续费]';
		--select gamebox_expense_gather(start_time,end_time,row_split,col_split) INTO hash;
		select gamebox_expense_gather(start_time,end_time,'TOP') INTO hash;
		raise info '%',hash;
	  --统计各代理返佣.
		FOR rec IN
			 SELECT p.player_id,u.username
			 ,SUM(p.effective_transaction) effective_transaction,SUM(p.profit_loss) profit_loss
			 ,SUM(occupy_total) occupy_total,SUM(rakeback) rakeback,SUM(rebate) rebate
			 FROM occupy_api p,sys_user u
			 WHERE p.player_id=u.id
			 AND p.occupy_bill_id=bill_id
			 AND u.user_type='24'
			 GROUP BY p.player_id,u.username
		LOOP
			player_id=rec.player_id::text;
			money=rec.occupy_total;
			trans=rec.effective_transaction;
			loss=	rec.profit_loss;
			backwater=rec.rakeback;
			rebate_value=rec.rebate;
			IF isexists(hash,player_id) THEN
				param=hash->player_id;
				raise info 'param=%',param;
				param=param||row_split||'occupy_total'||col_split||money::text;
				param=param||row_split||'effective_transaction'||col_split||trans::TEXT;
				param=param||row_split||'profit_loss'||col_split||loss::TEXT;
				param=param||row_split||'rakeback'||col_split||backwater::TEXT;
				param=param||row_split||'rebate'||col_split||rebate_value::TEXT;
				param=param||row_split||'username'||col_split||rec.username;
			ELSE
				raise info 'player_id:%',player_id;
				param='occupy_total'||col_split||money::text;
				param=param||row_split||'effective_transaction'||col_split||trans::TEXT;
				param=param||row_split||'profit_loss'||col_split||loss::TEXT;
				param=param||row_split||'rakeback'||col_split||backwater::TEXT;
				param=param||row_split||'rebate'||col_split||rebate_value::TEXT;
				param=param||row_split||'username'||col_split||rec.username;
			END IF;

			select player_id||'=>'||param into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;
		RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_gather(
bill_id INT
,start_time TIMESTAMP
,end_time TIMESTAMP
) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	player_id text:='';
	money float:=0.00;--占成.
	--发放状态
	issue_state text:='lssuing';
	col_split text:='^';
	row_split text:='^&^';
	trans FLOAT:=0.00;--有效交易量
	loss FLOAT:=0.00;--盈亏总和
	backwater FLOAT:=0.00;--返水.
	rebate_value FLOAT:=0.00;--返佣

BEGIN
		raise info '分摊费用[返水、优惠、推荐、返手续费]';
		select gamebox_expense_gather(start_time,end_time,row_split,col_split) INTO hash;
		raise info '%',hash;
	  --统计各代理返佣.
		FOR rec IN
			 SELECT p.player_id,u.username
			 ,SUM(p.effective_transaction) effective_transaction,SUM(p.profit_loss) profit_loss
			 ,SUM(occupy_total) occupy_total,SUM(rakeback) rakeback,SUM(rebate) rebate
			 FROM occupy_api p,sys_user u
			 WHERE p.player_id=u.id
			 AND p.occupy_bill_id=bill_id
			 AND u.user_type='24'
			 GROUP BY p.player_id,u.username
		LOOP
			player_id=rec.player_id::text;
			money=rec.occupy_total;
			trans=rec.effective_transaction;
			loss=	rec.profit_loss;
			backwater=rec.rakeback;
			rebate_value=rec.rebate;
			IF isexists(hash,player_id) THEN
				param=hash->player_id;
				raise info 'param=%',param;
				param=param||row_split||'occupy_total'||col_split||money::text;
				param=param||row_split||'effective_transaction'||col_split||trans::TEXT;
				param=param||row_split||'profit_loss'||col_split||loss::TEXT;
				param=param||row_split||'rakeback'||col_split||backwater::TEXT;
				param=param||row_split||'rebate'||col_split||rebate_value::TEXT;
				param=param||row_split||'username'||col_split||rec.username;
			ELSE
			raise info 'player_id:%',player_id;
				param='occupy_total'||col_split||money::text;
				param=param||row_split||'effective_transaction'||col_split||trans::TEXT;
				param=param||row_split||'profit_loss'||col_split||loss::TEXT;
				param=param||row_split||'rakeback'||col_split||backwater::TEXT;
				param=param||row_split||'rebate'||col_split||rebate_value::TEXT;
				param=param||row_split||'username'||col_split||rec.username;
			END IF;

			select player_id||'=>'||param into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;
		RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0249__A_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	sys_map 	hstore
) returns hstore as $$

DECLARE
	expense_map hstore;
BEGIN
	--取得各项费用
	SELECT gamebox_expense_gather(start_time, end_time, 'TOP') INTO expense_map;
	-- raise info '各项费用:%', expense_map;
	--取得返佣值
	SELECT gamebox_occupy_value(start_time, end_time, expense_map) INTO expense_map;
	-- raise info 'occupy fee:%', expense_map;
	--计算费用分摊
	SELECT gamebox_expense_calculate(expense_map, sys_map, 'OCCUPY') INTO expense_map;
	-- raise info '费用分摊%', expense_map;

	RETURN expense_map;
END;

$$ language plpgsql;",4_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	sys_map 	hstore
) returns hstore as $$

DECLARE
	expense_map hstore;
BEGIN
	--取得各项费用
	SELECT gamebox_expense_gather(start_time, end_time, 'TOP') INTO expense_map;
	-- raise info '各项费用:%', expense_map;
	--取得返佣值
	SELECT gamebox_occupy_value(start_time, end_time, expense_map) INTO expense_map;
	-- raise info 'occupy fee:%', expense_map;
	--计算费用分摊
	SELECT gamebox_expense_calculate(expense_map, sys_map, 'OCCUPY') INTO expense_map;
	-- raise info '费用分摊%', expense_map;

	RETURN expense_map;
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	sys_map 	hstore
) returns hstore as $$

DECLARE
	expense_map hstore;
BEGIN
	--取得各项费用
	SELECT gamebox_expense_gather(start_time, end_time, 'TOP') INTO expense_map;
	-- raise info '各项费用:%', expense_map;
	--取得返佣值
	SELECT gamebox_occupy_value(start_time, end_time, expense_map) INTO expense_map;
	-- raise info 'occupy fee:%', expense_map;
	--计算费用分摊
	SELECT gamebox_expense_calculate(expense_map, sys_map, 'OCCUPY') INTO expense_map;
	-- raise info '费用分摊%', expense_map;

	RETURN expense_map;
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_expense_map(
start_time TIMESTAMP
,end_time TIMESTAMP
,sys_map hstore
) returns hstore as $$
DECLARE
	expense_map hstore;
BEGIN
		--取得各项费用
		select gamebox_expense_gather(start_time,end_time,'TOP') INTO expense_map;
		raise info '各项费用:%',expense_map;
		--取得返佣值
		SELECT gamebox_occupy_value(start_time,end_time,expense_map) INTO expense_map;
		--计算费用分摊
		SELECT gamebox_expense_calculate(expense_map,sys_map,'OCCUPY') INTO expense_map;
		raise info '费用分摊%',expense_map;
		RETURN expense_map;
END;
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_occupy_map(
	url 		text,
	start_time 	text,
	end_time 	text
) returns hstore[] as $$

DECLARE
	sys_map 				hstore;--系统设置各种承担比例.
  	occupy_grads_map 		hstore;--各API的占成设置
	operation_occupy_map 	hstore;--运营商各API占成比例.

	mhash 		hstore;--临时
	api_map 	hstore;--各API占成额
	cost_map 	hstore;--费用及分摊

	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;

	sid 		INT;--站点ID.

	is_max 		BOOLEAN:=true;
	-- key_type 	int:=4;
	-- category 	TEXT:='AGENT';
	key_type 	int:=5;
	category 	TEXT:='TOPAGENT';

BEGIN
	stTime = start_time::TIMESTAMP;
	edTime = end_time::TIMESTAMP;

	raise info '统计总代占成,时间( %-% )',start_time, end_time;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') into sys_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  	SELECT gamebox_occupy_api_set() into occupy_grads_map;

  	raise info '总代.API占成';
	SELECT gamebox_occupy_api_map(stTime, edTime, occupy_grads_map, operation_occupy_map) INTO api_map;

  	raise info '总代.费用及分摊';
	SELECT gamebox_occupy_expense_map(stTime, edTime, sys_map) INTO cost_map;
	-- raise info 'API占成:%',api_map;
	-- raise info '各项费用:%',cost_map;

	RETURN array[api_map, cost_map];
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_map(
	url 		text,
	start_time 	text,
	end_time 	text
) returns hstore[] as $$

DECLARE
	sys_map 				hstore;--系统设置各种承担比例.
  	occupy_grads_map 		hstore;--各API的占成设置
	operation_occupy_map 	hstore;--运营商各API占成比例.

	mhash 		hstore;--临时
	api_map 	hstore;--各API占成额
	cost_map 	hstore;--费用及分摊

	stTime 		TIMESTAMP;
	edTime 		TIMESTAMP;

	sid 		INT;--站点ID.

	is_max 		BOOLEAN:=true;
	-- key_type 	int:=4;
	-- category 	TEXT:='AGENT';
	key_type 	int:=5;
	category 	TEXT:='TOPAGENT';

BEGIN
	stTime = start_time::TIMESTAMP;
	edTime = end_time::TIMESTAMP;

	raise info '统计总代占成,时间( %-% )',start_time, end_time;

	raise info '占成.取得当前站点ID';
	SELECT gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	SELECT gamebox_sys_param('apportionSetting') into sys_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  	SELECT gamebox_occupy_api_set() into occupy_grads_map;

  	raise info '总代.API占成';
	SELECT gamebox_occupy_api_map(stTime, edTime, occupy_grads_map, operation_occupy_map) INTO api_map;

  	raise info '总代.费用及分摊';
	SELECT gamebox_occupy_expense_map(stTime, edTime, sys_map) INTO cost_map;
	-- raise info 'API占成:%',api_map;
	-- raise info '各项费用:%',cost_map;

	RETURN array[api_map, cost_map];
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_map(
url text
,start_time text
,end_time text
) returns hstore[] as $$
DECLARE
	sys_map hstore;--系统设置各种承担比例.
  occupy_grads_map hstore;--各API的占成设置
	operation_occupy_map hstore;--运营商各API占成比例.

	mhash hstore;--临时
	api_map hstore;--各API占成额
	cost_map hstore;--费用及分摊

	stTime TIMESTAMP;
	edTime TIMESTAMP;

	sid INT;--站点ID.

	is_max BOOLEAN:=true;
	key_type int:=4;
	category TEXT:='AGENT';
BEGIN
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	stTime=start_time::TIMESTAMP;
	edTime=end_time::TIMESTAMP;

	raise info '统计总代占成,时间( %-% )',start_time,end_time;

	raise info '占成.取得当前站点ID';
	select gamebox_current_site() INTO sid;

	raise info '占成.系统各种分摊比例参数';
	select gamebox_sys_param('apportionSetting') into sys_map;

	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	select gamebox_operations_occupy(url,sid,stTime,edTime
	,category,is_max,key_type) into operation_occupy_map;

	raise info '取得当前返佣梯度设置信息';
  select gamebox_occupy_api_set() into occupy_grads_map;

  raise info '总代.API占成';
	select gamebox_occupy_api_map(stTime,edTime,occupy_grads_map,operation_occupy_map) INTO api_map;

  raise info '总代.费用及分摊';
	select gamebox_occupy_expense_map(stTime,edTime,sys_map) INTO cost_map;
	--sys_map=(select ('site_id=>'||sid)::hstore)||sys_map;
	raise info 'API占成:%',api_map;
	raise info '各项费用:%',cost_map;
	RETURN array[api_map,cost_map];
END;
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_occupy_value(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	expense_map hstore
) returns hstore as $$

DECLARE
	rec 		record;
	key_name 	TEXT:='';
	param 		TEXT:='';
	name 		TEXT:='';

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	FOR rec IN EXECUTE
		'SELECT ut.""id""					as topagent_id,
			   ut.username				as name,
			   SUM (rp.rebate_total) 	as rebate_total
		  FROM rebate_bill rb
		  LEFT JOIN rebate_agent ra ON rb.""id"" = ra.rebate_bill_id
		  LEFT JOIN rebate_player rp ON rb.""id"" = rp.rebate_bill_id
		  LEFT JOIN sys_user su ON rp.user_id = su.""id""
		  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  LEFT JOIN sys_user ut ON ua.owner_id = ut.""id""
		 WHERE rb.start_time >= $1
		   AND rb.end_time <= $2
		   AND ra.settlement_state = ''lssuing''
		   AND su.user_type = ''24''
		   AND ua.user_type = ''23''
		   AND ut.user_type = ''22''
		 GROUP BY ut.""id"", ut.username'
	  	USING start_time, end_time
	LOOP
		key_name 	= rec.topagent_id::TEXT;
		name 		= rec.name;
		IF expense_map is null THEN
			param = 'user_name'||cs||name||rs||'rebate'||cs||rec.rebate_total::TEXT;
			SELECT key_name||'=>'||param INTO expense_map;
		ELSEIF exist(expense_map, key_name) THEN
			param = expense_map->key_name;
			param = param||rs||'rebate'||cs||rec.rebate_total::TEXT;
			expense_map = expense_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param = 'user_name'||cs||name||rs||'rebate'||cs||rec.rebate_total;
			expense_map = expense_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;
	END LOOP;

	RETURN expense_map;
END;

$$ language plpgsql;",V1.0.1.0039__C_gamebox_occupy.sql
"create or replace function gamebox_occupy_value(
	start_time TIMESTAMP,
	end_time TIMESTAMP,
	expense_map hstore
) returns hstore as $$

DECLARE
	rec 		record;
	key_name 	TEXT:='';
	param 		TEXT:='';
	name 		TEXT:='';

	sys_config 	hstore;
	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';

	FOR rec IN EXECUTE
		'SELECT ut.""id""					as topagent_id,
			   ut.username				as name,
			   SUM (rp.rebate_total) 	as rebate_total
		  FROM rebate_bill rb
		  LEFT JOIN rebate_agent ra ON rb.""id"" = ra.rebate_bill_id
		  LEFT JOIN rebate_player rp ON rb.""id"" = rp.rebate_bill_id
		  LEFT JOIN sys_user su ON rp.user_id = su.""id""
		  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  LEFT JOIN sys_user ut ON ua.owner_id = ut.""id""
		 WHERE rb.start_time >= $1
		   AND rb.end_time <= $2
		   AND ra.settlement_state = ''lssuing''
		   AND su.user_type = ''24''
		   AND ua.user_type = ''23''
		   AND ut.user_type = ''22''
		 GROUP BY ut.""id"", ut.username'
	  	USING start_time, end_time
	LOOP
		key_name 	= rec.topagent_id::TEXT;
		name 		= rec.name;
		IF expense_map is null THEN
			param = 'user_name'||cs||name||rs||'rebate'||cs||rec.rebate_total::TEXT;
			SELECT key_name||'=>'||param INTO expense_map;
		ELSEIF exist(expense_map, key_name) THEN
			param = expense_map->key_name;
			param = param||rs||'rebate'||cs||rec.rebate_total::TEXT;
			expense_map = expense_map||(SELECT (key_name||'=>'||param)::hstore);
		ELSE
			param = 'user_name'||cs||name||rs||'rebate'||cs||rec.rebate_total;
			expense_map = expense_map||(SELECT (key_name||'=>'||param)::hstore);
		END IF;
	END LOOP;

	RETURN expense_map;
END;

$$ language plpgsql;",V1.0.1.0099__U_gamebox_occupy.sql
"create or replace function gamebox_occupy_value(
start_time TIMESTAMP
,end_time TIMESTAMP
,expense_map hstore
) returns hstore as $$
DECLARE
	rec record;
	--cs text:='^';--列分隔符
	--rs text:='^&^';--行分隔符
	key_name TEXT:='';
	param TEXT:='';
	name TEXT:='';

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';

		FOR rec IN EXECUTE
			'SELECT u.topagent_id,u.topagent_name as name,SUM(a.rebate_total) rebate_total
			FROM rebate_bill b,rebate_agent a,v_sys_user_tier u
			WHERE b.id=a.rebate_bill_id
			AND b.start_time>=$1 AND b.end_time<$2
			AND a.agent_id=u.agent_id
			GROUP BY u.topagent_id,u.topagent_name '
		  USING start_time,end_time
		LOOP
			key_name=rec.topagent_id::TEXT;
			name=rec.name;
			IF expense_map is null THEN
				param='user_name'||cs||name||rs||'rebate'||cs||rec.rebate_total::TEXT;
				SELECT key_name||'=>'||param INTO expense_map;
			ELSEIF exist(expense_map,key_name) THEN
				param=expense_map->key_name;
				param=param||rs||'rebate'||cs||rec.rebate_total::TEXT;
				expense_map=expense_map||(SELECT (key_name||'=>'||param)::hstore);
			ELSE
				param='user_name'||cs||name||rs||'rebate'||cs||re.rebate_total;
				expense_map=expense_map||(SELECT (key_name||'=>'||param)::hstore);
			END IF;
		END LOOP;
		RETURN expense_map;
END;
$$ language plpgsql;",V1.0.1.0264__E_gamebox_occupy.sql
"create or replace function gamebox_operation_favorable_calculate(
  favorable_map 	hstore,
  amount 			FLOAT
)returns hstore as $$
DECLARE
	val 				TEXT;
	keys 				TEXT[];
	key_name 			TEXT;
	favourable_grads 	TEXT:='';	-- 优惠满足梯度
	favourable_way 		TEXT:='';	-- 优惠方式(1:固定, 2:比例)
	favourable_value 	TEXT:='';	-- 优惠值
	favourable_limit 	TEXT:='';	-- 优惠上限
	actual_value		TEXT:='';	-- 实付值
	map 				hstore;
BEGIN
	IF favorable_map is null OR amount <= 0 THEN
		SELECT put(map, 'grads', '0') INTO map;
		SELECT put(map, 'limit', '0') INTO map;
		SELECT put(map, 'value', '0') INTO map;
		SELECT put(map, 'way', '0') INTO map;
	ELSE
		keys = akeys(favorable_map);
		FOR i IN REVERSE array_length(keys,  1)..1
		LOOP
			IF amount > (keys[i]::FLOAT) THEN
				key_name = keys[i];
				exit;
			END IF;
		END LOOP;

		val = favorable_map->key_name;
		--val格式:梯度下限_梯度上限_优惠类型_优惠方式_优惠值_优惠上限
		keys = regexp_split_to_array(val, '_');
		--raise info 'vals:%', keys;
		IF array_length(keys,  1) = 6 THEN
			favourable_grads = COALESCE(keys[2], '0');	-- 梯度值
			favourable_way = COALESCE(keys[4], '1');	-- 优惠方式(1:固定, 2:比例)
			favourable_value = COALESCE(keys[5], '0');	-- 优惠值
			favourable_limit = COALESCE(keys[6], '0');	-- 上限

			IF favourable_way = '2' THEN--比例
				favourable_value = (amount * (favourable_value::FLOAT) / 100)::TEXT;
			END IF;

			actual_value = favourable_value;
			IF favourable_limit::FLOAT > 0 AND favourable_value::FLOAT > favourable_limit::FLOAT THEN--超过上限
			 	actual_value = favourable_limit;
			END IF;

			SELECT put(map, 'grads', favourable_grads) INTO map;
			SELECT put(map, 'limit', favourable_limit) INTO map;
			SELECT put(map, 'value', favourable_value) INTO map;
			SELECT put(map, 'way', favourable_way) INTO map;
			SELECT put(map, 'actual', actual_value) INTO map;
		END IF;
	END IF;
	IF map is null THEN
		SELECT put(map, 'grads', '0') INTO map;
		SELECT put(map, 'limit', '0') INTO map;
		SELECT put(map, 'value', '0') INTO map;
		SELECT put(map, 'way', '0') INTO map;
	END IF;
	RETURN map;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_favorable_calculate(
favorable_map hstore
,amount FLOAT
)returns hstore as $$
DECLARE
	val TEXT;
	keys TEXT[];
	key_name TEXT;
	favourable_grads TEXT:='';--优惠满足梯度
	favourable_way TEXT:='';--优惠方式(1:固定,2:比例)
	favourable_value TEXT:='';--优惠值
	favourable_limit TEXT:='';--优惠上限
	map hstore;
BEGIN
	IF favorable_map is null OR amount<=0 THEN
		SELECT put(map,'grads','0') INTO map;
		SELECT put(map,'limit','0') INTO map;
		SELECT put(map,'value','0') INTO map;
		SELECT put(map,'way','0') INTO map;
	ELSE
		keys=akeys(favorable_map);
		FOR i IN REVERSE array_length(keys, 1)..1 LOOP

			IF amount>(keys[i]::FLOAT) THEN
				key_name=keys[i];
				exit;
			END IF;
		END LOOP;
		val=favorable_map->key_name;
		--val格式:梯度下限_梯度上限_优惠类型_优惠方式_优惠值_优惠上限
		keys=regexp_split_to_array(val,'_');
		--raise info 'vals:%',keys;
		IF array_length(keys, 1)=6 THEN
				favourable_grads=COALESCE(keys[2],'0');--梯度值
				favourable_way=COALESCE(keys[4],'1');--优惠方式(1:固定,2:比例)
				favourable_value=COALESCE(keys[5],'0');--优惠值
				favourable_limit=COALESCE(keys[6],'0');--上限
				IF favourable_way='2' THEN--比例
					favourable_value=(amount*(favourable_value::FLOAT)/100)::TEXT;
				END IF;
				IF favourable_limit::FLOAT>0 AND favourable_value::FLOAT>favourable_limit::FLOAT THEN--超过上限
					favourable_value=favourable_limit;
				END IF;
				--raise info 'way=%',favourable_way;
				SELECT put(map,'grads',favourable_grads) INTO map;
				SELECT put(map,'limit',favourable_limit) INTO map;
				SELECT put(map,'value',favourable_value) INTO map;
				SELECT put(map,'way',favourable_way) INTO map;
		END IF;
	END IF;
	IF map is null THEN
		SELECT put(map,'grads','0') INTO map;
		SELECT put(map,'limit','0') INTO map;
		SELECT put(map,'value','0') INTO map;
		SELECT put(map,'way','0') INTO map;
	END IF;
	RETURN map;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT
) RETURNS refcursor as $$

DECLARE
	cur refcursor;
BEGIN
	IF category = 'AGENT' THEN 	--代理
    	OPEN cur FOR
           	SELECT su.owner_id,
				   su.""id"",
				   rab.api_id,
				   rab.game_type,
				   COUNT(DISTINCT rab.player_id)					as player_num,
				   COALESCE(SUM(-rab.profit_loss), 0.00)			as profit_amount,
				   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
			  FROM rakeback_api_base rab
			  LEFT JOIN sys_user su ON rab.player_id = su.""id""
			 WHERE rab.rakeback_time >= start_time
			   AND rab.rakeback_time < end_time
			 GROUP BY su.owner_id, su.""id"", rab.api_id, rab.game_type
			 ORDER BY su.owner_id;

	ELSEIF category = 'TOPAGENT' THEN 	--总代.
    	OPEN cur FOR
           	SELECT ua.owner_id,
				   su.""id"",
				   rab.api_id,
				   rab.game_type,
				   COUNT(DISTINCT rab.player_id)					as player_num,
				   COALESCE(SUM(-rab.profit_loss), 0.00)			as profit_amount,
				   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
			  FROM rakeback_api_base rab
			  LEFT JOIN sys_user su ON rab.player_id = su.""id""
			  LEFT JOIN sys_user ua ON su.owner_id = ua.id
			 WHERE rab.rakeback_time >= start_time
			   AND rab.rakeback_time < end_time
			   AND su.user_type = '24'
			   AND ua.user_type = '23'
			 GROUP BY ua.owner_id, su.""id"", rab.api_id, rab.game_type
			 ORDER BY ua.owner_id;
	ELSE 	--站点统计
	   	OPEN cur FOR
           	SELECT rab.api_id,
				   rab.game_type,
				   COUNT(DISTINCT rab.player_id)					as player_num,
				   COALESCE(SUM(-rab.profit_loss), 0.00)			as profit_amount,
				   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
			  FROM rakeback_api_base rab
			 WHERE rab.rakeback_time >= start_time
			   AND rab.rakeback_time < end_time
			 GROUP BY rab.api_id, rab.game_type;
	END IF;

	-- raise info '------ cur = %', cur;
	RETURN cur;
END

$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operation_occupy(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	flag 		TEXT
) RETURNS refcursor as $$

DECLARE
	cur 			refcursor;
	settle_state	TEXT:='settle';
BEGIN

	IF flag = 'N' THEN
		-- settle_state = 'pending_settle';
	END IF;

	IF category = 'AGENT' THEN 	--代理
    	OPEN cur FOR
			SELECT ua.""id"" owner_id, pg.*
			  FROM (SELECT pgo.player_id ""id"",
						   pgo.api_id,
						   pgo.game_type,
						   COUNT(DISTINCT pgo.player_id)					as player_num,
						   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
						   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
					  FROM player_game_order pgo
					 WHERE pgo.create_time >= start_time
					   AND pgo.create_time <= end_time
					   AND pgo.order_state = settle_state
					   AND pgo.is_profit_loss = TRUE
					 GROUP BY pgo.player_id, pgo.api_id, pgo.game_type) pg
			  LEFT JOIN sys_user su ON pg.""id"" = su.""id""
			  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
			 WHERE su.user_type = '24'
			   AND ua.user_type = '23'
			 ORDER BY ua.id;

	ELSEIF category = 'TOPAGENT' THEN 	--总代.
    	OPEN cur FOR
           	SELECT ut.""id"" owner_id, pg.*
			  FROM (SELECT pgo.player_id ""id"",
						   pgo.api_id,
						   pgo.game_type,
						   COUNT(DISTINCT pgo.player_id)					as player_num,
						   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
						   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
					  FROM player_game_order pgo
					 WHERE pgo.create_time >= '2016-04-01'::TIMESTAMP
					   AND pgo.create_time <= '2016-04-30'::TIMESTAMP
					   AND pgo.order_state = settle_state
					   AND pgo.is_profit_loss = TRUE
					 GROUP BY pgo.player_id, pgo.api_id, pgo.game_type) pg
			  LEFT JOIN sys_user su ON pg.""id"" = su.""id""
			  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
			  LEFT JOIN sys_user ut ON ua.owner_id = ut.""id""
			 WHERE su.user_type = '24'
			   AND ua.user_type = '23'
			   AND ut.user_type = '22'
			 ORDER BY ut.""id"";
	ELSE 	--站点统计
	   	OPEN cur FOR
           	SELECT pgo.api_id,
				   pgo.game_type,
				   COUNT(DISTINCT pgo.player_id)					as player_num,
				   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
				   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
			  FROM player_game_order pgo
			 WHERE pgo.create_time >= '2016-04-01'::TIMESTAMP
			   AND pgo.create_time <= '2016-04-30'::TIMESTAMP
			   AND pgo.order_state = settle_state
			   AND pgo.is_profit_loss = TRUE
			 GROUP BY pgo.api_id, pgo.game_type;
	END IF;

	-- raise info '------ cur = %', cur;
	RETURN cur;
END

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_operation_occupy(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	flag 		TEXT
) RETURNS refcursor as $$

DECLARE
	cur 			refcursor;
	settle_state	TEXT:='settle';
BEGIN

	IF flag = 'N' THEN
		settle_state = 'pending_settle';
	END IF;

	IF category = 'AGENT' THEN 	--代理
    	OPEN cur FOR
			SELECT ua.""id"" owner_id, pg.*
			  FROM (SELECT pgo.player_id ""id"",
						   pgo.api_id,
						   pgo.game_type,
						   COUNT(DISTINCT pgo.player_id)					as player_num,
						   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
						   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
					  FROM player_game_order pgo
					 WHERE pgo.create_time >= start_time
					   AND pgo.create_time <= end_time
					   AND pgo.order_state = settle_state
					   AND pgo.is_profit_loss = TRUE
					 GROUP BY pgo.player_id, pgo.api_id, pgo.game_type) pg
			  LEFT JOIN sys_user su ON pg.""id"" = su.""id""
			  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
			 WHERE su.user_type = '24'
			   AND ua.user_type = '23'
			 ORDER BY ua.id;

	ELSEIF category = 'TOPAGENT' THEN 	--总代.
    	OPEN cur FOR
           	SELECT ut.""id"" owner_id, pg.*
			  FROM (SELECT pgo.player_id ""id"",
						   pgo.api_id,
						   pgo.game_type,
						   COUNT(DISTINCT pgo.player_id)					as player_num,
						   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
						   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
					  FROM player_game_order pgo
					 WHERE pgo.create_time >= '2016-04-01'::TIMESTAMP
					   AND pgo.create_time <= '2016-04-30'::TIMESTAMP
					   AND pgo.order_state = settle_state
					   AND pgo.is_profit_loss = TRUE
					 GROUP BY pgo.player_id, pgo.api_id, pgo.game_type) pg
			  LEFT JOIN sys_user su ON pg.""id"" = su.""id""
			  LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
			  LEFT JOIN sys_user ut ON ua.owner_id = ut.""id""
			 WHERE su.user_type = '24'
			   AND ua.user_type = '23'
			   AND ut.user_type = '22'
			 ORDER BY ut.""id"";
	ELSE 	--站点统计
	   	OPEN cur FOR
           	SELECT pgo.api_id,
				   pgo.game_type,
				   COUNT(DISTINCT pgo.player_id)					as player_num,
				   COALESCE(SUM(-pgo.profit_amount), 0.00)			as profit_amount,
				   COALESCE(SUM(-pgo.effective_trade_amount), 0.00)	as effective_trade_amount
			  FROM player_game_order pgo
			 WHERE pgo.create_time >= '2016-04-01'::TIMESTAMP
			   AND pgo.create_time <= '2016-04-30'::TIMESTAMP
			   AND pgo.order_state = settle_state
			   AND pgo.is_profit_loss = TRUE
			 GROUP BY pgo.api_id, pgo.game_type;
	END IF;

	-- raise info '------ cur = %', cur;
	RETURN cur;
END

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_operation_occupy(start_time TIMESTAMP,end_time TIMESTAMP,category TEXT) RETURNS refcursor as $$
DECLARE
	cur refcursor;
BEGIN
	IF category='AGENT' THEN
		--代理
    OPEN cur FOR
           SELECT
            u.owner_id,
						u.id,
            g.api_id,
            g.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o,v_site_game g,sys_user u
	          where
            o.create_time>=start_time and o.create_time<end_time and
            o.game_id=g.id and o.player_id=u.id
            group by u.owner_id,u.id,g.api_id,g.game_type
					  order by u.owner_id;

	ELSEIF category='TOPAGENT' THEN
		--总代.
    OPEN cur FOR
           SELECT
            a.owner_id,--代理的总代
						u.id,
            g.api_id,
            g.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o,v_site_game g,sys_user u,sys_user a
	          where
            o.create_time>=start_time and o.create_time<end_time
            and o.game_id=g.id
						and o.player_id=u.id
						and u.user_type='24' --TYPE 为玩家
						and u.owner_id=a.id --代理
					  and a.user_type='23' --TYPE 为代理
            group by a.owner_id,u.id,g.api_id,g.game_type
					  order by a.owner_id	;
	ELSE
	--站点统计
	   OPEN cur FOR
           SELECT
            g.api_id,
            g.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o,v_site_game g
	          where o.create_time>=start_time and o.create_time<end_time
            and o.game_id=g.id
            group by g.api_id,g.game_type;

	END IF;
	RETURN cur;
END
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_operation_occupy(start_time TIMESTAMP,end_time TIMESTAMP,category TEXT) RETURNS refcursor as $$
DECLARE
	cur refcursor;
BEGIN
	IF category='AGENT' THEN
		--代理
    OPEN cur FOR
           SELECT
            u.owner_id,
						u.id,
            o.api_id,
            o.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o,sys_user u
	          where
            o.create_time>=start_time and o.create_time<end_time
            and o.player_id=u.id
            group by u.owner_id,u.id,o.api_id,o.game_type
					  order by u.owner_id;

	ELSEIF category='TOPAGENT' THEN
		--总代.
    OPEN cur FOR
           SELECT
            a.owner_id,--代理的总代
						u.id,
            o.api_id,
            o.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o,sys_user u,sys_user a
	          where
            o.create_time>=start_time and o.create_time<end_time
						and o.player_id=u.id
						and u.user_type='24' --TYPE 为玩家
						and u.owner_id=a.id --代理
					  and a.user_type='23' --TYPE 为代理
            group by a.owner_id,u.id,o.api_id,o.game_type
					  order by a.owner_id	;
	ELSE
	--站点统计
	   OPEN cur FOR
           SELECT
            o.api_id,
            o.game_type,
						count(DISTINCT o.player_id) player_num,
						COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
            COALESCE(sum(o.effective_trade_amount),0.00) AS effective_trade_amount
            from player_game_order o
	          where o.create_time>=start_time and o.create_time<end_time
            group by o.api_id,o.game_type;

	END IF;
	RETURN cur;
END
$$ language plpgsql;",V1.0.1.0263__E_gamebox_operations_occupy.sql
"create or replace function gamebox_operation_occupy_api(
  url 		TEXT,
  start_time 	TEXT,
  end_time 	TEXT
) returns refcursor as $$
DECLARE
	cur refcursor;
BEGIN
    OPEN cur FOR
    	SELECT * FROM dblink(
    		url,
    		'SELECT o.api_id,
    				o.game_type,
    				COALESCE(sum(-o.profit_amount), 0.00) 			as profit_amount,
    				COALESCE(sum(o.effective_trade_amount), 0.00)  	as trade_amount
			   FROM player_game_order o
			  WHERE o.create_time >='''||start_time||'''
				AND o.create_time < '''||end_time||'''
			  GROUP BY o.api_id, o.game_type '
		) as p(api_id INT, game_type VARCHAR, profit_amount NUMERIC, trade_amount NUMERIC);
	return cur;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_api(
url TEXT
,start_time TEXT
,end_time TEXT
) returns refcursor as $$
DECLARE
	cur refcursor;
BEGIN
    OPEN cur FOR  SELECT * FROM dblink('host=192.168.0.88 dbname=gamebox-master user=postgres password=postgres','
		SELECT o.api_id,o.game_type,
		COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
		COALESCE(sum(o.effective_trade_amount),0.00) AS trade_amount
		from player_game_order o where
		o.create_time>='''||start_time||'''
		and o.create_time<'''||end_time||'''
		group by o.api_id,o.game_type ')
		as p(api_id INT,game_type VARCHAR,profit_amount NUMERIC,trade_amount NUMERIC);
	return cur;
END;
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_api(
url TEXT
,start_time TEXT
,end_time TEXT
) returns refcursor as $$
DECLARE
	cur refcursor;
BEGIN
    OPEN cur FOR  SELECT * FROM dblink('host=192.168.0.88 dbname=gamebox-master user=postgres password=postgres','
		SELECT o.api_id,o.game_type,
		COALESCE(sum(-o.profit_amount),0.00) as profit_amount,
		COALESCE(sum(o.effective_trade_amount),0.00) AS trade_amount
		from player_game_order o where
		o.create_time>='''||start_time||'''
		and o.create_time<'''||end_time||'''
		group by o.api_id,o.game_type ')
		as p(api_id INT,game_type VARCHAR,profit_amount NUMERIC,trade_amount NUMERIC);
	return cur;
END;
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_calculate(
	limit_values 	FLOAT[],
	retios 			FLOAT[],
	amount 			FLOAT,
	assume 			BOOLEAN
) returns FLOAT as $$
DECLARE
	val 		FLOAT;
	pre_value 	FLOAT:=0.00;
	occupy 		FLOAT:=0.00;
	cal_amount 	FLOAT:=0.00;
	o_val 		FLOAT;
	c_val 		FLOAT;	-- 当前上限值.
	retio 		FLOAT;	-- 当前占成比例.
	re_occupy	FLOAT:=0.00;
BEGIN
	val = amount;
	IF assume AND val < 0 THEN
		amount = -amount;
	ELSEIF assume = false AND val < 0 THEN
		raise info '盈亏不共担, 盈亏为负时, 占成计0';
		RETURN 0.00;	-- 盈亏不共担, 计税金额为负时, 占成计0.
	END IF;

	raise info '各API盈亏 = %', amount;
	IF array_length(limit_values, 1) = array_length(retios, 1) THEN
		FOR i IN 1..array_length(limit_values, 1) LOOP
			IF amount < 0 THEN
			 	exit;
			END IF;

			c_val = limit_values[i];
			-- raise info '------ val = %, c_val1 = %', val, c_val;
			-- 盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val < 0 AND c_val < 0 THEN
				c_val = -c_val;
			END IF;

			-- raise info '------ c_val2 = %', c_val;
			retio = retios[i];
			cal_amount = c_val - pre_value;
			amount = amount - cal_amount;
			-- raise info '------ retio = %, cal_amount = %, amount = %, pre_value = %', retio, cal_amount, amount, pre_value;

			/*
			IF amount < 0 THEN
				o_val = (amount + cal_amount) * retio / 100;
				occupy = occupy + o_val;
				exit;
			ELSE
				o_val = cal_amount * retio / 100;
				occupy = occupy + o_val;
				pre_value = c_val;
			END IF;
			*/
			IF amount > 0 THEN
				o_val = cal_amount * retio / 100;
				occupy = occupy + o_val;
				pre_value = c_val;
			END IF;
		END LOOP;
	END IF;

	-- raise info '------ occupy1 = %', occupy;

	-- raise info '各API盈亏remind = %', amount;
	IF amount > 0 THEN
		SELECT gamebox_occupy_calculate(limit_values, retios, amount, assume) into re_occupy;
	END IF;
	occupy = occupy + re_occupy;

	-- raise info '------ val = %, occupy1 = %', val, occupy;
	IF val < 0 THEN
		occupy = -occupy;
	END IF;
	-- raise info '------ occupy2 = %', occupy;

	-- raise info '各API盈亏 = %, 占成 = %', val, occupy;
	RETURN occupy;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_calculate(
  limit_values 	FLOAT[],
  retios 			FLOAT[],
  amount 			FLOAT,
  assume 			BOOLEAN
) returns FLOAT as $$
DECLARE
	val 		FLOAT;
	pre_value 	FLOAT:=0.00;
	occupy 		FLOAT:=0.00;
	cal_amount 	FLOAT:=0.00;
	o_val 		FLOAT;
	c_val 		FLOAT;	-- 当前上限值.
	retio 		FLOAT;	-- 当前占成比例.
	re_occupy	FLOAT:=0.00;
BEGIN
	val = amount;
	IF assume AND val < 0 THEN
		amount = -amount;
	ELSEIF assume = false AND val < 0 THEN
		raise info '盈亏不共担, 盈亏为负时, 占成计0';
		RETURN 0.00;	-- 盈亏不共担, 计税金额为负时, 占成计0.
	END IF;

	raise info '各API盈亏 = %', amount;
	IF array_length(limit_values,  1) = array_length(retios,  1) THEN
		FOR i IN 1..array_length(limit_values,  1) LOOP
			IF amount < 0 THEN
			 	exit;
			END IF;

			c_val = limit_values[i];
			-- raise info '------ val = %, c_val1 = %', val, c_val;
			-- 盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val < 0 AND c_val < 0 THEN
				c_val = -c_val;
			END IF;

			-- raise info '------ c_val2 = %', c_val;
			retio = retios[i];
			cal_amount = c_val - pre_value;
			amount = amount - cal_amount;
			-- raise info '------ retio = %, cal_amount = %, amount = %, pre_value = %', retio, cal_amount, amount, pre_value;

			/*
			IF amount < 0 THEN
				o_val = (amount + cal_amount) * retio / 100;
				occupy = occupy + o_val;
				exit;
			ELSE
				o_val = cal_amount * retio / 100;
				occupy = occupy + o_val;
				pre_value = c_val;
			END IF;
			*/
			IF amount > 0 THEN
				o_val = cal_amount * retio / 100;
				occupy = occupy + o_val;
				pre_value = c_val;
			END IF;
		END LOOP;
	END IF;

	raise info '------ occupy1 = %', occupy;

	raise info '各API盈亏remind = %', amount;
	IF amount > 0 THEN
		SELECT gamebox_occupy_calculate(limit_values, retios, amount, assume) into re_occupy;
	END IF;
	occupy = occupy + re_occupy;

	-- raise info '------ val = %, occupy1 = %', val, occupy;
	IF val < 0 THEN
		occupy = -occupy;
	END IF;
	raise info '------ occupy2 = %', occupy;

	-- raise info '各API盈亏 = %, 占成 = %', val, occupy;
	RETURN occupy;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_calculate(
limit_values FLOAT[]
,retios FLOAT[]
,amount FLOAT
,assume BOOLEAN
)
returns FLOAT as $$
DECLARE
	val FLOAT;
	pre_value FLOAT:=0.00;
	occupy FLOAT:=0.00;
	cal_amount FLOAT:=0.00;
	o_val FLOAT;
	c_val FLOAT;--当前上线值.
	retio FLOAT;--当前占成比例.
BEGIN
	val=amount;
	IF assume AND val<0 THEN
		amount=-amount;
	ELSEIF assume=false AND val<0 THEN
		raise info '盈亏不共担,计税金额为负时,占成计0';
		RETURN 0.00;--盈亏不共担,计税金额为负时,占成计0.
	END IF;
	raise info '计税金额:%',amount;
	IF array_length(limit_values, 1)=array_length(retios, 1) THEN
		FOR i IN 1..array_length(limit_values, 1) LOOP
			--raise info 'limit_values:%',limit_values[1:1][1]::FLOAT;
			IF amount<0 THEN
				exit;
			END IF;
			c_val=limit_values[i];
			--盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val<0 AND c_val<0 THEN
				c_val=-c_val;
			END IF;
			retio=retios[i];
			cal_amount=c_val-pre_value;
			amount=amount-cal_amount;
			IF amount<0 THEN
				o_val=(amount+cal_amount)*retio/100;
				raise info '梯度范围:%~%,计税额:%,比例:%,税额:%',pre_value,c_val,(amount+cal_amount),retio||'%',o_val;
				occupy=occupy+o_val;
				exit;
			ELSE
				o_val=cal_amount*retio/100;
				raise info '梯度范围:%~%,计税额:%,比例:%,税额:%',pre_value,c_val,cal_amount,retio||'%',o_val;
				occupy=occupy+o_val;
				pre_value=c_val;
			END IF;
		END LOOP;
	END IF;
	raise info '计税金额:%,税额:%',val,occupy;
	RETURN occupy;
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_calculate(
limit_values FLOAT[]
,retios FLOAT[]
,amount FLOAT
,assume BOOLEAN
)
returns FLOAT as $$
DECLARE
	val FLOAT;
	pre_value FLOAT:=0.00;
	occupy FLOAT:=0.00;
	cal_amount FLOAT:=0.00;
	o_val FLOAT;
	c_val FLOAT;--当前上线值.
	retio FLOAT;--当前占成比例.
BEGIN
	val=amount;
	IF assume AND val<0 THEN
		amount=-amount;
	ELSEIF assume=false AND val<0 THEN
		raise info '盈亏不共担,计税金额为负时,占成计0';
		RETURN 0.00;--盈亏不共担,计税金额为负时,占成计0.
	END IF;
	raise info '计税金额:%',amount;
	IF array_length(limit_values, 1)=array_length(retios, 1) THEN
		FOR i IN 1..array_length(limit_values, 1) LOOP
			--raise info 'limit_values:%',limit_values[1:1][1]::FLOAT;
			IF amount<0 THEN
				exit;
			END IF;
			c_val=limit_values[i];
			--盈亏共担 且 计税金额为负 且 当前梯度为负
			IF assume AND val<0 AND c_val<0 THEN
				c_val=-c_val;
			END IF;
			retio=retios[i];
			cal_amount=c_val-pre_value;
			amount=amount-cal_amount;
			IF amount<0 THEN
				o_val=(amount+cal_amount)*retio/100;
				raise info '梯度范围:%~%,计税额:%,比例:%,税额:%',pre_value,c_val,(amount+cal_amount),retio||'%',o_val;
				occupy=occupy+o_val;
				exit;
			ELSE
				o_val=cal_amount*retio/100;
				raise info '梯度范围:%~%,计税额:%,比例:%,税额:%',pre_value,c_val,cal_amount,retio||'%',o_val;
				occupy=occupy+o_val;
				pre_value=c_val;
			END IF;
		END LOOP;
	END IF;
	raise info '计税金额:%,税额:%',val,occupy;
	RETURN occupy;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
    val 		TEXT,
    subscript 	INT
) returns FLOAT[] as $$
DECLARE
	vals 	TEXT[];
	subs 	TEXT[];
	cs 		TEXT = '_';
	rs 		TEXT = '\^&\^';
	limit_values FLOAT[];
BEGIN
	-- ""1_01""=>""0_1000000_50^&^1000000_2000000_40^&^2000000_3000000_30""
	-- API 1,GameType 01在0到1000000比例为50...
	IF val is not null THEN
		vals = regexp_split_to_array(val, rs);
		-- raise info 'vals = %', vals;

		IF vals is not null AND array_length(vals,  1) > 0 THEN

			FOR i IN 1..array_length(vals,  1) LOOP
				subs = regexp_split_to_array(vals[i], cs);

				IF subs is not null AND array_length(subs,  1) = 3 THEN
					IF limit_values is null THEN
						limit_values = array[subs[subscript]::FLOAT];
					ELSE
						limit_values = array_append(limit_values, subs[subscript]::FLOAT);
					END IF;
				END IF;

			END LOOP;

		END IF;
	END IF;
	RETURN limit_values;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
  val 		TEXT,
  subscript 	INT
) returns FLOAT[] as $$
DECLARE
	vals 	TEXT[];
	subs 	TEXT[];
	cs 		TEXT = '_';
	rs 		TEXT = '\^&\^';
	limit_values FLOAT[];
BEGIN
	-- ""1_01""=>""0_1000000_50^&^1000000_2000000_40^&^2000000_3000000_30""
	-- API 1,GameType 01在0到1000000比例为50...
	IF val is not null THEN
		vals = regexp_split_to_array(val, rs);
		-- raise info 'vals = %', vals;

		IF vals is not null AND array_length(vals,  1) > 0 THEN

			FOR i IN 1..array_length(vals,  1) LOOP
				subs = regexp_split_to_array(vals[i], cs);

				IF subs is not null AND array_length(subs,  1) = 3 THEN
					IF limit_values is null THEN
						limit_values = array[subs[subscript]::FLOAT];
					ELSE
						limit_values = array_append(limit_values, subs[subscript]::FLOAT);
					END IF;
				END IF;

			END LOOP;

		END IF;
	END IF;
	RETURN limit_values;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
val TEXT
,subscript INT
)
returns FLOAT[] as $$
DECLARE
	vals TEXT[];
	subs TEXT[];
	cs TEXT='_';
	rs TEXT='\^&\^';
	limit_values FLOAT[];
	--retios FLOAT[];
BEGIN
	--val=map->key;
	--0_100_2^&^100_200_1^&^200_300_1^&^300_400_1^&^400_500_2
	IF val is not null THEN
		vals=regexp_split_to_array(val,rs);
		raise info 'vals=%',vals;
		IF vals is not null AND array_length(vals, 1)>0 THEN
			FOR i IN 1..array_length(vals, 1) LOOP
				subs=regexp_split_to_array(vals[i],cs);
				IF subs is not null AND array_length(subs, 1)=3 THEN
					IF limit_values is null THEN
						limit_values=array[subs[subscript]::FLOAT];
						--retios=array[subs[3]::FLOAT];
					ELSE
						limit_values=array_append(limit_values, subs[subscript]::FLOAT);
						--retios=array_append(retios, subs[3]::FLOAT);
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;
	RETURN limit_values;
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_operation_occupy_to_array(
val TEXT
,subscript INT
)
returns FLOAT[] as $$
DECLARE
	vals TEXT[];
	subs TEXT[];
	cs TEXT='_';
	rs TEXT='\^&\^';
	limit_values FLOAT[];
	--retios FLOAT[];
BEGIN
	--val=map->key;
	--0_100_2^&^100_200_1^&^200_300_1^&^300_400_1^&^400_500_2
	IF val is not null THEN
		vals=regexp_split_to_array(val,rs);
		raise info 'vals=%',vals;
		IF vals is not null AND array_length(vals, 1)>0 THEN
			FOR i IN 1..array_length(vals, 1) LOOP
				subs=regexp_split_to_array(vals[i],cs);
				IF subs is not null AND array_length(subs, 1)=3 THEN
					IF limit_values is null THEN
						limit_values=array[subs[subscript]::FLOAT];
						--retios=array[subs[3]::FLOAT];
					ELSE
						limit_values=array_append(limit_values, subs[subscript]::FLOAT);
						--retios=array_append(retios, subs[3]::FLOAT);
					END IF;
				END IF;
			END LOOP;
		END IF;
	END IF;
	RETURN limit_values;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_operations_occupy(
	hashs 		hstore[],
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT
) returns hstore as $$

DECLARE
	hash 		hstore;
	rec 		record;
	cur 		refcursor;
	amount 		FLOAT:=0.00;
	temp_amount FLOAT:=0.00;
	keyname 	TEXT:='';
	col_split 	TEXT:='_';

BEGIN
	--计算占成
	SELECT gamebox_operation_occupy(start_time, end_time, category) INTO cur;
	FETCH cur into rec;
	WHILE FOUND LOOP

		keyname = rec.owner_id::TEXT;
		IF key_type = 3 THEN
			keyname = (rec.id::TEXT);
		ELSIF key_type = 4 THEN
			keyname = (rec.id::TEXT);
			keyname = keyname||col_split||(rec.api_id::TEXT);
			keyname = keyname||col_split||(rec.game_type::TEXT);
		ELSIF key_type = 5 THEN
			keyname = rec.api_id::TEXT;
			keyname = keyname||col_split||(rec.game_type::TEXT);
		END IF;

		amount = 0.00;
		temp_amount = 0.00;
		SELECT gamebox_operations_occupy_calculate(hashs[2], row_to_json(rec), category) INTO amount;

		IF hash is NULL THEN
			SELECT keyname||'=>'||amount INTO hash;
		ELSEIF isexists(hash, keyname) THEN
			temp_amount = (hash->keyname)::float;
			amount = amount + temp_amount;
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		ELSE
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		END IF;
		FETCH cur INTO rec;

	END LOOP;

	CLOSE cur;
	return hash;
END;

$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operations_occupy(
	hashs 		hstore[],
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT,
	flag 		TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;
	rec 		record;
	cur 		refcursor;
	amount 		FLOAT:=0.00;
	temp_amount FLOAT:=0.00;
	keyname 	TEXT:='';
	col_split 	TEXT:='_';

BEGIN
	--计算占成
	SELECT gamebox_operation_occupy(start_time, end_time, category, flag) INTO cur;
	FETCH cur into rec;
	WHILE FOUND LOOP

		IF key_type = 3 THEN
			keyname = (rec.id::TEXT);
		ELSIF key_type = 4 THEN
			keyname = (rec.id::TEXT);
			keyname = keyname||col_split||(rec.api_id::TEXT);
			keyname = keyname||col_split||(rec.game_type::TEXT);
		ELSIF key_type = 5 THEN
			keyname = rec.api_id::TEXT;
			keyname = keyname||col_split||(rec.game_type::TEXT);
		ELSE
			keyname = rec.owner_id::TEXT;
		END IF;

		amount = 0.00;
		temp_amount = 0.00;
		SELECT gamebox_operations_occupy_calculate(hashs[2], row_to_json(rec), category) INTO amount;

		IF hash is NULL THEN
			SELECT keyname||'=>'||amount INTO hash;
		ELSEIF isexists(hash, keyname) THEN
			temp_amount = (hash->keyname)::float;
			amount = amount + temp_amount;
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		ELSE
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		END IF;
		FETCH cur INTO rec;

	END LOOP;

	CLOSE cur;
	return hash;
END;

$$ language plpgsql;",5_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(
	hashs 		hstore[],
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT,
	flag 		TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;
	rec 		record;
	cur 		refcursor;
	amount 		FLOAT:=0.00;
	temp_amount FLOAT:=0.00;
	keyname 	TEXT:='';
	col_split 	TEXT:='_';

BEGIN
	--计算占成
	SELECT gamebox_operation_occupy(start_time, end_time, category, flag) INTO cur;
	FETCH cur into rec;
	WHILE FOUND LOOP

		keyname = rec.owner_id::TEXT;
		IF key_type = 3 THEN
			keyname = (rec.id::TEXT);
		ELSIF key_type = 4 THEN
			keyname = (rec.id::TEXT);
			keyname = keyname||col_split||(rec.api_id::TEXT);
			keyname = keyname||col_split||(rec.game_type::TEXT);
		ELSIF key_type = 5 THEN
			keyname = rec.api_id::TEXT;
			keyname = keyname||col_split||(rec.game_type::TEXT);
		END IF;

		amount = 0.00;
		temp_amount = 0.00;
		SELECT gamebox_operations_occupy_calculate(hashs[2], row_to_json(rec), category) INTO amount;

		IF hash is NULL THEN
			SELECT keyname||'=>'||amount INTO hash;
		ELSEIF isexists(hash, keyname) THEN
			temp_amount = (hash->keyname)::float;
			amount = amount + temp_amount;
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		ELSE
			hash = hash||(SELECT (keyname||'=>'||amount)::hstore);
		END IF;
		FETCH cur INTO rec;

	END LOOP;

	CLOSE cur;
	return hash;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	site_id 	int,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	is_max 		BOOLEAN,
	key 		INT
) returns hstore as $$

DECLARE
	hashs hstore[];
	hash hstore;

BEGIN
	--取得当前站点的包网方案
	SELECT * FROM dblink(url, 'SELECT gamebox_contract('||site_id||', '||is_max||')') as a(hash hstore[]) INTO hashs;
  	SELECT gamebox_operations_occupy(hashs, start_time, end_time, category, key) INTO hash;
	--raise info '%', hash;
	return hash;
END;

$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	site_id 	int,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	is_max 		BOOLEAN,
	key 		INT,
	flag 		TEXT
) returns hstore as $$

DECLARE
	hashs hstore[];
	hash hstore;

BEGIN
	--取得当前站点的包网方案
	SELECT * FROM dblink(url, 'SELECT gamebox_contract('||site_id||', '||is_max||')') as a(hash hstore[]) INTO hashs;
  	SELECT gamebox_operations_occupy(hashs, start_time, end_time, category, key, flag) INTO hash;
	--raise info '%', hash;
	return hash;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	site_id 	int,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	is_max 		BOOLEAN,
	key 		INT,
	flag 		TEXT
) returns hstore as $$

DECLARE
	hashs hstore[];
	hash hstore;

BEGIN
	--取得当前站点的包网方案
	SELECT * FROM dblink(url, 'SELECT gamebox_contract('||site_id||', '||is_max||')') as a(hash hstore[]) INTO hashs;
  	SELECT gamebox_operations_occupy(hashs, start_time, end_time, category, key, flag) INTO hash;
	return hash;
END;

$$ language plpgsql;",5_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT
) returns hstore as $$

DECLARE
	sid 	int;
	is_max 	BOOLEAN:=TRUE;
	hash 	hstore;
	hashs 	hstore[];
	tmp 	int:=0;

BEGIN
  	--取得当前站点.
	SELECT gamebox_current_site() INTO sid;
	--取得当前站点的包网方案
	SELECT gamebox_operations_occupy(url, sid, start_time, end_time, category, is_max, key_type) into hash;
	-- raise info '%', hash;
	return hash;
END;

$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT
) returns hstore as $$

DECLARE
	sid 	int;
	is_max 	BOOLEAN:=TRUE;
	hash 	hstore;
	hashs 	hstore[];
	tmp 	int:=0;

BEGIN
  	--取得当前站点.
	SELECT gamebox_current_site() INTO sid;
	--取得当前站点的包网方案
	SELECT gamebox_operations_occupy(url, sid, start_time, end_time, category, is_max, key_type, 'Y') into hash;
	-- raise info '%', hash;
	return hash;
END;

$$ language plpgsql;",5_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT
) returns hstore as $$

DECLARE
	sid 	int;
	is_max 	BOOLEAN:=TRUE;
	hash 	hstore;
	hashs 	hstore[];
	tmp 	int:=0;
BEGIN
  	-- 取得当前站点.
	SELECT gamebox_current_site() INTO sid;
	-- 取得当前站点的包网方案
	SELECT gamebox_operations_occupy(url, sid, start_time, end_time, category, is_max, key_type) into hash;
	-- raise info 'gamebox_operations_occupy hash = %', hash;
	return hash;
END;
$$ language plpgsql;",5_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(
	url 		text,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	category 	TEXT,
	key_type 	INT
) returns hstore as $$

DECLARE
	sid 	int;
	is_max 	BOOLEAN:=TRUE;
	hash 	hstore;
	hashs 	hstore[];
	tmp 	int:=0;
BEGIN
  	-- 取得当前站点.
	SELECT gamebox_current_site() INTO sid;
	-- 取得当前站点的包网方案
	SELECT gamebox_operations_occupy(url, sid, start_time, end_time, category, is_max, key_type) into hash;
	-- raise info 'gamebox_operations_occupy hash = %', hash;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operations_occupy(hashs hstore[],start_time TIMESTAMP,end_time TIMESTAMP,category TEXT,key_type INT)
returns hstore as $$
DECLARE
	hash hstore;
	rec record;
	cur refcursor;
	amount FLOAT:=0.00;
	temp_amount FLOAT:=0.00;
	keyname TEXT:='';
	col_split TEXT:='_';
BEGIN
	--计算占成
		select gamebox_operation_occupy(start_time,end_time,category) INTO cur;
		FETCH cur into rec;
		WHILE FOUND LOOP
			keyname=rec.owner_id::TEXT;
			IF key_type=3 THEN
				keyname=(rec.id::TEXT);
			ELSIF key_type=4 THEN
				keyname=(rec.id::TEXT);
				keyname=keyname||col_split||(rec.api_id::TEXT);
				keyname=keyname||col_split||(rec.game_type::TEXT);
			ELSIF key_type=5 THEN
				keyname=rec.api_id::TEXT;
				keyname=keyname||col_split||(rec.game_type::TEXT);
			END IF;

			amount=0.00;
			temp_amount=0.00;
			select gamebox_operations_occupy_calculate(hashs[2],row_to_json(rec),category) INTO amount;
		  --raise info 'keyname=%,api=%,%,amount=%',keyname,rec.api_id,rec.game_type,amount;
			IF hash is NULL THEN
				SELECT keyname||'=>'||amount INTO hash;
			ELSEIF isexists(hash,keyname) THEN
				temp_amount=(hash->keyname)::float;
				--raise info 'temp:%',temp_amount;
				amount=amount+temp_amount;
				hash=hash||(select (keyname||'=>'||amount)::hstore);
			ELSE
				hash=hash||(select (keyname||'=>'||amount)::hstore);
			END IF;
      --raise info 'keyname=%,amount=%',keyname,amount;
			FETCH cur INTO rec;
		END LOOP;
		CLOSE cur;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0263__E_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(hashs hstore[],start_time TIMESTAMP,end_time TIMESTAMP,category TEXT,key_type INT)
returns hstore as $$
DECLARE
	hash hstore;
	rec record;
	cur refcursor;
	amount FLOAT:=0.00;
	temp_amount FLOAT:=0.00;
	keyname TEXT:='';
	col_split TEXT:='_';
BEGIN
	--计算占成
		select gamebox_operation_occupy(start_time,end_time,category) INTO cur;
		FETCH cur into rec;
		WHILE FOUND LOOP
			keyname=rec.owner_id::TEXT;
			IF key_type=3 THEN
				keyname=(rec.id::TEXT);
			ELSIF key_type=4 THEN
				keyname=(rec.id::TEXT);
				keyname=keyname||col_split||(rec.api_id::TEXT);
				keyname=keyname||col_split||(rec.game_type::TEXT);
			END IF;

			amount=0.00;
			temp_amount=0.00;
			select gamebox_operations_occupy_calculate(hashs[2],row_to_json(rec),category) INTO amount;
		  --raise info 'keyname=%,api=%,%,amount=%',keyname,rec.api_id,rec.game_type,amount;
			IF hash is NULL THEN
				SELECT keyname||'=>'||amount INTO hash;
			ELSEIF isexists(hash,keyname) THEN
				temp_amount=(hash->keyname)::float;
				--raise info 'temp:%',temp_amount;
				amount=amount+temp_amount;
				hash=hash||(select (keyname||'=>'||amount)::hstore);
			ELSE
				hash=hash||(select (keyname||'=>'||amount)::hstore);
			END IF;
      --raise info 'keyname=%,amount=%',keyname,amount;
			FETCH cur INTO rec;
		END LOOP;
		CLOSE cur;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(url text,site_id int,start_time TIMESTAMP,end_time TIMESTAMP,category TEXT,is_max BOOLEAN,key INT)
returns hstore as $$
DECLARE
	hashs hstore[];
	hash hstore;
BEGIN
	--取得当前站点的包网方案
	select * from dblink(url,'select gamebox_contract('||site_id||','||is_max||')') as a(hash hstore[]) INTO hashs;
  select gamebox_operations_occupy(hashs,start_time,end_time,category,key) INTO hash;
	--raise info '%',hash;
	return hash;
END;
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(url text,start_time TIMESTAMP,end_time TIMESTAMP,category TEXT,key_type INT)
returns hstore as $$
DECLARE
	sid int;
	is_max BOOLEAN:=TRUE;
	hash hstore;
	hashs hstore[];
	vname text:='v_site_game';
	tmp int:=0;
BEGIN
  --取得当前站点.
	select gamebox_current_site() INTO sid;
	--取得当前站点的游戏列表.
  --perform gamebox_site_game(url,vname,sid,'C');
	--取得当前站点的包网方案
	select gamebox_operations_occupy(url,sid,start_time,end_time,category,is_max,key_type) into hash;
	raise info '%',hash;
	--删除临时视图表.
	--perform gamebox_site_game(url,vname,sid,'D');
	return hash;
END;
$$ language plpgsql;",V1.0.1.0263__E_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy(url text,start_time TIMESTAMP,end_time TIMESTAMP,category TEXT,key_type INT)
returns hstore as $$
DECLARE
	sid int;
	is_max BOOLEAN:=TRUE;
	hash hstore;
	hashs hstore[];
	vname text:='v_site_game';
	tmp int:=0;
BEGIN
  --取得当前站点.
	select gamebox_current_site() INTO sid;
	--取得当前站点的游戏列表.
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前站点的包网方案
	select gamebox_operations_occupy(url,sid,start_time,end_time,category,is_max,key_type) into hash;
	raise info '%',hash;
	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');
	return hash;
END;
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy_calculate(
	hash 		hstore,
	rec 		json,
	category 	text
) returns FLOAT as $$

DECLARE
	keyname 	text:='';
	col_split 	text:='_';
	amount 		float:=0.00;

BEGIN
	amount = (rec->>'profit_amount')::float;

	IF category != 'SITE' THEN
		--raise info '%', rec;
		keyname = (rec->>'api_id')::TEXT||col_split||(rec->>'game_type')::TEXT;

		IF isexists(hash, keyname) THEN
			amount = amount * ((hash->keyname)::float) / 100;
			RETURN amount;
		ELSE
			RETURN 0.00;
		END IF;

	END IF;

	RETURN 0.00;
END;

$$ language plpgsql;",5_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_occupy_calculate(
	hash 		hstore,
	rec 		json,
	category 	text
) returns FLOAT as $$

DECLARE
	keyname text:='';
	col_split text:='_';
	amount float:=0.00;

BEGIN
	amount = (rec->>'profit_amount')::float;

	IF category != 'SITE' THEN
		--raise info '%', rec;
		keyname = (rec->>'api_id')::TEXT||col_split||(rec->>'game_type')::TEXT;

		IF isexists(hash, keyname) THEN
			amount = amount * ((hash->keyname)::float) / 100;
			-- raise info 'key = %, amount = %, ratio = %, occupy = %', keyname, (rec->>'profit_amount'), hash->keyname, amount;
			RETURN amount;
		ELSE
			RETURN 0.00;
		END IF;

	END IF;

	RETURN 0.00;
END;

$$ language plpgsql;",V1.0.1.0040__C_gamebox_operations_occupy.sql.sql
"create or replace function gamebox_operations_occupy_calculate(hash hstore,rec json,category text)
returns FLOAT as $$
DECLARE
	keyname text:='';
	col_split text:='_';
	amount float:=0.00;
BEGIN
	amount=(rec->>'profit_amount')::float;
	--IF amount<0.00 THEN
	--	RETURN amount;
	--END IF;
	IF category!='SITE' THEN
		--raise info '%',rec;
		keyname=(rec->>'api_id')::TEXT||col_split||(rec->>'game_type')::TEXT;

		IF isexists(hash,keyname) THEN
			--raise info '占成比例:%=%',keyname,(hash->keyname);
			amount=amount*((hash->keyname)::float)/100;
			--raise info 'key=%,amount=%,ratio=%,occupy=%',keyname,(rec->>'profit_amount'),hash->keyname,amount;
			RETURN amount;
		ELSE
			RETURN 0.00;
		END IF;

	END IF;
	RETURN 0.00;
END;
$$ language plpgsql;",V1.0.1.0240__C_gamebox_operations_occupy.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text,
	startTime 	text,
	endTime 	text,
	sids 		text,
	splitchar 	text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes 	varchar[];
	endTimes 	varchar[];
	siteids 	varchar[];
	rtn 		text:='';

BEGIN
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or rtrim(ltrim(masterhost)) = '' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

  	masterhosts:=regexp_split_to_array(masterhost, splitchar);
  	startTimes:=regexp_split_to_array(startTime, splitchar);
	endTimes:=regexp_split_to_array(endTime, splitchar);
  	siteids:=regexp_split_to_array(sids, splitchar);

	IF array_length(masterhosts, 1) > 0 THEN
		FOR i in 1..array_length(masterhosts, 1)
		LOOP
			raise notice '名称:%', masterhosts[i];
		END LOOP;
		SELECT gamebox_operations_statement(mainhost, masterhosts, startTimes, endTimes, siteids) into rtn;
	END IF;

	raise info '%', rtn;
return rtn;
END;

$$ language plpgsql;",4_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text,
	startTime 	text,
	endTime 	text,
	sids 		text,
	splitchar 	text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes 	varchar[];
	endTimes 	varchar[];
	siteids 	varchar[];
	rtn 		text:='';

BEGIN
	IF mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

  	masterhosts:=regexp_split_to_array(masterhost, splitchar);
  	startTimes:=regexp_split_to_array(startTime, splitchar);
	endTimes:=regexp_split_to_array(endTime, splitchar);
  	siteids:=regexp_split_to_array(sids, splitchar);

	IF array_length(masterhosts, 1) > 0 THEN
		FOR i in 1..array_length(masterhosts, 1)
		LOOP
			raise notice '名称:%', masterhosts[i];
		END LOOP;
		SELECT gamebox_operations_statement(mainhost, masterhosts, startTimes, endTimes, siteids) into rtn;
	END IF;

	raise info '%', rtn;
return rtn;
END;

$$ language plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text[],
	startTimes 	text[],
	endTimes 	text[],
	siteids 	text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';

BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE into curday;
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or array_length(masterhost,  1) < 0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

	--关闭所有链接.
  	perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  	perform gamebox_collect_site_infor(mainhost);

	--拆分所有站点数据库信息.
  	rtn = rtn||'1.  开始执行各个站点玩家经营报表';

	FOR i in 1..array_length(masterhost,  1)
	LOOP
     	raise notice '%.当前站点库信息：%', i, masterhost[i];
		IF rtrim(ltrim(masterhost[i])) = '' THEN
			return '站点库信息不能为空';
		END IF;

		--连接站点库
	  	perform dblink_connect('master', masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息', i, masterhost[i];
		rtn = rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		SELECT gamebox_master_operation_statement('master', siteids[i]::int, startTimes[i], endTimes[i], curday, mainhost) into tmp;
		rtn = rtn||'||'||tmp;
	  	raise info '%.收集完毕', i;
		--收集站点经营报表
		rtn = rtn||'4.  开始执行站点经营报表';
		SELECT gamebox_operation_site('master', curday) into tmp;
		rtn = rtn||'||'||tmp;
		perform dblink_disconnect('master');
	END LOOP;

	rtn = rtn||'5.  开始执行站长经营报表';
	SELECT gamebox_operation_master(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;
	rtn = rtn||'6.  开始执行运营商经营报表';
	SELECT gamebox_operation_company(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;

return rtn;
END;

$$ LANGUAGE plpgsql;",V1.0.1.0006__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	masterhost 	text[],
	startTimes 	text[],
	endTimes 	text[],
	siteids 	text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';

BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE into curday;
	IF mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	END IF;

	IF masterhost is null or array_length(masterhost,  1) < 0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	END IF;

	--关闭所有链接.
  	perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  	perform gamebox_collect_site_infor(mainhost);

	--拆分所有站点数据库信息.
  	rtn = rtn||'1.开始执行各个站点玩家经营报表';

	FOR i in 1..array_length(masterhost,  1)
	LOOP
     	raise notice '%.当前站点库信息：%', i, masterhost[i];
		IF rtrim(ltrim(masterhost[i])) = '' THEN
			return '站点库信息不能为空';
		END IF;

		--连接站点库
	  	perform dblink_connect('master', masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息', i, masterhost[i];
		rtn = rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		SELECT gamebox_master_operation_statement('master', siteids[i]::int, startTimes[i], endTimes[i], curday, mainhost) into tmp;
		rtn = rtn||'||'||tmp;
	  	raise info '%.收集完毕', i;
		--收集站点经营报表
		rtn = rtn||'4.  开始执行站点经营报表';
		SELECT gamebox_operation_site('master', curday) into tmp;
		rtn = rtn||'||'||tmp;
		perform dblink_disconnect('master');
	END LOOP;

	rtn = rtn||'5.  开始执行站长经营报表';
	SELECT gamebox_operation_master(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;
	rtn = rtn||'6.  开始执行运营商经营报表';
	SELECT gamebox_operation_company(curday::TEXT) into tmp;
	rtn = rtn||'||'||tmp;

return rtn;
END;

$$ LANGUAGE plpgsql;",4_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	sid 		int,
	start_time 	text,
	end_time 	text
) returns text as $$
DECLARE
	curday 	TEXT;
	rtn 	text:='';
	tmp 	text:='';
	rec 	json;
	red 	record;
	vname 	text:='vp_site_game';
  	cnum 	int:=0;
BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE::TEXT into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		return '运营商库信息没有设置';
	end if;

	--收集当前所有运营站点相关信息.
  	SELECT gamebox_collect_site_infor(mainhost, sid) into rec;
	IF rec->>'siteid' = '-1' THEN
		rtn = '运营商库中不存在当前站点的相关信息,请确保此站点是否合法.';
		raise info '%', rtn;
		return rtn;
	END IF;

	--拆分所有站点数据库信息.
  	rtn = rtn||'1. 开始收集站点玩家下单信息';
	SELECT gamebox_operations_player(start_time, end_time, curday, rec) into tmp;
	rtn = rtn||'||'||tmp;
	--raise info '%.收集完毕',i;

	--处理另外一些报表信息收集

	--统一执行代理以上的经营报表
	--执行代理经营报表
	rtn = rtn||'2.  开始执行代理经营报表';
	SELECT gamebox_operations_agent(curday,rec) into tmp;
	rtn = rtn||'||'||tmp;
	--执行总代经营报表
	rtn = rtn||'3.  开始执行总代经营报表';
	SELECT gamebox_operations_topagent(curday,rec) into tmp;
	rtn = rtn||'||'||tmp;

	return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0041__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
	mainhost 	text,
	sid 	int,
	start_time 	text,
	end_time 	text
) returns text as $$
DECLARE
	curday 	TEXT;
	rtn 	text:='';
	tmp 	text:='';
	rec 	json;
	red 	record;
	vname 	text:='vp_site_game';
	cnum 	int:=0;
BEGIN
	--设置当前日期.
	SELECT CURRENT_DATE::TEXT into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost)) = '' THEN
		return '运营商库信息没有设置';
	end if;

	--收集当前所有运营站点相关信息.
	SELECT gamebox_collect_site_infor(mainhost, sid) into rec;
	IF rec->>'siteid' = '-1' THEN
		rtn = '运营商库中不存在当前站点的相关信息,请确保此站点是否合法.';
		raise info '%', rtn;
		return rtn;
	END IF;

	--拆分所有站点数据库信息.
	rtn = rtn||'1. 开始收集站点玩家下单信息';
	SELECT gamebox_operations_player(start_time, end_time, curday, rec) into tmp;
	rtn = rtn||'||'||tmp;
	--raise info '%.收集完毕',i;

	--处理另外一些报表信息收集

	--统一执行代理以上的经营报表
	--执行代理经营报表
	rtn = rtn||'2.  开始执行代理经营报表';
	SELECT gamebox_operations_agent(curday, rec) into tmp;
	rtn = rtn||'||'||tmp;
	--执行总代经营报表
	rtn = rtn||'3.  开始执行总代经营报表';
	SELECT gamebox_operations_topagent(curday, rec) into tmp;
	rtn = rtn||'||'||tmp;

	return rtn;
END
$$ LANGUAGE plpgsql;",6_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text
,startTime text
,endTime text
,sids text
,splitchar text
) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	siteids varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
  siteids:=regexp_split_to_array(sids,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		--select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes,siteids) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库
		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--收集站点经营报表
			rtn=rtn||'2.  开始执行站点经营报表';
			select gamebox_operation_site('master',curday) into tmp;
			rtn=rtn||'||'||tmp;
		  perform dblink_disconnect('master');
	end loop;
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0012__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库
		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--收集站点经营报表
			rtn=rtn||'2.  开始执行站点经营报表';
			select gamebox_operation_site('master',curday) into tmp;
			rtn=rtn||'||'||tmp;
		  perform dblink_disconnect('master');
	end loop;
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0025__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,masterhost text[]
,startTimes text[]
,endTimes text[]
,siteids text[]
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
  rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
		if rtrim(ltrim(masterhost[i]))='' THEN
			return '站点库信息不能为空';
		end if;
		--连接站点库
	  	perform dblink_connect('master',masterhost[i]);
		--执行玩家经营报表
		raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
		rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
		select gamebox_master_operation_statement('master',siteids[i]::int,startTimes[i],endTimes[i],curday,mainhost) into tmp;
		rtn=rtn||'||'||tmp;
	  	raise info '%.收集完毕',i;
		--收集站点经营报表
		rtn=rtn||'4.  开始执行站点经营报表';
		select gamebox_operation_site('master',curday) into tmp;
		rtn=rtn||'||'||tmp;
		perform dblink_disconnect('master');
	end loop;
	rtn=rtn||'5.  开始执行站长经营报表';
	select gamebox_operation_master(curday::TEXT) into tmp;
	rtn=rtn||'||'||tmp;
	rtn=rtn||'6.  开始执行运营商经营报表';
	select gamebox_operation_company(curday::TEXT) into tmp;
	rtn=rtn||'||'||tmp;
return rtn;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0031__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,sid int
,start_time text
,end_time text
) returns text as $$
DECLARE
	curday TEXT;
	rtn text:='';
	tmp text:='';
	--当前站点信息
	rec json;
	red record;
	vname text:='vp_site_game';
  cnum int:=0;
BEGIN
	--设置当前日期.
	select CURRENT_DATE::TEXT into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	--关闭所有链接.
  --perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  select gamebox_collect_site_infor(mainhost,sid) into rec;
	IF rec->>'siteid' ='-1' THEN
			rtn='运营商库中不存在当前站点的相关信息,请确保此站点是否合法.';
			raise info '%',rtn;
			return rtn;
	END IF;
	--创建临时游戏表.
	--raise info '经营报表.site_game临时视图';
 -- perform gamebox_site_game(mainhost,vname,sid,'C');

	--拆分所有站点数据库信息.
  rtn=rtn||'1. 开始收集站点玩家下单信息';
	select gamebox_operations_player(start_time,end_time,curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--raise info '%.收集完毕',i;

	--处理另外一些报表信息收集

	--统一执行代理以上的经营报表
	--执行代理经营报表
	rtn=rtn||'2.  开始执行代理经营报表';
	select gamebox_operations_agent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--执行总代经营报表
	rtn=rtn||'3.  开始执行总代经营报表';
	select gamebox_operations_topagent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;

	--删除临时视图表.
	--perform gamebox_site_game(mainhost,vname,sid,'D');

	return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0272__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,sid int
,start_time text
,end_time text
) returns text as $$
DECLARE
	curday TEXT;
	rtn text:='';
	tmp text:='';
	--当前站点信息
	rec json;
	red record;
	vname text:='vp_site_game';
  cnum int:=0;
BEGIN
	--设置当前日期.
	select CURRENT_DATE::TEXT into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	--关闭所有链接.
  --perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  select gamebox_collect_site_infor(mainhost,sid) into rec;
	IF rec->>'siteid' ='-1' THEN
			rtn='运营商库中不存在当前站点的相关信息,请确保此站点是否合法.';
			raise info '%',rtn;
			return rtn;
	END IF;
	--创建临时游戏表.
	--raise info '经营报表.site_game临时视图';
 -- perform gamebox_site_game(mainhost,vname,sid,'C');

	--拆分所有站点数据库信息.
  rtn=rtn||'1. 开始收集站点玩家下单信息';
	select gamebox_operations_player(start_time,end_time,curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--raise info '%.收集完毕',i;

	--处理另外一些报表信息收集

	--统一执行代理以上的经营报表
	--执行代理经营报表
	rtn=rtn||'2.  开始执行代理经营报表';
	select gamebox_operations_agent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--执行总代经营报表
	rtn=rtn||'3.  开始执行总代经营报表';
	select gamebox_operations_topagent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;

	--删除临时视图表.
	--perform gamebox_site_game(mainhost,vname,sid,'D');

	return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0297__E_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(
mainhost text
,sid int
,start_time text
,end_time text
) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
	--当前站点信息
	rec json;
	red record;
	vname text:='vp_site_game';
  cnum int:=0;
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	--关闭所有链接.
  --perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  select gamebox_collect_site_infor(mainhost,sid) into rec;
	IF rec->>'siteid' ='-1' THEN
			rtn='运营商库中不存在当前站点的相关信息,请确保此站点是否合法.';
			raise info '%',rtn;
			return rtn;
	END IF;
	--创建临时游戏表.
	raise info '经营报表.site_game临时视图';
  perform gamebox_site_game(mainhost,vname,sid,'C');

	--拆分所有站点数据库信息.
  rtn=rtn||'1. 开始收集站点玩家下单信息';
	select gamebox_operations_player(start_time,end_time,curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--raise info '%.收集完毕',i;

	--处理另外一些报表信息收集

	--统一执行代理以上的经营报表
	--执行代理经营报表
	rtn=rtn||'2.  开始执行代理经营报表';
	select gamebox_operations_agent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;
	--执行总代经营报表
	rtn=rtn||'3.  开始执行总代经营报表';
	select gamebox_operations_topagent(curday,rec) into tmp;
	rtn=rtn||'||'||tmp;

	--删除临时视图表.
	perform gamebox_site_game(mainhost,vname,sid,'D');

	return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0231__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(mainhost text,masterhost text,startTime text,endTime text,splitchar text) returns text as $$
DECLARE
	masterhosts varchar[];
	startTimes varchar[];
	endTimes varchar[];
	rtn text:='';
BEGIN
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or rtrim(ltrim(masterhost))='' THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

  masterhosts:=regexp_split_to_array(masterhost,splitchar);
  startTimes:=regexp_split_to_array(startTime,splitchar);
	endTimes:=regexp_split_to_array(endTime,splitchar);
	if array_length(masterhosts,1)>0 THEN
		for i in 1..array_length(masterhosts,1) loop
			raise notice '名称:%',masterhosts[i];
		end loop;
		select gamebox_operations_statement(mainhost,masterhosts,startTimes,endTimes) into rtn;
	end if;
	--return '运行成功';
	raise info '%',rtn;
return rtn;
END
$$ language plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function gamebox_operations_statement(mainhost text,masterhost text[],startTimes text[],endTimes text[]) returns text as $$
DECLARE
	curday date;
	rtn text:='';
	tmp text:='';
BEGIN
	--设置当前日期.
	select CURRENT_DATE into curday;
	--raise notice 'ip:%',hostinfo;
	if mainhost is null or rtrim(ltrim(mainhost))='' THEN
		raise info '运营商库信息没有设置';
		return '运营商库信息没有设置';
	end if;

	if masterhost is null or array_length(masterhost, 1)<0 THEN
		raise info '站点库信息没有设置';
		return '站点库信息没有设置';
	end if;

	--关闭所有链接.
  perform dblink_close_all();
	--收集当前所有运营站点相关信息.
  perform gamebox_collect_site_infor(mainhost);
	--拆分所有站点数据库信息.
   rtn=rtn||'1.  开始执行各个站点玩家经营报表';
	for i in 1..array_length(masterhost, 1) loop
     raise notice '%.当前站点库信息：%',i,masterhost[i];
			if rtrim(ltrim(masterhost[i]))='' THEN
				return '站点库信息不能为空';
			end if;
			--连接站点库

		  perform dblink_connect('master',masterhost[i]);
			--执行玩家经营报表
			raise info '%.开始收集站点%的玩家下单信息',i,masterhost[i];
			rtn=rtn||'|||1.'||i||'.开始收集.站点.'||i||'.玩家报表.';
			select gamebox_player_statement('master',1,startTimes[i],endTimes[i],curday) into tmp;
			rtn=rtn||'||'||tmp;
		  raise info '%.收集完毕',i;
			--处理另外一些报表信息收集
			--@todo
		  perform dblink_disconnect('master');
	end loop;
			--统一执行代理以上的经营报表
			--执行代理经营报表
			rtn=rtn||'2.  开始执行代理经营报表';
			select gamebox_agent_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;
			--执行总代经营报表
			rtn=rtn||'3.  开始执行总代经营报表';
			select gamebox_topagent_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;
			--执行站点经营报表
			rtn=rtn||'4.  开始执行站点经营报表';
			select gamebox_site_statement(curday) into tmp;
			rtn=rtn||'||'||tmp;

	--return '运营信息收集完毕';
return rtn;
END
$$ LANGUAGE plpgsql;",V1.0.1.0010__C_gamebox_operations_statement.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
  	gradshash 	hstore;
	agenthash 	hstore;
	a1 	text;
	a2 	text;
	a3 	text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	vname 			text:='v_site_game';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

  	perform gamebox_site_game(url, vname, sid, 'C');

	-- 取得当前返水梯度设置信息.
  	SELECT gamebox_rakeback_api_grads() into gradshash;
  	SELECT gamebox_agent_rakeback() 	into agenthash;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, gradshash, agenthash, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

	-- 删除临时视图表.
	perform gamebox_site_game(url, vname, sid, 'D');

	-- exception
	EXCEPTION WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT, a2 = PG_EXCEPTION_DETAIL, a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%, %, %', a1, a2, a3;

END;

$$ language plpgsql;",E_gamebox_rakeback_0125.sql
"create or replace function gamebox_rakeback(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		TEXT
) returns void as $$

DECLARE
  	gradshash 	hstore;
	agenthash 	hstore;
	a1 	text;
	a2 	text;
	a3 	text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	vname 			text:='v_site_game';
	bill_id 		INT:=-1;
	sid 			INT;
BEGIN
	raise info '开始统计( % )的返水, 周期( %-% )', name, startTime, endTime;
	raise info '创建站点游戏视图';

	SELECT gamebox_current_site() INTO sid;

  	perform gamebox_site_game(url, vname, sid, 'C');

	-- 取得当前返水梯度设置信息.
  	SELECT gamebox_rakeback_api_grads() into gradshash;
  	SELECT gamebox_agent_rakeback() 	into agenthash;

	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;

	raise info '返水总表数据预新增.';
	SELECT gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'I', flag) INTO bill_id;

	-- 收集每个API下每个玩家的返水.
  	raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id, stTime, edTime, gradshash, agenthash, flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  	perform gamebox_rakeback_player(bill_id, flag);
	raise info '统计玩家返水.完成';

  	raise info '更新返水总表';
	perform gamebox_rakeback_bill(name, stTime, edTime, bill_id, 'U', flag);

	-- 删除临时视图表.
	perform gamebox_site_game(url, vname, sid, 'D');

	-- exception
	EXCEPTION WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT, a2 = PG_EXCEPTION_DETAIL, a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%, %, %', a1, a2, a3;

END;

$$ language plpgsql;",V1.0.1.0357__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
name text,startTime text,endTime text
,url text) returns void as $$
DECLARE
  gradshash hstore;
	agenthash hstore;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	vname text:='v_site_game';
	bill_id INT:=-1;
	sid INT;
BEGIN
	raise info '开始统计( % )的返水,周期( %-% )',name,startTime,endTime;
	raise info '创建站点游戏视图';
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	select gamebox_current_site() INTO sid;
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前返水梯度设置信息.
  select gamebox_rakeback_api_grads() into gradshash;
  select gamebox_agent_rakeback() into agenthash;
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '返水总表数据预新增.';
	select gamebox_rakeback_bill(name,stTime,edTime,bill_id,'I') INTO bill_id;
	--收集每个API下每个玩家的返水.
  raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id,stTime,edTime,gradshash,agenthash);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  perform gamebox_rakeback_player(bill_id);
	raise info '统计玩家返水.完成';

  raise info '更新返水总表';
	perform gamebox_rakeback_bill(name,stTime,edTime,bill_id,'U');

	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

  --EXCEPTION WHEN unique_violation THEN
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,
                          a2 = PG_EXCEPTION_DETAIL,
                          a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%',a1,a2,a3;

END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
name text,startTime text,endTime text
,url text,flag TEXT) returns void as $$
DECLARE
  gradshash hstore;
	agenthash hstore;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	vname text:='v_site_game';
	bill_id INT:=-1;
	sid INT;
BEGIN
	raise info '开始统计( % )的返水,周期( %-% )',name,startTime,endTime;
	raise info '创建站点游戏视图';
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	select gamebox_current_site() INTO sid;
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前返水梯度设置信息.
  select gamebox_rakeback_api_grads() into gradshash;
  select gamebox_agent_rakeback() into agenthash;
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '返水总表数据预新增.';
	select gamebox_rakeback_bill(name,stTime,edTime,bill_id,'I',flag) INTO bill_id;
	--收集每个API下每个玩家的返水.
  raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id,stTime,edTime,gradshash,agenthash,flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  perform gamebox_rakeback_player(bill_id,flag);
	raise info '统计玩家返水.完成';

  raise info '更新返水总表';
	perform gamebox_rakeback_bill(name,stTime,edTime,bill_id,'U',flag);

	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

  --EXCEPTION WHEN unique_violation THEN
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,
                          a2 = PG_EXCEPTION_DETAIL,
                          a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%',a1,a2,a3;

END;
$$ language plpgsql;",V1.0.1.0258__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
name text,startTime text,endTime text
,url text,flag TEXT) returns void as $$
DECLARE
  gradshash hstore;
	agenthash hstore;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	vname text:='v_site_game';
	bill_id INT:=-1;
	sid INT;
BEGIN
	raise info '开始统计( % )的返水,周期( %-% )',name,startTime,endTime;
	raise info '创建站点游戏视图';
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	select gamebox_current_site() INTO sid;
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前返水梯度设置信息.
  select gamebox_rakeback_api_grads() into gradshash;
  select gamebox_agent_rakeback() into agenthash;
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '返水总表数据预新增.';
	select gamebox_rakeback_bill(name,stTime,edTime,bill_id,'I',flag) INTO bill_id;
	--收集每个API下每个玩家的返水.
  raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id,stTime,edTime,gradshash,agenthash,flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  perform gamebox_rakeback_player(bill_id,flag);
	raise info '统计玩家返水.完成';

  raise info '更新返水总表';
	perform gamebox_rakeback_bill(name,stTime,edTime,bill_id,'U',flag);

	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

  --EXCEPTION WHEN unique_violation THEN
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,
                          a2 = PG_EXCEPTION_DETAIL,
                          a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%',a1,a2,a3;

END;
$$ language plpgsql;",V1.0.1.0305__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback(
name text,startTime text,endTime text
,url text,flag TEXT) returns void as $$
DECLARE
  gradshash hstore;
	agenthash hstore;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;
	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	vname text:='v_site_game';
	bill_id INT:=-1;
	sid INT;
BEGIN
	raise info '开始统计( % )的返水,周期( %-% )',name,startTime,endTime;
	raise info '创建站点游戏视图';
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
	select gamebox_current_site() INTO sid;
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前返水梯度设置信息.
  select gamebox_rakeback_api_grads() into gradshash;
  select gamebox_agent_rakeback() into agenthash;
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '返水总表数据预新增.';
	select gamebox_rakeback_bill(name,stTime,edTime,bill_id,'I',flag) INTO bill_id;
	--收集每个API下每个玩家的返水.
  raise info '统计玩家API返水';
	perform gamebox_rakeback_api(bill_id,stTime,edTime,gradshash,agenthash,flag);
	raise info '统计玩家API返水.完成';

	raise info '统计玩家返水';
  perform gamebox_rakeback_player(bill_id,flag);
	raise info '统计玩家返水.完成';

  raise info '更新返水总表';
	perform gamebox_rakeback_bill(name,stTime,edTime,bill_id,'U',flag);

	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

  --EXCEPTION WHEN unique_violation THEN
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,
                          a2 = PG_EXCEPTION_DETAIL,
                          a3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%',a1,a2,a3;

END;
$$ language plpgsql;",V1.0.1.0314__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
	rec 		record;
	param 		text:='';
	gradshash 	hstore;
	tmphash 	hstore;
	keyname 	text:='';
	val 		text:='';
	val2 		text:='';

BEGIN
	FOR rec IN
		SELECT rs.id,
			   rg.id as grads_id,
			   rga.api_id,
			   rga.game_type,
			   COALESCE(rga.ratio, 0) 		as ratio,
			   COALESCE(rg.max_rakeback, 0) as max_rakeback,
			   COALESCE(rg.valid_value, 0) 	as valid_value,
			   rs.name,
			   COALESCE(rs.audit_num, 0) 	as audit_num
		  FROM rakeback_grads 		rg,
		  	   rakeback_grads_api 	rga,
		  	   rakeback_set 		rs
		 WHERE rg.id = rga.rakeback_grads_id
		   AND rg.rakeback_id = rs.id
		   AND rs.status = '1'
		 ORDER BY rs.id, rga.api_id, rga.game_type, rg.valid_value desc;
   LOOP
		--判断主方案是否存在.
		--键值格式:ID+GRADSID+API+GAMETYPE
		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text;
		--val:=row_to_json(row(5, 6, 7, 8, 9));
		val:=row_to_json(rec);
		val:=replace(val, ', ', '\|');
		val:=replace(val, 'null', '-1');
		--raise info 'count:%', array_length(akeys(gradshash),  1);
		if (gradshash?keyname) is null OR (gradshash?keyname) =false THEN
		--gradshash = hash||tmphash;

		if gradshash is null then
			SELECT keyname||'=>'||val into gradshash;
		ELSE
			SELECT keyname||'=>'||val into tmphash;
			gradshash = gradshash||tmphash;
		end IF;
		-- raise info 'gradsHash=%', gradshash->keyname;

		else
			val2 = gradshash->keyname;
			--raise info '原值=%', gradshash->keyname;
			SELECT keyname||'=>'||val||'^&^'||val2 into tmphash;
			gradshash = gradshash||tmphash;
			--raise info '新值=%', gradshash->keyname;
		end if;
		--raise info '============';
	END LOOP;

	return gradshash;
END;

$$ language plpgsql;",E_gamebox_rakeback_0125.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
	rec 		record;
	param 		text:='';
	gradshash 	hstore;
	tmphash 	hstore;
	keyname 	text:='';
	val 		text:='';
	val2 		text:='';

BEGIN
	FOR rec in
		SELECT m.id,
			   s.id as grads_id,
			   d.api_id,
			   d.game_type,
			   COALESCE(d.ratio,0) 			as ratio,
			   COALESCE(s.max_rakeback,0) 	as max_rakeback,
			   COALESCE(s.valid_value,0) 	as valid_value,
			   m.name,
			   COALESCE(m.audit_num,0) 		as audit_num
		  FROM rakeback_grads s, rakeback_grads_api d, rakeback_set m
		 WHERE s.id = d.rakeback_grads_id
		   AND s.rakeback_id = m.id
		   AND m.status='1'
		 ORDER BY m.id,d.api_id,d.game_type,s.valid_value desc
   	LOOP
		-- 判断主方案是否存在.
		-- 键值格式:ID + gradsId + API + gameType
		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text;

		val:=row_to_json(rec);
		val:=replace(val,',','\|');
		val:=replace(val,'null','-1');
		IF (gradshash?keyname) is null OR (gradshash?keyname) = false THEN
			--gradshash=hash||tmphash;
			IF gradshash is null THEN
				select keyname||'=>'||val into gradshash;
			ELSE
				select keyname||'=>'||val into tmphash;
				gradshash = gradshash||tmphash;
			END IF;

		ELSE
			val2 = gradshash->keyname;
			select keyname||'=>'||val||'^&^'||val2 into tmphash;
			gradshash = gradshash||tmphash;
		END IF;
	END LOOP;

	return gradshash;
END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
	rec record;
	param text:='';
	gradshash hstore;
	tmphash hstore;
	keyname text:='';
	val text:='';
	val2 text:='';
BEGIN
	for rec in
	SELECT
		m.id,
		s.id as grads_id,
		d.api_id,
		d.game_type,
		COALESCE(d.ratio,0) ratio,
		COALESCE(s.max_rakeback,0) max_rakeback,
		COALESCE(s.valid_value,0) valid_value,
		m.name,
		COALESCE(m.audit_num,0) audit_num
	FROM
		rakeback_grads s,
		rakeback_grads_api d,
		rakeback_set m
	WHERE
		s.id = d.rakeback_grads_id AND
		s.rakeback_id = m.id AND m.status='1'
		order by m.id,d.api_id,d.game_type,s.valid_value desc
   loop
		--判断主方案是否存在.
		--键值格式:ID+GRADSID+API+GAMETYPE
		  keyname=	rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text;
			--val:=row_to_json(row(5,6,7,8,9));
		  val:=row_to_json(rec);
			val:=replace(val,',','\|');
			val:=replace(val,'null','-1');
			--raise info '============%,%',keyname,gradshash?keyname;
			--raise info 'count:%',array_length(akeys(gradshash), 1);
			if (gradshash?keyname) is null OR (gradshash?keyname) =false THEN
				--raise info '创建KEY:%',val;
				--select keyname||'=>'||val into tmphash;
        --gradshash=hash||tmphash;
					if gradshash is null then
						select keyname||'=>'||val into gradshash;
					ELSE
						select keyname||'=>'||val into tmphash;
						gradshash=gradshash||tmphash;
					end IF;
	      -- raise info 'gradsHash=%',gradshash->keyname;
			else
				val2=gradshash->keyname;
				--raise info '原值=%',gradshash->keyname;
				select keyname||'=>'||val||'^&^'||val2 into tmphash;
				gradshash=gradshash||tmphash;
				--raise info '新值=%',gradshash->keyname;
			end if;
			--raise info '============';
	end loop;
		--raise info '键的数量：%',array_length(akeys(gradshash),1);
    --raise info '键值：%',akeys(gradshash);
    --raise info '值：%',avals(gradshash);
	return gradshash;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
 	rec 		record;
 	param 		text:='';
 	gradshash 	hstore;
 	tmphash 	hstore;
 	keyname 	text:='';
 	val 		text:='';
 	val2 		text:='';

BEGIN
 	FOR rec in
 		SELECT m.id,
 			   s.id as grads_id,
 			   d.api_id,
 			   d.game_type,
 			   COALESCE(d.ratio,0) 			as ratio,
 			   COALESCE(s.max_rakeback,0) 	as max_rakeback,
 			   COALESCE(s.valid_value,0) 	as valid_value,
 			   m.name,
 			   COALESCE(m.audit_num,0) 		as audit_num
 		  FROM rakeback_grads s, rakeback_grads_api d, rakeback_set m
 		 WHERE s.id = d.rakeback_grads_id
 		   AND s.rakeback_id = m.id
 		   AND m.status='1'
 		 ORDER BY m.id, s.valid_value desc, d.api_id, d.game_type
    	LOOP
 		-- 判断主方案是否存在.
 		-- 键值格式:ID + gradsId + API + gameType
 		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text||'_'||rec.valid_value::float;

 		val:=row_to_json(rec);
 		val:=replace(val,',','\|');
 		val:=replace(val,'null','-1');
 		IF (gradshash?keyname) is null OR (gradshash?keyname) = false THEN
 			--gradshash=hash||tmphash;
 			IF gradshash is null THEN
 				select keyname||'=>'||val into gradshash;
 			ELSE
 				select keyname||'=>'||val into tmphash;
 				gradshash = gradshash||tmphash;
 			END IF;

 		ELSE
 			val2 = gradshash->keyname;
 			select keyname||'=>'||val||'^&^'||val2 into tmphash;
 			gradshash = gradshash||tmphash;
 		END IF;
 	END LOOP;

 	return gradshash;
END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
 	rec 		record;
 	param 		text:='';
 	gradshash 	hstore;
 	tmphash 	hstore;
 	keyname 	text:='';
 	val 		text:='';
 	val2 		text:='';

BEGIN
 	FOR rec in
 		SELECT m.id,
 			   s.id as grads_id,
 			   d.api_id,
 			   d.game_type,
 			   COALESCE(d.ratio,0) 			as ratio,
 			   COALESCE(s.max_rakeback,0) 	as max_rakeback,
 			   COALESCE(s.valid_value,0) 	as valid_value,
 			   m.name,
 			   COALESCE(m.audit_num,0) 		as audit_num
 		  FROM rakeback_grads s, rakeback_grads_api d, rakeback_set m
 		 WHERE s.id = d.rakeback_grads_id
 		   AND s.rakeback_id = m.id
 		   AND m.status='1'
 		 ORDER BY m.id, s.valid_value desc, d.api_id, d.game_type
    	LOOP
 		-- 判断主方案是否存在.
 		-- 键值格式:ID + gradsId + API + gameType
 		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text||'_'||rec.valid_value::float;

 		val:=row_to_json(rec);
 		val:=replace(val,',','\|');
 		val:=replace(val,'null','-1');
 		IF (gradshash?keyname) is null OR (gradshash?keyname) = false THEN
 			--gradshash=hash||tmphash;
 			IF gradshash is null THEN
 				select keyname||'=>'||val into gradshash;
 			ELSE
 				select keyname||'=>'||val into tmphash;
 				gradshash = gradshash||tmphash;
 			END IF;

 		ELSE
 			val2 = gradshash->keyname;
 			select keyname||'=>'||val||'^&^'||val2 into tmphash;
 			gradshash = gradshash||tmphash;
 		END IF;
 	END LOOP;

 	return gradshash;
END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_grads() returns hstore as $$
DECLARE
 	rec 		record;
 	param 		text:='';
 	gradshash 	hstore;
 	tmphash 	hstore;
 	keyname 	text:='';
 	val 		text:='';
 	val2 		text:='';

BEGIN
 	FOR rec in
 		SELECT m.id,
 			   s.id as grads_id,
 			   d.api_id,
 			   d.game_type,
 			   COALESCE(d.ratio,0) 			as ratio,
 			   COALESCE(s.max_rakeback,0) 	as max_rakeback,
 			   COALESCE(s.valid_value,0) 	as valid_value,
 			   m.name,
 			   COALESCE(m.audit_num,0) 		as audit_num
 		  FROM rakeback_grads s, rakeback_grads_api d, rakeback_set m
 		 WHERE s.id = d.rakeback_grads_id
 		   AND s.rakeback_id = m.id
 		   AND m.status='1'
 		 ORDER BY m.id,s.valid_value desc,d.api_id,d.game_type
    	LOOP
 		-- 判断主方案是否存在.
 		-- 键值格式:ID + gradsId + API + gameType
 		keyname = rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text||'_'||rec.valid_value::float;

 		val:=row_to_json(rec);
 		val:=replace(val,',','\|');
 		val:=replace(val,'null','-1');
 		IF (gradshash?keyname) is null OR (gradshash?keyname) = false THEN
 			--gradshash=hash||tmphash;
 			IF gradshash is null THEN
 				select keyname||'=>'||val into gradshash;
 			ELSE
 				select keyname||'=>'||val into tmphash;
 				gradshash = gradshash||tmphash;
 			END IF;

 		ELSE
 			val2 = gradshash->keyname;
 			select keyname||'=>'||val||'^&^'||val2 into tmphash;
 			gradshash = gradshash||tmphash;
 		END IF;
 	END LOOP;

 	return gradshash;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  su.username,
					  COUNT(DISTINCT rab.player_id) 					as player_num,
					  SUM(COALESCE(rab.effective_transaction, 0.00)) 	as effective_trade_amount,
					  up.rakeback_id
				 FROM rakeback_api_base rab
				 LEFT JOIN sys_user su ON rab.player_id = su.""id""
				 LEFT JOIN user_player up ON rab.player_id = up.""id""
			    WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				  AND up.rakeback_id IS NOT NULL
			    GROUP BY rab.api_id, rab.game_type, rab.player_id, su.username, up.rakeback_id';
	END IF;

	FOR rec IN EXECUTE sql USING start_time, end_time
	LOOP
		-- raise info '用户:%, 梯度:%, api:%, game_type:%', rec.player_id, rec.rakeback_id, rec.api_id, rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash, agenthash, row_to_json(rec)) into rakeback;
		-- raise info '玩家:%, 有效交易量:%, 返水:%', rec.username, rec.effective_trade_amount, rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key = rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback||col_split||rec.player_num;
			hash = (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key = rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback;
			hash = (SELECT param::hstore)||hash;
		ELSE
			key = rec.player_id;
			param = key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val + rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	-- raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0036__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  su.username,
					  COUNT(DISTINCT rab.player_id) 					as player_num,
					  SUM(COALESCE(rab.effective_transaction, 0.00)) 	as effective_trade_amount,
					  up.rakeback_id
				 FROM rakeback_api_base rab
				 LEFT JOIN sys_user su ON rab.player_id = su.""id""
				 LEFT JOIN user_player up ON rab.player_id = up.""id""
			    WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				  AND up.rakeback_id IS NOT NULL
			    GROUP BY rab.api_id, rab.game_type, rab.player_id, su.username, up.rakeback_id';
	END IF;

	FOR rec IN EXECUTE sql USING start_time, end_time
	LOOP
		-- raise info '用户:%, 梯度:%, api:%, game_type:%', rec.player_id, rec.rakeback_id, rec.api_id, rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash, agenthash, row_to_json(rec), NULL) into rakeback;
		-- raise info '玩家:%, 有效交易量:%, 返水:%', rec.username, rec.effective_trade_amount, rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key 	= rec.api_id||col_split||rec.game_type;
			param 	= key||'=>'||rakeback||col_split||rec.player_num;
			hash 	= (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key 	= rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param 	= key||'=>'||rakeback;
			hash 	= (SELECT param::hstore)||hash;
		ELSE
			key 	= rec.player_id;
			param 	= key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val + rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	-- raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0107__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  su.username,
					  COUNT(DISTINCT rab.player_id) 					as player_num,
					  SUM(COALESCE(rab.effective_transaction, 0.00)) 	as effective_trade_amount,
					  up.rakeback_id
				 FROM rakeback_api_base rab
				 LEFT JOIN sys_user su ON rab.player_id = su.""id""
				 LEFT JOIN user_player up ON rab.player_id = up.""id""
			    WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				  AND up.rakeback_id IS NOT NULL
			    GROUP BY rab.api_id, rab.game_type, rab.player_id, su.username, up.rakeback_id';
	END IF;

	FOR rec IN EXECUTE sql USING start_time, end_time
	LOOP
		-- raise info '用户:%, 梯度:%, api:%, game_type:%', rec.player_id, rec.rakeback_id, rec.api_id, rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash, agenthash, row_to_json(rec), NULL) into rakeback;
		-- raise info '玩家:%, 有效交易量:%, 返水:%', rec.username, rec.effective_trade_amount, rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key = rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback||col_split||rec.player_num;
			hash = (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key = rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback;
			hash = (SELECT param::hstore)||hash;
		ELSE
			key = rec.player_id;
			param = key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val + rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	-- raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0096__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  su.username,
					  COUNT(DISTINCT rab.player_id) 					as player_num,
					  SUM(COALESCE(rab.effective_transaction, 0.00)) 	as effective_trade_amount,
					  up.rakeback_id
				 FROM rakeback_api_base rab
				 LEFT JOIN sys_user su ON rab.player_id = su.""id""
				 LEFT JOIN user_player up ON rab.player_id = up.""id""
			    WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				  AND up.rakeback_id IS NOT NULL
			    GROUP BY rab.api_id, rab.game_type, rab.player_id, su.username, up.rakeback_id';
	END IF;

	FOR rec IN EXECUTE sql USING start_time, end_time
	LOOP
		-- raise info '用户:%, 梯度:%, api:%, game_type:%', rec.player_id, rec.rakeback_id, rec.api_id, rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash, agenthash, row_to_json(rec), NULL) into rakeback;
		-- raise info '玩家:%, 有效交易量:%, 返水:%', rec.username, rec.effective_trade_amount, rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key = rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback||col_split||rec.player_num;
			hash = (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key = rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback;
			hash = (SELECT param::hstore)||hash;
		ELSE
			key = rec.player_id;
			param = key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val + rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	-- raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0104__U_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  COUNT(DISTINCT rab.player_id) 					as player_num,
				 FROM rakeback_api_base rab
			    WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				  AND up.rakeback_id IS NOT NULL
			    GROUP BY rab.api_id, rab.game_type, rab.player_id';
	ELSE
		sql = 'SELECT rab.api_id,
					  rab.game_type,
					  rab.player_id,
					  SUM(rakeback)	rakeback
				 FROM rakeback_api_base rab
				WHERE rab.rakeback_time >= $1
				  AND rab.rakeback_time < $2
				GROUP BY rab.api_id, rab.game_type, rab.player_id';
	END IF;

	FOR rec IN EXECUTE sql USING start_time, end_time
	LOOP
		-- SELECT gamebox_rakeback_calculator(gradshash, agenthash, row_to_json(rec), NULL) into rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key 	= rec.api_id||col_split||rec.game_type;
			param 	= key||'=>'||rec.rakeback||col_split||rec.player_num;
			hash 	= (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key 	= rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param 	= key||'=>'||rec.rakeback;
			hash 	= (SELECT param::hstore)||hash;
		ELSE
			key 	= rec.player_id;
			param 	= key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val + rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	-- raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",1_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT,
	vname 		TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = ' SELECT p.api_id,
					   p.game_type,
					   p.player_num,
					   p.effective_trade_amount,
					   up.rakeback_id
				  FROM (SELECT g.api_id,
				  			   g.game_type,
				  			   sum(distinct po.player_id)  		as player_num,
				  			   sum(po.effective_trade_amount) 	as effective_trade_amount
						  FROM player_game_order po,  '||vname||' g
						 WHERE po.game_id = g.id
						   AND po.create_time >= $1
						   AND po.create_time < $2
						 GROUP BY g.api_id,  g.game_type
					   ) p
				  LEFT JOIN user_player up on p.player_id = up.id';
	END IF;

	raise info 'gamebox_rakeback_api_map.sql = %',  sql;

	FOR rec IN EXECUTE sql USING start_time,  end_time
	LOOP
		--raise info '用户:%,  梯度:%,  api:%,  game_type:%',  rec.player_id,  rec.rakeback_id,  rec.api_id,  rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash,  agenthash,  row_to_json(rec)) into rakeback;
		--raise info '玩家:%,  有效交易量:%,  返水:%',  rec.username,  rec.effective_trade_amount,  rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key = rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback||col_split||rec.player_num;
			hash = (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key = rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback;
			hash = (SELECT param::hstore)||hash;
		ELSE
			key = rec.player_id;
			param = key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val+rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",E_gamebox_rakeback_0125.sql
"create or replace function gamebox_rakeback_api_map(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	gradshash 	hstore,
	agenthash 	hstore,
	category 	TEXT,
	vname 		TEXT
) returns hstore as $$

DECLARE
	hash 		hstore;--玩家API或玩家返水.
	rakeback 	FLOAT:=0.00;
	val 		FLOAT:=0.00;
	key 		TEXT:='';
	col_split 	TEXT:='_';
	rec 		record;
	param 		TEXT:='';
	sql 		TEXT:='';

BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category = 'GAME_TYPE' THEN
		sql = '';
	ELSE
		sql = ' SELECT p.api_id,
					   p.game_type,
					   p.player_num,
					   p.effective_trade_amount,
					   up.rakeback_id
				  FROM (SELECT g.api_id,
				  			   g.game_type,
				  			   sum(distinct po.player_id)  		as player_num,
				  			   sum(po.effective_trade_amount) 	as effective_trade_amount
						  FROM player_game_order po,  '||vname||' g
						 WHERE po.game_id = g.id
						   AND po.create_time >= $1
						   AND po.create_time < $2
						 GROUP BY g.api_id,  g.game_type
					   ) p
				  LEFT JOIN user_player up on p.player_id = up.id';
	END IF;

	raise info 'gamebox_rakeback_api_map.sql = %',  sql;

	FOR rec IN EXECUTE sql USING start_time,  end_time
	LOOP
		--raise info '用户:%,  梯度:%,  api:%,  game_type:%',  rec.player_id,  rec.rakeback_id,  rec.api_id,  rec.game_type;
		SELECT gamebox_rakeback_calculator(gradshash,  agenthash,  row_to_json(rec)) into rakeback;
		--raise info '玩家:%,  有效交易量:%,  返水:%',  rec.username,  rec.effective_trade_amount,  rakeback;

	  	IF category = 'GAME_TYPE' THEN
			key = rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback||col_split||rec.player_num;
			hash = (SELECT param::hstore)||hash;
		ELSEIF category = 'API' THEN
			key = rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
			param = key||'=>'||rakeback;
			hash = (SELECT param::hstore)||hash;
		ELSE
			key = rec.player_id;
			param = key||'=>'||rakeback;
			IF isexists(hash,  key) THEN
				val = (hash->key)::FLOAT;
				val = val+rakeback;
				param = key||'=>'||val;
			END IF;
			hash = (SELECT param::hstore)||hash;
		END IF;
	END LOOP;
	raise info 'Last Hash = %',  hash;

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0357__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
start_time TIMESTAMP,end_time TIMESTAMP
,gradshash hstore,agenthash hstore,category TEXT,vname TEXT)
 returns hstore as $$
DECLARE
	hash hstore;--玩家API或玩家返水.
	rakeback FLOAT:=0.00;
	val FLOAT:=0.00;
	key TEXT:='';
	col_split TEXT:='_';
	rec record;
	param TEXT:='';
	sql TEXT:='';
BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category='GAME_TYPE' THEN
		sql='select p.api_id
			,p.game_type
			,p.player_num
			,p.effective_trade_amount
			,up.rakeback_id
			from
			(
				SELECT g.api_id
				,g.game_type
				,sum(distinct po.player_id) as player_num
				,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY g.api_id,g.game_type
			) p left join user_player up
			on p.player_id=up.id ';
	ELSE
		sql='select p.player_id,u.owner_id
			,p.api_id,p.api_type_id,p.game_type
			,p.effective_trade_amount,up.rakeback_id
			from
			(
				SELECT po.player_id,g.api_id,g.game_type,
				g.api_type_id,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY po.player_id,g.api_id,g.game_type,g.api_type_id
			) p left join user_player up
			on p.player_id=up.id,sys_user u
			where p.player_id=u.id ';
	END IF;
	FOR rec IN EXECUTE sql USING start_time,end_time
	LOOP
			--raise info '用户:%,梯度:%,api:%,game_type:%',rec.player_id,rec.rakeback_id,rec.api_id,rec.game_type;
			select gamebox_rakeback_calculator(gradshash,agenthash,row_to_json(rec)) into rakeback;
			--raise info '玩家:%,有效交易量:%,返水:%',rec.username,rec.effective_trade_amount,rakeback;

		  IF category='GAME_TYPE' THEN
				key=rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback||col_split||rec.player_num;
				hash=(SELECT param::hstore)||hash;
			ELSEIF category='API' THEN
				key=rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback;
				hash=(SELECT param::hstore)||hash;
			ELSE
				key=rec.player_id;
				param=key||'=>'||rakeback;
				IF isexists(hash,key) THEN
					val=(hash->key)::FLOAT;
					val=val+rakeback;
					param=key||'=>'||val;
				END IF;
				hash=(SELECT param::hstore)||hash;
			END IF;
	END LOOP;
	raise info '%',hash;
	RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0258__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
start_time TIMESTAMP,end_time TIMESTAMP
,gradshash hstore,agenthash hstore,category TEXT,vname TEXT)
 returns hstore as $$
DECLARE
	hash hstore;--玩家API或玩家返水.
	rakeback FLOAT:=0.00;
	val FLOAT:=0.00;
	key TEXT:='';
	col_split TEXT:='_';
	rec record;
	param TEXT:='';
	sql TEXT:='';
BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category='GAME_TYPE' THEN
		sql='select p.api_id
			,p.game_type
			,p.player_num
			,p.effective_trade_amount
			,up.rakeback_id
			from
			(
				SELECT g.api_id
				,g.game_type
				,sum(distinct po.player_id) as player_num
				,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY g.api_id,g.game_type
			) p left join user_player up
			on p.player_id=up.id ';
	ELSE
		sql='select p.player_id,u.owner_id
			,p.api_id,p.api_type_id,p.game_type
			,p.effective_trade_amount,up.rakeback_id
			from
			(
				SELECT po.player_id,g.api_id,g.game_type,
				g.api_type_id,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY po.player_id,g.api_id,g.game_type,g.api_type_id
			) p left join user_player up
			on p.player_id=up.id,sys_user u
			where p.player_id=u.id ';
	END IF;
	FOR rec IN EXECUTE sql USING start_time,end_time
	LOOP
			--raise info '用户:%,梯度:%,api:%,game_type:%',rec.player_id,rec.rakeback_id,rec.api_id,rec.game_type;
			select gamebox_rakeback_calculator(gradshash,agenthash,row_to_json(rec)) into rakeback;
			--raise info '玩家:%,有效交易量:%,返水:%',rec.username,rec.effective_trade_amount,rakeback;

		  IF category='GAME_TYPE' THEN
				key=rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback||col_split||rec.player_num;
				hash=(SELECT param::hstore)||hash;
			ELSEIF category='API' THEN
				key=rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback;
				hash=(SELECT param::hstore)||hash;
			ELSE
				key=rec.player_id;
				param=key||'=>'||rakeback;
				IF isexists(hash,key) THEN
					val=(hash->key)::FLOAT;
					val=val+rakeback;
					param=key||'=>'||val;
				END IF;
				hash=(SELECT param::hstore)||hash;
			END IF;
	END LOOP;
	raise info '%',hash;
	RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0305__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
start_time TIMESTAMP,end_time TIMESTAMP
,gradshash hstore,agenthash hstore,category TEXT,vname TEXT)
 returns hstore as $$
DECLARE
	hash hstore;--玩家API或玩家返水.
	rakeback FLOAT:=0.00;
	val FLOAT:=0.00;
	key TEXT:='';
	col_split TEXT:='_';
	rec record;
	param TEXT:='';
	sql TEXT:='';
BEGIN
	SELECT '-1=>-1' INTO hash;
	IF category='GAME_TYPE' THEN
		sql='select p.api_id
			,p.game_type
			,p.player_num
			,p.effective_trade_amount
			,up.rakeback_id
			from
			(
				SELECT g.api_id
				,g.game_type
				,sum(distinct po.player_id) as player_num
				,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY g.api_id,g.game_type
			) p left join user_player up
			on p.player_id=up.id ';
	ELSE
		sql='select p.player_id,u.owner_id
			,p.api_id,p.api_type_id,p.game_type
			,p.effective_trade_amount,up.rakeback_id
			from
			(
				SELECT po.player_id,g.api_id,g.game_type,
				g.api_type_id,sum(po.effective_trade_amount) AS effective_trade_amount
				FROM player_game_order po,'||vname||' g
				where po.game_id=g.id
				and po.create_time>=$1 and po.create_time<$2
				GROUP BY po.player_id,g.api_id,g.game_type,g.api_type_id
			) p left join user_player up
			on p.player_id=up.id,sys_user u
			where p.player_id=u.id ';
	END IF;
	FOR rec IN EXECUTE sql USING start_time,end_time
	LOOP
			--raise info '用户:%,梯度:%,api:%,game_type:%',rec.player_id,rec.rakeback_id,rec.api_id,rec.game_type;
			select gamebox_rakeback_calculator(gradshash,agenthash,row_to_json(rec)) into rakeback;
			--raise info '玩家:%,有效交易量:%,返水:%',rec.username,rec.effective_trade_amount,rakeback;

		  IF category='GAME_TYPE' THEN
				key=rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback||col_split||rec.player_num;
				hash=(SELECT param::hstore)||hash;
			ELSEIF category='API' THEN
				key=rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback;
				hash=(SELECT param::hstore)||hash;
			ELSE
				key=rec.player_id;
				param=key||'=>'||rakeback;
				IF isexists(hash,key) THEN
					val=(hash->key)::FLOAT;
					val=val+rakeback;
					param=key||'=>'||val;
				END IF;
				hash=(SELECT param::hstore)||hash;
			END IF;
	END LOOP;
	raise info '%',hash;
	RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0314__E_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_api_map(
start_time TIMESTAMP,end_time TIMESTAMP
,gradshash hstore,agenthash hstore,category TEXT,vname TEXT)
 returns hstore as $$
DECLARE
	hash hstore;--玩家API或玩家返水.
	rakeback FLOAT:=0.00;
	val FLOAT:=0.00;
	key TEXT:='';
	col_split TEXT:='_';
	rec record;
	param TEXT:='';
BEGIN
	SELECT '-1=>-1' INTO hash;
	FOR rec IN EXECUTE '
		select p.player_id,u.owner_id
		,p.api_id,p.api_type_id,p.game_type
		,p.effective_trade_amount,up.rakeback_id
		from
		(
			SELECT po.player_id,g.api_id,g.game_type,
	    g.api_type_id,sum(po.effective_trade_amount) AS effective_trade_amount
      FROM player_game_order po,'||vname||' g
			where po.game_id=g.id
			and po.create_time>=$1 and po.create_time<$2
      GROUP BY po.player_id,g.api_id,g.game_type,g.api_type_id
		) p left join user_player up
		on p.player_id=up.id,sys_user u
		where p.player_id=u.id
		'
		USING start_time,end_time
	LOOP
			--raise info '用户:%,梯度:%,api:%,game_type:%',rec.player_id,rec.rakeback_id,rec.api_id,rec.game_type;
			select gamebox_rakeback_calculator(gradshash,agenthash,row_to_json(rec)) into rakeback;
			--raise info '玩家:%,有效交易量:%,返水:%',rec.username,rec.effective_trade_amount,rakeback;
			IF category='API' THEN
				key=rec.player_id||col_split||rec.api_id||col_split||rec.game_type;
				param=key||'=>'||rakeback;
				hash=(SELECT param::hstore)||hash;
			ELSE
				key=rec.player_id;
				param=key||'=>'||rakeback;
				IF isexists(hash,key) THEN
					val=(hash->key)::FLOAT;
					val=val+rakeback;
					param=key||'=>'||val;
				END IF;
				hash=(SELECT param::hstore)||hash;
			END IF;
	END LOOP;
	raise info '%',hash;
	RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_calculator(gradshash hstore,agenthash hstore,rec json) returns FLOAT as $$
DECLARE
	--gradshash hstore;
	--agenthash hstore;
	--rec record;
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	--临时Hstore
	hash hstore;
	--梯度有效交易量
	valid_value float:=0.00;
	--上次梯度有效交易量
	pre_valid_value float:=0.00;
	--返水值.
	back_water_value float:=0.00;
	--占成
	ratio float:=0.00;
	--最大返水上限
	max_back_water float:=0.00;
	--玩家有效交易量
	effective_trade_amount float:=0.00;
	--梯度ID.
	back_water_id int:=0;
	--API
	api int:=0;
	--游戏类型
	gameType text;
	--代理ID
	agent_id text;
BEGIN
		--raise info 'gradshash=%',gradshash;
		keys=akeys(gradshash);
		--raise info 'Len=%',array_length(keys, 1);
	  --raise info 'rec=%',rec;
		for i in 1..array_length(keys, 1) loop
			subkeys=regexp_split_to_array(keys[i],'_');
			keyname=keys[i];

		  back_water_id=rec->>'rakeback_id';
			api=rec->>'api_id';
			gameType=rtrim(ltrim(rec->>'game_type'));
			--玩家未设置返水梯度,取当前玩家的代理返水梯度.
			agent_id=rec->>'owner_id';
			--raise info '代理ID:%,梯度:%',keyname,back_water_id;
			if back_water_id is null THEN
				back_water_id=agenthash->agent_id;
			end if;
			if back_water_id is null THEN
				--raise exception '%:玩家未设置返水梯度,代理也未设置',rec->>'username';
				raise info '%:玩家未设置返水梯度,代理也未设置',rec->>'username';
				return 0;
			end if;
			--raise info 'gameType=%',gameType;
			IF subkeys[1]::int=back_water_id AND subkeys[3]::int=api AND rtrim(ltrim(subkeys[4]))=gameType
			THEN
	      --raise info 'key=%',subkeys;
				--raise info '找到返水主方案:%',subkeys[1];
				--开始作比较.
			  --raise info 'val=%',gradshash->keyname;
				val=gradshash->keyname;
			  --玩家有效交易量
				effective_trade_amount=(rec->>'effective_trade_amount')::float;
				--判断是否已经比较够且有效交易量大于当前值.
				--raise info '%>%:%',effective_trade_amount,pre_valid_value,(effective_trade_amount>pre_valid_value);
				IF effective_trade_amount>pre_valid_value THEN
					select * from strToHash(val) into hash;
					--占成数
					ratio=(hash->'ratio')::float;
					--梯度有效交易量
					valid_value=(hash->'valid_value')::float;
					--返水上限
					max_back_water=(hash->'max_rakeback')::float;

					--raise info '梯度有效交易量:%,返水上限:%,占成比例:%,占成比例:%',valid_value,max_back_water,ratio,effective_trade_amount;
					--raise info '返水上限:%',max_back_water;
					--raise info '占成比例:%',ratio;
					--raise info '玩家有效值:%',effective_trade_amount;

					IF effective_trade_amount >= valid_value THEN
						--存储此次梯度有效交易量,作下次比较.
						pre_valid_value=valid_value;
						--返水计算:有效交易量*占成
						back_water_value=effective_trade_amount*ratio/100;
						--返水大于返水上限，以上限值为准.
						IF back_water_value>max_back_water THEN
								back_water_value=max_back_water;
						END IF;
						raise info '玩家信息.ID:%,API:%,GAMETYPE:%,有效交易量:%,梯度.有效交易量:%,上限:%,比例:%,返水:%'
							,rec->>'player_id',api,gameType,effective_trade_amount,valid_value,max_back_water,ratio,back_water_value;
					END IF;
					--raise info '玩家返水值:%',back_water_value;
				END IF;
			ELSE
			--	raise info '没找到返水方案';
			END IF;
		END LOOP;
	return back_water_value;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rakeback_map(
startTime TIMESTAMP,endTime TIMESTAMP
,url TEXT,category TEXT) returns hstore as $$
DECLARE
  gradshash hstore;
	agenthash hstore;
	hash hstore;
	vname text:='v_site_game';
	sid INT:=-1;
BEGIN

	select gamebox_current_site() INTO sid;
  perform gamebox_site_game(url,vname,sid,'C');
	--取得当前返水梯度设置信息.
  select gamebox_rakeback_api_grads() into gradshash;
  select gamebox_agent_rakeback() into agenthash;
  raise info '统计玩家API返水';
	SELECT gamebox_rakeback_api_map(startTime,endTime,gradshash,agenthash,category,vname) INTO hash;
	raise info '统计玩家API返水.完成';
	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');
	RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0245__C_gamebox_rakeback.sql
"create or replace function gamebox_rebate(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		text
) returns void as $$

DECLARE
	rec 		record;
	--系统设置各种承担比例.
	syshash 	hstore;
	--各API的返佣设置
  	gradshash 	hstore;
	--各个代理的返佣设置
	agenthash 	hstore;
	--运营商各API占成比例.
	mainhash 	hstore;
	--存储每个代理是否满足梯度.
	checkhash 	hstore;
	--各玩家返水.
	rakebackhash hstore;
	--临时
	hash 		hstore;
	mhash 		hstore;
	--返佣值
	rebate_value FLOAT;

	sid 	int;
	keyId 	int;
	tmp 	int;
	e1 		text;	-- 异常信息
	e2 		text;
	e3 		text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;

	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	--分隔符
	row_split 	text:='^&^';
	col_split 	text:='^';

	vname 		text:='v_site_game';
	--运营商占成参数.
	is_max 		BOOLEAN:=true;
	key_type 	int:=4;
	category 	TEXT:='AGENT';

	rebate_bill_id INT:=-1;--返佣主表键值.

BEGIN
	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;
	raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
	raise info '取得玩家返水';
	-- ============================================================================================================================
	-- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
	SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
	raise info 'rakebackhash = %', rakebackhash;
	raise info '创建站点游戏视图';
  	--取得当前站点.
	SELECT gamebox_current_site() INTO sid;
  	perform gamebox_site_game(url,vname,sid, 'C');
	--取得系统关于各种承担比例参数.
	SELECT gamebox_sys_param('apportionSetting') INTO syshash;
	--取得当前返佣梯度设置信息.
  	SELECT gamebox_rebate_api_grads() INTO gradshash;
	--取得代理默认返佣方案
  	SELECT gamebox_rebate_agent_default_set() INTO agenthash;
  	--判断各个代理满足的返佣梯度.
	SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;
	--raise info 'keys:%', checkhash;
	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

	--先插入返佣总记录并取得键值.
  	raise info '返佣rebate_bill新增记录';
	SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;
  	raise info '返佣rebate_bill.ID=%', rebate_bill_id;
	--先统计每个代理的有效交易量、有效玩家、盈亏总额.
  	raise info '计算各玩家API返佣';
	perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

  	raise info '收集各玩家的分摊费用';
	SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

	raise info '统计各玩家返佣';
  	perform gamebox_rebate_player(syshash, hash, rakebackhash, rebate_bill_id, row_split, col_split, flag);

	raise info '开始统计代理返佣';
	perform gamebox_rebate_agent(rebate_bill_id,flag);

  	raise info '更新返佣总表';
	perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);
	--删除临时视图表.
	perform gamebox_site_game(url, vname, sid, 'D');

	--异常处理
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS e1 = MESSAGE_TEXT, e2 = PG_EXCEPTION_DETAIL, e3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%', e1, e2, e3;
END;

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_rebate(
	name 		text,
	startTime 	text,
	endTime 	text,
	url 		text,
	flag 		text
) returns void as $$

DECLARE
	rec 		record;
	--系统设置各种承担比例.
	syshash 	hstore;
	--各API的返佣设置
  	gradshash 	hstore;
	--各个代理的返佣设置
	agenthash 	hstore;
	--运营商各API占成比例.
	mainhash 	hstore;
	--存储每个代理是否满足梯度.
	checkhash 	hstore;
	--各玩家返水.
	rakebackhash hstore;
	--临时
	hash 		hstore;
	mhash 		hstore;
	--返佣值
	rebate_value FLOAT;

	sid 	int;
	keyId 	int;
	tmp 	int;
	e1 		text;	-- 异常信息
	e2 		text;
	e3 		text;
	stTime 	TIMESTAMP;
	edTime 	TIMESTAMP;

	pending_lssuing text:='pending_lssuing';
	pending_pay 	text:='pending_pay';
	--分隔符
	row_split 	text:='^&^';
	col_split 	text:='^';

	vname 		text:='v_site_game';
	--运营商占成参数.
	is_max 		BOOLEAN:=true;
	key_type 	int:=4;
	category 	TEXT:='AGENT';

	rebate_bill_id INT:=-1;--返佣主表键值.

BEGIN
	stTime = startTime::TIMESTAMP;
	edTime = endTime::TIMESTAMP;
	raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
	raise info '取得玩家返水';
	-- ============================================================================================================================
	-- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
	SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
	raise info 'rakebackhash = %', rakebackhash;
	raise info '创建站点游戏视图';
  	--取得当前站点.
	SELECT gamebox_current_site() INTO sid;
  	perform gamebox_site_game(url,vname,sid, 'C');
	--取得系统关于各种承担比例参数.
	SELECT gamebox_sys_param('apportionSetting') INTO syshash;
	--取得当前返佣梯度设置信息.
  	SELECT gamebox_rebate_api_grads() INTO gradshash;
	--取得代理默认返佣方案
  	SELECT gamebox_rebate_agent_default_set() INTO agenthash;
  	--判断各个代理满足的返佣梯度.
	SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;
	--raise info 'keys:%', checkhash;
	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

	--先插入返佣总记录并取得键值.
  	raise info '返佣rebate_bill新增记录';
	SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;
  	raise info '返佣rebate_bill.ID=%', rebate_bill_id;
	--先统计每个代理的有效交易量、有效玩家、盈亏总额.
  	raise info '计算各玩家API返佣';
	perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

  	raise info '收集各玩家的分摊费用';
	SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

	raise info '统计各玩家返佣';
  	perform gamebox_rebate_player(syshash, hash, rakebackhash, rebate_bill_id, row_split, col_split, flag);

	raise info '开始统计代理返佣';
	perform gamebox_rebate_agent(rebate_bill_id,flag);

  	raise info '更新返佣总表';
	perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);
	--删除临时视图表.
	perform gamebox_site_game(url, vname, sid, 'D');

	--异常处理
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS e1 = MESSAGE_TEXT, e2 = PG_EXCEPTION_DETAIL, e3 = PG_EXCEPTION_HINT;
	raise EXCEPTION '异常:%,%,%', e1, e2, e3;
END;

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_rebate(
    name 		text,
    startTime 	text,
    endTime 	text,
    url 		text,
    flag 		text
) returns void as $$

DECLARE
    rec 		record;   --系统设置各种承担比例.
    syshash 	hstore;   --各API的返佣设置
    gradshash 	hstore;   --各个代理的返佣设置
    agenthash 	hstore;   --运营商各API占成比例.
    mainhash 	hstore;   --存储每个代理是否满足梯度.
    checkhash 	hstore;   --各玩家返水.
    rakebackhash hstore;  --临时
    hash 		hstore;
    mhash 		hstore;   --返佣值
    rebate_value FLOAT;

    sid 	int;
    keyId 	int;
    tmp 	int;
    e1 		text;	-- 异常信息
    e2 		text;
    e3 		text;
    stTime 	TIMESTAMP;
    edTime 	TIMESTAMP;

    pending_lssuing text:='pending_lssuing';
    pending_pay 	text:='pending_pay';
    --分隔符
    row_split 	text:='^&^';
    col_split 	text:='^';

    --运营商占成参数.
    is_max 		BOOLEAN:=true;
    key_type 	int:=4;
    category 	TEXT:='AGENT';

    rebate_bill_id INT:=-1; --返佣主表键值.

BEGIN
    stTime = startTime::TIMESTAMP;
    edTime = endTime::TIMESTAMP;
    raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
    raise info '取得玩家返水';
    -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
    SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
    -- raise info 'rakebackhash = %', rakebackhash;
    --取得当前站点.
    SELECT gamebox_current_site() INTO sid;
    --取得系统关于各种承担比例参数.
    SELECT gamebox_sys_param('apportionSetting') INTO syshash;
    --取得当前返佣梯度设置信息.
    SELECT gamebox_rebate_api_grads() INTO gradshash;
    --取得代理默认返佣方案
    SELECT gamebox_rebate_agent_default_set() INTO agenthash;
    --判断各个代理满足的返佣梯度.
    SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;
    --raise info 'keys:%', checkhash;
    --取得各API的运营商占成.
    raise info '取得运营商各API占成';
    SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

    --先插入返佣总记录并取得键值.
    raise info '返佣rebate_bill新增记录';
    SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;
    raise info '返佣rebate_bill.ID=%', rebate_bill_id;
    --先统计每个代理的有效交易量、有效玩家、盈亏总额.
    raise info '计算各玩家API返佣';
    perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

    raise info '收集各玩家的分摊费用';
    SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

    raise info '统计各玩家返佣';
    perform gamebox_rebate_player(syshash, hash, rakebackhash, gradshash, rebate_bill_id, row_split, col_split, flag);

    raise info '开始统计代理返佣';
    perform gamebox_rebate_agent(rebate_bill_id,flag);

    raise info '更新返佣总表';
    perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

    --异常处理
    EXCEPTION
    WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS e1 = MESSAGE_TEXT, e2 = PG_EXCEPTION_DETAIL, e3 = PG_EXCEPTION_HINT;
    raise EXCEPTION '异常:%,%,%', e1, e2, e3;
END;

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_rebate(
    name 		text,
    startTime 	text,
    endTime 	text,
    url 		text,
    flag 		text
) returns void as $$

DECLARE
    rec 		record;   --系统设置各种承担比例.
    syshash 	hstore;   --各API的返佣设置
    gradshash 	hstore;   --各个代理的返佣设置
    agenthash 	hstore;   --运营商各API占成比例.
    mainhash 	hstore;   --存储每个代理是否满足梯度.
    checkhash 	hstore;   --各玩家返水.
    rakebackhash hstore;  --临时
    hash 		hstore;
    mhash 		hstore;   --返佣值
    rebate_value FLOAT;

    sid 	int;
    keyId 	int;
    tmp 	int;
    stTime 	TIMESTAMP;
    edTime 	TIMESTAMP;

    pending_lssuing text:='pending_lssuing';
    pending_pay 	text:='pending_pay';
    --分隔符
    row_split 	text:='^&^';
    col_split 	text:='^';

    --运营商占成参数.
    is_max 		BOOLEAN:=true;
    key_type 	int:=4;
    category 	TEXT:='AGENT';

    rebate_bill_id INT:=-1; --返佣主表键值.

BEGIN
    stTime = startTime::TIMESTAMP;
    edTime = endTime::TIMESTAMP;
    raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
    raise info '取得玩家返水';
    -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
    SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
    --取得当前站点.
    SELECT gamebox_current_site() INTO sid;
    --取得系统关于各种承担比例参数.
    SELECT gamebox_sys_param('apportionSetting') INTO syshash;
    --取得当前返佣梯度设置信息.
    SELECT gamebox_rebate_api_grads() INTO gradshash;
    --取得代理默认返佣方案
    SELECT gamebox_rebate_agent_default_set() INTO agenthash;
    --判断各个代理满足的返佣梯度.
    SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;

    IF checkhash IS NOT NULL THEN

    	--取得各API的运营商占成.
	    raise info '取得运营商各API占成';
	    SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

	    --先插入返佣总记录并取得键值.
	    raise info '返佣rebate_bill新增记录';
	    SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;

	    raise info '计算各玩家API返佣';
	    perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

	    raise info '收集各玩家的分摊费用';
	    SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

	    raise info '统计各玩家返佣';
	    perform gamebox_rebate_player(syshash, hash, rakebackhash, gradshash, rebate_bill_id, row_split, col_split, flag);

	    raise info '开始统计代理返佣';
	    perform gamebox_rebate_agent(rebate_bill_id,flag, checkhash);

	    raise info '更新返佣总表';
	    perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

	END IF;

END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_rebate(
    name 		text,
    startTime 	text,
    endTime 	text,
    url 		text,
    flag 		text
) returns void as $$

DECLARE
    rec 		record;   --系统设置各种承担比例.
    syshash 	hstore;   --各API的返佣设置
    gradshash 	hstore;   --各个代理的返佣设置
    agenthash 	hstore;   --运营商各API占成比例.
    mainhash 	hstore;   --存储每个代理是否满足梯度.
    checkhash 	hstore;   --各玩家返水.
    rakebackhash hstore;  --临时
    hash 		hstore;
    mhash 		hstore;   --返佣值
    rebate_value FLOAT;

    sid 	int;
    keyId 	int;
    tmp 	int;
    stTime 	TIMESTAMP;
    edTime 	TIMESTAMP;

    pending_lssuing text:='pending_lssuing';
    pending_pay 	text:='pending_pay';
    --分隔符
    row_split 	text:='^&^';
    col_split 	text:='^';

    --运营商占成参数.
    is_max 		BOOLEAN:=true;
    key_type 	int:=4;
    category 	TEXT:='AGENT';

    rebate_bill_id INT:=-1; --返佣主表键值.

BEGIN
    stTime = startTime::TIMESTAMP;
    edTime = endTime::TIMESTAMP;
    raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
    raise info '取得玩家返水';
    -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
    SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
    --取得当前站点.
    SELECT gamebox_current_site() INTO sid;
    --取得系统关于各种承担比例参数.
    SELECT gamebox_sys_param('apportionSetting') INTO syshash;
    --取得当前返佣梯度设置信息.
    SELECT gamebox_rebate_api_grads() INTO gradshash;
    --取得代理默认返佣方案
    SELECT gamebox_rebate_agent_default_set() INTO agenthash;
    --判断各个代理满足的返佣梯度.
    SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime, flag) INTO checkhash;

    IF checkhash IS NOT NULL THEN

    	--取得各API的运营商占成.
	    raise info '取得运营商各API占成';
	    SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type, flag) INTO mainhash;

	    --先插入返佣总记录并取得键值.
	    raise info '返佣rebate_bill新增记录';
	    SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;

	    raise info '计算各玩家API返佣';
	    perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

	    raise info '收集各玩家的分摊费用';
	    SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split, flag) INTO hash;

	    raise info '统计各玩家返佣';
	    perform gamebox_rebate_player(syshash, hash, rakebackhash, gradshash, rebate_bill_id, row_split, col_split, flag);

	    raise info '开始统计代理返佣';
	    perform gamebox_rebate_agent(rebate_bill_id,flag, checkhash);

	    raise info '更新返佣总表';
	    perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

	END IF;

END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate(
    name 		text,
    startTime 	text,
    endTime 	text,
    url 		text,
    flag 		text
) returns void as $$

DECLARE
    rec 		record;   --系统设置各种承担比例.
    syshash 	hstore;   --各API的返佣设置
    gradshash 	hstore;   --各个代理的返佣设置
    agenthash 	hstore;   --运营商各API占成比例.
    mainhash 	hstore;   --存储每个代理是否满足梯度.
    checkhash 	hstore;   --各玩家返水.
    rakebackhash hstore;  --临时
    hash 		hstore;
    mhash 		hstore;   --返佣值
    rebate_value FLOAT;

    sid 	int;
    keyId 	int;
    tmp 	int;
    stTime 	TIMESTAMP;
    edTime 	TIMESTAMP;

    pending_lssuing text:='pending_lssuing';
    pending_pay 	text:='pending_pay';
    --分隔符
    row_split 	text:='^&^';
    col_split 	text:='^';

    --运营商占成参数.
    is_max 		BOOLEAN:=true;
    key_type 	int:=4;
    category 	TEXT:='AGENT';

    rebate_bill_id INT:=-1; --返佣主表键值.

BEGIN
    stTime = startTime::TIMESTAMP;
    edTime = endTime::TIMESTAMP;
    raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
    raise info '取得玩家返水';
    -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
    SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
    --取得当前站点.
    SELECT gamebox_current_site() INTO sid;
    --取得系统关于各种承担比例参数.
    SELECT gamebox_sys_param('apportionSetting') INTO syshash;
    --取得当前返佣梯度设置信息.
    SELECT gamebox_rebate_api_grads() INTO gradshash;
    --取得代理默认返佣方案
    SELECT gamebox_rebate_agent_default_set() INTO agenthash;
    --判断各个代理满足的返佣梯度.
    SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime, flag) INTO checkhash;

    IF checkhash IS NOT NULL THEN

    	--取得各API的运营商占成.
	    raise info '取得运营商各API占成';
	    SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type, flag) INTO mainhash;

	    --先插入返佣总记录并取得键值.
	    raise info '返佣rebate_bill新增记录';
	    SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;

	    raise info '计算各玩家API返佣';
	    perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

	    raise info '收集各玩家的分摊费用';
	    SELECT gamebox_rebate_expense_gather(rebate_bill_id, stTime, edTime, row_split, col_split, flag) INTO hash;

	    raise info '统计各玩家返佣';
	    perform gamebox_rebate_player(syshash, hash, rakebackhash, rebate_bill_id, row_split, col_split, flag);

	    raise info '开始统计代理返佣';
	    perform gamebox_rebate_agent(rebate_bill_id,flag, checkhash);

	    raise info '更新返佣总表';
	    perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

	END IF;

END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate(
  name 		text,
  startTime 	text,
  endTime 	text,
  url 		text,
  flag 		text
) returns void as $$

DECLARE
  rec 		record;
  --系统设置各种承担比例.
  syshash 	hstore;
  --各API的返佣设置
  gradshash 	hstore;
  --各个代理的返佣设置
  agenthash 	hstore;
  --运营商各API占成比例.
  mainhash 	hstore;
  --存储每个代理是否满足梯度.
  checkhash 	hstore;
  --各玩家返水.
  rakebackhash hstore;
  --临时
  hash 		hstore;
  mhash 		hstore;
  --返佣值
  rebate_value FLOAT;

  sid 	int;
  keyId 	int;
  tmp 	int;
  e1 		text;	-- 异常信息
  e2 		text;
  e3 		text;
  stTime 	TIMESTAMP;
  edTime 	TIMESTAMP;

  pending_lssuing text:='pending_lssuing';
  pending_pay 	text:='pending_pay';
  --分隔符
  row_split 	text:='^&^';
  col_split 	text:='^';

  --运营商占成参数.
  is_max 		BOOLEAN:=true;
  key_type 	int:=4;
  category 	TEXT:='AGENT';

  rebate_bill_id INT:=-1;--返佣主表键值.

BEGIN
  stTime = startTime::TIMESTAMP;
  edTime = endTime::TIMESTAMP;
  raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
  raise info '取得玩家返水';
  -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
  SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
  -- raise info 'rakebackhash = %', rakebackhash;
  raise info '创建站点游戏视图';
  --取得当前站点.
  SELECT gamebox_current_site() INTO sid;
  --取得系统关于各种承担比例参数.
  SELECT gamebox_sys_param('apportionSetting') INTO syshash;
  --取得当前返佣梯度设置信息.
  SELECT gamebox_rebate_api_grads() INTO gradshash;
  --取得代理默认返佣方案
  SELECT gamebox_rebate_agent_default_set() INTO agenthash;
  --判断各个代理满足的返佣梯度.
  SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;
  --raise info 'keys:%', checkhash;
  --取得各API的运营商占成.
  raise info '取得运营商各API占成';
  SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

  --先插入返佣总记录并取得键值.
  raise info '返佣rebate_bill新增记录';
  SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;
  raise info '返佣rebate_bill.ID=%', rebate_bill_id;
  --先统计每个代理的有效交易量、有效玩家、盈亏总额.
  raise info '计算各玩家API返佣';
  perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

  raise info '收集各玩家的分摊费用';
  SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

  raise info '统计各玩家返佣';
  perform gamebox_rebate_player(syshash, hash, rakebackhash, gradshash, rebate_bill_id, row_split, col_split, flag);

  raise info '开始统计代理返佣';
  perform gamebox_rebate_agent(rebate_bill_id,flag);

  raise info '更新返佣总表';
  perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

  --异常处理
  EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS e1 = MESSAGE_TEXT, e2 = PG_EXCEPTION_DETAIL, e3 = PG_EXCEPTION_HINT;
    raise EXCEPTION '异常:%,%,%', e1, e2, e3;
END;

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_rebate(
  name 		text,
  startTime 	text,
  endTime 	text,
  url 		text,
  flag 		text
) returns void as $$

DECLARE
  rec 		record;
  --系统设置各种承担比例.
  syshash 	hstore;
  --各API的返佣设置
  gradshash 	hstore;
  --各个代理的返佣设置
  agenthash 	hstore;
  --运营商各API占成比例.
  mainhash 	hstore;
  --存储每个代理是否满足梯度.
  checkhash 	hstore;
  --各玩家返水.
  rakebackhash hstore;
  --临时
  hash 		hstore;
  mhash 		hstore;
  --返佣值
  rebate_value FLOAT;

  sid 	int;
  keyId 	int;
  tmp 	int;
  e1 		text;	-- 异常信息
  e2 		text;
  e3 		text;
  stTime 	TIMESTAMP;
  edTime 	TIMESTAMP;

  pending_lssuing text:='pending_lssuing';
  pending_pay 	text:='pending_pay';
  --分隔符
  row_split 	text:='^&^';
  col_split 	text:='^';

  --运营商占成参数.
  is_max 		BOOLEAN:=true;
  key_type 	int:=4;
  category 	TEXT:='AGENT';

  rebate_bill_id INT:=-1;--返佣主表键值.

BEGIN
  stTime = startTime::TIMESTAMP;
  edTime = endTime::TIMESTAMP;
  raise info '开始统计第( % )期的返佣,周期( %-% )', name, startTime, endTime;
  raise info '取得玩家返水';
  -- SELECT gamebox_rakeback_map(stTime, edTime, url, 'PLAYER') INTO rakebackhash;
  SELECT gamebox_rebate_rakeback_map(stTime, edTime) INTO rakebackhash;
  -- raise info 'rakebackhash = %', rakebackhash;
  raise info '创建站点游戏视图';
  --取得当前站点.
  SELECT gamebox_current_site() INTO sid;
  --取得系统关于各种承担比例参数.
  SELECT gamebox_sys_param('apportionSetting') INTO syshash;
  --取得当前返佣梯度设置信息.
  SELECT gamebox_rebate_api_grads() INTO gradshash;
  --取得代理默认返佣方案
  SELECT gamebox_rebate_agent_default_set() INTO agenthash;
  --判断各个代理满足的返佣梯度.
  SELECT gamebox_rebate_agent_check(gradshash, agenthash, stTime, edTime) INTO checkhash;
  --raise info 'keys:%', checkhash;
  --取得各API的运营商占成.
  raise info '取得运营商各API占成';
  SELECT gamebox_operations_occupy(url, sid, stTime, edTime, category, is_max, key_type) INTO mainhash;

  --先插入返佣总记录并取得键值.
  raise info '返佣rebate_bill新增记录';
  SELECT gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'I', flag) INTO rebate_bill_id;
  raise info '返佣rebate_bill.ID=%', rebate_bill_id;
  --先统计每个代理的有效交易量、有效玩家、盈亏总额.
  raise info '计算各玩家API返佣';
  perform gamebox_rebate_api(rebate_bill_id, stTime, edTime, gradshash, checkhash, mainhash, flag);

  raise info '收集各玩家的分摊费用';
  SELECT gamebox_rebate_expense_gather(rebate_bill_id, rakebackhash, stTime, edTime, row_split, col_split) INTO hash;

  raise info '统计各玩家返佣';
  perform gamebox_rebate_player(syshash, hash, rakebackhash, gradshash, rebate_bill_id, row_split, col_split, flag);

  raise info '开始统计代理返佣';
  perform gamebox_rebate_agent(rebate_bill_id,flag);

  raise info '更新返佣总表';
  perform gamebox_rebate_bill(name, stTime, edTime, rebate_bill_id, 'U', flag);

  --异常处理
  EXCEPTION
  WHEN OTHERS THEN
    GET STACKED DIAGNOSTICS e1 = MESSAGE_TEXT, e2 = PG_EXCEPTION_DETAIL, e3 = PG_EXCEPTION_HINT;
    raise EXCEPTION '异常:%,%,%', e1, e2, e3;
END;

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_rebate(
name text
,startTime text
,endTime text
,url text
,flag text
) returns void as $$
DECLARE
	rec record;
	--系统设置各种承担比例.
	syshash hstore;
	--各API的返佣设置
  gradshash hstore;
	--各个代理的返佣设置
	agenthash hstore;
	--运营商各API占成比例.
	mainhash hstore;
	--存储每个代理是否满足梯度.
	checkhash hstore;

	rakebackhash hstore;--各玩家返水.
	--临时
	hash hstore;
	mhash hstore;
	--返佣值
	rebate_value FLOAT;

	sid int;
	keyId int;
	tmp int;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;

	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	--分隔符
	row_split text:='^&^';
	col_split text:='^';

	vname text:='v_site_game';
	--运营商占成参数.
	is_max BOOLEAN:=true;
	key_type int:=4;
	category TEXT:='AGENT';

	rebate_bill_id INT:=-1;--返佣主表键值.
BEGIN
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '开始统计( % )的返佣,周期( %-% )',name,startTime,endTime;
	raise info '取得玩家返水';
	select gamebox_rakeback_map(stTime,edTime,url,'PLAYER') INTO rakebackhash;
	raise info '创建站点游戏视图';
  --取得当前站点.
	select gamebox_current_site() INTO sid;
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
  perform gamebox_site_game(url,vname,sid,'C');
	--取得系统关于各种承担比例参数.
	select gamebox_sys_param('apportionSetting') into syshash;
	--取得当前返佣梯度设置信息.
  select gamebox_rebate_api_grads() into gradshash;
	--取得代理默认返佣方案
  select gamebox_rebate_agent_default_set() into agenthash;
  --判断各个代理满足的返佣梯度.
	select gamebox_rebate_agent_check(gradshash,agenthash,stTime,edTime) into checkhash;
	--raise info 'keys:%',checkhash;
	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	select gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) into mainhash;


	--先插入返水总记录并取得键值.
  raise info '返佣rebate_bill新增记录';
	SELECT gamebox_rebate_bill(name,stTime,edTime,rebate_bill_id,'I',flag) INTO rebate_bill_id;
  raise info '返佣rebate_bill.ID=%',rebate_bill_id;
	--先统计每个代理的有效交易量、有效玩家、盈亏总额.
  raise info '计算各玩家API返佣';
	perform gamebox_rebate_api(rebate_bill_id,stTime,edTime,gradshash,checkhash,mainhash,flag);

  raise info '收集各玩家的分摊费用';
	select gamebox_rebate_expense_gather(rebate_bill_id,rakebackhash
	,stTime,edTime,row_split,col_split) into hash;

	raise info '统计各玩家返佣';
  perform gamebox_rebate_player(syshash,hash,rakebackhash,rebate_bill_id,row_split,col_split,flag);

	raise info '开始统计代理返佣';
	--perform gamebox_rebate_agent(checkhash,syshash,hash,rebate_bill_id,row_split_char,col_split_char);
	perform gamebox_rebate_agent(rebate_bill_id,flag);

  raise info '更新返佣总表';
	perform gamebox_rebate_bill(name,stTime,edTime,rebate_bill_id,'U',flag);
	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

	--异常处理
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,a2 = PG_EXCEPTION_DETAIL,a3 = PG_EXCEPTION_HINT;
		raise EXCEPTION '异常:%,%,%',a1,a2,a3;
END;
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_rebate(name text,startTime text,endTime text,url text) returns void as $$
DECLARE
	rec record;
	--系统设置各种承担比例.
	syshash hstore;
	--各API的返佣设置
  gradshash hstore;
	--各个代理的返佣设置
	agenthash hstore;
	--运营商各API占成比例.
	mainhash hstore;
	--存储每个代理是否满足梯度.
	checkhash hstore;

	rakebackhash hstore;--各玩家返水.
	--临时
	hash hstore;
	mhash hstore;
	--返佣值
	rebate_value FLOAT;

	sid int;
	keyId int;
	tmp int;
	a1 text;
	a2 text;
	a3 text;
	stTime TIMESTAMP;
	edTime TIMESTAMP;

	pending_lssuing text:='pending_lssuing';
	pending_pay text:='pending_pay';
	--分隔符
	row_split text:='^&^';
	col_split text:='^';

	vname text:='v_site_game';
	--运营商占成参数.
	is_max BOOLEAN:=true;
	key_type int:=4;
	category TEXT:='AGENT';

	rebate_bill_id INT:=-1;--返佣主表键值.
BEGIN
	stTime=startTime::TIMESTAMP;
	edTime=endTime::TIMESTAMP;
	raise info '开始统计( % )的返佣,周期( %-% )',name,startTime,endTime;
	raise info '取得玩家返水';
	select gamebox_rakeback_map(stTime,edTime,url,'PLAYER') INTO rakebackhash;
	raise info '创建站点游戏视图';
  --取得当前站点.
	select gamebox_current_site() INTO sid;
	--url='host=192.168.0.88 dbname=gamebox-mainsite user=postgres password=postgres';
  perform gamebox_site_game(url,vname,sid,'C');
	--取得系统关于各种承担比例参数.
	select gamebox_sys_param('apportionSetting') into syshash;
	--取得当前返佣梯度设置信息.
  select gamebox_rebate_api_grads() into gradshash;
	--取得代理默认返佣方案
  select gamebox_rebate_agent_default_set() into agenthash;
  --判断各个代理满足的返佣梯度.
	select gamebox_rebate_agent_check(gradshash,agenthash,stTime,edTime) into checkhash;
	--raise info 'keys:%',checkhash;
	--取得各API的运营商占成.
	raise info '取得运营商各API占成';
	select gamebox_operations_occupy(url,sid,stTime,edTime,category,is_max,key_type) into mainhash;


	--先插入返水总记录并取得键值.
  raise info '返佣rebate_bill新增记录';
	SELECT gamebox_rebate_bill(name,stTime,edTime,rebate_bill_id,'I') INTO rebate_bill_id;
  raise info '返佣rebate_bill.ID=%',rebate_bill_id;
	--先统计每个代理的有效交易量、有效玩家、盈亏总额.
  raise info '计算各玩家API返佣';
	perform gamebox_rebate_api(rebate_bill_id,stTime,edTime,gradshash,checkhash,mainhash);

  raise info '收集各玩家的分摊费用';
	select gamebox_rebate_expense_gather(rebate_bill_id,rakebackhash
	,stTime,edTime,row_split,col_split) into hash;

	raise info '统计各玩家返佣';
  perform gamebox_rebate_player(syshash,hash,rakebackhash,rebate_bill_id,row_split,col_split);

	raise info '开始统计代理返佣';
	--perform gamebox_rebate_agent(checkhash,syshash,hash,rebate_bill_id,row_split_char,col_split_char);
	perform gamebox_rebate_agent(rebate_bill_id);

  raise info '更新返佣总表';
	perform gamebox_rebate_bill(name,stTime,edTime,rebate_bill_id,'U');
	--删除临时视图表.
	perform gamebox_site_game(url,vname,sid,'D');

	--异常处理
	EXCEPTION
	WHEN OTHERS THEN
	GET STACKED DIAGNOSTICS a1 = MESSAGE_TEXT,a2 = PG_EXCEPTION_DETAIL,a3 = PG_EXCEPTION_HINT;
		raise EXCEPTION '异常:%,%,%',a1,a2,a3;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限
	max_rebate 			float:=0.00;

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';

BEGIN
  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = 'settle'
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					max_rebate		= (hash->'max_rebate')::float;		-- 返佣上限
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	flag 		TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限
	max_rebate 			float:=0.00;

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';
	settle_state 		TEXT:='settle';

BEGIN

	IF flag = 'N' THEN
		settle_state:='pending_settle';
	END IF;

  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = settle_state
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					max_rebate		= (hash->'max_rebate')::float;		-- 返佣上限
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_agent_check(
	gradshash 	hstore,
	agenthash 	hstore,
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	flag 		TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';	--临时
	vals 		text[];
	param 		text:='';
	hash 		hstore;		--临时Hstore
	tmphash 	hstore;
	checkhash 	hstore;

	valid_value 		float:=0.00;	--梯度有效交易量
	pre_valid_value 	float:=0.00;	--上次梯度有效交易量
	pre_player_num 		int:=0;
	pre_profit 			float = 0.00;	--返水值.
	back_water_value 	float:=0.00;	--占成
	ratio 				float:=0.00;	--最大返佣上限

  	profit_amount 		float:=0.00;	--盈亏总额
	player_num 			int:=0;			--有效玩家数
	effective_trade_amount 	float:=0.00;--玩家有效交易量
	rebate_id 			int:=0;			--代理返佣主方案.

	api 		int:=0;	--API
	gameType 	text;	--游戏类型
	agent_id 	text;	--代理ID

  	valid_player_num 	int:=0;		--要达到的有效玩家数.
	total_profit 		float:=0.00;
	col_aplit 			TEXT:='_';
	settle_state 		TEXT:='settle';

BEGIN

	IF flag = 'N' THEN
		-- settle_state:='pending_settle';
	END IF;

  	keys = akeys(gradshash);
	FOR rec IN
		 SELECT ua.""id"",
				ua.username,
				SUM(COALESCE(pgo.effective_trade_amount, 0.00))	as effective_trade_amount,
				SUM(COALESCE(-pgo.profit_amount, 0.00))			as profit_amount
		   FROM player_game_order pgo
		   LEFT JOIN sys_user su ON pgo.player_id = su.""id""
		   LEFT JOIN sys_user ua ON su.owner_id = ua.""id""
		  WHERE su.user_type = '24'
			AND ua.user_type = '23'
			AND pgo.create_time >= start_time
			AND pgo.create_time <= end_time
			AND pgo.order_state = settle_state
			AND pgo.is_profit_loss = TRUE
		  GROUP BY ua.""id"", ua.username

   	LOOP

		pre_valid_value 	= 0.00;	-- 重置变量.
		pre_profit 			= 0.00;
      	pre_player_num 		= 0;
		profit_amount 		= rec.profit_amount;	--代理盈亏总额
		effective_trade_amount = rec.effective_trade_amount;	--代理有效交易量
	    --raise info '代理有效值:%, 盈亏总额:%, 玩家数:%', effective_trade_amount, profit_amount, player_num;

      	--如果代理盈亏总额为正时，才有返佣.
		IF profit_amount <= 0 THEN
			CONTINUE;
		END IF;

		-- 取得返佣主方案.
		agent_id:=(rec.id)::text;

		-- 判断代理是否设置了返佣梯度.
		IF isexists(agenthash, agent_id) THEN
			rebate_id = agenthash->agent_id;

			FOR i IN 1..array_length(keys,  1)
			LOOP
				subkeys = regexp_split_to_array(keys[i], '_');
				keyname = keys[i];

      			--取得当前返佣梯度.
				IF subkeys[1]::int = rebate_id THEN

					--判断是否已经比较过且有效交易量大于当前值.
	          		val = gradshash->keyname;

					--判断如果存在多条记录，取第一条.
					vals = regexp_split_to_array(val, '\^\&\^');

					IF array_length(vals,  1) > 1 THEN
						val = vals[1];
					END IF;

					SELECT * FROM strToHash(val) into hash;

					valid_player_num = (hash->'valid_player_num')::int;	-- 有效玩家数
					ratio 			= (hash->'ratio')::float;			-- 占成数
					valid_value 	= (hash->'valid_value')::float;		-- 梯度有效交易量
					total_profit 	= (hash->'total_profit')::float;	-- 盈亏总额

					SELECT gamebox_valid_player_num(start_time, end_time, valid_value) INTO player_num;

					-- 有效交易量、盈亏总额、有效玩家数.进行比较.
					IF total_profit >= pre_profit OR valid_player_num >= pre_player_num THEN
						IF effective_trade_amount >= valid_value AND profit_amount >= total_profit AND player_num >= valid_player_num THEN
							-- 存储此次梯度有效交易量, 作下次比较.
							pre_profit 		= total_profit;
							pre_player_num 	= valid_player_num;
							-- 代理满足第一阶条件，满足有效交易量与盈亏总额
							param = agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;

							IF checkhash IS NULL THEN
								SELECT param into checkhash;
							ELSE
								SELECT param into tmphash;

							checkhash = checkhash||tmphash;
							END IF;
						END IF;
					END IF;
				END IF;
			END LOOP;
		ELSE
			raise info '代理ID:%, 没有设置返佣梯度.', agent_id;
		END IF;
	END LOOP;

	return checkhash;
END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_agent_check(
gradshash hstore
,agenthash hstore
,start_time TIMESTAMP
,end_time TIMESTAMP
) returns hstore as $$
DECLARE
	rec record;
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	vals text[];
	param text:='';
	--临时Hstore
	hash hstore;
	tmphash hstore;
	checkhash hstore;
	--梯度有效交易量
	valid_value float:=0.00;
	--上次梯度有效交易量
	pre_valid_value float:=0.00;
	pre_player_num int=0;
	pre_profit float=0.00;
	--返水值.
	back_water_value float:=0.00;
	--占成
	ratio float:=0.00;
	--最大返佣上限
	max_rebate float:=0.00;

	--盈亏总额
  profit_amount float:=0.00;
	--有效玩家数
	player_num int:=0;
	--玩家有效交易量
	effective_trade_amount float:=0.00;
	--代理返佣主方案.
	rebate_id int:=0;

	--API
	api int:=0;
	--游戏类型
	gameType text;
	--代理ID
	agent_id text;

	--有效玩家数.
  valid_player_num int:=0;
	total_profit float:=0.00;
	col_aplit TEXT:='_';
BEGIN
  keys=akeys(gradshash);
  --raise info '%',agenthash;
	--raise info 'Len=%',array_length(keys, 1);
	FOR rec IN
            SELECT
            a.id,a.username,
						count(DISTINCT o.player_id) player_num,
						sum(-COALESCE(o.profit_amount,0)) as profit_amount,
            sum(COALESCE(o.effective_trade_amount,0)) AS effective_trade_amount
            FROM player_game_order o,sys_user u,sys_user a
	          where o.player_id=u.id
					  and u.owner_id=a.id
						and o.create_time>=start_time and o.create_time<end_time
            GROUP BY a.id,a.username
   LOOP
		  --重置变量.
			pre_valid_value=0.00;
			pre_profit=0.00;
      pre_player_num=0;
			--玩家数.
			player_num=rec.player_num;
			--代理盈亏总额
			profit_amount=rec.profit_amount;
			--代理有效交易量
			effective_trade_amount=rec.effective_trade_amount;
	    --raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;
      --如果代理盈亏总额为正时，才有返佣.
			--为了作测试.先把盈亏总额置为正数.
			--profit_amount=-profit_amount;
		  --player_num=5;
			if profit_amount<=0 THEN
				CONTINUE;
			end IF;
			--取得返佣主方案.
			agent_id:=(rec.id)::text;
		  --raise info '代理ID:%',agent_id;
			--判断代理是否设置了返佣梯度.
			--raise info 'isexists(agenthash,agent_id)=%',isexists(agenthash,agent_id);
			if isexists(agenthash,agent_id) THEN
					rebate_id=agenthash->agent_id;
				  --raise info 'rec=%',rec;
				for i in 1..array_length(keys, 1) loop
					--KEY格式. rebate_id+grads_id+api_id+game_type
					subkeys=regexp_split_to_array(keys[i],'_');
					keyname=keys[i];
					--raise info 'key=%',subkeys;
					--raise info '%,%,rebate_id=%',subkeys[1],rebate_id,((subkeys[1]::int)=rebate_id);
          --取得当前返佣梯度.

					IF subkeys[1]::int=rebate_id THEN
						--判断是否已经比较过且有效交易量大于当前值.
						--raise info '%>%:%',effective_trade_amount,pre_valid_value,(effective_trade_amount>pre_valid_value);
						--IF effective_trade_amount>pre_valid_value THEN
	             --raise info 'val=%',gradshash->keyname;
              val=gradshash->keyname;
							--raise info 'val=%',val;
							--判断如果存在多条记录，取第一条.
							vals=regexp_split_to_array(val,'\^\&\^');
							--raise info 'vals.len:%',array_length(vals, 1);
							IF array_length(vals, 1)>1 THEN
								val=vals[1];
							END IF;
							select * from strToHash(val) into hash;
							--有效玩家数
							valid_player_num=(hash->'valid_player_num')::int;
							--占成数
							ratio=(hash->'ratio')::float;
							--梯度有效交易量
							valid_value=(hash->'valid_value')::float;
							--返佣上限
							max_rebate=(hash->'max_rebate')::float;
							--盈亏总额
							total_profit=(hash->'total_profit')::float;

						 /*
							raise info '玩家数:%,盈亏:%,交易量:%,梯度.有效玩家:%,盈亏:%,交易量:%'
							,player_num,profit_amount,effective_trade_amount
							,valid_player_num,total_profit,valid_value;
						  */
							--raise info '梯度有效交易量:%,返佣上限:%,盈亏总额:%,玩家数:%,占成比例:%',valid_value,max_rebate,total_profit,valid_player_num,ratio;
							--raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;
							--有效交易量、盈亏总额、有效玩家数.进行比较.
						--因为一个返佣设置会有多个梯度.
						IF total_profit>=pre_profit OR valid_player_num>=pre_player_num THEN
							IF effective_trade_amount >= valid_value
								and profit_amount>=total_profit
								and player_num>=valid_player_num
							THEN
								--存储此次梯度有效交易量,作下次比较.
								--pre_valid_value=valid_value;
								pre_profit=total_profit;
								pre_player_num=valid_player_num;
								--代理满足第一阶条件，满足有效交易量与盈亏总额
								--param=agent_id||'=>'||'T|'||subkeys[1]||'|'||subkeys[2];
								--param=agent_id||'=>T_'||subkeys[1]||'_'||subkeys[2];
								param=agent_id||'=>'||subkeys[1]||col_aplit||subkeys[2]||col_aplit||player_num||col_aplit||profit_amount||col_aplit||effective_trade_amount||col_aplit||rec.username;
							 -- raise info 'hash is null:%',(hash is null);
								if checkhash is null THEN
									select param into checkhash;
								else
									select param into tmphash;
									--合并
									checkhash=checkhash||tmphash;
								END IF;
							END IF;
						END IF;
					END IF;
				END LOOP;
			ELSE
				  raise info '代理ID:%,没有设置返佣梯度.',agent_id;
			END IF;
	END LOOP;
	return checkhash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_agent_default_set() returns hstore as $$
DECLARE
	hash hstore;
	rec record;
	param text:='';
BEGIN
	for rec in
		select a.user_id,a.rebate_id
		from user_agent_rebate a,sys_user u
		where a.user_id=u.id and u.user_type='23'
    loop
			param=param||rec.user_id||'=>'||rec.rebate_id||',';
	end loop;
	IF length(param)>0 THEN
		param=substring(param,1,length(param)-1);
	END IF;
	--raise info '结果:%',param;
	select param::hstore into hash;
	--测试引用值.
  --raise info '4:%',hash->'3';
	return hash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_api_grads() returns hstore as $$
DECLARE
	rec record;
	param text:='';
	gradshash hstore;
	tmphash hstore;
	keyname text:='';
	val text:='';
	val2 text:='';
BEGIN
	for rec in
	SELECT
		DISTINCT
		m.id, --返佣主案ID
		m.name,
		s.id as grads_id, --返佣梯度ID
		d.api_id,
		d.game_type,
		d.ratio, --API占成比例
		m.valid_value,--有效交易量
		s.total_profit,--有效盈利总额
		s.max_rebate,--返佣上限
		s.valid_player_num--有效玩家数
		--,d.id
	FROM
		rebate_set m,
		rebate_grads s,
		rebate_grads_api d
	WHERE
    m.id=s.rebate_id AND m.status='1'
		AND s.id = d.rebate_grads_id

		order by m.id,d.api_id,d.game_type,m.valid_value desc,s.total_profit desc,s.valid_player_num desc

   loop
		--判断主方案是否存在.
		--键值格式:ID+GRADSID+API+GAMETYPE
			keyname=	rec.id::text||'_'||rec.grads_id::text||'_'||rec.api_id::text||'_'||rec.game_type::text;
		  --keyname=	rec.id::text||col_split_char||rec.grads_id::text||col_split_char||rec.api_id::text||col_split_char||rec.game_type::text;
			--val:=row_to_json(row(5,6,7,8,9));
		  val:=row_to_json(rec);
			--raise info 'rec=%',val;

			val:=replace(val,',','\|');
			val:=replace(val,'\:null\,','\:-1\,');
			--raise info 'rec2=%',val;
			--raise info '============%,%',keyname,gradshash?keyname;
			--raise info 'count:%',array_length(akeys(gradshash), 1);
			if (gradshash?keyname) is null OR (gradshash?keyname) =false THEN
				--raise info '创建KEY:%',val;
				--select keyname||'=>'||val into tmphash;
        --gradshash=hash||tmphash;
					if gradshash is null then
						select keyname||'=>'||val into gradshash;
					ELSE
						select keyname||'=>'||val into tmphash;
						gradshash=gradshash||tmphash;
					end IF;
	      -- raise info 'gradsHash=%',gradshash->keyname;
			else
				val2=gradshash->keyname;
				--raise info '原值=%',gradshash->keyname;
	      select keyname||'=>'||val||'^&^'||val2 into tmphash;
				--select keyname||'=>'||val||row_split_char||val2 into tmphash;
				gradshash=gradshash||tmphash;
				--raise info '新值=%',gradshash->keyname;
			end if;
			--raise info '============';
	end loop;
	raise info 'gamebox_rebate_set.键的数量：%',array_length(akeys(gradshash),1);
    --raise info '键值：%',akeys(gradshash);
    --raise info '值：%',avals(gradshash);
	--raise info '%',gradshash;
	return gradshash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_calculator(
	rebate_grads_map 	hstore,
	agent_check_map 	hstore,
	agent_id 			INT,
	api_id 				INT,
	game_type 			TEXT,
	profit_amount 		FLOAT,
	operation_occupy 	FLOAT
) returns FLOAT as $$

DECLARE
	keys 		text[];
	subkeys 	text[];
	keyname 	text:='';
	val 		text:='';--临时
	vals 		text[];
	hash 		hstore;	--临时Hstore

	rebate_value 	float:=0.00;--返佣值.
	ratio 			float:=0.00;--占成
	max_rebate 		float:=0.00;--最大返佣上限

	rebate_id 	text;	--梯度ID.
	api 		TEXT; 	--API
	agent 		text;	--代理ID
	col_split 	TEXT:='_';

BEGIN
	api = (api_id::TEXT);
	agent = (agent_id::TEXT);
	raise info '---- api = %, agent = %', api, agent;

	IF isexists(agent_check_map,agent) = false THEN --梯度不满足时不返佣
		RETURN 0.00;
	ELSEIF profit_amount <= 0 THEN --盈亏为负时,不返佣
		RETURN 0.00;
	END IF;

	rebate_id = agent_check_map->agent;
	-- raise info '---- rebate_id1 = %', rebate_id;
	vals = regexp_split_to_array(rebate_id, '_');
	-- raise info '---- vals = %', vals;

	rebate_id = vals[1]||'_'||vals[2];
	-- raise info '---- rebate_id2 = %', rebate_id;
	keys = akeys(rebate_grads_map);
	-- raise info '---- keys = %', keys;

	FOR i IN 1..array_length(keys, 1)
	LOOP
		-- raise info '---------- LOOP S ----------';
		keyname = keys[i];
		subkeys = regexp_split_to_array(keyname, '_');
		-- raise info '---- keyname = %, subkeys = %, position = %', keyname, subkeys, position(rebate_id in keyname);
		IF position(rebate_id in keyname) = 1 AND subkeys[3] = api AND rtrim(ltrim(subkeys[4])) = game_type THEN
			val = rebate_grads_map->keyname;
			-- 判断如果存在多条记录，取第一条.
			vals = regexp_split_to_array(val, '\^\&\^');
			-- raise info '---- val = %, vals = %', val, vals;
			IF array_length(vals, 1) > 1 THEN
				val = vals[1];
			END IF;
			-- raise info '---- val = %', val;

			select * from strToHash(val) into hash;
			-- raise info '---- hash = %', hash;
			ratio = (hash->'ratio')::float;--占成数
			raise info '--代理的佣金比例(ratio) = %', ratio;

			--各个API运营商占成.
			operation_occupy = coalesce(operation_occupy, 0);
			--各API各分类佣金总和 = [各API各分类盈亏总和-(各API各分类盈亏总和*运营商占成）]*代理的佣金比例；
			rebate_value = (profit_amount - operation_occupy) * ratio / 100;
		END IF;

		raise info '---------- LOOP E ----------';
	END LOOP;
	RETURN rebate_value;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_calculator(
rebate_grads_map hstore
,agent_check_map hstore
,agent_id INT
,api_id INT
,game_type TEXT
,profit_amount FLOAT
,operation_occupy FLOAT
) returns FLOAT as $$
DECLARE
	keys text[];
	subkeys text[];
	keyname text:='';
	val text:='';--临时
	vals text[];
	hash hstore;	--临时Hstore

	rebate_value float:=0.00;--返佣值.
	ratio float:=0.00;--占成
	max_rebate float:=0.00;--最大返佣上限

	rebate_id text;	--梯度ID.
	api TEXT;--API
	agent text;--代理ID
	col_split TEXT:='_';
BEGIN
		api=(api_id::TEXT);
		agent=(agent_id::TEXT);
		--raise info 'check_map:%,agent:%',agent_check_map,agent;
		IF isexists(agent_check_map,agent)=false THEN --梯度不满足时不返佣
			RETURN 0.00;
		ELSEIF profit_amount<=0 THEN --盈亏为负时,不返佣
			RETURN 0.00;
		END IF;

		rebate_id=agent_check_map->agent;
		vals=regexp_split_to_array(rebate_id,'_');
    --vals=regexp_split_to_array(rebate_id,col_split_char);
		rebate_id=vals[1]||'_'||vals[2];
		keys=akeys(rebate_grads_map);

		for i in 1..array_length(keys, 1) loop
			keyname=keys[i];
			subkeys=regexp_split_to_array(keyname,'_');
			--subkeys=regexp_split_to_array(keyname,col_split_char);
			/*
			if position(rebate_id in keyname)=1 then
			raise info '%,api:%,game_type:%',keyname,api,gameType;
			end if;
			*/
			--raise info 'rebate_id:%,keyname:%,api:%,game_type:%',rebate_id,keyname,api,game_type;
			IF position(rebate_id in keyname)=1 AND subkeys[3]=api AND rtrim(ltrim(subkeys[4]))=game_type
			THEN
				--开始作比较.
				val=rebate_grads_map->keyname;
				--判断如果存在多条记录，取第一条.
				vals=regexp_split_to_array(val,'\^\&\^');
				--vals=regexp_split_to_array(val,row_split_char);
				IF array_length(vals, 1)>1 THEN
					val=vals[1];
				END IF;

				select * from strToHash(val) into hash;
				ratio=(hash->'ratio')::float;--占成数
				max_rebate=(hash->'max_rebate')::float;--返佣上限

				--raise info '梯度有效交易量:%,返佣上限:%,盈亏总额:%,玩家数:%,占成比例:%',valid_value,max_rebate,total_profit,valid_player_num,ratio;
				--raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;

				--返佣计算公式如下：
				--各API各分类佣金总和
				--=[各API各分类盈亏总和-(各API各分类盈亏总和*运营商占成）]*代理的佣金比例；
				--此处需要取得各个API运营商占成.
				--@todo.运营商API占成
				--main_ratio=0;
				--根据playerId+apiId+gameType取得运营商占成.
				--keyname=player||col_split||api||col_split||game_type;
				--operation_occupy=(operation_occupy_map->keyname)::FLOAT;
				operation_occupy=coalesce(operation_occupy,0);

				raise info '运营商占成额:%',operation_occupy;
				rebate_value=(profit_amount-operation_occupy)*ratio/100;
        --raise info '[各API各分类盈亏总和 -(各API各分类盈亏总和*运营商占成）]*代理的佣金比例,计算:%*(1-%)*%/100=%',profit_amount,main_ratio,ratio,rebate_value;
				--返水大于返水上限，以上限值为准.
				IF max_rebate is not null and rebate_value>max_rebate THEN
					rebate_value=max_rebate;
				END IF;
				raise info '代理返佣值:%',rebate_value;
			END IF;
		END LOOP;
	return rebate_value;
END;
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_rebate_calculator(
rebate_grads_map hstore
,agent_check_map hstore
,operation_occupy_map hstore
,agent_id INT
,player_id INT
,api_id INT
,game_type TEXT
,profit_amount FLOAT
) returns FLOAT as $$
DECLARE
	keys text[];
	subkeys text[];
	keyname text:='';
	--临时
	val text:='';
	vals text[];
	--临时Hstore
	hash hstore;

	rebate_value float:=0.00;--返佣值.
	ratio float:=0.00;--占成
	max_rebate float:=0.00;--最大返佣上限

	rebate_id text;	--梯度ID.
	api TEXT;--API
	agent text;--代理ID
	player text;--玩家
	operation_occupy float:=0.00;--运营商API占成.

	col_split TEXT:='_';
BEGIN
		player=(player_id::TEXT);
		api=(api_id::TEXT);
		agent=(agent_id::TEXT);
		--raise info 'check_map:%,agent:%',agent_check_map,agent;
		IF isexists(agent_check_map,agent)=false THEN --梯度不满足时不返佣
			RETURN 0.00;
		ELSEIF profit_amount<=0 THEN --盈亏为负时,不返佣
			RETURN 0.00;
		END IF;

		rebate_id=agent_check_map->agent;
		vals=regexp_split_to_array(rebate_id,'_');
    --vals=regexp_split_to_array(rebate_id,col_split_char);
		rebate_id=vals[1]||'_'||vals[2];
		keys=akeys(rebate_grads_map);

		for i in 1..array_length(keys, 1) loop
			keyname=keys[i];
			subkeys=regexp_split_to_array(keyname,'_');
			--subkeys=regexp_split_to_array(keyname,col_split_char);
			/*
			if position(rebate_id in keyname)=1 then
			raise info '%,api:%,game_type:%',keyname,api,gameType;
			end if;
			*/
			--raise info 'rebate_id:%,keyname:%,api:%,game_type:%',rebate_id,keyname,api,game_type;
			IF position(rebate_id in keyname)=1 AND subkeys[3]=api AND rtrim(ltrim(subkeys[4]))=game_type
			THEN
				--开始作比较.
				val=rebate_grads_map->keyname;
				--判断如果存在多条记录，取第一条.
				vals=regexp_split_to_array(val,'\^\&\^');
				--vals=regexp_split_to_array(val,row_split_char);
				IF array_length(vals, 1)>1 THEN
					val=vals[1];
				END IF;

				select * from strToHash(val) into hash;
				ratio=(hash->'ratio')::float;--占成数
				max_rebate=(hash->'max_rebate')::float;--返佣上限

				--raise info '梯度有效交易量:%,返佣上限:%,盈亏总额:%,玩家数:%,占成比例:%',valid_value,max_rebate,total_profit,valid_player_num,ratio;
				--raise info '代理有效值:%,盈亏总额:%,玩家数:%',effective_trade_amount,profit_amount,player_num;

				--返佣计算公式如下：
				--各API各分类佣金总和
				--=[各API各分类盈亏总和-(各API各分类盈亏总和*运营商占成）]*代理的佣金比例；
				--此处需要取得各个API运营商占成.
				--@todo.运营商API占成
				--main_ratio=0;
				--根据playerId+apiId+gameType取得运营商占成.
				keyname=player||col_split||api||col_split||game_type;
				operation_occupy=(operation_occupy_map->keyname)::FLOAT;
				operation_occupy=coalesce(operation_occupy,0);

				raise info '运营商占成额:%',operation_occupy;
				rebate_value=(profit_amount-operation_occupy)*ratio/100;
        --raise info '[各API各分类盈亏总和 -(各API各分类盈亏总和*运营商占成）]*代理的佣金比例,计算:%*(1-%)*%/100=%',profit_amount,main_ratio,ratio,rebate_value;
				--返水大于返水上限，以上限值为准.
				IF max_rebate is not null and rebate_value>max_rebate THEN
					rebate_value=max_rebate;
				END IF;
				raise info '代理返佣值:%',rebate_value;
			END IF;
		END LOOP;
	return rebate_value;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_expense_gather(
	bill_id 		int,
	rakebackhash 	hstore,
	start_time 		TIMESTAMP,
	end_time 		TIMESTAMP,
	row_split 		text,
	col_split 		text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	eff_transaction 	FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;
	--raise info '%', hash;

	--统计各代理返佣.
	FOR rec IN
		SELECT p.player_id,
			   u.owner_id,
			   a.username,
			   p.rebate_total,
			   p.effective_transaction,
			   p.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM rebate_api
				 WHERE rebate_bill_id = bill_id
				 GROUP BY player_id) p,
		  	   sys_user u,
		  	   sys_user a
		 WHERE p.player_id = u.id
		   AND u.owner_id = a.id
		   AND u.user_type='24'
		   AND a.user_type='23'

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_rebate_expense_gather(
	bill_id 		int,
	rakebackhash 	hstore,
	start_time 		TIMESTAMP,
	end_time 		TIMESTAMP,
	row_split 		text,
	col_split 		text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	eff_transaction 	FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;
	--raise info '%', hash;

	--统计各代理返佣.
	FOR rec IN
		SELECT p.player_id,
			   u.owner_id,
			   a.username,
			   p.rebate_total,
			   p.effective_transaction,
			   p.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM rebate_api
				 WHERE rebate_bill_id = bill_id
				 GROUP BY player_id) p,
		  	   sys_user u,
		  	   sys_user a
		 WHERE p.player_id = u.id
		   AND u.owner_id = a.id
		   AND u.user_type='24'
		   AND a.user_type='23'

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_rebate_expense_gather(
	bill_id 		int,
	rakebackhash 	hstore,
	start_time 		TIMESTAMP,
	end_time 		TIMESTAMP,
	row_split 		text,
	col_split 		text,
	flag 			TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
	tbl 		TEXT:='rebate_api';
	tbl_id 		TEXT:='rebate_bill_id';
	sqld 		TEXT;

	eff_transaction 	FLOAT:=0.00;
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;

	IF flag = 'N' THEN
		tbl = 'rebate_api_nosettled';
		tbl_id = 'rebate_bill_nosettled_id';
	END IF;

	sqld = 'SELECT ra.player_id,
			   su.owner_id,
			   sa.username,
			   ra.rebate_total,
			   ra.effective_transaction,
			   ra.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM '||tbl||'
				 WHERE '||tbl_id||'='||bill_id||'
				 GROUP BY player_id) ra,
			   sys_user su,
			   sys_user sa
 		 WHERE ra.player_id = su.id
 		   AND su.owner_id  = sa.id
 		   AND su.user_type = ''24''
 		   AND sa.user_type = ''23''';
	--统计各代理返佣.
	FOR rec IN EXECUTE sqld

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_expense_gather(
	bill_id 		int,
	start_time 		TIMESTAMP,
	end_time 		TIMESTAMP,
	row_split 		text,
	col_split 		text,
	flag 			TEXT
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
	tbl 		TEXT:='rebate_api';
	tbl_id 		TEXT:='rebate_bill_id';
	sqld 		TEXT;

	eff_transaction 	FLOAT:=0.00;
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;

	IF flag = 'N' THEN
		tbl = 'rebate_api_nosettled';
		tbl_id = 'rebate_bill_nosettled_id';
	END IF;

	sqld = 'SELECT ra.player_id,
			   su.owner_id,
			   sa.username,
			   ra.rebate_total,
			   ra.effective_transaction,
			   ra.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM '||tbl||'
				 WHERE '||tbl_id||'='||bill_id||'
				 GROUP BY player_id) ra,
			   sys_user su,
			   sys_user sa
 		 WHERE ra.player_id = su.id
 		   AND su.owner_id  = sa.id
 		   AND su.user_type = ''24''
 		   AND sa.user_type = ''23''';
	--统计各代理返佣.
	FOR rec IN EXECUTE sqld

	LOOP
		user_id 		= rec.player_id::text;
		agent_id 		= rec.owner_id;
		agent_name 		= rec.username;
		money 			= rec.rebate_total;
		loss 			= rec.profit_loss;
		eff_transaction = rec.effective_transaction;

		IF isexists(hash, user_id) THEN
			param = hash->user_id;
			param = param||row_split||'rebate'||col_split||money::text;
			param = param||row_split||'profit_loss'||col_split||loss::text;
			param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
			param = param||row_split||'agent_name'||col_split||agent_name;
		ELSE
			param = 'rebate'||col_split||money::text;
			param = param||row_split||'profit_loss'||col_split||loss::text;
			param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
			param = param||row_split||'agent_name'||col_split||agent_name;
		END IF;
		IF position('agent_id' in param) = 0 THEN
			param = param||row_split||'agent_id'||col_split||agent_id::text;
		END IF;

		SELECT user_id||'=>'||param INTO mhash;
		IF hash is null THEN
			hash = mhash;
		ELSE
			hash = hash||mhash;
		END IF;

	END LOOP;
	raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_expense_gather(
  bill_id 		int,
  rakebackhash 	hstore,
  start_time 		TIMESTAMP,
  end_time 		TIMESTAMP,
  row_split 		text,
  col_split 		text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	eff_transaction 	FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;
	--raise info '%', hash;

	--统计各代理返佣.
	FOR rec IN
		SELECT ra.player_id,
			   su.owner_id,
			   sa.username,
			   ra.rebate_total,
			   ra.effective_transaction,
			   ra.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM rebate_api
				 WHERE rebate_bill_id = bill_id
				 GROUP BY player_id) ra,
			   sys_user su,
			   sys_user sa
 		 WHERE ra.player_id = su.id
 		   AND su.owner_id = sa.id
 		   AND su.user_type='24'
 		   AND sa.user_type='23'

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_rebate_expense_gather(
  bill_id 		int,
  rakebackhash 	hstore,
  start_time 		TIMESTAMP,
  end_time 		TIMESTAMP,
  row_split 		text,
  col_split 		text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	eff_transaction 	FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;
	--raise info '%', hash;

	--统计各代理返佣.
	FOR rec IN
		SELECT ra.player_id,
			   su.owner_id,
			   sa.username,
			   ra.rebate_total,
			   ra.effective_transaction,
			   ra.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM rebate_api
				 WHERE rebate_bill_id = bill_id
				 GROUP BY player_id) ra,
			   sys_user su,
			   sys_user sa
 		 WHERE ra.player_id = su.id
 		   AND su.owner_id = sa.id
 		   AND su.user_type='24'
 		   AND sa.user_type='23'

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_rebate_expense_gather(
  bill_id 		int,
  rakebackhash 	hstore,
  start_time 		TIMESTAMP,
  end_time 		TIMESTAMP,
  row_split 		text,
  col_split 		text
) returns hstore as $$

DECLARE
	rec 		record;
	hash 		hstore;
	mhash 		hstore;
	param 		text:='';
	user_id 	text:='';
	money 		float:=0.00;
	loss 		FLOAT:=0.00;

	eff_transaction 	FLOAT:=0.00;

	agent_id 	INT;
	agent_name 	TEXT:='';
BEGIN

	SELECT gamebox_expense_gather(start_time, end_time, row_split, col_split) INTO hash;
	--raise info '%', hash;

	--统计各代理返佣.
	FOR rec IN
		SELECT ra.player_id,
			   su.owner_id,
			   sa.username,
			   ra.rebate_total,
			   ra.effective_transaction,
			   ra.profit_loss
		  FROM (SELECT player_id,
		  			   sum(rebate_total) 			as rebate_total,
		  			   sum(effective_transaction)  	as effective_transaction,
		  			   sum(profit_loss)  			as profit_loss
				  FROM rebate_api
				 WHERE rebate_bill_id = bill_id
				 GROUP BY player_id) ra,
			   sys_user su,
			   sys_user sa
 		 WHERE ra.player_id = su.id
 		   AND su.owner_id = sa.id
 		   AND su.user_type='24'
 		   AND sa.user_type='23'

		LOOP
			user_id 		= rec.player_id::text;
			agent_id 		= rec.owner_id;
			agent_name 		= rec.username;
			money 			= rec.rebate_total;
			loss 			= rec.profit_loss;
			eff_transaction = rec.effective_transaction;

			IF isexists(hash, user_id) THEN
				param = hash->user_id;
				param = param||row_split||'rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param = param||row_split||'profit_loss'||col_split||loss::text;
				param = param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param = param||row_split||'agent_name'||col_split||agent_name;
				param = param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			SELECT user_id||'=>'||param INTO mhash;
			IF hash is null THEN
				hash = mhash;
			ELSE
				hash = hash||mhash;
			END IF;

		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_rebate_expense_gather(
bill_id int,rakebackhash hstore
,start_time TIMESTAMP,end_time TIMESTAMP
,row_split text,col_split text) returns hstore as $$
DECLARE
	rec record;
	hash hstore;
	mhash hstore;
	param text:='';
	user_id text:='';
	money float:=0.00;
	loss FLOAT:=0.00;
	eff_transaction FLOAT:=0.00;
	agent_id INT;
	agent_name TEXT:='';
BEGIN

		SELECT gamebox_expense_gather(start_time,end_time,row_split,col_split) INTO hash;
		--raise info '%',hash;

	  --统计各代理返佣.
		FOR rec IN
			SELECT p.player_id,u.owner_id,a.username
			,p.rebate_total,p.effective_transaction,p.profit_loss
			FROM
			(
				SELECT player_id,sum(rebate_total) rebate_total
				,sum(effective_transaction) effective_transaction
				,sum(profit_loss) profit_loss
				FROM rebate_api
				WHERE rebate_bill_id=bill_id
				GROUP BY player_id
			) p,sys_user u,sys_user a
			WHERE p.player_id=u.id AND u.owner_id=a.id
			AND u.user_type='24' and a.user_type='23'

		LOOP

			user_id=rec.player_id::text;
			agent_id=rec.owner_id;
			agent_name=rec.username;
			money=rec.rebate_total;
			loss=rec.profit_loss;
			eff_transaction=rec.effective_transaction;
			IF isexists(hash,user_id) THEN
				param=hash->user_id;
				param=param||row_split||'rebate'||col_split||money::text;
				param=param||row_split||'profit_loss'||col_split||loss::text;
				param=param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param=param||row_split||'agent_name'||col_split||agent_name;
				param=param||row_split||'agent_id'||col_split||agent_id::text;
			ELSE
				param='rebate'||col_split||money::text;
				param=param||row_split||'profit_loss'||col_split||loss::text;
				param=param||row_split||'effective_transaction'||col_split||eff_transaction::text;
				param=param||row_split||'agent_name'||col_split||agent_name;
				param=param||row_split||'agent_id'||col_split||agent_id::text;
			END IF;

			select user_id||'=>'||param into mhash;
			IF hash is null THEN
				hash=mhash;
			ELSE
				hash=hash||mhash;
			END IF;
		END LOOP;
		raise info '统计当前周期内各代理的各种费用信息.完成';
		RETURN hash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_rebate_limit(
	checkhash 	hstore
) returns hstore as $$

DECLARE
	rec 		record;
	rebate_info TEXT;
	agent_id	TEXT;
	subkeys 	TEXT[];
	limithash	hstore;
	keyname     TEXT;
    keyvalue    FLOAT:=0.0;
BEGIN
  	FOR rec IN
  		SELECT ua.user_id, rg.""id"", rg.rebate_id, rg.max_rebate
		  FROM rebate_grads rg
		  LEFT JOIN rebate_set rs ON rg.rebate_id = rs.""id""
		  LEFT JOIN user_agent_rebate ua ON rg.rebate_id = ua.rebate_id
		 WHERE rs.status = '1'
	LOOP

		agent_id:=rec.user_id::TEXT;
		---- agent_id = 927
		rebate_info = checkhash->agent_id;
		---- rebate_info = 62_79_3_580_2080_feiagent
		subkeys = regexp_split_to_array(rebate_info, '_');
		IF subkeys[1] = rec.rebate_id::TEXT AND subkeys[2] = rec.id::TEXT THEN

			keyname:=agent_id;
	        keyvalue:=rec.max_rebate::FLOAT;
	        IF limithash IS NULL THEN
	            SELECT keyname||'=>'||keyvalue||'_'||subkeys[3] into limithash;
	        ELSE
	            limithash = (SELECT (keyname||'=>'||keyvalue'_'||subkeys[3])::hstore)||limithash;
	        END IF;

		END IF;

	END LOOP;
	RETURN limithash;
END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_rebate_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	key_type 				INT,
	rebate_grads_map 		hstore,
	agent_check_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT su.owner_id,
			   rab.api_id,
			   rab.game_type,
			   COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		 GROUP BY su.owner_id, rab.api_id, rab.game_type
		 ORDER BY su.owner_id
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0120__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	key_type 				INT,
	rebate_grads_map 		hstore,
	agent_check_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT su.owner_id,
			   rab.api_id,
			   rab.game_type,
			   COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)				as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time <= end_time
		   AND su.user_type = '24'
		 GROUP BY su.owner_id, rab.api_id, rab.game_type
		 ORDER BY su.owner_id
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gamebox_rebate_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	key_type 				INT,
	rebate_grads_map 		hstore,
	agent_check_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT u.owner_id, g.api_id, g.game_type,
			   count(DISTINCT o.player_id) 					as player_num,
			   sum(-COALESCE(o.profit_amount,0.00)) 		as profit_amount,
               sum(COALESCE(o.effective_trade_amount,0.00)) as effective_trade_amount
          FROM player_game_order o,v_site_game g,sys_user u
	     WHERE o.create_time >= start_time
	       AND o.create_time < end_time
	       AND o.game_id = g.id
	       AND o.player_id = u.id
         GROUP BY u.owner_id, g.api_id, g.game_type
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;
		operation_occupy = coalesce(operation_occupy, 0);

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",E_gamebox_rebate_0125.sql
"create or replace function gamebox_rebate_map(
	start_time 				TIMESTAMP,
	end_time 				TIMESTAMP,
	key_type 				INT,
	rebate_grads_map 		hstore,
	agent_check_map 		hstore,
	operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT u.owner_id, g.api_id, g.game_type,
			   count(DISTINCT o.player_id) 					as player_num,
			   sum(-COALESCE(o.profit_amount,0.00)) 		as profit_amount,
               sum(COALESCE(o.effective_trade_amount,0.00)) as effective_trade_amount
          FROM player_game_order o,v_site_game g,sys_user u
	     WHERE o.create_time >= start_time
	       AND o.create_time < end_time
	       AND o.game_id = g.id
	       AND o.player_id = u.id
         GROUP BY u.owner_id, g.api_id, g.game_type
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;
		operation_occupy = coalesce(operation_occupy, 0);

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0358__C_gamebox_rebate.sql
"create or replace function gamebox_rebate_map(
  start_time 				TIMESTAMP,
  end_time 				TIMESTAMP,
  key_type 				INT,
  rebate_grads_map 		hstore,
  agent_check_map 		hstore,
  operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT su.owner_id,
			   rab.api_id,
			   rab.game_type,
			   COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)			as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		 GROUP BY su.owner_id, rab.api_id, rab.game_type
		 ORDER BY su.owner_id
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;
		operation_occupy = coalesce(operation_occupy, 0);

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0038__C_gamebox_rebate.sql
"create or replace function gamebox_rebate_map(
  start_time 				TIMESTAMP,
  end_time 				TIMESTAMP,
  key_type 				INT,
  rebate_grads_map 		hstore,
  agent_check_map 		hstore,
  operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT su.owner_id,
			   rab.api_id,
			   rab.game_type,
			   COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)			as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		 GROUP BY su.owner_id, rab.api_id, rab.game_type
		 ORDER BY su.owner_id
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;
		operation_occupy = coalesce(operation_occupy, 0);

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0098__U_gamebox_rebate.sql
"create or replace function gamebox_rebate_map(
  start_time 				TIMESTAMP,
  end_time 				TIMESTAMP,
  key_type 				INT,
  rebate_grads_map 		hstore,
  agent_check_map 		hstore,
  operation_occupy_map 	hstore
) returns hstore as $$

DECLARE
	rec 				record;
	rebate_value 		FLOAT:=0.00;--返佣.
	operation_occupy 	FLOAT:=0.00;--运营商占成额
	key_name 			TEXT;--运营商占成KEY值.
	rebate_map 			hstore;--各API返佣值.
	val 				FLOAT:=0.00;
	col_split 			TEXT:='_';
BEGIN
	FOR rec IN
        SELECT su.owner_id,
			   rab.api_id,
			   rab.game_type,
			   COUNT(DISTINCT rab.player_id)					as player_num,
			   COALESCE(SUM(rab.profit_loss), 0.00)			as profit_amount,
			   COALESCE(SUM(rab.effective_transaction), 0.00)	as effective_trade_amount
		  FROM rakeback_api_base rab
		  LEFT JOIN sys_user su ON rab.player_id = su.""id""
		 WHERE rab.rakeback_time >= start_time
		   AND rab.rakeback_time < end_time
		   AND su.user_type = '24'
		 GROUP BY su.owner_id, rab.api_id, rab.game_type
		 ORDER BY su.owner_id
	LOOP
		--检查当前代理是否满足返佣梯度.
		IF isexists(agent_check_map, (rec.owner_id)::text) = false THEN
			CONTINUE;
		END IF;

		raise info '取得各API各分类佣金总和';
		key_name = rec.api_id||col_split||rec.game_type;
		operation_occupy = (operation_occupy_map->key_name)::FLOAT;
		operation_occupy = coalesce(operation_occupy, 0);

		SELECT gamebox_rebate_calculator(rebate_grads_map, agent_check_map, rec.owner_id, rec.api_id, rec.game_type, rec.profit_amount, operation_occupy) INTO rebate_value;
		val = rebate_value;

		IF rebate_map is null THEN
			SELECT key_name||'=>'||val INTO rebate_map;
		ELSEIF exist(rebate_map, key_name) THEN
			val = val + ((rebate_map->key_name)::FLOAT);
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		ELSE
			rebate_map = (SELECT (key_name||'=>'||val)::hstore)||rebate_map;
		END IF;
	END LOOP;

	RETURN rebate_map;

END

$$ language plpgsql;",V1.0.1.0105__U_gamebox_rebate.sql
"create or replace function gamebox_rebate_map(
start_time TIMESTAMP
,end_time TIMESTAMP
,key_type INT
,rebate_grads_map hstore
,agent_check_map hstore
,operation_occupy_map hstore
) returns hstore as $$
DECLARE
	rec record;
	rebate_value FLOAT:=0.00;--返佣.
	operation_occupy FLOAT:=0.00;--运营商占成额
	key_name TEXT;--运营商占成KEY值.
	rebate_map hstore;--各API返佣值.
	val FLOAT:=0.00;
	col_split TEXT:='_';
BEGIN
	 FOR rec IN
            SELECT
            u.owner_id,
            g.api_id,
            g.game_type,
						count(DISTINCT o.player_id) player_num,
						sum(-COALESCE(o.profit_amount,0.00)) as profit_amount,
            sum(COALESCE(o.effective_trade_amount,0.00)) AS effective_trade_amount
            from player_game_order o,v_site_game g,sys_user u
	          where o.create_time>=start_time and o.create_time<end_time
            and o.game_id=g.id and o.player_id=u.id
            group by u.owner_id,g.api_id,g.game_type
			LOOP
			--检查当前代理是否满足返佣梯度.
			IF isexists(agent_check_map, (rec.owner_id)::text)=false THEN
				CONTINUE;
			END IF;
			raise info '取得各API各分类佣金总和';
			key_name=rec.api_id||col_split||rec.game_type;
			operation_occupy=(operation_occupy_map->key_name)::FLOAT;
			operation_occupy=coalesce(operation_occupy,0);

			select gamebox_rebate_calculator(rebate_grads_map,agent_check_map,rec.owner_id,rec.api_id,rec.game_type,rec.profit_amount,operation_occupy) into rebate_value;
			val=rebate_value;

			IF rebate_map is null THEN
				--param=sub_key||'='||rake_map->keys[i];
				SELECT key_name||'=>'||val INTO rebate_map;
			ELSEIF exist(rebate_map,key_name) THEN
				val=val+((rebate_map->key_name)::FLOAT);
				rebate_map=(SELECT (key_name||'=>'||val)::hstore)||rebate_map;
			ELSE
				rebate_map=(SELECT (key_name||'=>'||val)::hstore)||rebate_map;
			END IF;
		END LOOP;
	RETURN rebate_map;
END
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_rebate_rakeback_map(
	startTime 	TIMESTAMP,
	endTime 	TIMESTAMP
) returns hstore as $$

DECLARE
	rec 	record;
	sql 	TEXT:= '';
	key 	TEXT:= '';
	val 	TEXT:= '';
	hash 	hstore;
BEGIN
	raise info '统计玩家API返水';
	hash = '-1=>-1';
	sql = 'SELECT rp.player_id,
			 	  SUM(rp.rakeback_actual)	rakeback
			 FROM rakeback_bill rb
			 LEFT JOIN rakeback_player rp ON rb.""id"" = rp.rakeback_bill_id
			WHERE rp.settlement_time >= $1
			  AND rp.settlement_time <= $2
			  AND rp.settlement_state = ''lssuing''
			  AND rp.player_id IS NOT NULL
			GROUP BY rp.player_id';
	FOR rec IN EXECUTE sql USING startTime, endTime
	LOOP
		key 	= rec.player_id;
		val 	= key||'=>'||rec.rakeback;
		hash 	= hash||(SELECT val::hstore);
	END LOOP;
	-- raise info '玩家API返水 = %', hash;
	raise info '统计玩家API返水.完成';

	RETURN hash;
END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_site_game(url text,vname text,site_id INT) returns void as $$
DECLARE
	num int:=0;
BEGIN
select count(*) from pg_views where viewname=''||vname||'' into num;
	--raise info 'num:%',num;
	if num>0 THEN
		execute 'drop view '||vname;
	END IF;
EXECUTE
'create or replace view '||vname||' as
select * from dblink('''||url||''',
''select id,game_id,api_id,game_type,game_type_parent from site_game where site_id='||site_id||''')
 as p(id int4,game_id int4,api_id int4,game_type VARCHAR,game_type_parent VARCHAR)';

END;
$$ LANGUAGE plpgsql;",V1.0.1.0199__C_gamebox_site_game.sql
"create or replace function gamebox_site_game(url text,vname text,site_id INT,OP TEXT) returns void as $$
DECLARE
	num int:=0;
BEGIN
	select count(*) from pg_views where viewname=''||vname||'' into num;
	--raise info 'num:%',num;
  IF num>0 AND (OP='D' OR OP='C') THEN
		execute 'drop view '||vname;
	END IF;
	IF OP='C' THEN
  EXECUTE
	'create or replace view '||vname||'
	 as select * from dblink('''||url||''',
	''select id,game_id,api_id,game_type,api_type_id
		from site_game where site_id='||site_id||''')
	  as p(id int4,game_id int4,api_id int4,game_type VARCHAR
		,api_type_id int4)';
  END IF;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_site_information(
	main_url 	TEXT,
	master_urls TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '-1, 运营商URL为空';
		RETURN '1, 运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '-1, 站点库URL为空';
		RETURN '2, 站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1, 分隔符为空';
		RETURN '3, 分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);

	IF array_length(dblink_urls, 1) > 0 THEN

		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_role_information(dblink_urls[i]);
		END LOOP;

	END IF;
	RETURN '0';
END;

$$ language plpgsql;",1_gamebox_site_information.sql
"create or replace function gamebox_site_information(
	main_url TEXT,
	master_urls TEXT,
	split TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '-1, 运营商URL为空';
		RETURN '1, 运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '-1, 站点库URL为空';
		RETURN '2, 站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1, 分隔符为空';
		RETURN '3, 分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);

	IF array_length(dblink_urls,  1) > 0 THEN

		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1)
		LOOP
			perform gamebox_role_information(dblink_urls[i]);
		END LOOP;

	END IF;
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0003__C_gamebox_site_information.sql
"create or replace function gamebox_site_information(
main_url TEXT
,master_urls TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
BEGIN
	IF ltrim(rtrim(main_url))='' THEN
		raise info '-1,运营商URL为空';
		RETURN '1,运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '-1,站点库URL为空';
		RETURN '2,站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '-1,分隔符为空';
		RETURN '3,分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	IF array_length(dblink_urls, 1)>0 THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_information(dblink_urls[i]);
		END LOOP;
	END IF;
	RETURN '0';
END;
$$ language plpgsql;",V1.0.1.0020__C_gamebox_site_information.sql
"create or replace function gamebox_site_map(
	sid INT
) returns hstore as $$
DECLARE
	rec 		record;
	dict_map 	hstore;
BEGIN
	FOR rec IN
		SELECT  * FROM sys_site_info WHERE siteid = sid
	LOOP
		SELECT 'site_id=>'||rec.siteid INTO dict_map;
		IF rec.sitename != null AND rec.sitename != '' THEN
			dict_map = (SELECT ('site_name=>'||rec.sitename)::hstore)||dict_map;
		END IF;
		dict_map = (SELECT ('master_id=>'||rec.masterid)::hstore)||dict_map;
		dict_map = (SELECT ('master_name=>'||rec.mastername)::hstore)||dict_map;
		dict_map = (SELECT ('center_id=>'||rec.operationid)::hstore)||dict_map;
		dict_map = (SELECT ('center_name=>'||rec.operationname)::hstore)||dict_map;
	END LOOP;
	IF dict_map is null THEN
		SELECT '-1=>-1' INTO dict_map;
	END IF;

	RETURN dict_map;
END;

$$ language plpgsql;",5_gamebox_site_rakeback.sql
"create or replace function gamebox_site_map(
	sid INT
) returns hstore as $$
DECLARE
	rec 		record;
	dict_map 	hstore;
BEGIN
	FOR rec IN
		SELECT  * FROM sys_site_info WHERE siteid = sid
	LOOP
		SELECT 'site_id=>'||rec.siteid INTO dict_map;
		IF rec.sitename != null AND rec.sitename != '' THEN
			dict_map = (SELECT ('site_name=>'||rec.sitename)::hstore)||dict_map;
		END IF;
		dict_map = (SELECT ('master_id=>'||rec.masterid)::hstore)||dict_map;
		dict_map = (SELECT ('master_name=>'||rec.mastername)::hstore)||dict_map;
		dict_map = (SELECT ('center_id=>'||rec.operationid)::hstore)||dict_map;
		dict_map = (SELECT ('center_name=>'||rec.operationname)::hstore)||dict_map;
	END LOOP;
	IF dict_map is null THEN
		SELECT '-1=>-1' INTO dict_map;
	END IF;

	RETURN dict_map;
END;

$$ language plpgsql;",V1.0.1.0017__U_gamebox_site_rakeback.sql
"create or replace function gamebox_site_map(
	sid INT
) returns hstore as $$
DECLARE
	rec 		record;
	dict_map 	hstore;
BEGIN
	FOR rec IN
		SELECT  * FROM sys_site_info WHERE siteid = sid
	LOOP
		SELECT 'site_id=>'||rec.siteid INTO dict_map;
		dict_map = (SELECT ('site_name=>'||rec.sitename)::hstore)||dict_map;
		dict_map = (SELECT ('master_id=>'||rec.masterid)::hstore)||dict_map;
		dict_map = (SELECT ('master_name=>'||rec.mastername)::hstore)||dict_map;
		dict_map = (SELECT ('center_id=>'||rec.operationid)::hstore)||dict_map;
		dict_map = (SELECT ('center_name=>'||rec.operationname)::hstore)||dict_map;
	END LOOP;
	IF dict_map is null THEN
		SELECT '-1=>-1' INTO dict_map;
	END IF;

	RETURN dict_map;
END;

$$ language plpgsql;",V1.0.1.0007__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_map(
sid INT
)
returns hstore as $$
DECLARE
	rec record;
	dict_map hstore;
BEGIN
	FOR rec IN
		SELECT * FROM sys_site_info WHERE siteid=sid
	LOOP
			SELECT 'site_id=>'||rec.siteid INTO dict_map;
			dict_map=(SELECT ('site_name=>'||rec.sitename)::hstore)||dict_map;
			dict_map=(SELECT ('master_id=>'||rec.masterid)::hstore)||dict_map;
			dict_map=(SELECT ('master_name=>'||rec.mastername)::hstore)||dict_map;
			dict_map=(SELECT ('center_id=>'||rec.operationid)::hstore)||dict_map;
			dict_map=(SELECT ('center_name=>'||rec.operationname)::hstore)||dict_map;
	END LOOP;
	IF dict_map is null THEN
		SELECT '-1=>-1' INTO dict_map;
	END IF;
	RETURN dict_map;
END
$$ language plpgsql;",V1.0.1.0021__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_map(
sid INT
)
returns hstore as $$
DECLARE
	rec record;
	dict_map hstore;
BEGIN
	FOR rec IN
		SELECT * FROM sys_site_info WHERE siteid=sid
	LOOP
			SELECT 'site_id=>'||rec.siteid INTO dict_map;
			dict_map=(SELECT ('site_name=>'||rec.sitename)::hstore)||dict_map;
			dict_map=(SELECT ('master_id=>'||rec.masterid)::hstore)||dict_map;
			dict_map=(SELECT ('master_name=>'||rec.mastername)::hstore)||dict_map;
			dict_map=(SELECT ('center_id=>'||rec.operationid)::hstore)||dict_map;
			dict_map=(SELECT ('center_name=>'||rec.operationname)::hstore)||dict_map;
	END LOOP;
	IF dict_map is null THEN
		SELECT '-1=>-1' INTO dict_map;
	END IF;
	RETURN dict_map;
END
$$ language plpgsql;",V1.0.1.0034__E_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	rake_map 	hstore;
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;

BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master',  master_url);
	SELECT site_id FROM dblink('master', ' SELECT  * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
	SELECT gamebox_site_map(sid) INTO dict_map;

	date_time = end_time::TIMESTAMP;
	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month=>'||c_month)::hstore)||dict_map;

	SELECT  * FROM dblink(
		'master',
		'SELECT * FROM gamebox_rakeback_map('''||start_time||'''::TIMESTAMP, '''||end_time||'''::TIMESTAMP, '''||main_url||''', '''||category||''')'
	) as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys = akeys(rake_map);

		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i]) > 1 THEN
				sub_keys = regexp_split_to_array(keys[i], col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num = 1;
				ELSEIF exist(num_map, sub_keys[1]) = FALSE THEN
					num_map = (SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num = player_num + 1;
				END IF;
				--统计API.GAME_TYPE
				sub_key = sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map, sub_key) THEN
					val = (rake_map->keys[i])::FLOAT;
					val = val + ((api_map->sub_key)::FLOAT);
					api_map = (SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map = (SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;

		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map, dict_map);

		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);

		raise info '站点返水.玩家';
		dict_map = (SELECT ('player_num=>'||player_num)::hstore)||dict_map;

		perform gamebox_site_rakeback_player(dict_map);

	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0007__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	rake_map 	hstore;
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;

BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master', master_url);
	SELECT site_id FROM dblink('master', 'SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
	SELECT gamebox_site_map(sid) INTO dict_map;

	date_time = end_time::TIMESTAMP;
	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month=>'||c_month)::hstore)||dict_map;

	SELECT  * FROM dblink(
		'master',
		'SELECT * FROM gamebox_rakeback_map('''||start_time||'''::TIMESTAMP, '''||end_time||'''::TIMESTAMP, '''||main_url||''', '''||category||''')'
	) as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys = akeys(rake_map);

		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i]) > 1 THEN
				sub_keys = regexp_split_to_array(keys[i], col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num = 0;
				ELSEIF exist(num_map, sub_keys[1]) = FALSE THEN
					num_map = (SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num = player_num + 1;
				END IF;
				--统计API.GAME_TYPE
				sub_key = sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map, sub_key) THEN
					val = (rake_map->keys[i])::FLOAT;
					val = val + ((api_map->sub_key)::FLOAT);
					api_map = (SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map = (SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;

		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map, dict_map);

		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);

		raise info '站点返水.玩家';
		dict_map = (SELECT ('player_num=>'||player_num)::hstore)||dict_map;

		perform gamebox_site_rakeback_player(dict_map);

	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0017__U_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_site_rakeback(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0007__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];

BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1)
		LOOP
			perform gamebox_site_rakeback(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0017__U_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	rec record;
	cnum INT;
	rake_map hstore;
	category TEXT:='API';
	keys TEXT[];
	sub_keys TEXT[];
	sub_key TEXT:='';
	col_split TEXT:='_';
	num_map hstore;
	api_map hstore;
	dict_map hstore;
	param TEXT:='';
	sid INT;--站点ID.
	val FLOAT;
	date_time TIMESTAMP;
	c_year INT;
	c_month INT;
	player_num INT;
BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1,站点库URL为空';
	END IF;
	perform dblink_close_all();
	perform dblink_connect('master', master_url);
  SELECT site_id FROM dblink('master',' SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
  SELECT gamebox_site_map(sid) INTO dict_map;
	date_time=end_time::TIMESTAMP;
	select extract(year from date_time) INTO c_year;
	select extract(month from date_time) INTO c_month;
	dict_map=(SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map=(SELECT ('month=>'||c_month)::hstore)||dict_map;

	select * from dblink('master'
	,'select * from gamebox_rakeback_map(
	'''||start_time||'''::TIMESTAMP,'''||end_time||'''::TIMESTAMP
	,'''||main_url||''','''||category||''')') as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys=akeys(rake_map);
		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i])>1 THEN
				sub_keys=regexp_split_to_array(keys[i],col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num=1;
				ELSEIF exist(num_map,sub_keys[1])=FALSE THEN
					num_map=(SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num=player_num+1;
				END IF;
				--统计API.GAME_TYPE
				sub_key=sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map,sub_key) THEN
					val=(rake_map->keys[i])::FLOAT;
					val=val+((api_map->sub_key)::FLOAT);
					api_map=(SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map=(SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;
		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map,dict_map);
		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);
		raise info '站点返水.玩家';
		dict_map=(SELECT ('player_num=>'||player_num)::hstore)||dict_map;
		perform gamebox_site_rakeback_player(dict_map);
	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0021__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	rec record;
	cnum INT;
	rake_map hstore;
	category TEXT:='API';
	keys TEXT[];
	sub_keys TEXT[];
	sub_key TEXT:='';
	col_split TEXT:='_';
	num_map hstore;
	api_map hstore;
	dict_map hstore;
	param TEXT:='';
	sid INT;--站点ID.
	val FLOAT;
	date_time TIMESTAMP;
	c_year INT;
	c_month INT;
	player_num INT;
BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1,站点库URL为空';
	END IF;
	perform dblink_close_all();
	perform dblink_connect('master', master_url);
  SELECT site_id FROM dblink('master',' SELECT * FROM gamebox_current_site()') as s(site_id INT) INTO sid;
  SELECT gamebox_site_map(sid) INTO dict_map;
	date_time=end_time::TIMESTAMP;
	select extract(year from date_time) INTO c_year;
	select extract(month from date_time) INTO c_month;
	dict_map=(SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map=(SELECT ('month=>'||c_month)::hstore)||dict_map;

	select * from dblink('master'
	,'select * from gamebox_rakeback_map(
	'''||start_time||'''::TIMESTAMP,'''||end_time||'''::TIMESTAMP
	,'''||main_url||''','''||category||''')') as p(h hstore) INTO rake_map;

	IF rake_map is not null THEN
		keys=akeys(rake_map);
		FOR i IN 1..array_length(keys, 1) LOOP
			IF char_length(keys[i])>1 THEN
				sub_keys=regexp_split_to_array(keys[i],col_split);
				--统计玩家数.
				IF num_map is null THEN
					SELECT sub_keys[1]||'=>1' INTO num_map;
					player_num=1;
				ELSEIF exist(num_map,sub_keys[1])=FALSE THEN
					num_map=(SELECT (sub_keys[1]||'=>1')::hstore)||num_map;
					player_num=player_num+1;
				END IF;
				--统计API.GAME_TYPE
				sub_key=sub_keys[2]||col_split||sub_keys[3];
				IF api_map is null THEN
					--param=sub_key||'='||rake_map->keys[i];
					SELECT sub_key||'=>'||(rake_map->keys[i]) INTO api_map;
				ELSEIF exist(api_map,sub_key) THEN
					val=(rake_map->keys[i])::FLOAT;
					val=val+((api_map->sub_key)::FLOAT);
					api_map=(SELECT (sub_key||'=>'||val)::hstore)||api_map;
				ELSE
					api_map=(SELECT (sub_key||'=>'||(rake_map->keys[i]))::hstore)||api_map;
				END IF;
			END IF;
		END LOOP;
		raise info '站点返水.GAME_TYPE';
		perform gamebox_site_rakeback_gametype(api_map,dict_map);
		raise info '站点返水.API';
		perform gamebox_site_rakeback_api(dict_map);
		raise info '站点返水.玩家';
		dict_map=(SELECT ('player_num=>'||player_num)::hstore)||dict_map;
		perform gamebox_site_rakeback_player(dict_map);
	END IF;
	perform dblink_disconnect('master');
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0034__E_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rakeback(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0021__C_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rakeback(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rakeback(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0034__E_gamebox_site_rakeback.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	expense_map hstore;
	maps 		hstore[];
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;
BEGIN
	IF ltrim(rtrim(master_url)) = '' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master',  master_url);

	SELECT  * FROM dblink(
		'master',
		'SELECT  * FROM gamebox_rebate_map('''||main_url||''', '''||start_time||''', '''||end_time||''', '''||category||''')'
	) as p(h hstore[]) INTO maps;

	IF array_length(maps, 1) < 2 THEN
		RETURN '1.站点库返回信息有误';
	END IF;

	api_map = maps[1];
	expense_map = maps[2];
	sid = (expense_map->'site_id')::INT;
	perform gamebox_collect_site_infor(main_url);
  	SELECT gamebox_site_map(sid) INTO dict_map;
	date_time = end_time::TIMESTAMP;

	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month=>'||c_month)::hstore)||dict_map;

	raise info '站点返佣.GAME_TYPE';
	perform gamebox_site_rebate_gametype(api_map, dict_map);

	raise info '站点返佣.API';
	perform gamebox_site_rebate_api(dict_map);

	raise info '站点返佣';
	perform gamebox_site_rebate(expense_map, dict_map);

	perform dblink_disconnect('master');

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0014__U_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_url 	TEXT,
	start_time 	TEXT,
	end_time 	TEXT
) returns TEXT as $$
DECLARE
	rec 		record;
	cnum 		INT;
	expense_map hstore;
	maps 		hstore[];
	category 	TEXT:='API';
	keys 		TEXT[];
	sub_keys 	TEXT[];
	sub_key 	TEXT:='';
	col_split 	TEXT:='_';
	num_map 	hstore;
	api_map 	hstore;
	dict_map 	hstore;
	param 		TEXT:='';
	sid 		INT;--站点ID.
	val 		FLOAT;
	date_time 	TIMESTAMP;
	c_year 		INT;
	c_month 	INT;
	player_num 	INT;
BEGIN
	IF ltrim(rtrim(master_url)) = '' THEN
		RAISE EXCEPTION '-1, 站点库URL为空';
	END IF;

	perform dblink_close_all();
	perform dblink_connect('master',  master_url);

	SELECT  * FROM dblink(
		'master',
		'SELECT  * FROM gamebox_rebate_map('''||main_url||''', '''||start_time||''', '''||end_time||''', '''||category||''')'
	) as p(h hstore[]) INTO maps;

	IF array_length(maps, 1) < 2 THEN
		RETURN '1.站点库返回信息有误';
	END IF;

	api_map = maps[1];
	expense_map = maps[2];
	sid = (expense_map->'site_id')::INT;

  	SELECT gamebox_site_map(sid) INTO dict_map;
	date_time = end_time::TIMESTAMP;

	SELECT extract(year FROM date_time) INTO c_year;
	SELECT extract(month FROM date_time) INTO c_month;
	dict_map = (SELECT ('year = >'||c_year)::hstore)||dict_map;
	dict_map = (SELECT ('month = >'||c_month)::hstore)||dict_map;

	raise info '站点返佣.GAME_TYPE';
	perform gamebox_site_rebate_gametype(api_map, dict_map);

	raise info '站点返佣.API';
	perform gamebox_site_rebate_api(dict_map);

	raise info '站点返佣';
	perform gamebox_site_rebate(expense_map, dict_map);

	perform dblink_disconnect('master');

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0004__C_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];
BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1) LOOP
			perform gamebox_site_rebate(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0004__C_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
	main_url 	TEXT,
	master_urls TEXT,
	start_times TEXT,
	end_times 	TEXT,
	split 		TEXT
) returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time 	TEXT[];
	end_time 	TEXT[];
BEGIN
	IF ltrim(rtrim(main_url)) = '' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls)) = '' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split)) = '' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  	END IF;

	dblink_urls:=regexp_split_to_array(master_urls, split);
	start_time:=regexp_split_to_array(start_times, split);
	end_time:=regexp_split_to_array(end_times, split);

	IF array_length(dblink_urls, 1) > 0
		AND array_length(dblink_urls, 1) = array_length(start_time, 1)
		AND array_length(dblink_urls, 1) = array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);

		FOR i IN 1..array_length(dblink_urls,  1) LOOP
			perform gamebox_site_rebate(main_url, dblink_urls[i], start_time[i], end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0014__U_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
main_url TEXT
,master_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	rec record;
	cnum INT;
	expense_map hstore;
	maps hstore[];
	category TEXT:='API';
	keys TEXT[];
	sub_keys TEXT[];
	sub_key TEXT:='';
	col_split TEXT:='_';
	num_map hstore;
	api_map hstore;
	dict_map hstore;
	param TEXT:='';
	sid INT;--站点ID.
	val FLOAT;
	date_time TIMESTAMP;
	c_year INT;
	c_month INT;
	player_num INT;
BEGIN
	IF ltrim(rtrim(master_url))='' THEN
		RAISE EXCEPTION '-1,站点库URL为空';
	END IF;
	perform dblink_close_all();
	perform dblink_connect('master', master_url);

	select * from dblink('master'
	,'select * from gamebox_rebate_map(
	'''||main_url||''','''||start_time||''','''||end_time||'''
	,'''||category||''')') as p(h hstore[]) INTO maps;

	IF array_length(maps, 1)<2 THEN
		RETURN '1.站点库返回信息有误';
	END IF;

	api_map=maps[1];
	expense_map=maps[2];

	--raise info '%',api_map;
	--raise info '%',expense_map;
	sid=(expense_map->'site_id')::INT;
  SELECT gamebox_site_map(sid) INTO dict_map;
	date_time=end_time::TIMESTAMP;
	select extract(year from date_time) INTO c_year;
	select extract(month from date_time) INTO c_month;
	dict_map=(SELECT ('year=>'||c_year)::hstore)||dict_map;
	dict_map=(SELECT ('month=>'||c_month)::hstore)||dict_map;

	raise info '站点返佣.GAME_TYPE';
	perform gamebox_site_rebate_gametype(api_map,dict_map);
	raise info '站点返佣.API';
	perform gamebox_site_rebate_api(dict_map);
	raise info '站点返佣';
	perform gamebox_site_rebate(expense_map,dict_map);

	perform dblink_disconnect('master');
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0022__C_gamebox_site_rebate.sql
"create or replace function gamebox_site_rebate(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_site_rebate(main_url,dblink_urls[i],start_time[i],end_time[i]);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0022__C_gamebox_site_rebate.sql
"create or replace function gamebox_station_bill(
    main_url    TEXT,
    master_urls TEXT,
    start_times TEXT,
    end_times 	TEXT,
    split 		TEXT,
    flag 		INT
) returns TEXT as $$
DECLARE
    dblink_urls TEXT[];
    start_time 	TEXT[];
    end_time 	TEXT[];

BEGIN
    IF ltrim(rtrim(main_url)) = '' THEN
        raise info '运营商URL为空';
        RETURN '运营商URL为空';
    ELSEIF ltrim(rtrim(master_urls)) = '' THEN
        raise info '站点库URL为空';
        RETURN '站点库URL为空';
    ELSEIF ltrim(rtrim(split)) = '' THEN
        raise info '分隔符为空';
        RETURN '分隔符为空';
    END IF;

    dblink_urls:=regexp_split_to_array(master_urls, split);
    start_time:=regexp_split_to_array(start_times, split);
    end_time:=regexp_split_to_array(end_times, split);

    IF array_length(dblink_urls, 1) > 0
        AND array_length(dblink_urls, 1) = array_length(start_time, 1)
        AND array_length(dblink_urls, 1) = array_length(end_time, 1)
    THEN
        perform dblink_close_all();
        perform gamebox_collect_site_infor(main_url);
        FOR i IN 1..array_length(dblink_urls, 1)
        LOOP
            perform gamebox_station_bill(main_url, dblink_urls[i], start_time[i], end_time[i], flag);
        END LOOP;
    ELSE
        raise info '参数格式或者数量不一致';
        RETURN '参数格式或者数量不一致';
    END IF;

    RETURN '0';
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
  main_url 	TEXT,
  master_urls TEXT,
  start_times TEXT,
  end_times 	TEXT,
  split 		TEXT,
  flag 		INT
) returns TEXT as $$
DECLARE
  dblink_urls TEXT[];
  start_time 	TEXT[];
  end_time 	TEXT[];

BEGIN
  IF ltrim(rtrim(main_url)) = '' THEN
    raise info '1-运营商URL为空';
    RETURN '1-运营商URL为空';
  ELSEIF ltrim(rtrim(master_urls)) = '' THEN
    raise info '1-站点库URL为空';
    RETURN '1-站点库URL为空';
  ELSEIF ltrim(rtrim(split)) = '' THEN
    raise info '1-分隔符为空';
    RETURN '1-分隔符为空';
  END IF;

  dblink_urls:=regexp_split_to_array(master_urls, split);
  start_time:=regexp_split_to_array(start_times, split);
  end_time:=regexp_split_to_array(end_times, split);

  IF array_length(dblink_urls, 1) > 0
     AND array_length(dblink_urls, 1) = array_length(start_time, 1)
     AND array_length(dblink_urls, 1) = array_length(end_time, 1)
  THEN
    perform dblink_close_all();
    perform gamebox_collect_site_infor(main_url);
    FOR i IN 1..array_length(dblink_urls, 1)
    LOOP
      perform gamebox_station_bill(main_url, dblink_urls[i], start_time[i], end_time[i], flag);
    END LOOP;
  ELSE
    raise info '1-参数格式或者数量不一致';
    RETURN '1-参数格式或者数量不一致';
  END IF;

  RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
,flag INT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_station_bill(main_url,dblink_urls[i],start_time[i],end_time[i],flag);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill(
main_url TEXT
,master_urls TEXT
,start_times TEXT
,end_times TEXT
,split TEXT
,flag INT
)
returns TEXT as $$
DECLARE
	dblink_urls TEXT[];
	start_time TEXT[];
	end_time TEXT[];
BEGIN
	--start_time='2015-01-01';
	--end_time='2015-12-30';
	IF ltrim(rtrim(main_url))='' THEN
		raise info '1-运营商URL为空';
		RETURN '1-运营商URL为空';
	ELSEIF ltrim(rtrim(master_urls))='' THEN
		raise info '1-站点库URL为空';
		RETURN '1-站点库URL为空';
	ELSEIF ltrim(rtrim(split))='' THEN
		raise info '1-分隔符为空';
		RETURN '1-分隔符为空';
  END IF;
	dblink_urls:=regexp_split_to_array(master_urls,split);
	start_time:=regexp_split_to_array(start_times,split);
	end_time:=regexp_split_to_array(end_times,split);
	IF array_length(dblink_urls, 1)>0
		AND array_length(dblink_urls, 1)=array_length(start_time, 1)
		AND array_length(dblink_urls, 1)=array_length(end_time, 1)
	THEN
		perform dblink_close_all();
		perform gamebox_collect_site_infor(main_url);
		FOR i IN 1..array_length(dblink_urls, 1) LOOP
			perform gamebox_station_bill(main_url,dblink_urls[i],start_time[i],end_time[i],flag);
		END LOOP;
	ELSE
		raise info '1-参数格式或者数量不一致';
		RETURN '1-参数格式或者数量不一致';
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_master(
  sys_map 	hstore,		-- 优惠分摊比例
  dict_map 	hstore,		-- 运营商，站长，站点，年，月，账务类型
  url_name 	TEXT,
  main_url 	TEXT,
  start_time 	TEXT,
  end_time 	TEXT
) returns TEXT as $$
DECLARE
	net_maps 	hstore[];
	api_id 		INT;
	api 		TEXT;
	game_type 	TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id 	INT;
	bill_year 	INT;
	bill_month 	INT;

	id 			INT;
	name 		TEXT;
	val 		TEXT;		-- 单个API单个GameType占成方案
	vals 		TEXT[];
	sval 		TEXT[];
	keys 		TEXT[];
	key_name 	TEXT:='';

	map 		hstore;
	cost_map 	hstore;

	category 	TEXT:='';
	value 		FLOAT;
	h_keys 		TEXT[]:=array['-1'];	-- 记录已存在ID.
	amount 		FLOAT:=0.00;			-- 应付总额（各API盈亏(盈利)）
	expense 	FLOAT:=0.00;			-- 分摊费用.
	limit_values FLOAT[];				-- 梯度数组
	retios 		FLOAT[];				-- 占成数组

	is_max 		boolean:=false;
	sid 		INT; 					-- 站点ID.
	cur 		refcursor;  			-- 每个API的占成
	rec 		record;
	trade_amount FLOAT:=0.00;
	profilt_amount FLOAT:=0.00;
	occupy 		FLOAT:=0.00;			-- API占成
	assume 		BOOLEAN:=false;			-- 单个API是否盈亏共担
	fee 		FLOAT:=0.00;			-- 费用
	no_bill 	FLOAT:=0.00;			-- 上期未结金额
  	maintenance_charges FLOAT:=0.00;	-- 维护费
	ensure_consume FLOAT:=0.00;			-- 保底消费
	reduction_maintenance_fee FLOAT:=0.00; 		-- 减免维护费
	redu_main_fee_limit FLOAT:=0.00;	-- 减免维护费上限（最高=维护费）
	actual_maintenance_charges FLOAT:=0.00;		-- 实际维护费
	return_profit FLOAT:=0.00;			-- 返盈利
	actual_return_profit FLOAT:=0.00;	-- 实际返盈利

	net_map 	hstore;		-- 包网方案map
	occupy_map 	hstore;		-- API占成梯度map
	assume_map 	hstore;		-- 盈亏共担map.
	charge_map 	hstore; 	-- 维护费用map.
	favorable_map hstore;	-- 优惠map
	code 		TEXT:='';	-- 其它项目代码（maintenance_charges：维护费，ensure_consume：保底费，return_profit：反盈利，reduction_maintenance_fee：减免维护费，pending：上期未结，rakeback_offers：返水优惠，offers_recommended：优惠急推荐，back_charges：返手续费，rebate：佣金）
	sys_config 	hstore;		-- 系统变量
	prev_map	hstore;		-- 上期信息（未结金额，经办人）
	operator	TEXT:='';	-- 上期未结算经办人

	sp 			TEXT:='@';
	rs 			TEXT:='\~';
	cs 			TEXT:='\^';
	rs_a 		TEXT:='';
	cs_a 		TEXT:='';
	sp_a 		TEXT:='';
BEGIN
	-- 取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	sp_a = sys_config->'sp_split_a';
	rs_a = sys_config->'row_split_a';
	cs_a = sys_config->'col_split_a';
	rs_a = '\^&\^';
	cs_a = '\^';

	-- 取得当前站点的包网方案
	sid = sys_map->'site_id';
	SELECT  * FROM dblink(main_url, 'SELECT gamebox_contract('||sid||', '||is_max||')') as a(hash hstore[]) INTO net_maps;

	net_map = net_maps[1];
	occupy_map = net_maps[2];
	assume_map = net_maps[3];
	charge_map = net_maps[4];
	favorable_map = net_maps[5];

	amount = 0.00;
	SELECT put(dict_map, 'op', 'I') into dict_map;
	-- 准备station_bill.
	SELECT gamebox_station_bill(dict_map) INTO bill_id;

	-- 每个API的占成
	SELECT gamebox_operation_occupy_api(url_name, start_time, end_time) INTO cur;
	FETCH cur into rec;
	-- raise info '每个API的占成(rec) = %', rec;

	WHILE FOUND
	LOOP
		api 			= rec.api_id::TEXT;
		game_type 		= rec.game_type;
		profilt_amount 	= rec.profit_amount;
		trade_amount 	= rec.trade_amount;
		assume 			= COALESCE((assume_map->api)::BOOLEAN, FALSE); -- 是否盈亏共担
		key_name 		= api||'_'||game_type;
		val 			= COALESCE((occupy_map->key_name)::TEXT, '');
		IF val != '' THEN
			SELECT gamebox_operation_occupy_to_array(val, 2) INTO limit_values;	-- 梯度
			SELECT gamebox_operation_occupy_to_array(val, 3) INTO retios;
			SELECT gamebox_operation_occupy_calculate(limit_values, retios, profilt_amount, assume) INTO occupy;

			-- raise info 'api_id = %, game_type = %, 盈亏 = %, 占成 = %', api, game_type, profilt_amount, occupy;

			SELECT put(map, 'api_id', api) into map;			-- API_ID
			SELECT put(map, 'game_type', game_type) into map;	-- API二级分类
			SELECT put(map, 'amount_payable', occupy::TEXT) into map; 		--应付金额
			SELECT put(map, 'occupy_proportion', '0') into map;				--占成比例
			SELECT put(map, 'profit_loss', profilt_amount::TEXT) into map;	--盈亏总和
			SELECT put(map, 'bill_id', bill_id::TEXT) into map;
			-- 新增各API占成金额
			perform gamebox_station_profit_loss(map);

			-- 盈亏不共担时且占成金额为负时，计0
			IF assume = FALSE AND occupy < 0 THEN
				occupy = 0;
			END IF;
			-- 累计占成金额
			amount = amount + COALESCE(occupy, 0.00);
		END IF;
		FETCH cur INTO rec;
	END LOOP;

	CLOSE cur;

	-- 计算其它费用.
	-- raise info '------ 各API盈亏(amount) = %', amount;
	SELECT put(map, 'bill_id', bill_id::TEXT) into map;
	SELECT put(map, 'payable', '0') into map;
	SELECT put(map, 'actual', '0') into map;
	SELECT put(map, 'apportion', '0') into map;

	--------- 上期未结费用.START
	code = 'pending';
	bill_year = (dict_map->'year')::INT;
	bill_month = (dict_map->'month')::INT;
	SELECT gamebox_station_bill_prev(sid, bill_year, bill_month, '1') INTO prev_map;
	no_bill = COALESCE(prev_map->'no_bill', '0.00');
	operator = prev_map->'operator';
	SELECT put(map, 'name', operator) into map;
	SELECT put(map, 'code', code) into map;
	SELECT put(map, 'payable', no_bill::TEXT) into map;
	SELECT put(map, 'actual', no_bill::TEXT) into map;
	SELECT put(map, 'fee', '0.00') into map;
	perform gamebox_station_bill_other(map);
	--------- 上期未结费用.END

	SELECT put(map, 'name', '~') into map;

	--------- 保底费用.START
	ensure_consume = COALESCE((net_map->'ensure_consume')::FLOAT, 0.00);
	code = 'ensure_consume';
	SELECT put(map, 'code', code) into map;
	SELECT put(map, 'payable', ensure_consume::TEXT) into map;
	IF amount > ensure_consume THEN -- 盈亏大于保底费，不收保底费
		ensure_consume = 0.00;
	END IF;
	SELECT put(map, 'actual', ensure_consume::TEXT) into map;
	SELECT put(map, 'fee', ensure_consume::TEXT) into map;
  	perform gamebox_station_bill_other(map);
  	--------- 保底费用.END

	--------- 减免维护费.START
	code = 'reduction_maintenance_fee';
	SELECT gamebox_operation_favorable_calculate(charge_map, amount) INTO cost_map;
	-- 维护费
	maintenance_charges = COALESCE((net_map->'maintenance_charges')::FLOAT, 0.00);
	IF amount > 0 THEN
		reduction_maintenance_fee = COALESCE((cost_map->'value')::FLOAT, 0.00);
	ELSE
		reduction_maintenance_fee = 0.00;
	END IF;

	-- 减免维护费上限 = 全部维护费
	redu_main_fee_limit = reduction_maintenance_fee;
	IF redu_main_fee_limit > maintenance_charges THEN
		redu_main_fee_limit = maintenance_charges;
	END IF;

	SELECT put(map, 'code', code) into map;
	SELECT put(map, 'payable', reduction_maintenance_fee::TEXT) into map;
	SELECT put(map, 'actual', redu_main_fee_limit::TEXT) into map;
	SELECT put(map, 'fee', '0.00') into map;
	SELECT put(map, 'value', reduction_maintenance_fee::TEXT) into map;
	SELECT put(map, 'grads', COALESCE(cost_map->'grads', '0')) into map;
	SELECT put(map, 'way', COALESCE(cost_map->'way', '0')) into map;
	SELECT put(map, 'limit', COALESCE(cost_map->'limit', '0')) into map;

	map = cost_map||map;
	perform gamebox_station_bill_other(map);
	--------- 减免维护费.END

	--------- 维护费.START
	code = 'maintenance_charges';
	actual_maintenance_charges = maintenance_charges - redu_main_fee_limit;
	SELECT put(map, 'payable', maintenance_charges::TEXT) into map;
	SELECT put(map, 'actual', actual_maintenance_charges::TEXT) into map;
	SELECT put(map, 'code', code) into map;
	SELECT put(map, 'fee', maintenance_charges::TEXT) into map;
	SELECT put(map, 'value', '0') into map;
	SELECT put(map, 'grads', '0') into map;
	SELECT put(map, 'way', '0') into map;
	SELECT put(map, 'limit', '0') into map;
  	perform gamebox_station_bill_other(map);
  	--------- 维护费.END

	--------- 返盈利.START
	code = 'return_profit';
	SELECT gamebox_operation_favorable_calculate(favorable_map, amount) INTO cost_map;
	IF amount > 0 THEN
		return_profit = COALESCE((cost_map->'value')::FLOAT, 0.00);
	ELSE
		return_profit = 0.00;
	END IF;
	actual_return_profit = COALESCE(cost_map->'actual', '0');
	SELECT put(map, 'code', code) into map;
	SELECT put(map, 'payable', return_profit::TEXT) into map;
	SELECT put(map, 'actual', actual_return_profit::TEXT) into map;
	SELECT put(map, 'fee', '0.00') into map;
	SELECT put(map, 'value', return_profit::TEXT) into map;
	SELECT put(map, 'grads', COALESCE(cost_map->'grads', '0')) into map;
	SELECT put(map, 'way', COALESCE(cost_map->'way', '0')) into map;
	SELECT put(map, 'limit', COALESCE(cost_map->'limit', '0')) into map;
	--------- 返盈利.END

	map = map||cost_map;
	perform gamebox_station_bill_other(map);

	IF amount < 0 THEN					-- 各API盈亏为负
		amount = amount + ensure_consume;
	ELSEIF amount < ensure_consume THEN	-- 各API盈亏小于保底消费
		amount = ensure_consume;
	END IF;

	-- 站长付给运营商账务 = 各API盈亏 + 上期未结 + 维护费 - 实付减免维护费 - 实付返盈利
	fee = amount + no_bill +  maintenance_charges - redu_main_fee_limit - actual_return_profit;
	-- raise info '-------- API占成 = %', amount;
	-- raise info '-------- 应付金额 = %', fee;
	--更新账务.
	SELECT put(dict_map, 'bill_id', bill_id::TEXT) INTO dict_map;
	SELECT put(dict_map, 'op', 'U') INTO dict_map;
	SELECT put(dict_map, 'amount', fee::TEXT) into dict_map;
	-- raise info '------ dict_map = %', dict_map;
	SELECT gamebox_station_bill(dict_map) INTO bill_id;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_master(
sys_map hstore
,dict_map hstore
,url_name TEXT
,main_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	net_maps hstore[];
	api_id INT;
	api TEXT;
	game_type TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id INT;
	bill_year INT;
	bill_month INT;

	id INT;
	name TEXT;
	val TEXT;
	vals TEXT[];
	sval TEXT[];
	keys TEXT[];
	key_name TEXT:='';

	map hstore;
	cost_map hstore;

	category TEXT:='';
	value FLOAT;
	h_keys TEXT[]:=array['-1'];--记录已存在ID.
	amount FLOAT:=0.00;--应付总额
	expense FLOAT:=0.00;--分摊费用.
	limit_values FLOAT[];--梯度数组
	retios FLOAT[];--占成数组

	is_max boolean:=false;
	sid INT;--站点ID.
	cur refcursor;
	rec record;
	trade_amount FLOAT:=0.00;
	profilt_amount FLOAT:=0.00;
	occupy FLOAT:=0.00;--API占成
	assume BOOLEAN:=false;--是否盈亏共担.
	fee FLOAT:=0.00;--费用.
	no_bill FLOAT:=0.00;--上期未结金额
  maintenance_charges FLOAT:=0.00;--维护费
	ensure_consume FLOAT:=0.00;--保底消费
	reduction_maintenance_fee FLOAT:=0.00;--减免维护费
	return_profit FLOAT:=0.00;--返盈利

	net_map hstore;--包网方案
	occupy_map hstore;--API占成梯度map
	assume_map hstore;--盈亏共担map.
	charge_map hstore;--维护费用map.
	favorable_map hstore;--优惠map
	code TEXT:='';--项目代码
	sys_config hstore;

	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
	rs_a TEXT:='';
	cs_a TEXT:='';
	sp_a TEXT:='';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';
	sp_a=sys_config->'sp_split_a';
	rs_a=sys_config->'row_split_a';
	cs_a=sys_config->'col_split_a';
	rs_a='\^&\^';
	cs_a='\^';

	raise info 'sp:%,rs:%,cs:%,sp_a:%,rs_a:%,cs_a:%',sp,rs,cs,sp_a,rs_a,cs_a;

	--取得当前站点的包网方案
	sid=sys_map->'site_id';
	select * from dblink(main_url,'select gamebox_contract('||sid||','||is_max||')') as a(hash hstore[]) INTO net_maps;
	--raise info 'maps:%',net_maps;
	raise info '包网方案:%',net_maps[1];
	raise info '占成方案:%',net_maps[2];
	raise info '盈亏共担:%',net_maps[3];
	raise info '维护费:%',net_maps[4];
	raise info '优惠方案:%',net_maps[5];
	net_map=net_maps[1];
	occupy_map=net_maps[2];
	assume_map=net_maps[3];
	charge_map=net_maps[4];
	favorable_map=net_maps[5];

	amount=0.00;
	select put(dict_map,'op','I') into dict_map;
	--准备station_bill.
	select gamebox_station_bill(dict_map) INTO bill_id;

	--每个API的占成
	select gamebox_operation_occupy_api(url_name,start_time,end_time) INTO cur;
	FETCH cur into rec;
	WHILE FOUND LOOP
		api=rec.api_id::TEXT;
		game_type=rec.game_type;
		profilt_amount=rec.profit_amount;
		trade_amount=rec.trade_amount;
		assume=COALESCE((assume_map->api)::BOOLEAN,FALSE);
		key_name=api||'_'||game_type;
		val=COALESCE((occupy_map->key_name)::TEXT,'');
		IF val!='' THEN
			SELECT gamebox_operation_occupy_to_array(val,2) INTO limit_values;
			SELECT gamebox_operation_occupy_to_array(val,3) INTO retios;
			SELECT gamebox_operation_occupy_calculate(limit_values,retios,profilt_amount,assume) INTO occupy;
			raise info 'api:%,game_type:%,计税金额:%,占成:%',api,game_type,profilt_amount,occupy;
			select put(map,'api_id',api) into map;--API
			select put(map,'game_type',game_type) into map;--API二级分类
			select put(map,'amount_payable',occupy::TEXT) into map;--应付金额
			select put(map,'occupy_proportion','0') into map;--占成比例
			select put(map,'profit_loss',profilt_amount::TEXT) into map;--盈亏总和
			select put(map,'bill_id',bill_id::TEXT) into map;
			--新增各API占成金额
			perform gamebox_station_profit_loss(map);

			--盈亏不共担时,占成金额为负时，计0
			IF assume=FALSE AND occupy<0 THEN
				occupy=0;
			END IF;
			--累计占成金额
			amount=amount+COALESCE(occupy,0.00);
		END IF;
		FETCH cur INTO rec;
	END LOOP;
	CLOSE cur;
	--计算其它费用.
	raise info '占成总额:%',amount;
	select put(map,'bill_id',bill_id::TEXT) into map;
	select put(map,'payable','0') into map;
	select put(map,'actual','0') into map;
	select put(map,'apportion','0') into map;
	bill_month=(dict_map->'bill_month')::INT;
	bill_year=(dict_map->'bill_year')::INT;

	raise info 'bill_month:%',bill_month;
	raise info 'bill_year:%',bill_year;
	--上期未结费用.
	code='pending';
	select gamebox_station_no_bill(sid,bill_year,bill_month,'2') INTO no_bill;
	select put(map,'payable',no_bill::TEXT) into map;
	select put(map,'actual',no_bill::TEXT) into map;
	select put(map,'apportion','0') into map;
	select put(map,'code',code) into map;
	perform gamebox_station_bill_other(map);

	select put(map,'payable','0') into map;--复位
	select put(map,'actual','0') into map;--复位
	select put(map,'apportion','0') into map;--复位
	--维护费
	maintenance_charges=COALESCE((net_map->'maintenance_charges')::FLOAT,0.00);
	code='maintenance_charges';
	select put(map,'code',code) into map;
	select put(map,'fee',maintenance_charges::TEXT) into map;
  perform gamebox_station_bill_other(map);

	--保底费用
	ensure_consume=COALESCE((net_map->'ensure_consume')::FLOAT,0.00);
	code='ensure_consume';
	select put(map,'code',code) into map;
	select put(map,'fee',ensure_consume::TEXT) into map;
  perform gamebox_station_bill_other(map);

	select put(map,'fee','0.00') into map;--复位
	--减免维护费
	code='reduction_maintenance_fee';
	select put(map,'code',code) into map;
	SELECT gamebox_operation_favorable_calculate(charge_map,amount) INTO cost_map;
	reduction_maintenance_fee=COALESCE((cost_map->'value')::FLOAT,0.00);
	map=map||cost_map;
	perform gamebox_station_bill_other(map);

	--返盈利
	code='return_profit';
	select put(map,'code',code) into map;
	SELECT gamebox_operation_favorable_calculate(favorable_map,amount) INTO cost_map;
	return_profit=COALESCE((cost_map->'value')::FLOAT,0.00);
	map=map||cost_map;
	perform gamebox_station_bill_other(map);

	IF amount<ensure_consume THEN--运营商API占成小于保底消费
		amount=ensure_consume;
	END IF;
	--站长付给运营商账务：
	--API占成(或保底费)+维护费-返盈利-减免维护费+上期未结
	fee=amount+maintenance_charges-return_profit-reduction_maintenance_fee+no_bill;
	raise info '站长付给运营商账务:%',fee;
	--更新账务.
	select put(dict_map,'bill_id',bill_id::TEXT) INTO dict_map;
	select put(dict_map,'op','U') INTO dict_map;
	select put(dict_map,'amount',fee::TEXT) into dict_map;
	select gamebox_station_bill(dict_map) INTO bill_id;

	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_master(
sys_map hstore
,dict_map hstore
,url_name TEXT
,main_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	net_maps hstore[];
	api_id INT;
	api TEXT;
	game_type TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id INT;

	id INT;
	name TEXT;
	val TEXT;
	vals TEXT[];
	sval TEXT[];
	keys TEXT[];
	key_name TEXT:='';

	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	h_keys TEXT[]:=array['-1'];--记录已存在ID.
	amount FLOAT:=0.00;--应付总额
	expense FLOAT:=0.00;--分摊费用.
	limit_values FLOAT[];--梯度数组
	retios FLOAT[];--占成数组

	is_max boolean:=false;
	sid INT;--站点ID.
	cur refcursor;
	rec record;
	trade_amount FLOAT:=0.00;
	profilt_amount FLOAT:=0.00;
	occupy FLOAT:=0.00;--API占成
	assume BOOLEAN:=false;--是否盈亏共担.

	net_map hstore;--包网方案
	occupy_map hstore;--API占成梯度map
	assume_map hstore;--盈亏共担map.
	charge_map hstore;--维护费用map.
	favorable_map hstore;--优惠map

	sys_config hstore;

	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
	rs_a TEXT:='';
	cs_a TEXT:='';
	sp_a TEXT:='';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';
	sp_a=sys_config->'sp_split_a';
	rs_a=sys_config->'row_split_a';
	cs_a=sys_config->'col_split_a';
	rs_a='\^&\^';
	cs_a='\^';

	raise info 'sp:%,rs:%,cs:%,sp_a:%,rs_a:%,cs_a:%',sp,rs,cs,sp_a,rs_a,cs_a;

	--取得当前站点的包网方案
	sid=sys_map->'site_id';
	select * from dblink(main_url,'select gamebox_contract('||sid||','||is_max||')') as a(hash hstore[]) INTO net_maps;
	--raise info 'maps:%',net_maps;
	raise info '包网方案:%',net_maps[1];
	raise info '占成方案:%',net_maps[2];
	raise info '盈亏共担:%',net_maps[3];
	raise info '维护费:%',net_maps[4];
	raise info '优惠方案:%',net_maps[5];
	net_map=net_maps[1];
	occupy_map=net_maps[2];
	assume_map=net_maps[3];
	charge_map=net_maps[4];
	favorable_map=net_maps[5];

	--每个API的占成
	select gamebox_operation_occupy_api(url_name,start_time,end_time) INTO cur;
	FETCH cur into rec;
	WHILE FOUND LOOP
		api=rec.api_id::TEXT;
		game_type=rec.game_type;
		profilt_amount=rec.profit_amount;
		trade_amount=rec.trade_amount;
		assume=COALESCE((assume_map->api)::BOOLEAN,FALSE);
		key_name=api||'_'||game_type;
		val=COALESCE((occupy_map->key_name)::TEXT,'');
		IF val!='' THEN
			SELECT gamebox_operation_occupy_to_array(val,2) INTO limit_values;
			SELECT gamebox_operation_occupy_to_array(val,3) INTO retios;
			SELECT gamebox_operation_occupy_calculate(limit_values,retios,profilt_amount,assume) INTO occupy;
			raise info 'api:%,game_type:%,计税金额:%,占成:%',api,game_type,profilt_amount,occupy;
			--未实现数据插入
		END IF;
		FETCH cur INTO rec;
	END LOOP;
	CLOSE cur;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
    cost_map 	hstore,
    sys_map 	hstore,
    bill_id 	INT
) returns FLOAT as $$
DECLARE
	map 		hstore;
	expense_category 	TEXT[]:=array['backwater', 'refund_fee', 'favourable', 'rebate'];
	category 	TEXT:='';
	expense_code 		TEXT[]:=array['rakeback_offers', 'back_charges', 'offers_recommended', 'rebate'];
	code 		TEXT:='';
	value 		FLOAT;
	amount 		FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category = expense_category[j];
		code = expense_code[j];
		value = (cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;

		map = null;
		amount = amount + COALESCE((cost_map->(category||'_apportion'))::FLOAT, 0.00);

		SELECT put(map, 'bill_id', bill_id::TEXT) into map;
		SELECT put(map, 'payable', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'actual', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'apportion', sys_map->(category||'_percent')) into map;
		SELECT put(map, 'code', code) into map;

		perform gamebox_station_bill_other(map);

	END LOOP;
	RETURN amount;
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
  cost_map 	hstore,
  sys_map 	hstore,
  bill_id 	INT
) returns FLOAT as $$
DECLARE
	map 		hstore;
	expense_category 	TEXT[]:=array['backwater', 'refund_fee', 'favourable', 'rebate'];
	category 	TEXT:='';
	expense_code 		TEXT[]:=array['rakeback_offers', 'back_charges', 'offers_recommended', 'rebate'];
	code 		TEXT:='';
	value 		FLOAT;
	amount 		FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category = expense_category[j];
		code = expense_code[j];
		value = (cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;

		map = null;
		amount = amount + COALESCE((cost_map->(category||'_apportion'))::FLOAT, 0.00);

		SELECT put(map, 'bill_id', bill_id::TEXT) into map;
		SELECT put(map, 'payable', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'actual', cost_map->(category||'_apportion')) into map;
		SELECT put(map, 'apportion', sys_map->(category||'_percent')) into map;
		SELECT put(map, 'code', code) into map;

		perform gamebox_station_bill_other(map);

	END LOOP;
	RETURN amount;
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
cost_map hstore
,sys_map hstore
,bill_id INT
)
returns FLOAT as $$
DECLARE
	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	amount FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category=expense_category[j];
		value=(cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;
		map=null;
		amount=amount+COALESCE((cost_map->(category||'_apportion'))::FLOAT,0.00);
		select put(map,'bill_id',bill_id::TEXT) into map;
		select put(map,'payable',cost_map->(category||'_apportion')) into map;
		select put(map,'actual',cost_map->(category||'_apportion')) into map;
		select put(map,'apportion',sys_map->(category||'_percent')) into map;
		select put(map,'code',category) into map;
		perform gamebox_station_bill_other(map);
	END LOOP;
	RETURN amount;
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_other(
cost_map hstore
,sys_map hstore
,bill_id INT
)
returns FLOAT as $$
DECLARE
	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	amount FLOAT:=0.00;--费用总和.
BEGIN
	FOR j IN 1..array_length(expense_category, 1) LOOP
		category=expense_category[j];
		value=(cost_map->category)::FLOAT;
		IF value is null THEN
			CONTINUE;
		END IF;
		map=null;
		amount=amount+COALESCE((cost_map->(category||'_apportion'))::FLOAT,0.00);
		select put(map,'bill_id',bill_id::TEXT) into map;
		select put(map,'payable',cost_map->(category||'_apportion')) into map;
		select put(map,'actual',cost_map->(category||'_apportion')) into map;
		select put(map,'apportion',sys_map->(category||'_percent')) into map;
		select put(map,'code',category) into map;
		perform gamebox_station_bill_other(map);
	END LOOP;
	RETURN amount;
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_prev(
  site_id 	INT,
  bill_year 	INT,
  bill_month 	INT,
  bill_type 	TEXT
) returns hstore as $$
DECLARE
	map hstore:='';
	rec record;
BEGIN
	IF bill_month = 1 THEN
		bill_month = 12;
		bill_year = bill_year - 1;
	ELSE
		bill_month = bill_month - 1;
	END IF;

	FOR rec IN EXECUTE
		' SELECT amount_actual, operate_user_name
			FROM station_bill
		   WHERE site_id = $1
		     AND bill_year = $2
		     AND bill_month = $3
		     AND bill_type = $4
		     AND amount_actual < 0
		   LIMIT 1' USING site_id, bill_year, bill_month, bill_type
	LOOP
		SELECT put(map, 'no_bill', COALESCE(rec.amount_actual, 0.00)::TEXT) INTO map;
 		SELECT put(map, 'operator', COALESCE(rec.operate_user_name, '~')) INTO map;
	END LOOP;
	RETURN map;
END;

$$ LANGUAGE plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_top(
    sys_map 	hstore,		-- 优惠分摊比例
    dict_map 	hstore,		-- 运营商，站长，站点，年，月，账务类型
    url_name 	TEXT,
    main_url 	TEXT,
    start_time 	TEXT,
    end_time 	TEXT
) returns TEXT as $$
DECLARE
	maps 		hstore[];
	api_map 	hstore;
	expense_map hstore;		-- 分推比例
	cost_map 	hstore;

	api_id 		INT;
	game_type 	TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id 	INT;

	id 			INT;
	name 		TEXT;
	val 		TEXT;
	vals 		TEXT[];
	sval 		TEXT[];
	keys 		TEXT[];

	map 		hstore;
	expense_category TEXT[]:=array['backwater', 'refund_fee', 'favorable', 'rebate'];
	category 	TEXT:='';
	value 		FLOAT;
	h_keys 		TEXT[]:=array['-1'];	-- 记录已存在ID.
	amount 		FLOAT:=0.00;			-- 应付总额
	expense 	FLOAT:=0.00;			-- 分摊费用.

	sys_config hstore;
	sp 		TEXT:='@';
	rs 		TEXT:='\~';
	cs 		TEXT:='\^';
	rs_a 	TEXT:='';
	cs_a 	TEXT:='';
	sp_a 	TEXT:='';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	sp_a = sys_config->'sp_split_a';
	rs_a = sys_config->'row_split_a';
	cs_a = sys_config->'col_split_a';
	rs_a = '\^&\^';
	cs_a = '\^';

	-- raise info '------ url_name = %', url_name;
	-- raise info '------ main_url = %', main_url;

	SELECT  * FROM dblink(
		url_name,
		'SELECT  * FROM gamebox_occupy_map('''||main_url||''', '''||start_time||''', '''||end_time||''')'
	) as p(h hstore[]) INTO maps;

	IF array_length(maps,  1) < 2 THEN
		RETURN '1.站点库返回总代信息有误';
	END IF;

	api_map = maps[1];
	-- raise info '------ api_map = %', api_map;
	expense_map = maps[2];
	raise info '------ expense_map = %', expense_map;

	-- 格式：id=>name@api^game^val^retio^loss^&^api^game^val^retio^loss
	keys = akeys(api_map);
	-- raise info '------ keys = %', keys;
	-- raise info '------------------------- OFF LINE 1 -------------------------';
	IF array_length(keys, 1) > 0 THEN
		FOR i IN 1..array_length(keys, 1) LOOP

			val = api_map->keys[i];
			-- raise info '------ val = %', val;
			vals = regexp_split_to_array(val, sp);
			-- raise info '------ vals 1 = %', vals;

			IF array_length(vals, 1) = 2 THEN

				name = vals[1];
				-- raise info '------ name = %', name;
				SELECT put(dict_map, 'topagent_id', keys[i]) into dict_map;
				SELECT put(dict_map, 'topagent_name', name) into dict_map;
				SELECT put(dict_map, 'op', 'I') into dict_map;

				--准备station_bill.
				amount = 0.00;

				-- raise info '------ dict_map 1 = %', dict_map;
				SELECT gamebox_station_bill(dict_map) INTO bill_id;

				--API盈亏
				--vals[2].值格式:api^game^val^retio^loss
				vals = regexp_split_to_array(vals[2], rs_a);
				-- raise info '------ vals 2 = %', vals;

				IF array_length(vals, 1) > 0 THEN
					FOR k IN 1..array_length(vals, 1) LOOP

						--vals[k].值格式:api^game^val^retio^loss
						sval = regexp_split_to_array(vals[k], cs_a);
						-- raise info '------ sval = %', sval;
						IF array_length(sval, 1) >= 4 THEN
							map = null;
							SELECT put(map, 'api_id', sval[1]) into map;			--API
							SELECT put(map, 'game_type', sval[2]) into map;			--API二级分类
							SELECT put(map, 'amount_payable', sval[3]) into map;	--应付金额
							SELECT put(map, 'occupy_proportion', sval[4]) into map;	--占成比例
							SELECT put(map, 'profit_loss', sval[5]) into map;		--盈亏总和
							SELECT put(map, 'bill_id', bill_id::TEXT) into map;
							amount = amount + COALESCE(sval[3]::FLOAT, 0.00);

							-- raise info '------ map = %', map;
							perform gamebox_station_profit_loss(map);
						END IF;

					END LOOP;
				END IF;

				-- raise info '------ amount = %', amount;

				-- 其它费用.
				expense = 0.00;
				-- raise info '------ keys[i] = %', keys[i];
				IF exist(expense_map, keys[i]) THEN
					h_keys = array_append(h_keys, keys[i]);
					val = expense_map->keys[i];
					val = replace(val, rs, ',');
					val = replace(val, cs, '=>');
					SELECT val INTO cost_map;

					-- raise info '------ cost_map = %', cost_map;

					SELECT gamebox_station_bill_other(cost_map, sys_map, bill_id) INTO expense;
				END IF;

				-- raise info '------ expense = %', expense;

				-- 更新账务.
				amount = amount-expense;

				SELECT put(dict_map, 'bill_id', bill_id::TEXT) into dict_map;
				SELECT put(dict_map, 'op', 'U') into dict_map;
				SELECT put(dict_map, 'amount', amount::TEXT) into dict_map;

				-- raise info '------ dict_map 2 = %', dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;

	-- raise info '------------------------- OFF LINE 2 -------------------------';
	-- 处理特殊其它费用
	keys = akeys(expense_map);
	-- raise info '------ 其它 keys = %', keys;

	IF array_length(keys, 1) > 0 THEN
		FOR i IN 1..array_length(keys, 1)
		LOOP
			IF h_keys @> array[keys[i]] = false THEN--判断是否已经记账

				val = expense_map->keys[i];
				val = replace(val, rs, ',');
				val = replace(val, cs, '=>');
				SELECT val INTO cost_map;

				-- 准备station_bill.
				name = cost_map->'user_name';

				-- raise info '------ 其它 name = %', name;

				SELECT put(dict_map, 'topagent_id', keys[i]) INTO dict_map;
				SELECT put(dict_map, 'topagent_name', name) INTO dict_map;
				SELECT put(dict_map, 'op', 'I') INTO dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

				-- 其它费用
				-- raise info '------ 其它 cost_map = %', cost_map;
				SELECT gamebox_station_bill_other(cost_map, sys_map, bill_id) INTO expense;

				-- raise info '------ 其它 expense = %', expense;

				-- 更新账务.
				SELECT put(dict_map, 'bill_id', bill_id::TEXT) INTO dict_map;
				SELECT put(dict_map, 'op', 'U') INTO dict_map;
				SELECT put(dict_map, 'amount', (-expense)::TEXT) into dict_map;

				-- raise info '------ 其它 dict_map = %', dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",3_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_top(
  sys_map 	hstore,		-- 优惠分摊比例
  dict_map 	hstore,		-- 运营商，站长，站点，年，月，账务类型
  url_name 	TEXT,
  main_url 	TEXT,
  start_time 	TEXT,
  end_time 	TEXT
) returns TEXT as $$
DECLARE
	maps 		hstore[];
	api_map 	hstore;
	expense_map hstore;		-- 分推比例
	cost_map 	hstore;

	api_id 		INT;
	game_type 	TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id 	INT;

	id 			INT;
	name 		TEXT;
	val 		TEXT;
	vals 		TEXT[];
	sval 		TEXT[];
	keys 		TEXT[];

	map 		hstore;
	expense_category TEXT[]:=array['backwater', 'refund_fee', 'favorable', 'rebate'];
	category 	TEXT:='';
	value 		FLOAT;
	h_keys 		TEXT[]:=array['-1'];	-- 记录已存在ID.
	amount 		FLOAT:=0.00;			-- 应付总额
	expense 	FLOAT:=0.00;			-- 分摊费用.

	sys_config hstore;
	sp 		TEXT:='@';
	rs 		TEXT:='\~';
	cs 		TEXT:='\^';
	rs_a 	TEXT:='';
	cs_a 	TEXT:='';
	sp_a 	TEXT:='';
BEGIN
	--取得系统变量
	SELECT sys_config() INTO sys_config;
	sp = sys_config->'sp_split';
	rs = sys_config->'row_split';
	cs = sys_config->'col_split';
	sp_a = sys_config->'sp_split_a';
	rs_a = sys_config->'row_split_a';
	cs_a = sys_config->'col_split_a';
	rs_a = '\^&\^';
	cs_a = '\^';

	-- raise info '------ url_name = %', url_name;
	-- raise info '------ main_url = %', main_url;

	SELECT  * FROM dblink(
		url_name,
		'SELECT  * FROM gamebox_occupy_map('''||main_url||''', '''||start_time||''', '''||end_time||''')'
	) as p(h hstore[]) INTO maps;

	IF array_length(maps,  1) < 2 THEN
		RETURN '1.站点库返回总代信息有误';
	END IF;

	api_map = maps[1];
	raise info '------ api_map = %', api_map;
	expense_map = maps[2];
	raise info '------ expense_map = %', expense_map;

	-- 格式：id=>name@api^game^val^retio^loss^&^api^game^val^retio^loss
	keys = akeys(api_map);
	raise info '------ keys = %', keys;
	-- raise info '------------------------- OFF LINE 1 -------------------------';
	IF array_length(keys, 1) > 0 THEN
		FOR i IN 1..array_length(keys, 1) LOOP

			val = api_map->keys[i];
			raise info '------ val = %', val;
			vals = regexp_split_to_array(val, sp);
			raise info '------ vals 1 = %', vals;

			IF array_length(vals, 1) = 2 THEN

				name = vals[1];
				raise info '------ name = %', name;
				SELECT put(dict_map, 'topagent_id', keys[i]) into dict_map;
				SELECT put(dict_map, 'topagent_name', name) into dict_map;
				SELECT put(dict_map, 'op', 'I') into dict_map;

				--准备station_bill.
				amount = 0.00;

				raise info '------ dict_map 1 = %', dict_map;
				SELECT gamebox_station_bill(dict_map) INTO bill_id;

				--API盈亏
				--vals[2].值格式:api^game^val^retio^loss
				vals = regexp_split_to_array(vals[2], rs_a);
				raise info '------ vals 2 = %', vals;

				IF array_length(vals,  1) > 0 THEN
					FOR k IN 1..array_length(vals,  1) LOOP

						--vals[k].值格式:api^game^val^retio^loss
						sval = regexp_split_to_array(vals[k], cs_a);
						raise info '------ sval = %', sval;
						IF array_length(sval,  1) >= 4 THEN
							map = null;
							SELECT put(map, 'api_id', sval[1]) into map;			--API
							SELECT put(map, 'game_type', sval[2]) into map;			--API二级分类
							SELECT put(map, 'amount_payable', sval[3]) into map;	--应付金额
							SELECT put(map, 'occupy_proportion', sval[4]) into map;	--占成比例
							SELECT put(map, 'profit_loss', sval[5]) into map;		--盈亏总和
							SELECT put(map, 'bill_id', bill_id::TEXT) into map;
							amount = amount + COALESCE(sval[3]::FLOAT, 0.00);

							raise info '------ map = %', map;
							perform gamebox_station_profit_loss(map);
						END IF;

					END LOOP;
				END IF;

				raise info '------ amount = %', amount;

				-- 其它费用.
				expense = 0.00;
				raise info '------ keys[i] = %', keys[i];
				IF exist(expense_map, keys[i]) THEN
					h_keys = array_append(h_keys,  keys[i]);
					val = expense_map->keys[i];
					val = replace(val, rs, ',');
					val = replace(val, cs, '=>');
					SELECT val INTO cost_map;

					raise info '------ cost_map = %', cost_map;

					SELECT gamebox_station_bill_other(cost_map, sys_map, bill_id) INTO expense;
				END IF;

				raise info '------ expense = %', expense;

				-- 更新账务.
				amount = amount-expense;

				SELECT put(dict_map, 'bill_id', bill_id::TEXT) into dict_map;
				SELECT put(dict_map, 'op', 'U') into dict_map;
				SELECT put(dict_map, 'amount', amount::TEXT) into dict_map;

				raise info '------ dict_map 2 = %', dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;

	-- raise info '------------------------- OFF LINE 2 -------------------------';
	-- 处理特殊其它费用
	keys = akeys(expense_map);
	raise info '------ 其它 keys = %', keys;

	IF array_length(keys,  1) > 0 THEN
		FOR i IN 1..array_length(keys,  1)
		LOOP
			IF h_keys @> array[keys[i]] = false THEN--判断是否已经记账

				val = expense_map->keys[i];
				val = replace(val, rs, ',');
				val = replace(val, cs, '=>');
				SELECT val INTO cost_map;

				-- 准备station_bill.
				name = cost_map->'user_name';

				raise info '------ 其它 name = %', name;

				SELECT put(dict_map, 'topagent_id', keys[i]) INTO dict_map;
				SELECT put(dict_map, 'topagent_name', name) INTO dict_map;
				SELECT put(dict_map, 'op', 'I') INTO dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

				-- 其它费用
				raise info '------ 其它 cost_map = %', cost_map;
				SELECT gamebox_station_bill_other(cost_map, sys_map, bill_id) INTO expense;

				raise info '------ 其它 expense = %', expense;

				-- 更新账务.
				SELECT put(dict_map, 'bill_id', bill_id::TEXT) INTO dict_map;
				SELECT put(dict_map, 'op', 'U') INTO dict_map;
				SELECT put(dict_map, 'amount', (-expense)::TEXT) into dict_map;

				raise info '------ 其它 dict_map = %', dict_map;

				SELECT gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;

	RETURN '0';
END;

$$ language plpgsql;",V1.0.1.0005__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_top(
sys_map hstore
,dict_map hstore
,url_name TEXT
,main_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	maps hstore[];
	api_map hstore;
	expense_map hstore;
	cost_map hstore;


	api_id INT;
	game_type TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id INT;

	id INT;
	name TEXT;
	val TEXT;
	vals TEXT[];
	sval TEXT[];
	keys TEXT[];

	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	h_keys TEXT[]:=array['-1'];--记录已存在ID.
	amount FLOAT:=0.00;--应付总额
	expense FLOAT:=0.00;--分摊费用.

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
	rs_a TEXT:='';
	cs_a TEXT:='';
	sp_a TEXT:='';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';
	sp_a=sys_config->'sp_split_a';
	rs_a=sys_config->'row_split_a';
	cs_a=sys_config->'col_split_a';
	rs_a='\^&\^';
	cs_a='\^';

	raise info 'sp:%,rs:%,cs:%,sp_a:%,rs_a:%,cs_a:%',sp,rs,cs,sp_a,rs_a,cs_a;
	select * from dblink(url_name
	,'select * from gamebox_occupy_map('''||main_url||''','''||start_time||''','''||end_time||''')'
	) as p(h hstore[]) INTO maps;
	IF array_length(maps, 1)<2 THEN
		RETURN '1.站点库返回总代信息有误';
	END IF;
	api_map=maps[1];
	expense_map=maps[2];
	--raise info '%',api_map;
	--raise info '%',expense_map;
	--格式：id=>name@api^game^val^retio^loss^&^api^game^val^retio^loss
	keys=akeys(api_map);
	IF array_length(keys,1)>0 THEN
		FOR i IN 1..array_length(keys,1) LOOP
			val=api_map->keys[i];
			vals=regexp_split_to_array(val,sp);
			IF array_length(vals,1)=2 THEN
				name=vals[1];
				select put(dict_map,'topagent_id',keys[i]) into dict_map;
				select put(dict_map,'topagent_name',name) into dict_map;
				select put(dict_map,'op','I') into dict_map;

				--准备station_bill.
				amount=0.00;
				select gamebox_station_bill(dict_map) INTO bill_id;
				--API盈亏
				--vals[2].值格式:api^game^val^retio^loss^&^api^game^val^retio^loss
				vals=regexp_split_to_array(vals[2],rs_a);
				IF array_length(vals, 1)>0 THEN
					FOR k IN 1..array_length(vals, 1) LOOP
						--vals[k].值格式:api^game^val^retio^loss
						sval=regexp_split_to_array(vals[k],cs_a);
						IF array_length(sval, 1)>=4 THEN
							map=null;
							select put(map,'api_id',sval[1]) into map;--API
							select put(map,'game_type',sval[2]) into map;--API二级分类
							select put(map,'amount_payable',sval[3]) into map;--应付金额
							select put(map,'occupy_proportion',sval[4]) into map;--占成比例
							select put(map,'profit_loss',sval[5]) into map;--盈亏总和
							select put(map,'bill_id',bill_id::TEXT) into map;
							amount=amount+COALESCE(sval[3]::FLOAT,0.00);
							perform gamebox_station_profit_loss(map);
							--raise info 'New profit_loss';
						END IF;
					END LOOP;
				END IF;
				--其它费用.
				expense=0.00;
				IF exist(expense_map,keys[i]) THEN
					h_keys=array_append(h_keys, keys[i]);
					val=expense_map->keys[i];
					val=replace(val,rs,',');
					val=replace(val,cs,'=>');
					select val INTO cost_map;
					--raise info 'cost_map=%',cost_map;
					select gamebox_station_bill_other(cost_map,sys_map,bill_id) INTO expense;
				END IF;
				--更新账务.
				amount=amount-expense;
				select put(dict_map,'bill_id',bill_id::TEXT) into dict_map;
				select put(dict_map,'op','U') into dict_map;
				select put(dict_map,'amount',amount::TEXT) into dict_map;
				select gamebox_station_bill(dict_map) INTO bill_id;
			END IF;
		END LOOP;
	END IF;

	--处理特殊其它费用
	keys=akeys(expense_map);

	IF array_length(keys, 1)>0 THEN
		FOR i IN 1..array_length(keys, 1)
		LOOP
			IF h_keys@>array[keys[i]]=false THEN--判断是否已经记账
					val=expense_map->keys[i];
					val=replace(val,rs,',');
					val=replace(val,cs,'=>');
					select val INTO cost_map;

					--准备station_bill.
					name=cost_map->'user_name';
					select put(dict_map,'topagent_id',keys[i]) INTO dict_map;
					select put(dict_map,'topagent_name',name) INTO dict_map;
					select put(dict_map,'op','I') INTO dict_map;

					select gamebox_station_bill(dict_map) INTO bill_id;
					--其它费用
					select gamebox_station_bill_other(cost_map,sys_map,bill_id) INTO expense;

					--更新账务.
					select put(dict_map,'bill_id',bill_id::TEXT) INTO dict_map;
					select put(dict_map,'op','U') INTO dict_map;
					select put(dict_map,'amount',(-expense)::TEXT) into dict_map;
					select gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0023__C_gamebox_station_bill.sql
"create or replace function gamebox_station_bill_top(
sys_map hstore
,dict_map hstore
,url_name TEXT
,main_url TEXT
,start_time TEXT
,end_time TEXT
)
returns TEXT as $$
DECLARE
	maps hstore[];
	api_map hstore;
	expense_map hstore;
	cost_map hstore;


	api_id INT;
	game_type TEXT;
	profit_loss FLOAT;
	occupy_proportion FLOAT;
	amount_payable FLOAT;

	bill_id INT;

	id INT;
	name TEXT;
	val TEXT;
	vals TEXT[];
	sval TEXT[];
	keys TEXT[];

	map hstore;
	expense_category TEXT[]:=array['backwater','refund_fee','favorable','rebate'];
	category TEXT:='';
	value FLOAT;
	h_keys TEXT[]:=array['-1'];--记录已存在ID.
	amount FLOAT:=0.00;--应付总额
	expense FLOAT:=0.00;--分摊费用.

	sys_config hstore;
	sp TEXT:='@';
	rs TEXT:='\~';
	cs TEXT:='\^';
	rs_a TEXT:='';
	cs_a TEXT:='';
	sp_a TEXT:='';
BEGIN
	--取得系统变量
	select sys_config() INTO sys_config;
	sp=sys_config->'sp_split';
	rs=sys_config->'row_split';
	cs=sys_config->'col_split';
	sp_a=sys_config->'sp_split_a';
	rs_a=sys_config->'row_split_a';
	cs_a=sys_config->'col_split_a';
	rs_a='\^&\^';
	cs_a='\^';

	raise info 'sp:%,rs:%,cs:%,sp_a:%,rs_a:%,cs_a:%',sp,rs,cs,sp_a,rs_a,cs_a;
	select * from dblink(url_name
	,'select * from gamebox_occupy_map('''||main_url||''','''||start_time||''','''||end_time||''')'
	) as p(h hstore[]) INTO maps;
	IF array_length(maps, 1)<2 THEN
		RETURN '1.站点库返回总代信息有误';
	END IF;
	api_map=maps[1];
	expense_map=maps[2];
	--raise info '%',api_map;
	--raise info '%',expense_map;
	--格式：id=>name@api^game^val^retio^loss^&^api^game^val^retio^loss
	keys=akeys(api_map);
	IF array_length(keys,1)>0 THEN
		FOR i IN 1..array_length(keys,1) LOOP
			val=api_map->keys[i];
			vals=regexp_split_to_array(val,sp);
			IF array_length(vals,1)=2 THEN
				name=vals[1];
				select put(dict_map,'topagent_id',keys[i]) into dict_map;
				select put(dict_map,'topagent_name',name) into dict_map;
				select put(dict_map,'op','I') into dict_map;

				--准备station_bill.
				amount=0.00;
				select gamebox_station_bill(dict_map) INTO bill_id;
				--API盈亏
				--vals[2].值格式:api^game^val^retio^loss^&^api^game^val^retio^loss
				vals=regexp_split_to_array(vals[2],rs_a);
				IF array_length(vals, 1)>0 THEN
					FOR k IN 1..array_length(vals, 1) LOOP
						--vals[k].值格式:api^game^val^retio^loss
						sval=regexp_split_to_array(vals[k],cs_a);
						IF array_length(sval, 1)>=4 THEN
							map=null;
							select put(map,'api_id',sval[1]) into map;--API
							select put(map,'game_type',sval[2]) into map;--API二级分类
							select put(map,'amount_payable',sval[3]) into map;--应付金额
							select put(map,'occupy_proportion',sval[4]) into map;--占成比例
							select put(map,'profit_loss',sval[5]) into map;--盈亏总和
							select put(map,'bill_id',bill_id::TEXT) into map;
							amount=amount+COALESCE(sval[3]::FLOAT,0.00);
							perform gamebox_station_profit_loss(map);
							--raise info 'New profit_loss';
						END IF;
					END LOOP;
				END IF;
				--其它费用.
				expense=0.00;
				IF exist(expense_map,keys[i]) THEN
					h_keys=array_append(h_keys, keys[i]);
					val=expense_map->keys[i];
					val=replace(val,rs,',');
					val=replace(val,cs,'=>');
					select val INTO cost_map;
					--raise info 'cost_map=%',cost_map;
					select gamebox_station_bill_other(cost_map,sys_map,bill_id) INTO expense;
				END IF;
				--更新账务.
				amount=amount-expense;
				select put(dict_map,'bill_id',bill_id::TEXT) into dict_map;
				select put(dict_map,'op','U') into dict_map;
				select put(dict_map,'amount',amount::TEXT) into dict_map;
				select gamebox_station_bill(dict_map) INTO bill_id;
			END IF;
		END LOOP;
	END IF;

	--处理特殊其它费用
	keys=akeys(expense_map);

	IF array_length(keys, 1)>0 THEN
		FOR i IN 1..array_length(keys, 1)
		LOOP
			IF h_keys@>array[keys[i]]=false THEN--判断是否已经记账
					val=expense_map->keys[i];
					val=replace(val,rs,',');
					val=replace(val,cs,'=>');
					select val INTO cost_map;

					--准备station_bill.
					name=cost_map->'user_name';
					select put(dict_map,'topagent_id',keys[i]) INTO dict_map;
					select put(dict_map,'topagent_name',name) INTO dict_map;
					select put(dict_map,'op','I') INTO dict_map;

					select gamebox_station_bill(dict_map) INTO bill_id;
					--其它费用
					select gamebox_station_bill_other(cost_map,sys_map,bill_id) INTO expense;

					--更新账务.
					select put(dict_map,'bill_id',bill_id::TEXT) INTO dict_map;
					select put(dict_map,'op','U') INTO dict_map;
					select put(dict_map,'amount',(-expense)::TEXT) into dict_map;
					select gamebox_station_bill(dict_map) INTO bill_id;

			END IF;
		END LOOP;
	END IF;
	RETURN '0';
END
$$ language plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_station_no_bill(
site_id INT
,bill_year INT
,bill_month INT
,bill_type TEXT
) returns FLOAT as $$
DECLARE
	amount FLOAT:=0.00;
BEGIN
	EXECUTE 'SELECT amount_actual FROM station_bill
					WHERE site_id=$1
					AND bill_year=$2
					AND bill_month=$3
					AND bill_type=$4
					AND amount_actual<0 '
	USING site_id,bill_year,bill_month,bill_type
	INTO amount;
	IF amount is null THEN
		amount=0.00;
	END IF;
	RETURN amount;
END;
$$ LANGUAGE plpgsql;",V1.0.1.0030__E_gamebox_station_bill.sql
"create or replace function gamebox_sys_param(paramType text) returns hstore as $$
DECLARE
	param text:='';
	hash hstore;
	rec record;
	sid INT;
BEGIN
	for rec in select param_code,param_value from sys_param where param_type=$1 loop
		param=param||rec.param_code||'=>'||rec.param_value||',';
	end loop;
	--raise notice '结果:%',param;
	if length(param)>0 THEN
		param=substring(param,1,length(param)-1);
	end IF;
	select param::hstore into hash;
  --raise info '取得优惠值比例:%',hash->'topagent.rakeback.percent';
	select gamebox_current_site() INTO sid;
	hash=hash||(select ('site_id=>'||sid)::hstore);
	return hash;
END;
$$ language plpgsql;",V1.0.1.0260__E_gamebox_rebate.sql
"create or replace function gamebox_sys_param(paramType text) returns hstore as $$
DECLARE
	param text:='';
	hash hstore;
	rec record;
BEGIN
	for rec in select param_code,param_value from sys_param where param_type=$1 loop
		param=param||rec.param_code||'=>'||rec.param_value||',';
	end loop;
	--raise notice '结果:%',param;
	if length(param)>0 THEN
		param=substring(param,1,length(param)-1);
	end IF;
	select param::hstore into hash;
  --raise info '取得优惠值比例:%',hash->'topagent.rakeback.percent';
	return hash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function gamebox_valid_player_num(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	valid_value FLOAT
) returns INT as $$

DECLARE
	player_num 	INT:=0;

BEGIN
	SELECT COUNT(1)
	  FROM (SELECT pgo.player_id, SUM(pgo.effective_trade_amount) effeTa
		  	  FROM player_game_order pgo
		 	 WHERE pgo.create_time >= start_time
		 	   AND pgo.create_time < end_time
		 	   AND pgo.order_state = 'settle'
			   AND pgo.is_profit_loss = TRUE
		 	 GROUP BY pgo.player_id) pn
	 WHERE pn.effeTa >= valid_value INTO player_num;
	RETURN player_num;
END;

$$ language plpgsql;",V1.0.1.0117__C_gamebox_effective_volume.sql
"create or replace function gamebox_valid_player_num(
	start_time 	TIMESTAMP,
	end_time 	TIMESTAMP,
	valid_value FLOAT
) returns INT as $$

DECLARE
	player_num 	INT:=0;

BEGIN
	SELECT COUNT(1)
	  FROM (SELECT pgo.player_id, SUM(pgo.effective_trade_amount) effeTa
		  	  FROM player_game_order pgo
		 	 WHERE pgo.create_time >= start_time
		 	   AND pgo.create_time <= end_time
		 	   AND pgo.order_state = 'settle'
			   AND pgo.is_profit_loss = TRUE
		 	 GROUP BY pgo.player_id) pn
	 WHERE pn.effeTa >= valid_value INTO player_num;
	RETURN player_num;
END;

$$ language plpgsql;",V1.0.1.0123__C_gamebox_rebate_agent_check.sql
"create or replace function gen_address(int) returns text as $$  
declare  
  res text;  
begin  
  if $1 >=1 then  
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);  
    return res;  
  end if;  
  return null;  
end;  
$$ language plpgsql strict;",citus%E6%B5%8B%E8%AF%95%E8%AE%B0%E5%BD%95.md
"create or replace function gen_hanzi(int) returns text as $$    
declare    
  res text;    
begin    
  if $1 &gt;=1 then    
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);    
    return res;    
  end if;    
  return null;    
end;    
$$ language plpgsql strict;",index.html
"create or replace function gen_hanzi(int) returns text as $$    
declare    
  res text;    
begin    
  if $1 >=1 then    
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);    
    return res;    
  end if;    
  return null;    
end;    
$$ language plpgsql strict;",20180202_01.md
"create or replace function gen_hanzi(int) returns text as $$      
declare      
  res text;      
begin      
  if $1 &gt;=1 then      
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);      
    return res;      
  end if;      
  return null;      
end;      
$$ language plpgsql strict;",index.html
"create or replace function gen_hanzi(int) returns text as $$      
declare      
  res text;      
begin      
  if $1 >=1 then      
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);      
    return res;      
  end if;      
  return null;      
end;      
$$ language plpgsql strict;",20180202_01.md
"create or replace function gen_hanzi(int) returns text as $$      
declare      
  res text;      
begin      
  if $1 >=1 then      
    select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1);      
    return res;      
  end if;      
  return null;      
end;      
$$ language plpgsql strict;",20180205_03.md
"create or replace function gen_hanzi(int) returns text as $$ declare res text; begin if $1 &gt;=1 then select string_agg(chr(19968+(random()*20901)::int), '') into res from generate_series(1,$1); return res; end if; return null; end; $$ language plpgsql strict;",index.html
"create or replace function gen_tids(blkid int) returns tid[] as $$  
declare
  res tid[] := '{}'::tid[];  
begin
  for x in blkid..(blkid+199) loop  
    select array_cat(res, array(  
      SELECT ('('||x||',' || s.i || ')')::tid  
      FROM generate_series(0, 50) AS s(i)  
    )
    ) into res;  
  end loop;  
return res;  
end;
$$ language plpgsql strict immutable;",20170522_01.md
"create or replace function gen_tids(blkid int) returns tid[] as $$  
declare
  res tid[] := '{}'::tid[];  
begin
  for x in blkid..(blkid+199) loop  
    select array_cat(res, array(  
      SELECT ('('||x||',' || s.i || ')')::tid  
      FROM generate_series(0, 50) AS s(i)  
    )
    ) into res;  
  end loop;  
return res;  
end;
$$ language plpgsql strict immutable;",index.html
"create or replace function generate_c_last(num integer) returns text as $$
declare
	arr		text[]	= array['BAR', 'OUGHT', 'ABLE', 'PRI', 'PRES', 'ESE', 'ANTI', 'CALLY', 'ATION', 'EING'];
	first	integer = num / 100;
	second	integer = (num % 100) / 10;
	third	integer = num % 10;
begin
	/* The Postgres arrays are 1-based, so increment all offsets by 1 */
	return arr[first+1] || arr[second+1] || arr[third+1];
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function generate_node_array(s_node_list bigint[], e_node_list bigint[])
returns bigint[]
language plpgsql
as
$$
declare
    resultArray bigint[];
begin
    for i in 1..array_upper(s_node_list, 1)-1 loop
        resultArray := resultArray || get_connected_node(s_node_list[i], e_node_list[i], s_node_list[i+1], e_node_list[i+1]);
    end loop;
    return resultArray;
end;
$$;",LanePushLink.py
"create or replace function generate_uid()
  returns text as
$$
declare
  chars  text [] := '{0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z}';
  result text := chars [11 + random() * (array_length(chars, 1) - 11)];
begin
  for i in 1..10 loop
    result := result || chars [1 + random() * (array_length(chars, 1) - 1)];
  end loop;
  return result;	
end;
$$
language plpgsql;",BazarCommands.txt
"create or replace function getCodAlmacen(nroNota integer)returns integer as $$
begin
	return (select cod_Almacen
		    from nota
		    where nro_nota=nroNota);
end; 
$$ language plpgsql;",script.sql
"create or replace function getCodInsumo(nombreInsumo varchar(35)) returns integer as $$ begin
	return (select cod_insumo
			from insumo
			where nombre=nombreInsumo);
end; $$ 
language plpgsql;",script.sql
"create or replace function getFechaNota(nroNota INTEGER)returns date as 
$$
begin
	return (select fecha
		   	from nota
		   	where nro_nota=nroNota);
end;
$$ language plpgsql;",script.sql
"create or replace function getPrecioTotalUnaNota(cod_nota integer) returns decimal(12,2) as $$
begin
	return (select coalesce(cast(sum(cantidad*precio_unitario))as decimal(12,2),0)
			from Detalle_Ingreso
			where cod_nota=nro_ingreso
			);
end;
$$
language plpgsql;",script.sql
"create or replace function getStockInsumo(nombreInsumo varchar(35), codAlmacen integer)returns int as $$
begin
	return (select insumo_almacen.stock
			from insumo,insumo_almacen
			where insumo.cod_insumo=insumo_almacen.cod_insumo and nombre=nombreInsumo and cod_almacen=codAlmacen);	
end; $$ 
language plpgsql;",script.sql
"create or replace function getTipoNota(nroNota integer)returns text as 
$$ begin
	return (select tipo
		 from nota 
		 where nro_nota=nroNota);
end; $$ 
language plpgsql;",script.sql
"create or replace function get_arqueo_caja(
       in id_caja int)
returns int as $$
declare
	id_inicio int;
	id_termino int;
	last_caja int;
	arqueo bigint;
	mixto_efectivo bigint;
	egresos bigint;
	ingresos bigint;
	monto_apertura bigint;
	q varchar;
	l record;
        open_date timestamp without time zone;
	close_date timestamp without time zone;
	close_date_back timestamp without time zone;
	cash_payed_money bigint;
	monto1 bigint;
	monto2 bigint;
begin

if id_caja = -1 then
    select last_value into last_caja from caja_id_seq;
else
    last_caja := id_caja;
end if;

select inicio into monto_apertura
       from caja where id = last_caja;

if monto_apertura is null then
   monto_apertura := 0;
end if;

select id_venta_inicio, id_venta_termino into id_inicio, id_termino
       from caja where id = last_caja;


if id_termino is null then
   select last_value into id_termino from venta_id_seq;
end if;

-- --
-- NOTA: *id_inicio = id_termino (caja anterior).
--       *id_inicio = 1 en la primera caja
--       *La clausula 'where id > id_inicio' no puede
--        ser '>=' debido al punto 1.
-- --
if id_inicio = 1 then
 id_inicio := 0; -- En este caso, se deja en 0 para que tome del id 1 en adelante
end if;

-- Venta efectivo
select sum(monto) into arqueo
from venta
where id > id_inicio and id <= id_termino
  and tipo_documento = 0
  and tipo_venta = 0;

--Venta Mixta parte efectivo
select sum (pm.monto2) into mixto_efectivo
  from pago_mixto pm 
  where pm.tipo_pago2 = 0 --Efectivo
  and pm.id_sale > id_inicio and pm.id_sale <= id_termino;

--Si no existe ninguna parte efectivo de venta mixta
if mixto_efectivo is null then
   mixto_efectivo := 0;
end if;

if arqueo is null then
   arqueo := 0;
else
   arqueo := arqueo + mixto_efectivo;
end if;

egresos := 0;
q := $S$ select monto from egreso where id_caja = $S$ || last_caja;
for l in execute q loop
    egresos := egresos + l.monto;
end loop;

ingresos := 0;

q := $S$ select monto from ingreso where id_caja = $S$ || last_caja;

for l in execute q loop
    ingresos := ingresos + l.monto;
end loop;

select fecha_inicio into open_date
       from caja where id=last_caja;

close_date := now();

select fecha_termino into close_date_back
       from caja where id = last_caja - 1;

select sum (monto_abonado) into monto1
       from abono where fecha_abono > open_date and fecha_abono < close_date;

if monto1 is null then
   monto1 := 0;
end if;

select sum (monto_abonado) into monto2
       from abono where fecha_abono > close_date_back and  fecha_abono < open_date;

if monto2 is null then
   monto2 := 0;
end if;

cash_payed_money := monto1 + monto2;

return (monto_apertura + arqueo + cash_payed_money + ingresos - egresos);
end; $$ language plpgsql;",funciones.sql
"create or replace function get_catalog(v_sql text) returns int8 as $$  
declare  
  res int8;  
begin  
  execute v_sql into res;  
  return res;  
end;  
$$ language plpgsql strict;",20180624_02.md
"create or replace function get_cnt() returns setof record as $$  
declare  
begin  
  for i in 0..127 loop         
    perform conn('link'||i,  'hostaddr=127.0.0.1 port=9999 user=postgres dbname=postgres');         
    perform 1 from dblink_get_result('link'||i) as t(c1 int, cnt int8);        
    perform dblink_send_query('link'||i, format('select t1.c1,count(*) from a%s t1 join a%s t2 using (id) group by t1.c1', i, i));        
  end loop;     
  for i in 0..127 loop  
    return query select * from dblink_get_result('link'||i) as t(c1 int, cnt int8);  
  end loop;  
end;  
$$ language plpgsql strict;",20180201_02.md
"create or replace function get_compras (
		OUT id_compra integer,
		OUT nombre varchar(100),
		OUT precio double precision,
		OUT dia integer,
		OUT mes integer,
		OUT ano integer)
returns setof record as $$
declare
		list record;
		query text;
begin
		query := $S$ select compra.id,
		      proveedor.nombre,
		      SUM((compra_detalle.cantidad - compra_detalle.cantidad_ingresada) * compra_detalle.precio) as monto,
		      date_part('day', compra.fecha) as dia,
		      date_part ('month', compra.fecha) as mes,
		      date_part('year', compra.fecha) as ano

		      FROM compra
		      	   inner join proveedor on compra.rut_proveedor = proveedor.rut
			   inner join compra_detalle on compra.id = compra_detalle.id_compra

		      WHERE compra_detalle.cantidad_ingresada<compra_detalle.cantidad
		      	    and compra.anulada='f'
			    and compra.anulada_pi='f'
			    and compra_detalle.anulado='f'

		      GROUP BY compra.id, proveedor.nombre, compra.fecha
		      ORDER BY fecha DESC $S$;

	FOR list IN EXECUTE query LOOP
	id_compra := list.id;
	nombre := list.nombre;
	precio := list.monto;
	dia := list.dia;
	mes := list.mes;
	ano := list.ano;
	RETURN NEXT;
	END LOOP;

end; $$ language plpgsql;",funciones.sql
"create or replace function get_connected_node(s_node1 bigint, e_node1 bigint, s_node2 bigint, e_node2 bigint)
returns bigint
language plpgsql
as
$$
begin
    if s_node1=s_node2 or s_node1=e_node2 then
        return s_node1;
    elseif e_node1=s_node2 or e_node1=e_node2 then
        return e_node1;
    else
        return -1;
    end if;
end;
$$;",LanePushLink.py
"create or replace function get_detalle_compra (IN id_compra integer,
		                               OUT codigo_corto varchar(16),
					       OUT descripcion varchar(50),
					       OUT marca varchar(35),
					       OUT contenido varchar(10),
					       OUT unidad varchar(10),
					       OUT precio double precision,
					       OUT cantidad double precision,
					       OUT cantidad_ingresada double precision,
					       OUT costo_ingresado bigint,
					       OUT barcode bigint,
					       OUT precio_venta double precision,
					       OUT margen double precision)
RETURNS setof record AS $$
DECLARE
	list record;
	query text;
BEGIN
	query := $S$ SELECT t2.barcode, t2.codigo_corto, t2.descripcion, t2.marca, t2.contenido, t2.unidad,
	                    t1.precio, t1.cantidad, t1.cantidad_ingresada, t1.precio_venta, t1.margen,
			    (t1.precio * (t1.cantidad - t1.cantidad_ingresada))::bigint AS costo_ingresado
		     FROM compra_detalle AS t1,
		          producto AS t2
		     WHERE t1.id_compra = $S$||id_compra||$S$
		     AND t2.barcode = t1.barcode_product
		     AND t1.cantidad_ingresada < t1.cantidad
		     AND t1.anulado ='f' $S$;

	FOR list IN EXECUTE query LOOP
	    codigo_corto := list.codigo_corto;
	    descripcion := list.descripcion;
	    marca := list.marca;
	    contenido := list.contenido;
	    unidad := list.unidad;
	    precio := list.precio;
	    cantidad := list.cantidad;
	    cantidad_ingresada := list.cantidad_ingresada;
	    costo_ingresado := list.costo_ingresado;
	    barcode := list.barcode;
	    precio_venta := list.precio_venta;
	    margen := list.margen;
	    RETURN NEXT;
	END LOOP;

END; $$ LANGUAGE plpgsql;",funciones.sql
"create or replace function get_dict (    
  int8[],   -- 维度值    
  int       -- 返回多少行    
) returns setof tbl_lab as $$    
declare    
  r_cnt int := 0;    
  v_tmp int := 0;    
begin    
  for i in 1..100 loop    
    return query select * from tbl_lab where dict @> $1 and score >(100-i) and score<=(101-i)    
      order by score desc limit $2;     
    GET DIAGNOSTICS v_tmp = ROW_COUNT;    
    r_cnt := r_cnt + v_tmp ;    
    if r_cnt >= $2 then    
      return;    
    end if;    
  end loop;    
  return;    
end;    
$$ language plpgsql strict;",20180424_04.md
"create or replace function get_distinct_value(  
  name,   -- schema  
  name,   -- table  
  name    -- column  
) returns text as $$  
declare  
  v int;  
  res text;  
begin  
  select   
    case attstattarget   
      when -1 then current_setting('default_statistics_target')::int   -- 默认bucket  
      else attstattarget   -- 自定义bucket  
    end into v   
  from pg_attribute where attrelid=($1||'.'||$2)::regclass and attname=$3 ;  
    
  select (most_common_vals)::text into res -- 高频词  
    from pg_stats where not inherited and schemaname = $1 and tablename = $2 and attname = $3 and n_distinct >=1 and n_distinct <= v;  
  return res;  
end;  
$$ language plpgsql strict;",20180822_04.md
"create or replace function get_except1()   
  returns setof refcursor as $$       
declare   
  ref refcursor[];    
  res refcursor;  
begin      
for i in 0..47 loop       
  ref[i] := 'cur'||i;  
  res := ref[i];  
  open res for execute format('select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s except select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s', i, i);    
  return next res;  
end loop;      
  return;    
end;      
$$ language plpgsql strict;",20180201_02.md
"create or replace function get_fifo(in barcode_in int8)
returns double precision as $$
declare
	resultado double precision;
begin

resultado := (select costo_promedio from producto where barcode=barcode_in);
return resultado;

end; $$ language plpgsql;",funciones.sql
"create or replace function get_guide_detail(
		IN id_guia integer,
                IN rut_proveedor integer,
		OUT codigo_corto integer,
		OUT descripcion varchar(50),
		OUT marca varchar(35),
		OUT contenido varchar(10),
		OUT unidad varchar(10),
		OUT precio double precision,
		OUT cantidad double precision,
		OUT precio_compra bigint,
		OUT barcode bigint)
returns setof record as $$
declare
        list record;
        query text;
begin
        query := $S$ SELECT t2.codigo_corto, t2.descripcion, t2.marca, t2.contenido, t2.unidad, t2.precio as precio_venta, t1.precio as precio_compra, t1.cantidad, t2.barcode FROM guias_compra_detalle AS t1, producto AS t2, guias_compra as t3 WHERE t1.barcode=t2.barcode and t1.id_guias_compra=t3.id and t3.numero=$S$|| id_guia ||$S$ and t3.rut_proveedor=$S$|| rut_proveedor;

		FOR list IN EXECUTE query LOOP
		codigo_corto := list.codigo_corto;
		descripcion := list.descripcion;
		marca := list.marca;
		contenido := list.contenido;
		unidad := list.unidad;
		precio := list.precio_venta;
		cantidad := list.cantidad;
		precio_compra := list.precio_compra;
		barcode := list.barcode;
		RETURN NEXT;
		END LOOP;
END; $$ LANGUAGE plpgsql;",funciones.sql
"create or replace function get_intersect(    
  conn text,         -- 连接串    
  OUT id int,    
  OUT c1 int    
) returns setof record as $$       
declare      
begin      
for i in 0..47 loop       
  perform conn('link'||i,  conn);       
  perform 1 from dblink_get_result('link'||i) as t(id int, c1 int);      
  perform dblink_send_query('link'||i, format('select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s intersect select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s', i, i));      
end loop;      
      
for i in 0..47 loop      
  return query SELECT * FROM dblink_get_result('link'||i) as t(id int, c1 int);      
end loop;      
end;      
$$ language plpgsql strict;",20180201_02.md
"create or replace function get_intersect1()   
  returns setof refcursor as $$       
declare   
  ref refcursor[];    
  res refcursor;  
begin      
for i in 0..47 loop       
  ref[i] := 'cur'||i;  
  res := ref[i];  
  open res for execute format('select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s intersect select * from tbl t1 where mod(abs(hashint4(id)), 48)=%s', i, i);    
  return next res;  
end loop;      
  return;    
end;      
$$ language plpgsql strict;",20180201_02.md
"create or replace function get_invoice_detail(
		IN id_invoice integer,
		OUT codigo_corto varchar(16),
		OUT descripcion varchar(50),
		OUT marca varchar(35),
		OUT contenido varchar(10),
		OUT unidad varchar(10),
		OUT precio double precision,
		OUT cantidad double precision,
		OUT precio_compra double precision,
		OUT barcode bigint)
RETURNS SETOF record AS $$
DECLARE
        list record;
        query text;
BEGIN
        query := $S$ SELECT t2.codigo_corto, t2.descripcion, t2.marca, t2.contenido, t2.unidad, t2.precio as precio_venta,
	      	     	    t1.precio as precio_compra, t1.cantidad, t2.barcode
		     FROM factura_compra_detalle AS t1, producto AS t2, factura_compra as t3
		     WHERE t1.barcode=t2.barcode and t1.id_factura_compra=t3.id and t3.id=$S$|| id_invoice;

	FOR list IN EXECUTE query LOOP
	    codigo_corto := list.codigo_corto;
	    descripcion := list.descripcion;
	    marca := list.marca;
	    contenido := list.contenido;
	    unidad := list.unidad;
	    precio := list.precio_venta;
	    cantidad := list.cantidad;
	    precio_compra := list.precio_compra;
	    barcode := list.barcode;
	    RETURN NEXT;
	END LOOP;
END; $$ LANGUAGE plpgsql;",funciones.sql
"create or replace function get_max(v_sql text) returns int as $$  
declare  
  res int;  
begin  
  execute v_sql into res;  
  return res;  
end;  
$$ language plpgsql strict;",20180624_02.md
"create or replace function get_max(v_sql text) returns int as $$  
declare  
  res int;  
begin  
  execute v_sql into res;  
  return res;  
end;  
$$ language plpgsql strict;",index.html
"create or replace function get_proveedor_compra(
		IN id_compra integer,
		OUT nombre_out varchar(100),
		OUT rut_out integer,
		OUT dv_out varchar(1))
RETURNS SETOF RECORD AS $$
DECLARE
   l record;
   q varchar;
BEGIN

   -- Se obtienen los datos del proveedor a quien de le compro
   q := $S$ SELECT rut, dv, nombre
      	    FROM proveedor
   	    WHERE rut = (SELECT rut_proveedor FROM compra WHERE id = $S$||id_compra||$S$)$S$;

   -- Se supone que siempre devolvera una fila...
   FOR l IN EXECUTE q LOOP
       nombre_out := l.nombre;
       rut_out := l.rut;
       dv_out := l.dv;
       RETURN NEXT;
   END LOOP;

RETURN;
END; $$ language plpgsql;",funciones.sql
"create or replace function get_res(
  text,     -- 要按相似搜的文本
  int8,     -- 限制返回多少条
  float4 default 0.3,   -- 相似度阈值，低于这个值不再搜搜
  float4 default 0.1    -- 相似度递减步长，直至阈值
) returns setof record as $$  
declare  
  lim float4 := 1;  
begin  
  -- 判定
  if not ($3 <= 1 and $3 > 0) then 
    raise notice '$3 must >0 and <=1';
    return;
  end if;
  
  if not ($4 > 0 and $4 < 1) then
    raise notice '$4 must >0 and <=1';
    return;
  end if;
  loop  
    -- 设置相似度阈值  
    perform set_limit(lim);  
      
    return query select similarity(info, $1) as sml, * from tbl where info % $1 order by sml desc limit $2;  

    -- 如果有，则退出loop  
    if found then  
      return;  
    end if;  
  
    -- 否则继续，降低阈值  
    -- 当阈值小于0.3时，不再降阈值搜索，认为没有相似。  
    if lim < $3 then  
      return;  
    else  
      lim := lim - $4;  
    end if;  
  end loop;  
end;  
$$ language plpgsql strict;",20180202_01.md
"create or replace function get_res(  
  int[],     -- 要按相似搜的数组  
  int,       -- 限制返回多少条  
  int,       -- 重叠度个数  
  text default 'overlap'  -- 相似度算法 cosine, overlap, tfidf   
) returns setof record as $$    
declare    
  lim int := array_length($1,1);    
  cnt int := 0;  
  tmp_cnt int8 :=0;  
begin    
  set smlar.type='overlap';  
  set enable_seqscan=off;  
  loop    
    -- 设置相似度阈值    
    perform set_smlar_limit(lim);    
        
    return query select smlar(arr,$1,'N.i') as overlap , * from t where arr % $1 limit $2;    
    -- 一次性查询： select set_smlar_limit($3); select smlar(arr,$1,'N.i') as overlap , * from t where arr % $1 order by overlap desc limit $2;   
      
    -- 如果有，则退出loop    
    if found then    
      GET DIAGNOSTICS tmp_cnt = ROW_COUNT;  
      cnt := cnt + tmp_cnt;  
      if cnt >= $2 then  
        return;    
      end if;  
    end if;    
    
    -- 否则继续，降低阈值    
    -- 当阈值小于$3时，不再降阈值搜索，认为没有相似。    
    if lim < $3 then    
      return;    
    else    
      lim := lim - 1;    
    end if;    
  end loop;    
end;    
$$ language plpgsql strict;",20180202_01.md
"create or replace function get_res(  
  text,     -- 要按相似搜的文本  
  int8,     -- 限制返回多少条  
  float4 default 0.3,   -- 相似度阈值，低于这个值不再搜搜  
  float4 default 0.1    -- 相似度递减步长，直至阈值  
) returns setof record as $$    
declare    
  lim float4 := 1;    
begin    
  -- 判定  
  if not ($3 <= 1 and $3 > 0) then   
    raise notice '$3 must >0 and <=1';  
    return;  
  end if;  
    
  if not ($4 > 0 and $4 < 1) then  
    raise notice '$4 must >0 and <=1';  
    return;  
  end if;  
  loop    
    -- 设置相似度阈值    
    perform set_limit(lim);    
        
    -- 查看当前阈值下，有没有相似记录    
    perform similarity(info, $1) as sml, * from tbl where info % $1 limit 1;    
        
    -- 如果有，则返回N条    
    if found then    
      return query select similarity(info, $1) as sml, * from tbl where info % $1 order by sml desc limit $2;    
      return;    
    end if;    
    
    -- 否则继续，降低阈值    
    -- 当阈值小于0.3时，不再降阈值搜索，认为没有相似。    
    if lim < $3 then    
      return;    
    else    
      lim := lim - $4;    
    end if;    
  end loop;    
end;    
$$ language plpgsql strict;",20180205_03.md
"create or replace function get_res(  
  text,     -- 要按相似搜的文本  
  int8,     -- 限制返回多少条  
  float4 default 0.3,   -- 相似度阈值，低于这个值不再搜搜  
  float4 default 0.1    -- 相似度递减步长，直至阈值  
) returns setof record as $$    
declare    
  lim float4 := 1;    
begin    
  -- 判定  
  if not ($3 <= 1 and $3 > 0) then   
    raise notice '$3 must >0 and <=1';  
    return;  
  end if;  
    
  if not ($4 > 0 and $4 < 1) then  
    raise notice '$4 must >0 and <=1';  
    return;  
  end if;  
  loop    
    -- 设置相似度阈值    
    perform set_limit(lim);    
        
    return query select similarity(info, $1) as sml, * from tbl where info % $1 order by sml desc limit $2;    
  
    -- 如果有，则退出loop    
    if found then    
      return;    
    end if;    
    
    -- 否则继续，降低阈值    
    -- 当阈值小于0.3时，不再降阈值搜索，认为没有相似。    
    if lim < $3 then    
      return;    
    else    
      lim := lim - $4;    
    end if;    
  end loop;    
end;    
$$ language plpgsql strict;",20180202_01.md
"create or replace function get_res() returns setof record as $$    
declare    
begin    
  for i in 0..55 loop           
    perform conn('link'||i,  'hostaddr=127.0.0.1 port=1921 user=postgres dbname=postgres');           
    perform 1 from dblink_get_result('link'||i) as t(c1 int, cnt int8, min int, max int, sum int8);          
    perform dblink_send_query('link'||i, format('select c1,count(*),min(id),max(id),sum(id) from a%s group by c1', i));          
  end loop;       
  for i in 0..55 loop    
    return query select * from dblink_get_result('link'||i) as t(c1 int, cnt int8, min int, max int, sum int8);    
  end loop;    
end;    
$$ language plpgsql strict;",20180210_01.md
"create or replace function get_res() returns setof record as $$      
declare      
begin      
  for i in 0..55 loop             
    perform conn('link'||i,  'hostaddr=127.0.0.1 port='||current_setting('port')||' user=postgres dbname=postgres');           
    perform 1 from dblink_get_result('link'||i) as t(res text);            
    perform dblink_send_query('link'||i, format('copy ut from %L', '/data01/pg/ut.csv'));            
  end loop;         
  for i in 0..55 loop      
    return query select * from dblink_get_result('link'||i) as t(res text);      
  end loop;      
end;      
$$ language plpgsql strict;",20180427_03.md
"create or replace function get_res() returns setof record as $$      
declare      
begin      
  for i in 0..55 loop             
    perform conn('link'||i,  'hostaddr=127.0.0.1 port='||current_setting('port')||' user=postgres dbname=postgres');             
    perform 1 from dblink_get_result('link'||i) as t(res text);            
    perform dblink_send_query('link'||i, format('copy ut%s from %L', i, '/data01/pg/ut.csv'));            
  end loop;         
  for i in 0..55 loop      
    return query select * from dblink_get_result('link'||i) as t(res text);      
  end loop;      
end;      
$$ language plpgsql strict;",20180427_03.md
"create or replace function get_res() returns setof tbl as $$  
declare  
  v_c1 int;  
begin  
  -- 初始递归条件  
  select c1 into v_c1 from tbl where c3=1 and c1<100 order by c1 limit 1;  
  
  -- 初始语句  
  return query select * from tbl where c3=1 and c1<100 and c1=v_c1 order by c1 limit 10;  
  
  loop  
    -- 递归条件  
    select c1 into v_c1 from tbl where c3=1 and c1<100 and c1>v_c1 order by c1 limit 1;  
    if not found then  
      return;  
    end if;  
  
    -- 返回加入递归条件后的结果  
    return query select * from tbl where c3=1 and c1<100 and c1=v_c1 order by c1 limit 10;  
  
  
  end loop;  
end;  
$$ language plpgsql strict;",20180406_01.md
"create or replace function get_res() returns setof tbl as $$  
declare  
  v_c1 int;  
begin  
  -- 初始递归条件  
  select c1 into v_c1 from tbl where c3=1 order by c1 limit 1;  
  
  -- 初始语句  
  return query select * from (select distinct on (c1,c2) * from tbl where c3=1 and c1=v_c1 order by c1,c2) t order by random() limit 10;  
  
  loop  
    -- 递归条件  
    select c1 into v_c1 from tbl where c3=1 and c1>v_c1 order by c1 limit 1;  
    if not found then  
      return;  
    end if;  
  
    -- 返回加入递归条件后的结果  
    return query select * from (select distinct on (c1,c2) * from tbl where c3=1 and c1=v_c1 order by c1,c2) t order by random() limit 10;  
  
  
  end loop;  
end;  
$$ language plpgsql strict;",20180406_01.md
"create or replace function get_res() returns setof tbl as $$  
declare  
  v_c1 int;  
begin  
  -- 初始递归条件  
  select c1 into v_c1 from tbl where c3=1 order by c1 limit 1;  
  
  -- 初始语句  
  return query select * from tbl where c3=1 and c1=v_c1 order by c1 limit 10;  
  
  loop  
    -- 递归条件  
    select c1 into v_c1 from tbl where c3=1 and c1>v_c1 order by c1 limit 1;  
    if not found then  
      return;  
    end if;  
  
    -- 返回加入递归条件后的结果  
    return query select * from tbl where c3=1 and c1=v_c1 order by c1 limit 10;  
  
  
  end loop;  
end;  
$$ language plpgsql strict;",20180406_01.md
"create or replace function get_res() returns setof tbl as $$  
declare  
  v_c1 int;  
begin  
  -- 初始递归条件  
  select c1 into v_c1 from tbl where c3=1 order by c1 limit 1;  
  
  -- 初始语句  
  return query select distinct on (c1,c2) * from tbl where c3=1 and c1=v_c1 order by c1,c2 limit 10;  
  
  loop  
    -- 递归条件  
    select c1 into v_c1 from tbl where c3=1 and c1>v_c1 order by c1 limit 1;  
    if not found then  
      return;  
    end if;  
  
    -- 返回加入递归条件后的结果  
    return query select distinct on (c1,c2) * from tbl where c3=1 and c1=v_c1 order by c1,c2 limit 10;  
  
  
  end loop;  
end;  
$$ language plpgsql strict;",20180406_01.md
"create or replace function get_res_cursor(  
  text,     -- 要按相似搜的文本  
  int8,     -- 限制返回多少条  
  float4 default 0.3,   -- 相似度阈值，低于这个值不再搜搜  
  float4 default 0.1    -- 相似度递减步长，直至阈值  
) returns setof refcursor as $$    
declare    
  i int := 1;  
  ref refcursor[];    
  res refcursor;   
  dbname name[] := array['db0', 'db1', 'db2', 'db3'];  -- 定义集群  
  db name;  
begin  
  foreach db in array dbname  
  loop   
    ref[i] := 'link'||i;  
    res := ref[i];  
    perform conn('link'||i,  db);         
    perform dblink_open('link'||i, 'link'||i, format('select * from get_res(%L, %s, %s, %s) as t(sml real, id int, info text)', $1, $2, $3, $4));    
    return next res;  
    i := i+1;  
  end loop;  
end;  
$$ language plpgsql strict;",20180205_03.md
"create or replace function get_res_record(  
  text,     -- 要按相似搜的文本  
  int8,     -- 限制返回多少条  
  float4 default 0.3,   -- 相似度阈值，低于这个值不再搜搜  
  float4 default 0.1    -- 相似度递减步长，直至阈值  
) returns setof record as $$    
declare    
  i int;  
  ref refcursor[];    
  res refcursor;   
  dbname name[] := array['db0', 'db1', 'db2', 'db3'];  -- 定义集群  
  db name;  
begin  
  i := 1;  
  foreach db in array dbname  
  loop   
    perform conn('link'||i,  db);     
    perform 1 from dblink_get_result('link'||i) as t(sml real, id int, info text);       
    perform dblink_send_query('link'||i, format('select * from get_res(%L, %s, %s, %s) as t(sml real, id int, info text)', $1, $2, $3, $4));    
    i := i+1;  
  end loop;  
  
  i := 1;  
  foreach db in array dbname  
  loop   
    return query SELECT * FROM dblink_get_result('link'||i) as t(sml real, id int, info text);     
    i := i+1;  
  end loop;  
end;  
$$ language plpgsql strict;",20180205_03.md
"create or replace function get_res_vops() returns setof record as $$    
declare    
begin    
  for i in 0..55 loop           
    perform conn('link'||i,  'hostaddr=127.0.0.1 port=1921 user=postgres dbname=postgres');           
    perform 1 from dblink_get_result('link'||i) as t(c1 int, cnt int8, aggs int8[]);          
    perform dblink_send_query('link'||i, format('select (reduce(map(c1, ''min,max,sum'', id,id,id))).* from b%s', i));          
  end loop;       
  for i in 0..55 loop    
    return query select * from dblink_get_result('link'||i) as t(c1 int, cnt int8, aggs int8[]);    
  end loop;    
end;    
$$ language plpgsql strict;",20180210_01.md
"create or replace function get_session_id() returns int8 as $$  
declare  
  res int8;  
begin  
  -- 新版本  
  create sequence IF NOT EXISTS pg_session_id_sequence_oracle_comp;  
  select currval('pg_session_id_sequence_oracle_comp') into res;  
  return res;  
  exception when sqlstate '55000' then  
    create sequence IF NOT EXISTS pg_session_id_sequence_oracle_comp;  
    select nextval('pg_session_id_sequence_oracle_comp') into res;  
    return res;  
end;  
$$ language plpgsql strict set client_min_messages to error;",20170922_01.md
"create or replace function get_session_id() returns int8 as $$  
declare  
  res int8;  
begin  
  -- 老版本  
  select currval('pg_session_id_sequence_oracle_comp') into res;  
  return res;  
  exception   
    when sqlstate '55000' then  
      select nextval('pg_session_id_sequence_oracle_comp') into res;  
      return res;  
    when sqlstate '42P01' then  
      create sequence pg_session_id_sequence_oracle_comp;  
      select nextval('pg_session_id_sequence_oracle_comp') into res;  
      return res;  
end;  
$$ language plpgsql strict set client_min_messages to error;",20170922_01.md
"create or replace function get_site_order(v_get_on date, v_train_id int, v_box_id int2, v_site_id int2) returns setof train_order as $$  
declare  
  tbl name := 'train_order_'||to_char(v_get_on,'yyyymmdd');  
begin  
  return query execute format('select * from %I where train_id=%L and box_id=%L and site_id=%L', tbl, v_train_id, v_box_id, v_site_id);  
end;  
$$ language plpgsql strict;",20170927_03.md
"create or replace function get_tbl(int) returns setof record as    
$$    
declare    
  str text;    
begin    
  perform set_limit(0.7);  
    
  -- 从第1位开始，取28位，然后插入4个随机中文，再从29位开始取28位。这个字符串作为相似查询的输入。相似度为0.75。  
  select substring(info,1,28)||gen_hanzi(4)||substring(info,29,28) into str from tbl where id=$1 limit 1;      
  
  return query execute format($_$select similarity(info, %L) as sml,   -- 计算输入词与存储字符串的相似度  
     * from tbl   
     where info %% %L             -- 相似度超过阈值  
     order by sml desc            -- 按相似度排序(倒排，越相似的排在越前面)  
     limit 10$_$,  str, str);      
end;    
$$ language plpgsql strict;",20180202_01.md
"create or replace function get_tbl(int) returns setof record as    
$$    
declare    
  str text;    
begin    
  perform set_limit(0.7);  
    
  -- 从第1位开始，取28位，然后插入4个随机中文，再从29位开始取28位。这个字符串作为相似查询的输入。相似度为0.75。  
  select substring(info,1,28)||gen_hanzi(4)||substring(info,29,28) into str from tbl where id=$1 limit 1;      
  
  return query execute format($_$select similarity(info, %L) as sml,   -- 计算输入词与存储字符串的相似度  
     * from tbl   
     where info %% %L             -- 相似度超过阈值  
     order by sml desc            -- 按相似度排序(倒排，越相似的排在越前面)  
     limit 10$_$,  str, str);      
end;    
$$ language plpgsql strict;",index.html
"create or replace function get_tbl(int) returns setof record as      
$$      
declare      
  str text;      
begin      
  perform set_limit(0.7);    
      
  -- 从第1位开始，取28位，然后插入4个随机中文，再从29位开始取28位。这个字符串作为相似查询的输入。相似度为0.75。    
  select substring(info,1,28)||gen_hanzi(4)||substring(info,29,28) into str from tbl where id=$1 limit 1;        
    
  return query execute format($_$select similarity(info, %L) as sml,   -- 计算输入词与存储字符串的相似度    
     * from tbl     
     where info %% %L             -- 相似度超过阈值    
     order by sml desc            -- 按相似度排序(倒排，越相似的排在越前面)    
     limit 10$_$,  str, str);        
end;      
$$ language plpgsql strict;",20180202_01.md
"create or replace function get_test1(timestamp, int) returns test as $$  
declare  
  v1 timestamp;  
  v2 text;  
  res text;  
begin  
  set enable_seqscan=off;  
  
  -- 从输入的C2的条件，得到最小的C2  
  -- 索引精确定位  
  select c2 into v1 from test where c2 >= $1 order by c2 limit 1;  
    
  -- 在最小的C2中，求最小的C1  
  -- 索引精确定位  
  select min(c1) into v2 from test where c2 = v1;  
  
  -- 大于最小的C1，排序返回  
  -- 索引offset定位  
  select t into res from test t where c1 >= v2 order by c1 limit 1 offset $2 ;  
  return res::test;  
end;  
$$ language plpgsql strict;",20180122_02.md
"create or replace function get_user_order(v_uid int8) returns setof train_order_u as $$  
declare  
  tbl name := 'train_order_u'||mod(v_uid,32);  
begin  
  return query execute format('select * from %I where uid=%L', tbl, v_uid);  
end;  
$$ language plpgsql strict;",20170927_03.md
"create or replace function get_v_ids(
i_uid int8,
i_ef int,
i_limit int, 
i_tbl_prefix text, 
i_suffix text, 
i_idx_ops text
) returns int8[] as $$
declare
  u_hll_w1 hll;
  u_hll_w2 hll;
  u_hll_w7 hll;
  v_vec text;
  res int8[];
  query text;
begin
  set local enable_seqscan=off;
  set local enable_bitmapscan=off;
  set local enable_indexscan=on;
  set local enable_indexonlyscan=on;
  select coalesce(w1,hll_empty()),coalesce(w2,hll_empty()),coalesce(w7,hll_empty()) 
    into u_hll_w1,u_hll_w2,u_hll_w7 from video_user_read where user_id=i_uid; 
  select rtrim(ltrim(vec::text,'{'),'}') into v_vec from u_like_tag where user_id = i_uid; 
  query := format($_$
select array_agg(v_id order by video_weight desc) from
(
  select v_id,video_weight from %I v 
    where %L::hll || hll_hash_bigint(v.v_id) <> %L::hll 
    or %L::hll || hll_hash_bigint(v.v_id) <> %L::hll 
    or %L::hll || hll_hash_bigint(v.v_id) <> %L::hll 
  order by vec %s (%L)::pase 
  limit %s
) t
$_$,
i_tbl_prefix||'_'||i_suffix, 
u_hll_w1,u_hll_w1,
u_hll_w2,u_hll_w2,
u_hll_w7,u_hll_w7,
i_idx_ops,
v_vec||':'||i_ef||':0',
i_limit
);
raise notice '%', query;
execute query into res;
return res;
end;
$$ language plpgsql strict;",20200424_01.md
"create or replace function get_vec(  
in i_id int,   
in i_pect int,  
out v_id int,  
out v_dist float4,  
out v_vec float4[]  
) returns setof record as $$  
declare  
v_vec float4[];  
v_pase text;  
begin  
  select vec into v_vec from t_vec_80 where id=i_id;  
  v_vec := gen_float4_arr(v_vec, i_pect);  
  v_pase := rtrim(ltrim(v_vec::text, '{'),'}')||':40:0';  
  -- raise notice '%', v_pase;  
  return query   
  select   
  id as v_id,   
  vec <?> v_pase::pase as v_dist,   
  vec as v_vec   
    from t_vec_80   
  order by vec <?> v_pase::pase limit 5;  
end;  
$$ language plpgsql strict;",20200227_01.md
"create or replace function gp_upsert_batch(nsp name, tbl name, keys text[], js jsonb[]) returns void as $$ declare icontent jsonb; begin foreach icontent in array js loop perform gp_upsert(nsp,tbl,keys,icontent); -- 调用单次请求的函数 end loop; return; end; $$ language plpgsql strict;",index.html
"create or replace function hay_devolucion(int8)
returns setof record as $$
declare
	prod ALIAS FOR $1;
	query varchar(255);
	list record;
begin
query := 'SELECT id FROM devolucion WHERE barcode_product='
	|| quote_literal(prod)
	|| ' AND devuelto=FALSE';

FOR list IN EXECUTE query LOOP
	RETURN NEXT list;
END LOOP;

RETURN;

END;
$$ LANGUAGE plpgsql;",funciones.sql
"create or replace function im_conf_item__name (integer) 
returns varchar as $$
DECLARE
	v_conf_item_id	alias for $1;
	v_name		varchar;
BEGIN
	select	conf_item_name
	into	v_name
	from	im_conf_items
	where	conf_item_id = v_conf_item_id;

	return v_name;
end;$$ language 'plpgsql';",intranet-confdb-create.sql
"create or replace function im_conf_item_name_from_id (integer)
returns varchar as $$
DECLARE
	p_conf_item_id		alias for $1;
	v_conf_item_name	text;
BEGIN
	select conf_item_name
	into v_conf_item_name
	from im_conf_items
	where conf_item_id = p_conf_item_id;

	return v_conf_item_name;
end;$$ language 'plpgsql';",intranet-confdb-create.sql
"create or replace function im_conf_item_nr_from_id (integer)
returns varchar as $$
DECLARE
	p_conf_item_id	alias for $1;
	v_name		text;
BEGIN
	select conf_item_nr
	into v_name
	from im_conf_items
	where conf_item_id = p_conf_item_id;

	return v_name;
end;$$ language 'plpgsql';",intranet-confdb-create.sql
"create or replace function imt_compute_xy(id integer, num text, aoff double precision, OUT x double precision, OUT y double precision) as
$body$
declare
  rec record;
  pnt geometry;
  d1 double precision;
  d2 double precision;
  our_side integer;
  geom geometry;
  pos double precision;
  p1 geometry;
  p2 geometry;
  dx double precision;
  dy double precision;
  px double precision;
  py double precision;
  ux double precision;
  uy double precision;
  len double precision;
  
begin

  -- num is null for intersections and we get intersection locations from another table
  if num is null or num='0' then
    x := NULL;
    y := NULL;
    return;
  end if;
  
  -- side: 1=R, 2=L
  select refaddr, nrefaddr, side, st_geometryn(the_geom,1) as the_geom into rec from streets where gid=id;
  if found then
    if rec.refaddr<rec.nrefaddr then
      d2 := to_number(num,'999999999') - rec.refaddr;
      d1 := rec.nrefaddr - rec.refaddr;
    else
      d2 := rec.refaddr - to_number(num,'999999999');
      d1 := rec.refaddr - rec.nrefaddr;
    end if;
    if d1 = 0.0 then -- check and avoid divide by zero
      pos := 0.5;    -- the start and end are the same, then pick the midpoint of the segment. 
    else
      pos := d2/d1;
    end if;

--raise notice 'num: %, ref: %, nref: %, d2: %, d1: %, pos: %',num, rec.refaddr, rec.nrefaddr, d2, d1, pos;

    /* compute the offset from the center line if requested. aoff=0.0 is the trivial case */
    if aoff = 0.0 then 
        pnt := ST_LineInterpolatePoint(rec.the_geom, pos);
        x := st_x(pnt);
        y := st_y(pnt);
    else
        /* compute the offset to the right or left for this address
           * if the parity does not match then we should probably reverse the R/L side of the offset
           * if the location it at the end of the line, ie: pos=1.0, then we reverse the line and the sides to compute the offset
           * algorithm is:
           *   trim the line to start at pos
           *   get the unit vector from pnt1 to pos2
           *   use vector algebra to compute the offset
        */
        our_side := rec.side;
        geom := rec.the_geom;
        if pos = 1.0 then
	    geom := st_reverse(geom);                              -- reverse the line
	    our_side := case when rec.side = 1 then 2 else 1 end;  -- reverse the side
	    pos := 0.0;                                            -- reverse the ends
	end if;
	geom := ST_LineSubstring(geom, pos, 1.0);  -- trim the line so pos is the start now
	p1 := st_pointn(geom, 1);
	p2 := st_pointn(geom, 2);
	dx := st_x(p2) - st_x(p1);
	dy := st_y(p2) - st_y(p1);
	len := sqrt(dx*dx + dy*dy);     -- this could be zero if coincident points
	if len = 0.0 then
	    x := NULL;
	    y := NULL;
	    return;
	end if;
	ux := dx/len;  -- unit x
	uy := dy/len;  -- unit y
	if our_side = 1 then            -- right side
	    px := uy * aoff / 111120.0;
	    py := -ux * aoff / 111120.0;
	else                            -- left side
	    px := -uy * aoff / 111120.0;
	    py := ux * aoff / 111120.0;
	end if;
	x := st_x(p1) + px;
	y := st_y(p1) + py;
    end if;
  else
    x := NULL;
    y := NULL;
  end if;
end;
$body$
  language plpgsql immutable;",prep-tiger-geo-new.sql
"create or replace function imt_geo_planner(inp stdaddr)
  returns setof text as
$body$
declare
  sql text;
  i integer;
  rec record;
  
begin
  <<planner>>
  for i in 0..8 loop 
    sql := 'select a.*, '||i::text||' as plan from stdstreets a, streets b where a.id=b.gid ' || imt_geo_add_where_clauses(inp, i);
    return next sql;
    /*
    for rec in execute sql loop
      -- do something
    end loop;
    */
  end loop planner;
  return;
end;
$body$
  language plpgsql immutable
  cost 1
  rows 10;",prep-tiger-geo-new.sql
"create or replace function imt_geo_planner2(inp stdaddr, opt integer)
  returns text as
$body$
declare
  sql text;
  i integer;
  rec record;
  mm integer;
  
begin
  mm := case when opt>0 then 8 else 5 end;
  sql := '';
  <<planner>>
  for i in 0..mm loop 
    sql := sql 
      || case when i>0 then '
    union
    ' else '' end
      || 'select a.*, '
                 ||i::text||' as plan, '
                 ||coalesce(to_number(quote_literal(inp.house_num),'999999999')||'::integer%2=b.refaddr::integer%2','null')||' as parity'
      || ' from stdstreets a, streets b'
      || ' where a.id=b.gid ' 
      || imt_geo_add_where_clauses(inp, i);
  end loop planner;

--  sql := 'select distinct on (id) foo.* from (' || sql || ') as foo order by id';
  -- added sub-select to enforce an order by id, plan so all servers return the same results
  sql := 'select distinct on (id) * from (select * from (' || sql || ') as bar order by id, plan) as foo order by id';

  return sql;
end;
$body$
  language plpgsql immutable;",prep-tiger-geo-new.sql
"create or replace function imt_geo_score(sql text, sin stdaddr, aoff double precision)
  returns setof geo_result as
$body$
declare
  rec geo_result;
  score double precision;
  w1 double precision := 0.05;
  w2 double precision := 0.25;
  w3 double precision := 0.125;
  len integer;
  xy record;
  
begin

  for rec in execute sql loop
    select * into xy from imt_compute_xy(rec.id, sin.house_num, aoff);
    rec.x := xy.x;
    rec.y := xy.y;
    score := case when coalesce(rec.parity,true) then 0.0 else 0.1 end;
    len := max(length(coalesce(rec.predir,'')), length(coalesce(sin.predir,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.predir,''), coalesce(sin.predir,''))::double precision / len::double precision * w1 else 0.0 end;
    len := max(length(coalesce(rec.sufdir,'')), length(coalesce(sin.sufdir,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.sufdir,''), coalesce(sin.sufdir,''))::double precision / len::double precision * w1 else 0.0 end;
    len := max(length(coalesce(rec.pretype,'')), length(coalesce(sin.pretype,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.pretype,''), coalesce(sin.pretype,''))::double precision / len::double precision * w1 else 0.0 end;
    len := max(length(coalesce(rec.suftype,'')), length(coalesce(sin.suftype,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.suftype,''), coalesce(sin.suftype,''))::double precision / len::double precision * w1 else 0.0 end;
    len := max(length(coalesce(rec.qual,'')), length(coalesce(sin.qual,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.qual,''), coalesce(sin.qual,''))::double precision / len::double precision * w1 else 0.0 end;
    len := max(length(coalesce(rec.name,'')), length(coalesce(sin.name,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.name,''), coalesce(sin.name,''))::double precision / len::double precision * w2 else 0.0 end;
    len := max(length(coalesce(rec.city,'')), length(coalesce(sin.city,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.city,''), coalesce(sin.city,''))::double precision / len::double precision * w3 else 0.0 end;
    len := max(length(coalesce(rec.state,'')), length(coalesce(sin.state,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.state,''), coalesce(sin.state,''))::double precision / len::double precision * w3 else 0.0 end;
    len := max(length(coalesce(rec.postcode,'')), length(coalesce(sin.postcode,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.postcode,''), coalesce(sin.postcode,''))::double precision / len::double precision * w3 else 0.0 end;
    len := max(length(coalesce(rec.country,'')), length(coalesce(sin.country,'')));
    score := score + case when len>0 then levenshtein(coalesce(rec.country,''), coalesce(sin.country,''))::double precision / len::double precision * w3 else 0.0 end;
    rec.score := 1.0 - score;
    return next rec;
  end loop;
  return;
end;
$body$
  language plpgsql immutable strict cost 1 rows 100;",prep-tiger-geo-new.sql
"create or replace function imt_geocode_intersection(micro1_in text, micro2_in text, macro_in text, fuzzy integer, method integer)
  returns setof geo_intersection as
$body$
declare
  srec stdaddr;
  sql text;
  sql2 text;
  asql text[];
  sfld stdaddr[];
  rec geo_intersection;
  cnt integer := 0;

begin

  -- add house num for standardizer
  srec := standardize_address('lex', 'gaz', 'rules', trim(both from '10 '||micro1_in)::text, trim(both from macro_in)::text);
  -- kill house num now because we don't want it for intersections
  srec.house_num := null;
--raise notice 'st1: srec: %', srec;

  -- make sure we got a result that we can use
  if coalesce(srec.house_num,srec.predir,srec.qual,srec.pretype,srec.name,srec.suftype,srec.sufdir,srec.city,srec.state,srec.postcode,srec.country) is not null then
      select * into sql2 from imt_geo_planner2(srec, fuzzy);
      if found then
          asql[cnt] := sql2;
--raise notice 'st1: asql: %', sql2;
          sfld[cnt] := srec;
          cnt := cnt + 1;
      else
          return;
      end if;
  else
      return;
  end if;

  -- add house num for standardizer
  srec := standardize_address('lex', 'gaz', 'rules', trim(both from '10 '||micro2_in)::text, trim(both from macro_in)::text);
  -- kill house num now because we don't want it for intersections
  srec.house_num := null;
--raise notice 'st2: srec: %', srec;

  -- make sure we got a result that we can use
  if coalesce(srec.house_num,srec.predir,srec.qual,srec.pretype,srec.name,srec.suftype,srec.sufdir,srec.city,srec.state,srec.postcode,srec.country) is not null then
      select * into sql2 from imt_geo_planner2(srec, fuzzy);
      if found then
          asql[cnt] := sql2;
--raise notice 'st2: asql: %', sql2;
          sfld[cnt] := srec;
          cnt := cnt + 1;
      else
          return;
      end if;
  else
      return;
  end if;

  if (sfld[0].state is null and sfld[0].postcode is null) or (sfld[0].state is null and sfld[0].postcode is null) then
    return;
  end if;

  for rec in select * from (
               select distinct on (x, y)
                 a.id as id1,
                 c.id as id2,
                 f.tlid as id1a,
                 g.tlid as id2a,
                 array_to_string(ARRAY[f.predirabrv, f.prequalabr, f.pretypabrv, f.name, f.suftypabrv, f.sufdirabrv, f.prequalabr], ' ') as street1,
                 array_to_string(ARRAY[g.predirabrv, g.prequalabr, g.pretypabrv, g.name, g.suftypabrv, g.sufdirabrv, g.prequalabr], ' ') as street2,
                 coalesce(f.ac5,f.ac4,f.ac3) as placename,
                 f.usps as placename_usps,
                 f.ac2 as statename,
                 f.ac1 as countrycode,
                 f.postcode as zipcode,
                 a.plan,
                 (a.score+c.score)/2.0 as geocodematchcode,
                 st_x(e.the_geom) as x,
                 st_y(e.the_geom) as y
               from 
                   (select * from imt_geo_score(asql[0], sfld[0], 0.0)) as a, st_vert_tmp b, streets f,
                   (select * from imt_geo_score(asql[1], sfld[1], 0.0)) as c, st_vert_tmp d, streets g,
                   intersections_tmp e
              where
                   a.id=b.gid and b.gid=f.gid and
                   c.id=d.gid and d.gid=g.gid and
                   b.vid=d.vid and
                   b.vid=e.id and
                   array_to_string(ARRAY[f.predirabrv, f.prequalabr, f.pretypabrv, f.name, f.suftypabrv, f.sufdirabrv, f.prequalabr], ' ') != array_to_string(ARRAY[g.predirabrv, g.prequalabr, g.pretypabrv, g.name, g.suftypabrv, g.sufdirabrv, g.prequalabr], ' ')
              order by x, y ) as foo
            order by geocodematchcode desc
  loop
        return next rec;
  end loop;
  return;
end;
$body$
  language plpgsql immutable strict cost 5 rows 100;",prep-tiger-geo-new.sql
"create or replace function imt_geocoder(address_in text, fuzzy integer, aoffset double precision, method integer)
  returns setof geo_result2 as
$body$
declare
  sfld stdaddr;
  sql text;
  rec geo_result2;
  cnt integer := 0;
  paddr record;
  micro_in text;
  macro_in text;

begin
  select * into paddr from parse_address(address_in);
  if not found then
    return;
  end if;

  macro_in := array_to_string(ARRAY[paddr.city, paddr.state, paddr.zip, paddr.county], ',');
  
  if paddr.street is not null and paddr.street2 is not null then
    -- we are doing an intersection
    return query select * from imt_geocode_intersection(paddr.street, paddr.street2, macro_in, fuzzy, method);
  else
    -- we are doing an address
    micro_in := paddr.address1;

    sql := 'select 0::int4 as id, '||trim(both from quote_literal(micro_in))||'::text as micro, '||trim(both from quote_literal(macro_in))||'::text as macro';
--raise notice 'sql: %', sql;
    select * into sfld from standardize_address(
          'lex',
          'gaz',
          'rules',
          sql);
--raise notice 'sfld: %', sfld;

    return query select * from imt_geocoder(sfld, fuzzy, aoffset, method);
  end if;
end;
$body$
  language plpgsql immutable strict cost 5 rows 100;",prep-tiger-geo-new.sql
"create or replace function imt_geocoder(micro_in text, macro_in text, fuzzy integer, aoffset double precision, method integer)
  returns setof geo_result2 as
$body$
declare
  sfld stdaddr;

begin
  select * into sfld 
    from standardize_address('lex', 'gaz', 'rules', 
           trim(both from micro_in)::text, 
           trim(both from macro_in)::text);
--raise notice 'sfld: %', sfld;
  if sfld.state is null and sfld.postcode is null then
    return;
  end if;

  return query select * from imt_geocoder(sfld, fuzzy, aoffset, method);
end;
$body$
  language plpgsql immutable strict cost 5 rows 100;",prep-tiger-geo-new.sql
"create or replace function imt_geocoder(sfld stdaddr, fuzzy integer, aoffset double precision, method integer)
  returns setof geo_result2 as
$body$
declare
  sql text;
  rec geo_result2;
  cnt integer := 0;

begin

--raise notice 'sfld: %', sfld;
  if sfld.state is null and sfld.postcode is null then
    return;
  end if;

  -- make sure we got an address that we can use
  if coalesce(sfld.house_num,sfld.predir,sfld.qual,sfld.pretype,sfld.name,sfld.suftype,sfld.sufdir) is not null and
     coalesce(sfld.city,sfld.state,sfld.postcode /*,sfld.country */) is not null then
    select * into sql from imt_geo_planner2(sfld, fuzzy);
--raise notice '%', sql;
    if found then
      for rec in select 
                             0::int4 as rid,
                             a.id,
                             b.tlid as id1,
                             b.side as id2,
                             b.tfid as id3,
                             sfld.house_num as completeaddressnumber,
                             b.predirabrv as predirectional,
                             b.prequalabr as premodifier,
                             b.sufqualabr as postmodifier,
                             b.pretypabrv as pretype,
                             b.name as streetname,
                             b.suftypabrv as posttype,
                             b.sufdirabrv as postdirectional,
                             coalesce(b.ac5,b.ac4,b.ac3) as placename,
                             b.usps as placename_usps,
                             b.ac2 as statename,
                             b.ac1 as countrycode,
                             b.postcode as zipcode,
                             sfld.building,
                             sfld.unit,
                             plan,
                             parity,
                             a.score as geocodematchcode,
                             a.x,
                             a.y
                   from (select * from imt_geo_score(sql, sfld, aoffset)) as a, streets b where a.id=b.gid order by a.score desc, plan asc loop
        cnt := cnt + 1;
        rec.rid := cnt;
        return next rec;
      end loop;
    end if;
  end if;
  return;
end;
$body$
  language plpgsql immutable strict cost 5 rows 100;",prep-tiger-geo-new.sql
"create or replace function imt_geocoder2(micro_in text, macro_in text, opts integer)
  returns setof geo_result as
$body$
declare
  sfld stdaddr;
  sql text;
  rec geo_result;
  cnt integer := 0;

begin
  sql := 'select 0::int4 as id, '||trim(both from quote_literal(micro_in))||'::text as micro, '||trim(both from quote_literal(macro_in))||'::text as macro';
--raise notice 'sql: %', sql;
  select * into sfld from standardize_address(
        'lex',
        'gaz',
        'rules',
        sql);
--raise notice 'sfld: %', sfld;

  -- make sure we got a result that we can use
  if found  and coalesce(sfld.house_num,sfld.predir,sfld.qual,sfld.pretype,sfld.name,sfld.suftype,sfld.sufdir,sfld.city,sfld.state,sfld.postcode,sfld.country) is not null then
    select * into sql from imt_geo_planner2(sfld, opts);
--raise notice '%', sql;
    if found then
      for rec in select * from (select * from imt_geo_score(sql, sfld, 0.0)) as a order by a.score desc, plan asc loop
        cnt := cnt + 1;
        return next rec;
      end loop;
    end if;
  end if;
  return;
end;
$body$
  language plpgsql immutable strict;",prep-tiger-geo-new.sql
"create or replace function imt_geocoder_best(sql text, fuzzy integer, aoffset double precision, method integer)
  returns setof geo_result2 as
$body$
declare
  sfld stdaddr;
  rec geo_result2;
  t0 timestamp with time zone;

begin
  for sfld in execute sql loop
    continue when sfld.state is null and sfld.postcode is null;
    t0 := clock_timestamp();
    for rec in select * from imt_geocoder(sfld, fuzzy, aoffset, method) loop
      return next rec;
      exit;
    end loop;
    if method < 0 then
      raise notice 'id=%, time=%', sfld.id, clock_timestamp()-t0;
    end if;
  end loop;

  return;
end;
$body$
  language plpgsql immutable strict cost 5 rows 100;",prep-tiger-geo-new.sql
"create or replace function incr_fecha(
	in pfecha date
	)
returns date as $$
begin
	return pfecha + integer '1';
end;
 $$ language plpgsql;",funciones.sql
"create or replace function inline_0 ()
returns integer as $$
declare
	-- Menu IDs
	v_menu			integer;
	v_main_menu		integer;
	v_employees		integer;
BEGIN
	-- Determine the main menu. ""Label"" is used to identify menus.
	select menu_id into v_main_menu
	from im_menus where label='conf_items';

	-- Create the menu.
	v_menu := im_menu__new (
		null,				-- p_menu_id
		'im_menu',			-- object_type
		now(),				-- creation_date
		null,				-- creation_user
		null,				-- creation_ip
		null,				-- context_id
		'intranet-confdb',		-- package_name
		'conf_items_new',		-- label
		'Add a new Conf Item',	-- name
		'/intranet-confdb/new?form%5fmode=edit',	-- url
		100,				-- sort_order
		v_main_menu,			-- parent_menu_id
		'im_permission $user_id add_conf_items'	-- p_visible_tcl
	);

	-- Grant read permissions to most of the system
	select group_id into v_employees from groups where group_name = 'Employees';

	return 0;
end;$$ language 'plpgsql';",intranet-confdb-create.sql
"create or replace function inline_0 ()
returns integer as $$
declare
	-- Menu IDs
	v_menu			integer;
	v_main_menu		integer;

	-- Groups
	v_employees		integer;
	v_accounting		integer;
	v_senman		integer;
	v_companies		integer;
	v_freelancers		integer;
	v_proman		integer;
	v_admins		integer;
	v_reg_users		integer;
BEGIN
	-- Get some group IDs
	select group_id into v_admins from groups where group_name = 'P/O Admins';
	select group_id into v_senman from groups where group_name = 'Senior Managers';
	select group_id into v_proman from groups where group_name = 'Project Managers';
	select group_id into v_accounting from groups where group_name = 'Accounting';
	select group_id into v_employees from groups where group_name = 'Employees';
	select group_id into v_companies from groups where group_name = 'Customers';
	select group_id into v_freelancers from groups where group_name = 'Freelancers';
	select group_id into v_reg_users from groups where group_name = 'Registered Users';

	-- Determine the main menu. ""Label"" is used to identify menus.
	select menu_id into v_main_menu 
	from im_menus where label='main';

	-- Create the menu.
	v_menu := im_menu__new (
		null,			-- p_menu_id
		'im_menu',		-- object_type
		now(),			-- creation_date
		null,			-- creation_user
		null,			-- creation_ip
		null,			-- context_id
		'intranet-confdb',	-- package_name
		'conf_items',		-- label
		'Conf Items',		-- name
		'/intranet-confdb/index',   -- url
		95,			-- sort_order
		v_main_menu,		-- parent_menu_id
		null			-- p_visible_tcl
	);

	-- Grant read permissions to most of the system
	PERFORM acs_permission__grant_permission(v_menu, v_admins, 'read');
	PERFORM acs_permission__grant_permission(v_menu, v_senman, 'read');
	PERFORM acs_permission__grant_permission(v_menu, v_proman, 'read');
	PERFORM acs_permission__grant_permission(v_menu, v_accounting, 'read');
	PERFORM acs_permission__grant_permission(v_menu, v_employees, 'read');

	return 0;
end;$$ language 'plpgsql';",intranet-confdb-create.sql
"create or replace function ins_p_batch(p[]) returns void as $$  
declare  
  i p;  
begin  
  foreach i in array $1 loop  
    perform ins_p(i.id, i.info, i.crt_time);  
  end loop;  
end;  
$$ language plpgsql strict;",20190109_01.md
"create or replace function majnote() returns void as $$
begin
	if not exists (SELECT * from information_schema.table_constraints where table_name = 'note' and constraint_type = 'UNIQUE') then 
	execute 
	'ALTER TABLE ONLY note
	  ADD CONSTRAINT note_notetypecode_id_thesaurus_id_concept_lang_key UNIQUE (notetypecode, id_thesaurus, id_concept, lang, lexicalvalue);
	ALTER TABLE ONLY note
	ADD CONSTRAINT note_notetypecode_id_thesaurus_id_term_lang_key UNIQUE (notetypecode, id_thesaurus, id_term, lang, lexicalvalue);';
	else 
	execute
	'alter table note drop constraint note_notetypecode_id_thesaurus_id_concept_lang_key;
	alter table note drop constraint note_notetypecode_id_thesaurus_id_term_lang_key;
	ALTER TABLE ONLY note
	  ADD CONSTRAINT note_notetypecode_id_thesaurus_id_concept_lang_key UNIQUE (notetypecode, id_thesaurus, id_concept, lang, lexicalvalue);
	ALTER TABLE ONLY note
	ADD CONSTRAINT note_notetypecode_id_thesaurus_id_term_lang_key UNIQUE (notetypecode, id_thesaurus, id_term, lang, lexicalvalue);';
  end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function matong_rule(  
  v_sid int,   -- 传感器ID  
  pos_range box,  -- 空间区间 , 如果使用postgis，请使用geometry来标注一个空间 
  ts interval     -- 持续时间，采用interval类型  
) returns jsonb as $$  
declare  
  v sensor_info;  -- 临时类型  
  e timestamp;    -- 最后时间  
  s timestamp;    -- 最前时间  
begin  
  for v in select * from sensor_info_1 where sid=v_sid order by crt_time desc   
  loop  
    if pos_range @> v.pos then  
      if e is null then e := v.crt_time; end if;  
      s := v.crt_time;  
    else  
      exit;  
    end if;  
  end loop;  
  
  if e-s >= ts then  
     return jsonb_build_object('sid', v_sid, 'pos_range', pos_range, 'start_time', s, 'end_time', e, 'interval', e-s);  
  else  
    return null;  
  end if;  
end;  
$$ language plpgsql strict;",20170731_01.md
"create or replace function max(a numeric, b numeric)
  returns numeric as
$body$
begin
  return case when a>b then a else b end;
end;
$body$
  language plpgsql immutable;",prep-tiger-geo-new.sql
"create or replace function max_prods_a_devolver(int8)
returns setof record as $$
declare
	prod ALIAS FOR $1;
	list record;
	query varchar(255);

begin
query := 'SELECT cantidad FROM devolucion WHERE id= '
	|| '(SELECT id FROM devolucion WHERE barcode_product='
	|| quote_literal(prod) || ' AND devuelto=FALSE)';


FOR list IN EXECUTE query LOOP
	RETURN NEXT list;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function mid_find_sapa_by_distance(nIC integer, nDistance integer)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	sapa_user_id     integer;
	ic_node          bigint;
	ic_geometry    geometry;
BEGIN
	-- Get the new node id of ic
	select new_node into ic_node
	  from (
		select mesh, node 
		  from org_interchange
		  where ic = nIC
	  ) as a
	  left join mesh_mapping_tbl as b
	  on a.mesh = b.meshid_str
	  left join temp_node_mapping as c
	  on globl_mesh_id = meshid and a.node = c.node;
	  
	if not found or ic_node is null then 
		return 0;
	end if;

	-- get the geometry of IC Node
	select the_geom into ic_geometry from node_tbl where node_id = ic_node;
	if not found or ic_geometry is null then 
		return 0;
	end if;

	--raise info '%', st_astext(ic_geometry);
	-- search SAPA in nDistance 
	SELECT sapa into sapa_user_id
		  from (
			select *
			from temp_node_mapping
			where new_node in (
				select node_id 
				  from node_tbl
				  where ST_DWithin(the_geom, st_setsrid(ic_geometry, 4326), 0.000002694945852358566745 * (nDistance / 0.25)) 
				  --and node_id <> ic_node
			 )
		  ) as a
		  left join mesh_mapping_tbl as b
		  on a.meshid = globl_mesh_id
		  inner join org_sapa as c
		  on meshid_str = c.mesh and (a.node = c.node);

	if sapa_user_id is not null then 
		return sapa_user_id;
	else 
		raise info '3';
		return 0;
	end if;
end;
$$;",create_function.sql
"create or replace function mid_find_sapa_by_path(nIC integer)
	RETURNS integer[]
	LANGUAGE plpgsql
AS $$ 
DECLARE	
	tmpPathArray		varchar[];
	tmpLastNodeArray	bigint[];
	tmpPathCount		integer;
	tmpPathIndex		integer;
	tmplastLinkArray	bigint[];
	
	nStartNode              bigint;
	in_out_type             smallint;
	sapa_user_id            integer;
	start_oneway_cond       character varying;
	end_oneway_cond         character varying;
	rec			record;
BEGIN
	
	-- get new node id
	select new_node into nStartNode
	  from (
		select *
		from org_interchange
		where ic = nIC
	  ) as a
	  left join mesh_mapping_tbl as b
	  on a.mesh = b.meshid_str 
	  left join temp_node_mapping as c
	  on globl_mesh_id = c.meshid and a.node = c.node;
	if not found then 
		raise info 'IC: %', nIC;
		return null;
	end if;  
	
	-- get in/out type: 
	in_out_type := mid_get_hwy_in_out_type(nStartNode, 0::smallint, 1::smallint);

	-- out: forward
	if in_out_type = 1 then 
		start_oneway_cond := '(1, 2)';
		end_oneway_cond   := '(1, 3)';
	else -- IN: backward
		start_oneway_cond := '(1, 3)';
		end_oneway_cond   := '(1, 2)';
	end if;

	--rstPathArray
	tmpPathArray		:= ARRAY[''];
	tmpLastNodeArray	:= ARRAY[nStartNode];
	tmpPathCount		:= 1;
	tmpPathIndex		:= 1;
	sapa_user_id            := 0;
	
	--raise INFO 'ic: %', nIC;
	WHILE tmpPathIndex <= tmpPathCount LOOP
		--raise INFO '%', tmpPathIndex;
		--raise INFO '%', cast(tmpPathArray[tmpPathIndex] as varchar);
		--raise INFO 'tmpLastNodeArray[tmpPathIndex]: %', tmpLastNodeArray[tmpPathIndex];
		sapa_user_id = mid_get_sapa_user_id(tmpLastNodeArray[tmpPathIndex]);
		-- found the sapa node
		if sapa_user_id > 0 then
			exit;
		end if;
		
		if array_upper(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+'), 1) >= 12 then  -- It is longer then 15.
			--raise INFO '%', 15;
			--raise INFO '%', replace(replace(cast(tmpPathArray[tmpPathIndex] as varchar), '(2)', ''), '(3)', '');
			tmpPathIndex := tmpPathIndex + 1;
			continue;
		end if;	
		
		-- search next links
		for rec in execute
				'
				 select  nextroad, a.dir, a.nextnode
				 from
				 (
					 select link_id as nextroad, ''(2)'' as dir, e_node as nextnode
					 from link_tbl
					 where	(s_node = ' || tmpLastNodeArray[tmpPathIndex]|| ') and 
							(one_way_code in ' || start_oneway_cond ||') and 
							--(road_type in (0, 1) or 
							 link_type in (3,4, 5,7)
							-- toll = 1)
					 union
					 
					 select link_id as nextroad, ''(3)'' as dir, s_node as nextnode
					 from link_tbl
					 where	(e_node = ' || tmpLastNodeArray[tmpPathIndex]|| ') and
							(one_way_code in ' || end_oneway_cond ||') and 
							--(road_type in (0, 1) or 
							 link_type in (3,4, 5,7)
							-- toll = 1)
				 )as a
				'
		loop
			if not ((rec.nextroad::varchar) = ANY(regexp_split_to_array(tmpPathArray[tmpPathIndex], E'\\|+'))) then
				tmpPathCount        := tmpPathCount + 1;
				tmpPathArray        := array_append(tmpPathArray, cast(tmpPathArray[tmpPathIndex]||'|'||rec.nextroad as varchar));
				tmpLastNodeArray    := array_append(tmpLastNodeArray, cast(rec.nextnode as bigint));
				tmplastLinkArray    := array_append(tmplastLinkArray, cast(rec.nextroad as bigint));
			end if;
		end loop;
		
		-- next path
		tmpPathIndex := tmpPathIndex + 1;
	END LOOP;

	-- does not find.
	if sapa_user_id = 0 then 
		return array[NULL, in_out_type];
	else
		return array[sapa_user_id, in_out_type];
	end if;
END;
$$;",create_function.sql
"create or replace function mid_get_access_lane_info(all_lane_info varchar, target_arrow_info smallint, lane_array char[], lane_info_target_direction varchar)
returns varchar
LANGUAGE plpgsql
AS
$$ 
DECLARE
	current_char char;
	ipos integer;
	rtn_value smallint;
	total_lane_no integer;
	itor_cnt integer;
BEGIN
	ipos := 1;
	rtn_value := 0;
	itor_cnt := 0;
	total_lane_no := char_length(all_lane_info);
	
	if target_arrow_info = -1 then
		while ipos <= total_lane_no  loop
			current_char := substring(all_lane_info, ipos, 1);
			if current_char = 'D' then
				rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos));
			end if;

			ipos := ipos + 1;
		end loop;
	else
		while ipos <= total_lane_no loop
			current_char := substring(all_lane_info, ipos, 1);
			if current_char = any(lane_array) then
				rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos));
			end if;

			ipos := ipos + 1;
		end loop;
	end if;

	-- feedback to adjust lane info
--	if mid_get_specific_char_num(cast(rtn_value::int::bit(16) as varchar), '1') > char_length(lane_info_target_direction) then
--		-- match real lane postion
--		ipos := position(lane_info_target_direction in all_lane_info);
--
--		while itor_cnt <= char_length(lane_info_target_direction) loop
--			rtn_value := rtn_value | ((1::smallint) << (total_lane_no - ipos - itor_cnt));
--			itor_cnt := itor_cnt + 1;
--		end loop;
--	end if;

	return substring(cast(rtn_value::int::bit(16) as varchar), 17 - total_lane_no, total_lane_no);
END;
$$;",create_function.sql
"create or replace function mid_get_arrow_info(lane_info_target_direction varchar, lane_no smallint[])
returns smallint
LANGUAGE plpgsql
AS
$$ 
DECLARE
	ipos integer;
	current_char char;
BEGIN
	ipos := 1;
	if lane_no is null then
		lane_no = -1;
	end if;

	while ipos <= char_length(lane_info_target_direction) loop
--		if ipos = lane_no then
--			ipos := ipos + 1;
--			continue;
--		end if;

		if ipos = any(lane_no) then
			ipos := ipos + 1;
			continue;
		end if;

		current_char := substring(lane_info_target_direction, ipos, 1);
		if current_char = 'D' or current_char = 'Q' then
			ipos := ipos + 1;
			continue;
		end if;
		
		if current_char = '0' or current_char = 'G' or current_char = 'R' then
			return 1;
		elsif current_char = '1' or current_char = 'H' or current_char = 'Z' then 
			return 64;
		elsif current_char = '3' or current_char = 'O' or current_char = 'S' then 
			return 4;
		elsif current_char = '5' or current_char = 'I' then
			return 16;
		elsif current_char = '8' or current_char = 'T' then
			return 2048;
		else
			ipos := ipos + 1;
		end if;
	end loop;

	return -1;
END;
$$;",create_function.sql
"create or replace function mid_get_lane_xlpath_info(start_xlpath bigint, path_cnt bigint,meshid integer)
returns bigint[]
LANGUAGE plpgsql
AS
$$ 
DECLARE
	curs1 refcursor;
	temp_path_links bigint[];
BEGIN
	OPEN curs1 for execute 'select array_agg(new_road) from (
	select gid, xlpath, xlpath_id, globl_mesh_id, new_road, area_flag from temp_org_xlpath  where xlpath between ' 
	|| cast(start_xlpath as varchar) || ' and '
	|| cast(start_xlpath + path_cnt -1 as varchar) || 'and meshid = ' || cast(meshid as varchar) || ' order by xlpath ) as A' ;
	
	FETCH curs1 INTO temp_path_links;

	if temp_path_links is not null then
		return temp_path_links;
	else
		return null;
	end if;

	close curs1;
END;
$$;",create_function.sql
"create or replace function mid_get_sapa_user_id(nNewNodeID bigint)
	RETURNS integer
	LANGUAGE plpgsql
AS $$ 
DECLARE
	sapa_user_id     integer;
BEGIN
	sapa_user_id := 0;
	SELECT sapa into sapa_user_id
		  from (
			select *
			from temp_node_mapping
			where new_node = nNewNodeID
		  ) as a
		  left join mesh_mapping_tbl as b
		  on a.meshid = globl_mesh_id
		  left join org_sapa as c
		  on meshid_str = c.mesh and (a.node = c.node or a.node = c.node_entr);

	if found and sapa_user_id is not null then 
		return sapa_user_id;
	else 
		return 0;
	end if;
END;
$$;",create_function.sql
"create or replace function my_date(d date,m int) returns date as $$
declare
    d2 alias for d;
    m2 alias for m;
begin
    return d2+m2*interval '2 day';
end;
$$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_date(d timestamp with time zone,m int) returns date as $$
declare
    d2 alias for d;
    m2 alias for m;
begin
    return d2+m2*interval '2 day';
end;
$$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_name(int) returns varchar as $$
declare
    j2 alias for $1;
    t2 y.t%type;
begin
    select into t2 t from y
    where j=j2;

    return j2 || ',' || t2;
end
$$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_not_equal(i int,j int)returns bool as $$
begin
    return i <> j;
end
$$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_row(int) returns varchar as $$
declare
    j2 alias for $1;
    y2 y%rowtype;
begin
    select into y2 *from y
    where y.j=j2;

    return j2 || ': ' || y2.j || ', ' || y2.t;
end
$$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_sum(m int,n int) returns int as $$ begin
    return m+n;
end $$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function my_sum(m int,n int) returns int as $$ begin return m+n; end $$ language plpgsql;",LOG_29_sep_2015.txt.bak
"create or replace function new_dblink_connect(text,text) returns void as $$  
declare  
begin  
  perform dblink_connect($1,$2);  
  exception   
    when SQLSTATE '42710' then  
      return;  
    when others then  
      raise;  
end;  
$$ language plpgsql;",20151220_02.md
"create or replace function obtener_img(in character varying,out integer, out character varying,out bytea)
RETURNS SETOF record AS
$$
begin
	return query select id_user, name_user, img from User_VE u inner join Img_VE i on u.id_img=i.id_img where username_user=$1;
	
end
$$
LANGUAGE plpgsql VOLATILE COST 100;",gad_manta.sql
"create or replace function parallel_img_search(  
  v_mod int,   -- 分区数  
  v_sig signature,  -- 图像特征值  
  conn text default format('hostaddr=%s port=%s user=%s dbname=%s application_name=', '127.0.0.1', current_setting('port'), current_user, current_database())  -- dblink连接  
)  
returns setof record as  
$$  
declare  
  app_prefix text := 'abc';     
  sql text;  
  ts1 timestamp;  
begin  
  for i in 0..v_mod loop  
    perform conn(app_prefix||i,  conn||app_prefix||i);   
    perform id,sig from dblink_get_result(app_prefix||i, false) as t(id int, sig signature);   
    sql := format('select * from t_img%s order by sig <-> %L limit 1', i, v_sig);  
    perform dblink_send_query(app_prefix||i, sql);     
  end loop;  
  
  ts1 := clock_timestamp();  
  for i in 0..v_mod loop  
    return query select id,sig from dblink_get_result(app_prefix||i, false) as t(id int, sig signature);    
  end loop;  
  raise notice '%', clock_timestamp()-ts1;  
    
  return;  
end;  
$$ language plpgsql strict;",20180904_03.md
"create or replace function parallel_img_search(    
  vc1 text,  -- 第1组向量  
  vc2 text,  -- 第2组向量  
  vc3 text,  -- 第3组向量  
  vc4 text,  -- 第4组向量  
  vc5 text,  -- 第5组向量  
  lmt1 int,  -- 每一个维度返回TOP N条 欧式距离最小的记录  
  lmt2 int,  -- 最终返回N条 所有维度上 欧式距离最小的记录  
  conn text default format('hostaddr=%s port=%s user=%s dbname=%s application_name=', '127.0.0.1', current_setting('port'), current_user, current_database())  -- dblink连接    
)    
returns setof record as    
$$    
declare    
  app_prefix text := 'abc';       
  sql text[];    
  vsql text;  
  i int :=1 ;  
  ids int[];  
  ids1 int[] := '{}'::int[];  
  ts1 timestamp;    
begin    
  sql := array[  
format(  
$_$  
select id from test_sig order by (('('||c1||')')::cube) <-> cube '(%s)' limit %s  
$_$,vc1,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c2||')')::cube) <-> cube '(%s)' limit %s  
$_$,vc2,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c3||')')::cube) <-> cube '(%s)' limit %s  
$_$,vc3,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c4||')')::cube) <-> cube '(%s)' limit %s  
$_$,vc4,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c5||')')::cube) <-> cube '(%s)' limit %s  
$_$,vc5,lmt1)];  
  foreach vsql in array sql loop    
    perform conn(app_prefix||i,  conn||app_prefix||i);     
    perform id from dblink_get_result(app_prefix||i, false) as t(id int);      
    perform dblink_send_query(app_prefix||i, vsql);       
    i := i+1;  
  end loop;    
    
  ts1 := clock_timestamp();    
  for i in 1..5 loop    
    select array_agg(id) into ids from dblink_get_result(app_prefix||i, false) as t(id int);      
    ids1 := ids1||ids;  
  end loop;    
  raise notice '%', clock_timestamp()-ts1;   
  return query execute  
  format($_$  
  select * from test_sig where id = any (%L) order by (('('||c1||','||c2||','||c3||','||c4||','||c5||')')::cube) <->   
cube '(%s,%s,%s,%s,%s)'   
limit %s $_$,ids1,vc1,vc2,vc3,vc4,vc5,lmt2);  
      
  return;    
end;    
$$ language plpgsql strict;",20181129_01.md
"create or replace function parallel_img_search(    
  vc1 text,  -- 第1组向量  
  vc2 text,  -- 第2组向量  
  vc3 text,  -- 第3组向量  
  vc4 text,  -- 第4组向量  
  vc5 text,  -- 第5组向量  
  lmt1 int,  -- 每一个维度返回TOP N条 欧式距离最小的记录  
  lmt2 int,  -- 最终返回N条 所有维度上 欧式距离最小的记录  
  conn text default format('hostaddr=%s port=%s user=%s dbname=%s application_name=', '127.0.0.1', current_setting('port'), current_user, current_database())  -- dblink连接    
)    
returns setof record as    
$$    
declare    
  app_prefix text := 'abc';       
  sql text[];    
  vsql text;  
  i int :=1 ;  
  ids int[];  
  ids1 int[] := '{}'::int[];  
  ts1 timestamp;    
begin    
  sql := array[  
format(  
$_$  
select id from test_sig order by (('('||c1||')')::signature) <-> signature '(%s)' limit %s  
$_$,vc1,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c2||')')::signature) <-> signature '(%s)' limit %s  
$_$,vc2,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c3||')')::signature) <-> signature '(%s)' limit %s  
$_$,vc3,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c4||')')::signature) <-> signature '(%s)' limit %s  
$_$,vc4,lmt1),  
format(  
$_$  
select id from test_sig order by (('('||c5||')')::signature) <-> signature '(%s)' limit %s  
$_$,vc5,lmt1)];  
  foreach vsql in array sql loop    
    perform conn(app_prefix||i,  conn||app_prefix||i);     
    perform id from dblink_get_result(app_prefix||i, false) as t(id int);      
    perform dblink_send_query(app_prefix||i, vsql);       
    i := i+1;  
  end loop;    
    
  ts1 := clock_timestamp();    
  for i in 1..5 loop    
    select array_agg(id) into ids from dblink_get_result(app_prefix||i, false) as t(id int);      
    ids1 := ids1||ids;  
  end loop;    
  raise notice '%', clock_timestamp()-ts1;   
  return query execute  
  format($_$  
  select * from test_sig where id = any (%L) order by (('('||c1||','||c2||','||c3||','||c4||','||c5||')')::cube) <->   
cube '(%s,%s,%s,%s,%s)'   
limit %s $_$,ids1,vc1,vc2,vc3,vc4,vc5,lmt2);  
      
  return;    
end;    
$$ language plpgsql strict;",20181129_01.md
"create or replace function plproxy.get_cluster_config(cluster_name text, out key text, out val text)
returns setof record as $$
begin
    key := 'statement_timeout';
    val := 60;
    return next;
    return;
end; $$ language plpgsql;",plproxy.txt
"create or replace function primary_key_info() returns void as 
$$
begin	
if not exists (SELECT * from information_schema.table_constraints where table_name = 'info' and constraint_type = 'PRIMARY KEY'
	and constraint_name ='info_pkey') then 
	execute
	'
            ALTER TABLE ONLY info
			ADD CONSTRAINT info_pkey PRIMARY KEY (version_opentheso, version_bdd);
        ';
        end if;
  end;
  $$LANGUAGE plpgsql;",maj_bdd_current.sql
"create or replace function producto_en_fecha(
       in fecha_inicio timestamp,
       in barcode_in bigint,
       out barcode varchar,
       out codigo_corto varchar,
       out descripcion varchar,
       out marca varchar,
       out cont_un varchar,
       out familia integer,
       out cantidad_ingresada double precision,
       out cantidad_c_anuladas double precision,
       out cantidad_vendida double precision,
       out cantidad_anulada double precision,
       out cantidad_insumida double precision,
       out cantidad_merma double precision,
       out cantidad_devoluciones double precision,
       out cantidad_envio double precision,
       out cantidad_recibida double precision,
       out cantidad_fecha double precision
       )
returns setof record as $$
declare
q text;
l record;
corriente int4;
materia_prima int4;
begin

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

q := $S$ SELECT p.barcode, p.codigo_corto, p.marca, p.descripcion, p.contenido, p.unidad, p.familia, cantidad_ingresada, cantidad_c_anuladas, cantidad_vendida, unidades_merma, unidades_merma_mcd, cantidad_anulada, cantidad_vmcd, cantidad_devolucion, cantidad_envio, cantidad_mc_envio, cantidad_recibida, cantidad_mc_recibida
       	 	FROM producto p

	 	-- Las compras ingresadas hechas hasta la fecha determinada
	 	LEFT JOIN (SELECT SUM(fcd.cantidad) AS cantidad_ingresada, fcd.barcode AS barcode
		          	  FROM factura_compra_detalle fcd
       		     	          INNER JOIN factura_compra fc
       		     	          ON fc.id = fcd.id_factura_compra

       		     	          WHERE fc.fecha < $S$ || quote_literal(fecha_inicio) || $S$
                     	          AND fcd.cantidad > 0
                     	          GROUP BY barcode) AS cantidad_ingresada
                ON p.barcode = cantidad_ingresada.barcode

	        -- Las anulaciones de compras hechas hasta la fecha determinada
		LEFT JOIN (SELECT SUM(cad.cantidad_anulada) AS cantidad_c_anuladas, cad.barcode AS barcode
		       	          FROM compra_anulada ca
				  INNER JOIN compra_anulada_detalle cad
				  ON ca.id = cad.id_compra_anulada

				  WHERE ca.fecha_anulacion < $S$ || quote_literal(fecha_inicio) || $S$
				  GROUP BY barcode) AS compras_anuladas
	        ON p.barcode = compras_anuladas.barcode

       		-- Las Ventas hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_vendida, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	      	  INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  WHERE v.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			  	  GROUP BY barcode) AS ventas
		ON p.barcode = ventas.barcode

       	        -- Las anulaciones de venta hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_anulada, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	          INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  INNER JOIN venta_anulada va
			    	  ON va.id_sale = v.id

				  WHERE va.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS ventas_anuladas
                ON p.barcode = ventas_anuladas.barcode

		-- Las Ventas (de compuestos) menos sus anulaciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vmcd.cantidad) AS cantidad_vmcd, vmcd.barcode_componente AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta_mc_detalle vmcd
				  INNER JOIN venta v ON vmcd.id_venta_vd = v.id

			  	  WHERE vmcd.id_venta_vd NOT IN (SELECT id_sale FROM venta_anulada)
				  AND v.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			  	  GROUP BY barcode_componente) AS ventas_mcd
		ON p.barcode = ventas_mcd.barcode

	        -- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT barcode, SUM(unidades) AS unidades_merma
       	     	                  FROM merma m

		         	  WHERE m.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS merma
	        ON p.barcode = merma.barcode

		-- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT mmcd.barcode_componente AS barcode, SUM(mmcd.cantidad) AS unidades_merma_mcd
       	     	                  FROM merma m
				  INNER JOIN merma_mc_detalle mmcd
				  ON m.id = mmcd.id_merma

		         	  WHERE m.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode_componente) AS merma_mcd
	        ON p.barcode = merma_mcd.barcode

                -- Las devoluciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT dd.barcode AS barcode, SUM(dd.cantidad) AS cantidad_devolucion
       	     	                  FROM devolucion d
		 	          INNER JOIN devolucion_detalle dd
			 	  ON d.id = dd.id_devolucion

			          WHERE d.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS devolucion
                ON p.barcode = devolucion.barcode

	        -- Los traspasos enviados hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen = 1
			          GROUP BY barcode) AS traspaso_envio
                ON p.barcode = traspaso_envio.barcode

		-- Los traspasos enviados (a traves de un compuesto) hasta la fecha determinada
		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen = 1
			          GROUP BY barcode_componente) AS traspaso_mc_envio
                ON p.barcode = traspaso_mc_envio.barcode

	        -- Los traspasos recibidos hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen != 1
			          GROUP BY barcode) AS traspaso_recibido
                ON p.barcode = traspaso_recibido.barcode

		-- Los traspasos recibidos (a traves de un compuesto) hasta la fecha determinada
       		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen != 1
			          GROUP BY barcode_componente) AS traspaso_mc_recibido
                ON p.barcode = traspaso_mc_recibido.barcode

                WHERE p.estado = true
		AND (p.tipo = $S$ || corriente || $S$
		     OR p.tipo = $S$ || materia_prima || $S$ ) $S$ ;

if barcode_in != 0 then
    q := q || $S$ AND p.barcode = $S$ || barcode_in;
end if;

q := q || $S$ GROUP BY p.barcode, p.codigo_corto, p.marca, p.descripcion, p.contenido, p.unidad, p.familia, cantidad_ingresada, cantidad_c_anuladas, cantidad_vendida, unidades_merma, unidades_merma_mcd, cantidad_anulada, cantidad_vmcd, cantidad_devolucion, cantidad_envio, cantidad_mc_envio, cantidad_recibida, cantidad_mc_recibida
              ORDER BY barcode $S$;

for l in execute q loop
    barcode := l.barcode;
    codigo_corto := l.codigo_corto;
    marca := l.marca;
    descripcion := l.descripcion;
    cont_un := l.contenido ||' '|| l.unidad;
    familia := l.familia;
    cantidad_ingresada := COALESCE (l.cantidad_ingresada,0);
    cantidad_c_anuladas := COALESCE(l.cantidad_c_anuladas,0);
    cantidad_vendida := COALESCE(l.cantidad_vendida,0);
    cantidad_merma := COALESCE(l.unidades_merma,0) + COALESCE(l.unidades_merma_mcd,0);
    cantidad_anulada := COALESCE(l.cantidad_anulada,0);
    cantidad_insumida := COALESCE(l.cantidad_vmcd,0);
    cantidad_devoluciones := COALESCE(l.cantidad_devolucion,0);
    cantidad_envio := COALESCE(l.cantidad_envio,0) + COALESCE(l.cantidad_mc_envio,0);
    cantidad_recibida := COALESCE(l.cantidad_recibida,0) + COALESCE(l.cantidad_mc_recibida,0);
    cantidad_fecha := COALESCE(l.cantidad_ingresada,0) - COALESCE(l.cantidad_c_anuladas,0) - COALESCE(l.cantidad_vendida,0) - COALESCE(l.cantidad_vmcd,0) - COALESCE(l.unidades_merma,0) + COALESCE(l.cantidad_anulada,0) - COALESCE(l.cantidad_devolucion,0) - COALESCE(l.cantidad_envio,0) + COALESCE(l.cantidad_recibida,0);
    return next;
end loop;

return;
end; $$ language plpgsql;",funciones.sql
"create or replace function producto_en_fecha2(
       in fecha_inicio timestamp,
       in barcode_in bigint,
       out barcode varchar,
       out codigo_corto varchar,
       out descripcion varchar,
       out marca varchar,
       out cont_un varchar,
       out familia integer,
       out cantidad_ingresada double precision,
       out cantidad_c_anuladas double precision,
       out cantidad_vendida double precision,
       out cantidad_anulada double precision,
       out cantidad_insumida double precision,
       out cantidad_merma double precision,
       out cantidad_devoluciones double precision,
       out cantidad_envio double precision,
       out cantidad_recibida double precision,
       out cantidad_fecha double precision,
       out costo_fecha double precision
       )
returns setof record as $$
declare
q text;
l record;
corriente int4;
materia_prima int4;
begin

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

q := $S$ SELECT p.barcode, p.codigo_corto, p.marca, p.descripcion, p.contenido, p.unidad, p.familia, cantidad_ingresada, cantidad_c_anuladas, cantidad_vendida, unidades_merma, unidades_merma_mcd, cantidad_anulada, cantidad_vmcd, cantidad_devolucion, cantidad_envio, cantidad_mc_envio, cantidad_recibida, cantidad_mc_recibida,
     	 	(SELECT fcd.costo_promedio
			FROM factura_compra_detalle fcd
			INNER JOIN factura_compra fc
			ON fcd.id_factura_compra = fc.id

			WHERE fc.fecha < $S$ ||quote_literal (fecha_inicio+'1 days')|| $S$
			AND barcode = p.barcode
			ORDER BY fcd.id_factura_compra DESC
			LIMIT 1) AS costo_fecha

       	 	FROM producto p

	 	-- Las compras ingresadas hechas hasta la fecha determinada
	 	LEFT JOIN (SELECT SUM(fcd.cantidad) AS cantidad_ingresada, fcd.barcode AS barcode
		          	  FROM factura_compra_detalle fcd
       		     	          INNER JOIN factura_compra fc
       		     	          ON fc.id = fcd.id_factura_compra

       		     	          WHERE fc.fecha < $S$ || quote_literal(fecha_inicio) || $S$
                     	          AND fcd.cantidad > 0
                     	          GROUP BY barcode) AS cantidad_ingresada
                ON p.barcode = cantidad_ingresada.barcode

	        -- Las anulaciones de compras hechas hasta la fecha determinada
		LEFT JOIN (SELECT SUM(cad.cantidad_anulada) AS cantidad_c_anuladas, cad.barcode AS barcode
		       	          FROM compra_anulada ca
				  INNER JOIN compra_anulada_detalle cad
				  ON ca.id = cad.id_compra_anulada

				  WHERE ca.fecha_anulacion < $S$ || quote_literal(fecha_inicio) || $S$
				  GROUP BY barcode) AS compras_anuladas
	        ON p.barcode = compras_anuladas.barcode

       		-- Las Ventas hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_vendida, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	      	  INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  WHERE v.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			  	  GROUP BY barcode) AS ventas
		ON p.barcode = ventas.barcode

       	        -- Las anulaciones de venta hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vd.cantidad) AS cantidad_anulada, vd.barcode AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta v
		 	          INNER JOIN venta_detalle vd
			  	  ON v.id = vd.id_venta

			  	  INNER JOIN venta_anulada va
			    	  ON va.id_sale = v.id

				  WHERE va.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS ventas_anuladas
                ON p.barcode = ventas_anuladas.barcode

		-- Las Ventas (de compuestos) menos sus anulaciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT SUM(vmcd.cantidad) AS cantidad_vmcd, vmcd.barcode_componente AS barcode -- LEFT JOIN MUESTRA TODOS LOS PRODUCTOS
       	     	                  FROM venta_mc_detalle vmcd
				  INNER JOIN venta v ON vmcd.id_venta_vd = v.id

			  	  WHERE vmcd.id_venta_vd NOT IN (SELECT id_sale FROM venta_anulada)
				  AND v.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			  	  GROUP BY barcode_componente) AS ventas_mcd
		ON p.barcode = ventas_mcd.barcode

	        -- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT barcode, SUM(unidades) AS unidades_merma
       	     	                  FROM merma m

		         	  WHERE m.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS merma
	        ON p.barcode = merma.barcode

		-- Las Mermas sufridas hasta la fecha determinada
		LEFT JOIN (SELECT mmcd.barcode_componente AS barcode, SUM(mmcd.cantidad) AS unidades_merma_mcd
       	     	                  FROM merma m
				  INNER JOIN merma_mc_detalle mmcd
				  ON m.id = mmcd.id_merma

		         	  WHERE m.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode_componente) AS merma_mcd
	        ON p.barcode = merma_mcd.barcode

                -- Las devoluciones hechas hasta la fecha determinada
       		LEFT JOIN (SELECT dd.barcode AS barcode, SUM(dd.cantidad) AS cantidad_devolucion
       	     	                  FROM devolucion d
		 	          INNER JOIN devolucion_detalle dd
			 	  ON d.id = dd.id_devolucion

			          WHERE d.fecha < $S$ || quote_literal(fecha_inicio) || $S$
			          GROUP BY barcode) AS devolucion
                ON p.barcode = devolucion.barcode

	        -- Los traspasos enviados hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen = 1
			          GROUP BY barcode) AS traspaso_envio
                ON p.barcode = traspaso_envio.barcode

		-- Los traspasos enviados (a traves de un compuesto) hasta la fecha determinada
		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_envio
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen = 1
			          GROUP BY barcode_componente) AS traspaso_mc_envio
                ON p.barcode = traspaso_mc_envio.barcode

	        -- Los traspasos recibidos hasta la fecha determinada
       		LEFT JOIN (SELECT td.barcode AS barcode, SUM(td.cantidad) AS cantidad_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_detalle td
			 	  ON t.id = td.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen != 1
			          GROUP BY barcode) AS traspaso_recibido
                ON p.barcode = traspaso_recibido.barcode

		-- Los traspasos recibidos (a traves de un compuesto) hasta la fecha determinada
       		LEFT JOIN (SELECT tmcd.barcode_componente AS barcode, SUM(tmcd.cantidad) AS cantidad_mc_recibida
       	     	                  FROM traspaso t
		 	          INNER JOIN traspaso_mc_detalle tmcd
			 	  ON t.id = tmcd.id_traspaso

			          WHERE t.fecha < $S$ || quote_literal(fecha_inicio) || $S$
				  AND t.origen != 1
			          GROUP BY barcode_componente) AS traspaso_mc_recibido
                ON p.barcode = traspaso_mc_recibido.barcode

                WHERE p.estado = true
		AND (p.tipo = $S$ || corriente || $S$
		     OR p.tipo = $S$ || materia_prima || $S$ ) $S$ ;

if barcode_in != 0 then
    q := q || $S$ AND p.barcode = $S$ || barcode_in;
end if;

q := q || $S$ GROUP BY p.barcode, p.codigo_corto, p.marca, p.descripcion, p.contenido, p.unidad, p.familia, cantidad_ingresada, cantidad_c_anuladas, cantidad_vendida, unidades_merma, unidades_merma_mcd, cantidad_anulada, cantidad_vmcd, cantidad_devolucion, cantidad_envio, cantidad_mc_envio, cantidad_recibida, cantidad_mc_recibida, costo_fecha
              ORDER BY barcode $S$;

for l in execute q loop
    barcode := l.barcode;
    codigo_corto := l.codigo_corto;
    marca := l.marca;
    descripcion := l.descripcion;
    cont_un := l.contenido ||' '|| l.unidad;
    familia := l.familia;
    cantidad_ingresada := COALESCE (l.cantidad_ingresada,0);
    cantidad_c_anuladas := COALESCE(l.cantidad_c_anuladas,0);
    cantidad_vendida := COALESCE(l.cantidad_vendida,0);
    cantidad_merma := COALESCE(l.unidades_merma,0) + COALESCE(l.unidades_merma_mcd,0);
    cantidad_anulada := COALESCE(l.cantidad_anulada,0);
    cantidad_insumida := COALESCE(l.cantidad_vmcd,0);
    cantidad_devoluciones := COALESCE(l.cantidad_devolucion,0);
    cantidad_envio := COALESCE(l.cantidad_envio,0) + COALESCE(l.cantidad_mc_envio,0);
    cantidad_recibida := COALESCE(l.cantidad_recibida,0) + COALESCE(l.cantidad_mc_recibida,0);
    cantidad_fecha := COALESCE(l.cantidad_ingresada,0) - COALESCE(l.cantidad_c_anuladas,0) - COALESCE(l.cantidad_vendida,0) - COALESCE(l.cantidad_vmcd,0) - COALESCE(l.unidades_merma,0) + COALESCE(l.cantidad_anulada,0) - COALESCE(l.cantidad_devolucion,0) - COALESCE(l.cantidad_envio,0) + COALESCE(l.cantidad_recibida,0);
    costo_fecha := COALESCE (l.costo_fecha, 0);
    return next;
end loop;

return;
end; $$ language plpgsql;",funciones.sql
"create or replace function producto_en_periodo(
       in fecha_inicio timestamp,
       out barcode varchar,
       out codigo_corto varchar,
       out descripcion varchar,
       out marca varchar,
       out cont_un varchar,
       out familia integer,
       out stock_inicial double precision,
       out compras_periodo double precision,
       out anulaciones_c_periodo double precision,
       out ventas_periodo double precision,
       out anulaciones_periodo double precision,
       out insumidos_periodo double precision,
       out devoluciones_periodo double precision,
       out mermas_periodo double precision,
       out enviados_periodo double precision,
       out recibidos_periodo double precision,
       out stock_teorico double precision
       )
RETURNS setof record AS $$
DECLARE
q text;
l record;
z record;
BEGIN

q := $S$ SELECT stock1.barcode AS barcode,
	        stock1.codigo_corto AS codigo_corto,
       	 	stock1.descripcion AS descripcion,
		stock1.marca AS marca,
		stock1.cont_un AS cont_un,
		stock1.familia AS familia,

		-- Los mismos datos de distintas fechas --
       	 	-- stock inicial
       	 	stock1.cantidad_fecha AS stock1_cantidad_fecha,
       	 	stock2.cantidad_fecha AS stock2_cantidad_fecha,
       	 	-- compras_periodo
       	 	stock1.cantidad_ingresada AS stock1_cantidad_ingresada,
       	 	stock2.cantidad_ingresada AS stock2_cantidad_ingresada,
		-- anulaciones_c_periodo
		stock1.cantidad_c_anuladas AS stock1_cantidad_c_anuladas,
       	 	stock2.cantidad_c_anuladas AS stock2_cantidad_c_anuladas,
       	 	-- ventas_periodo
       	 	stock1.cantidad_vendida AS stock1_cantidad_vendida,
       	 	stock2.cantidad_vendida AS stock2_cantidad_vendida,
		-- anulaciones_periodo
       	 	stock1.cantidad_anulada AS stock1_cantidad_anulada,
       	 	stock2.cantidad_anulada AS stock2_cantidad_anulada,
		-- insumidos_periodo
       	 	stock1.cantidad_insumida AS stock1_cantidad_insumida,
       	 	stock2.cantidad_insumida AS stock2_cantidad_insumida,
       	 	-- devoluciones_periodo
       	 	stock1.cantidad_devoluciones AS stock1_cantidad_devoluciones,
       	 	stock2.cantidad_devoluciones AS stock2_cantidad_devoluciones,
       	 	-- mermas_periodo
       	 	stock1.cantidad_merma AS stock1_cantidad_merma,
       	 	stock2.cantidad_merma AS stock2_cantidad_merma,
       	 	-- envios_periodo
       	 	stock1.cantidad_envio AS stock1_cantidad_envio,
       	 	stock2.cantidad_envio AS stock2_cantidad_envio,
		-- recibidos_periodo
       	 	stock1.cantidad_recibida AS stock1_cantidad_recibida,
       	 	stock2.cantidad_recibida AS stock2_cantidad_recibida,

       	 	-- El stock actual --
       	 	-- stock_teorico
       	 	stock2.cantidad_fecha

	 FROM producto_en_fecha( $S$ || quote_literal(fecha_inicio) || $S$, 0 ) stock1 INNER JOIN producto_en_fecha( $S$ || quote_literal(current_date::timestamp + '1 days') || $S$, 0 ) stock2
       	 ON stock1.barcode = stock2.barcode $S$;

FOR l IN EXECUTE q loop
    barcode := l.barcode;
    codigo_corto := l.codigo_corto;
    marca := l.marca;
    familia := l.familia;
    descripcion := l.descripcion;
    cont_un := l.cont_un;
    stock_inicial := l.stock1_cantidad_fecha;  -- cantidad_fecha = stock con el que se inicio el día seleccionado (ESTE SE MANTIENE)
    compras_periodo := l.stock2_cantidad_ingresada - l.stock1_cantidad_ingresada;
    anulaciones_c_periodo := l.stock2_cantidad_c_anuladas - l.stock1_cantidad_c_anuladas;
    ventas_periodo := l.stock2_cantidad_vendida - l.stock1_cantidad_vendida;
    anulaciones_periodo := l.stock2_cantidad_anulada - l.stock1_cantidad_anulada;
    insumidos_periodo := l.stock2_cantidad_insumida - l.stock1_cantidad_insumida;
    devoluciones_periodo := l.stock2_cantidad_devoluciones - l.stock1_cantidad_devoluciones;
    mermas_periodo := l.stock2_cantidad_merma - l.stock1_cantidad_merma;
    enviados_periodo := l.stock2_cantidad_envio - l.stock1_cantidad_envio;
    recibidos_periodo := l.stock2_cantidad_recibida - l.stock1_cantidad_recibida;
    stock_teorico := l.stock2_cantidad_fecha;
    RETURN NEXT;
END loop;

return;
end; $$ language plpgsql;",funciones.sql
"create or replace function public.box_link(
 file_id text,
 top float,
 left float,
 bottom float,
 right float,
 out link text) as $$
BEGIN
  SELECT INTO link
  format('https://digital.ucdavis.edu/ark:/87287/%s/media/images/%s.jpg/svc:iiif/%s,%s,%s,%s/full/0/default.jpg',
  split_part(file_id,'-',1),file_id,top,""left"",top-bottom,""right""-""left"");
END;
$$ LANGUAGE PLPGSQL IMMUTABLE;",README.org
"create or replace function public.box_link(
 file_id text,
 top float,
 left float,
 bottom float,
 right float,
 out link text) as $$
BEGIN
  SELECT INTO link
  format('https://digital.ucdavis.edu/ark:/87287/%s/media/images/%s.jpg/svc:iiif/%s,%s,%s,%s/full/0/default.jpg',
  split_part(file_id,'-',1),file_id,top,""left"",top-bottom,""right""-""left"");
END;
$$ LANGUAGE PLPGSQL IMMUTABLE;",save.org
"create or replace function public.ddlExec(query text) returns integer as $$
declare
   ret integer;
begin
   execute query;
   return 1;
end;
$$ language plpgsql;",plproxy.txt
"create or replace function public.dmlExec(query text) returns integer as $$
declare
   ret integer;
begin
   execute query;
   return 1;
end;
$$ language plpgsql;",plproxy.txt
"create or replace function raise_notice(msg text) returns text as $$
begin
	raise notice '%', msg;
	return msg;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function random_a_string(x integer, y integer) returns text as $$
declare
	/* The length of the string should be between x and y characters long. */
	len			integer	= x + floor(random() * ((y + 1) - x))::integer;
	characters	text	= '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
	chars_len	integer	= length(characters);
	result		text	= '';
begin
	for i in 1..len loop
		result = result || substr(characters, 1 + floor(random() * chars_len)::integer, 1);
	end loop;
	return result;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function random_n_string(x integer, y integer) returns text as $$
declare
	/* The length of the string should be between x and y characters long. */
	len			integer	= x + floor(random() * ((y + 1) - x))::integer;
	characters	text	= '0123456789';
	chars_len	integer	= length(characters);
	result		text	= '';
begin
	for i in 1..len loop
		result = result || substr(characters, 1 + floor(random() * chars_len)::integer, 1);
	end loop;
	return result;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function read_lo (i_lo_oid oid, i_size int4) returns bytea as $$    
declare    
  result bytea;    
  fd_lo int;    
begin    
  select lo_open(i_lo_oid, 262144) into fd_lo;    
  select loread(fd_lo, i_size) into result;    
  perform lo_close(fd_lo);    
  return result;    
end;    
$$ language plpgsql;",20130109_01.md
"create or replace function refresh_mv(nsp name, mvname name) returns void as $$
declare
begin
  execute 'refresh materialized view CONCURRENTLY '||quote_ident($1)||'.'||quote_ident($2)||' with data';
end;
$$ language plpgsql strict;",20161005_01.md
"create or replace function refresh_mv(nsp name, mvname name) returns void as $$
declare
begin
  execute 'refresh materialized view CONCURRENTLY '||quote_ident($1)||'.'||quote_ident($2)||' with data';
end;
$$ language plpgsql strict;",index.html
"create or replace function samp_rows(nsp name, rel name, cnt int8, dist float8 default 100.0) returns setof record as $$
declare
  pages int8;
  tups float8;
begin
  if dist<0 or dist>100 then 
    raise notice 'dist must between 0 and 100';
    return;
  end if;
  select relpages,reltuples into pages,tups from pg_class where oid=(quote_ident(nsp)||'.'||quote_ident(rel))::regclass;
  if not found then
    return;
  end if;
  if cnt >= tups then 
    return query execute 'select * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' t limit '||cnt;
  else
    -- 如果采样的记录数小于实际的记录数，则根据随机数的概率来返回采样结果  cnt/tups 即全离散时的采样概率   
    -- 离散度0-100，越大表示采样的结果越离散，可以理解为随机采样时覆盖的数据面，0表示连续采样，100则表示在所有数据中随机采样。  
    if dist = 100.0 then 
      return query execute 'select * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' where random() <= '||cnt/tups||' limit '||cnt; 
    elsif (dist/100.0) <= (cnt/tups) then 
      return query execute 'select * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' limit '||cnt; 
    else 
      return query execute 'select * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' where random() <= '||(cnt/tups) * (100.0/dist)||' limit '||cnt; 
    end if; 
  end if; 
end;
$$ language plpgsql strict;",20160929_01.md
"create or replace function samp_rows(nsp name, rel name, cnt int8, dist float8 default 100.0) returns setof record as $$
declare
  pages int8;
  tups float8;
begin
  if dist<0 or dist>100 then 
    raise notice 'dist must between 0 and 100';
    return;
  end if;
  select relpages,reltuples into pages,tups from pg_class where oid=(quote_ident(nsp)||'.'||quote_ident(rel))::regclass;
  if not found then
    return;
  end if;
  if cnt >= tups then   -- 输入的采样记录数大于实际的记录数, 直接返回全表  
    -- ctid可以反映采样的随机度, 仅用于观察, 实际使用中可以不返回ctid  
    return query execute 'select ctid, * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' t limit '||cnt;
  else
    -- 如果采样的记录数小于实际的记录数，则根据随机数的概率来返回采样结果  cnt/tups 即全离散时的采样概率   
    -- 离散度0-100，越大表示采样的结果越离散，可以理解为随机采样时覆盖的数据面，0表示连续采样，100则表示在所有数据中随机采样。  
    if dist = 100.0 then 
      return query execute 'select ctid, * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' where random() <= '||cnt/tups||' limit '||cnt; 
    elsif (dist/100.0) <= (cnt/tups) then 
      return query execute 'select ctid, * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' limit '||cnt; 
    else 
      return query execute 'select ctid, * from '||quote_ident(nsp)||'.'||quote_ident(rel)||' where random() <= '||(cnt/tups) * (100.0/dist)||' limit '||cnt; 
    end if; 
  end if; 
end;
$$ language plpgsql strict;",20160929_01.md
"create or replace function sel_tbl(                                                         
  i_gid text, 
  begin_crt_time timestamp, 
  end_crt_time timestamp 
) returns setof tbl as $$
declare
begin
  return query execute format('select * from %I where crt_time between %L and %L', 'tbl_'||i_gid, begin_crt_time, end_crt_time);
end;
$$ language plpgsql strict;",20170417_01.md
"create or replace function sel_tbl(                                                         
  i_gid text[], 
  begin_crt_time timestamp, 
  end_crt_time timestamp 
) returns setof tbl as $$
declare
  v_gid text;
begin
  foreach v_gid in array i_gid
  loop
    return query execute format('select * from %I where crt_time between %L and %L', 'tbl_'||v_gid, begin_crt_time, end_crt_time);
  end loop;
end;
$$ language plpgsql strict;",20170417_01.md
"create or replace function select_asistencia(
       in in_id_user int,
       out entrada_year float8,
       out entrada_month float8,
       out entrada_day float8,
       out entrada_hour float8,
       out entrada_min float8,
       out salida_year float8,
       out salida_month float8,
       out salida_day float8,
       out salida_hour float8,
       out salida_min float8)
returns setof record as $$
declare
	l record;
	q text;
begin
q := $S$SELECT date_part ('year', entrada) as entrada_year,
     	       date_part ('month', entrada) as entrada_month,
	       date_part ('day', entrada) as entrada_day,
	       date_part ('hour', entrada) as entrada_hour,
	       date_part ('minute', entrada) as entrada_min,
	       date_part ('year', salida) as salida_year,
	       date_part ('month', salida) as salida_month,
	       date_part ('day', salida) as salida_day,
	       date_part ('hour', salida) as salida_hour,
	       date_part ('minute', salida) as salida_min
	FROM asistencia WHERE id_user=$S$
	|| quote_literal(in_id_user) || $S$ ORDER BY entrada DESC LIMIT 1$S$;

for l in execute q loop
       entrada_year := l.entrada_year;
       entrada_month := l.entrada_month;
       entrada_day := l.entrada_day;
       entrada_hour := l.entrada_hour;
       entrada_min := l.entrada_min;
       salida_year := l.salida_year;
       salida_month := l.salida_month;
       salida_day := l.salida_day;
       salida_hour := l.salida_hour;
       salida_min := l.salida_min;
       return next;
end loop;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function select_cliente(
       OUT rut int4,
       OUT dv varchar(1),
       OUT nombre varchar(60),
       OUT apell_p varchar(60),
       OUT apell_m varchar(60),
       OUT giro varchar(255),
       OUT direccion varchar(150),
       OUT telefono varchar(15),
       OUT telefono_movil varchar(15),
       OUT mail varchar(30),
       OUT abonado int4,
       OUT credito int4,
       OUT credito_enable boolean,
       OUT activo boolean,
       OUT tipo tc)
returns setof record as $$
declare
	l record;
	query varchar(255);
begin
query := 'select rut, dv, nombre, apell_p, apell_m, giro, direccion, telefono,
      	 	  telefono_movil, mail, abonado, credito, credito_enable, activo, tipo
		  FROM cliente';

FOR l IN EXECUTE query LOOP
    rut = l.rut;
    dv = l.dv;
    nombre = l.nombre;
    apell_p = l.apell_p;
    apell_m = l.apell_m;
    giro = l.giro;
    direccion = l.direccion;
    telefono = l.telefono;
    telefono_movil = l.telefono_movil;
    mail = l.mail;
    abonado = l.abonado;
    credito = l.credito;
    credito_enable = l.credito_enable;
    activo = l.activo;
    tipo = l.tipo;
    RETURN NEXT;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function select_factura_compra_by_num_factura
       	  	  	   (IN factura_numero int4,
			   OUT id int4,
			   OUT id_compra int4,
			   OUT rut_proveedor varchar(20),
			   OUT num_factura int4,
			   OUT fecha timestamp,
			   OUT valor_neto int4,
			   OUT valor_iva int4,
			   OUT descuento int4,
			   OUT pagada bool,
			   OUT monto int4,
			   OUT fecha_pago timestamp,
			   OUT forma_pago int4)
returns setof record as $$
declare
	list record;
	query text;
begin
query := $S$ SELECT id, id_compra, rut_proveedor, num_factura, fecha,
      	     	    valor_neto, valor_iva, descuento, pagada, monto,
		    fecha_pago, forma_pago
		    FROM factura_compra
		    WHERE num_factura=$S$ || factura_numero;

FOR list IN EXECUTE query LOOP
    id            := list.id;
    id_compra	  := list.id_compra;
    rut_proveedor := list.rut_proveedor;
    num_factura	  := list.num_factura;
    fecha	  := list.fecha;
    valor_neto	  := list.valor_neto;
    valor_iva	  := list.valor_iva;
    descuento	  := list.descuento;
    pagada	  := list.pagada;
    monto	  := list.monto;
    fecha_pago	  := list.fecha_pago;
    forma_pago	  := list.forma_pago;
    RETURN NEXT;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function select_impuesto( OUT id int4,
       	  	  	   		    OUT descripcion varchar(250),
					    OUT monto float8)
returns setof record as $$
declare
	list record;
	query varchar(255);
begin

query := 'SELECT id, descripcion, monto FROM impuesto ORDER BY id';

for list in execute query loop
    id = list.id;
    descripcion := list.descripcion;
    monto := list.monto;
    return next;
end loop;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function select_merma(IN barcode_in bigint,
		  	   		OUT unidades_merma double precision)
returns double precision as $$
declare
   aux int;
   derivada_l int4;
BEGIN
  aux := (SELECT COALESCE (count(*), 0) FROM merma WHERE barcode = barcode_in);
  aux := aux + (SELECT COALESCE (count(*), 0) FROM merma_mc_detalle WHERE barcode_componente = barcode_in);
  IF aux = 0 THEN
     unidades_merma := 0;
  ELSE
     unidades_merma := (SELECT COALESCE (sum(unidades), 0) FROM merma WHERE barcode = barcode_in);
     unidades_merma := unidades_merma + (SELECT COALESCE (sum(cantidad), 0) FROM merma_mc_detalle WHERE barcode_componente = barcode_in);
  END IF;

RETURN;
END;
$$ LANGUAGE plpgsql;",funciones.sql
"create or replace function select_otros_impuestos (OUT id int4,
       	  	  	   			   OUT descripcion varchar(250),
						   OUT monto float8)
returns setof record as $$
declare
	list record;
	query varchar(255);
begin
query := 'SELECT id, descripcion, monto FROM impuesto WHERE id != 1 ORDER BY id';

FOR list IN EXECUTE query LOOP
    id := list.id;
    descripcion := list.descripcion;
    monto := list.monto;
    RETURN NEXT;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function select_producto (OUT barcode int8,
					    OUT codigo_corto varchar(16),
					    OUT marca varchar(35),
					    OUT descripcion varchar(50),
					    OUT contenido varchar(10),
					    OUT unidad varchar(10),
					    OUT stock float8,
					    OUT precio double precision,
					    OUT precio_neto double precision,
					    OUT costo_promedio float8,
					    OUT vendidos float8,
					    OUT impuestos bool,
					    OUT otros int4,
					    OUT familia int2,
					    OUT perecibles bool,
					    OUT stock_min float8,
					    OUT dias_stock float8,
					    OUT margen_promedio float8,
					    OUT fraccion bool,
					    OUT canje bool,
					    OUT stock_pro float8,
					    OUT tasa_canje float8,
					    OUT precio_mayor double precision,
					    OUT cantidad_mayor double precision,
					    OUT mayorista bool,
					    OUT tipo int4)
returns setof record as $$
declare
	list record;
	query text;
	corriente int4;
	materia_prima int4;
begin
query := $S$ SELECT codigo_corto, barcode, descripcion, marca, contenido,
      	     	    unidad, stock, precio, precio_neto, costo_promedio, vendidos, impuestos,
		    otros, familia, perecibles, margen_promedio, dias_stock,
		    COALESCE ((dias_stock * select_ventas_dia(producto.barcode, TRUE)::float), 0) AS stock_min,
		    fraccion, canje, stock_pro, tasa_canje, precio_mayor,
		    cantidad_mayor, mayorista, tipo
		    FROM producto ORDER BY descripcion, marca$S$;

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

FOR list IN EXECUTE query LOOP
    barcode := list.barcode;
    codigo_corto := list.codigo_corto;
    marca := list.marca;
    descripcion := list.descripcion;
    contenido := list.contenido;
    unidad := list.unidad;

    -- Su la mercadería es derivada, calcula su stock de acuerdo a sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
	stock := (SELECT disponible FROM obtener_stock_desde_barcode (list.barcode));
    ELSE
	stock := list.stock;
    END IF;

    precio := list.precio;
    precio_neto := list.precio_neto;

    -- Si la mercadería es derivada, calcula su costo promedio a partir del costo de sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
        costo_promedio := (SELECT costo FROM obtener_costo_promedio_desde_barcode (list.barcode));
    ELSE
	costo_promedio := list.costo_promedio;
    END IF;

    vendidos := list.vendidos;
    impuestos := list.impuestos;
    otros := list.otros;
    familia := list.familia;
    perecibles := list.perecibles;
    stock_min := list.stock_min;
    dias_stock := list.dias_stock;
    margen_promedio := list.margen_promedio;
    fraccion := list.fraccion;
    canje := list.canje;
    stock_pro := list.stock_pro;
    tasa_canje := list.tasa_canje;
    precio_mayor := list.precio_mayor;
    cantidad_mayor := list.cantidad_mayor;
    mayorista := list.mayorista;
    tipo := list.tipo;
    RETURN NEXT;
END LOOP;

RETURN;
END; $$ language plpgsql;",funciones.sql
"create or replace function select_producto( IN prod_barcode int8,
       	  	  	   		    OUT barcode int8,
					    OUT codigo_corto varchar(16),
					    OUT marca varchar(35),
					    OUT descripcion varchar(50),
					    OUT contenido varchar(10),
					    OUT unidad varchar(10),
					    OUT stock float8,
					    OUT precio double precision,
					    OUT precio_neto double precision,
					    OUT costo_promedio float8,
					    OUT vendidos float8,
					    OUT impuestos bool,
					    OUT otros int4,
					    OUT familia int2,
					    OUT perecibles bool,
					    OUT stock_min float8,
					    OUT dias_stock float8,
					    OUT margen_promedio float8,
					    OUT fraccion bool,
					    OUT canje bool,
					    OUT stock_pro float8,
					    OUT tasa_canje float8,
					    OUT precio_mayor double precision,
					    OUT cantidad_mayor double precision,
					    OUT mayorista bool,
					    OUT tipo int4)
returns setof record as $$
declare
	list record;
	query text;
	corriente int4;
	materia_prima int4;
begin
query := $S$ SELECT codigo_corto, barcode, descripcion, marca, contenido,
      	     	    unidad, stock, precio, precio_neto, costo_promedio, vendidos, impuestos,
		    otros, familia, perecibles, margen_promedio,
		    COALESCE ((dias_stock * select_ventas_dia(producto.barcode, TRUE)::float), 0) AS stock_min,
		    fraccion, canje, stock_pro, tasa_canje, precio_mayor, dias_stock,
		    cantidad_mayor, mayorista, tipo
             FROM producto WHERE barcode= $S$
	     || quote_literal(prod_barcode);

corriente := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'CORRIENTE');
materia_prima := (SELECT id FROM tipo_mercaderia WHERE upper(nombre) LIKE 'MATERIA PRIMA');

FOR list IN EXECUTE query LOOP
    barcode := list.barcode;
    codigo_corto := list.codigo_corto;
    marca := list.marca;
    descripcion := list.descripcion;
    contenido := list.contenido;
    unidad := list.unidad;

    -- Su la mercadería es derivada, calcula su stock de acuerdo a sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
	stock := (SELECT disponible FROM obtener_stock_desde_barcode (list.barcode));
    ELSE
	stock := list.stock;
    END IF;

    precio := list.precio;
    precio_neto := list.precio_neto;

    -- Si la mercadería es derivada, calcula su costo promedio a partir del costo de sus componentes
    IF list.tipo != corriente AND list.tipo != materia_prima THEN
        costo_promedio := (SELECT costo FROM obtener_costo_promedio_desde_barcode (list.barcode));
    ELSE
	costo_promedio := list.costo_promedio;
    END IF;

    vendidos := list.vendidos;
    impuestos := list.impuestos;
    otros := list.otros;
    familia := list.familia;
    perecibles := list.perecibles;
    stock_min := list.stock_min;
    dias_stock := list.dias_stock;
    margen_promedio := list.margen_promedio;
    fraccion := list.fraccion;
    canje := list.canje;
    stock_pro := list.stock_pro;
    tasa_canje := list.tasa_canje;
    precio_mayor := list.precio_mayor;
    cantidad_mayor := list.cantidad_mayor;
    mayorista := list.mayorista;
    tipo := list.tipo;
    RETURN NEXT;
END LOOP;
RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function select_proveedor ( OUT rut int4,
       	  	  	   		      OUT dv varchar(1),
					      OUT nombre varchar(100),
					      OUT direccion varchar(100),
					      OUT ciudad varchar(100),
					      OUT comuna varchar(100),
					      OUT telefono varchar(100),
					      OUT email varchar(300),
					      OUT web varchar(300),
					      OUT contacto varchar(100),
					      OUT giro varchar(100),
					      OUT lapso_reposicion integer)
returns setof record as $$
declare
	l record;
	q varchar(255);
begin
q := 'SELECT rut, dv, nombre, direccion, ciudad, comuna, telefono,
     email, web, contacto, giro, lapso_reposicion FROM proveedor ORDER BY nombre';

for l in execute q loop
    rut := l.rut;
    dv := l.dv;
    nombre := l.nombre;
    direccion := l.direccion;
    ciudad := l.ciudad;
    comuna := l.comuna;
    telefono := l.telefono;
    email := l.email;
    web := l.web;
    contacto := l.contacto;
    giro := l.giro;
    lapso_reposicion := l.lapso_reposicion;
    return next;
end loop;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function select_proveedor (IN prov_rut int4,
       	  	  	   		    OUT rut int4,
					    OUT dv varchar(1),
					    OUT nombre varchar(100),
					    OUT direccion varchar(100),
  					    OUT ciudad varchar(100),
					    OUT comuna varchar(100),
					    OUT telefono varchar(100),
					    OUT email varchar(300),
					    OUT web varchar(300),
					    OUT contacto varchar(100),
					    OUT giro varchar(100),
					    OUT lapso_reposicion integer)
returns setof record as $$
declare
	list record;
	query text;
begin
query := 'SELECT rut,dv,nombre, direccion, ciudad, comuna, telefono, email,
      	 	 web, contacto, giro, lapso_reposicion FROM proveedor WHERE rut=' || prov_rut;

for list in execute query loop
    rut       := list.rut;
    dv	      := list.dv;
    nombre    := list.nombre;
    direccion := list.direccion;
    ciudad    := list.ciudad;
    comuna    := list.comuna;
    telefono  := list.telefono;
    email     := list.email;
    web	      := list.web;
    contacto  := list.contacto;
    giro      := list.giro;
    lapso_reposicion := list.lapso_reposicion;
    return next;
end loop;

return;

end; $$ language plpgsql;",funciones.sql
"create or replace function select_proveedor_for_product(IN prod_barcode int8,
            	  	  	     			OUT nombre varchar(100))
returns setof varchar(100) as $$
declare
	list record;
	query text;
begin
query := $S$SELECT nombre FROM proveedor
      	 inner join compra on proveedor.rut = compra.rut_proveedor
	 inner join compra_detalle on compra_detalle.id_compra = compra.id
	 and barcode_product= $S$ || prod_barcode
	 || $S$ GROUP BY proveedor.nombre $S$;


FOR list IN EXECUTE query LOOP
	nombre := list.nombre;
	RETURN NEXT;
END LOOP;

RETURN;

END; $$ language plpgsql;",funciones.sql
"create or replace function select_stats_proveedor(
       	  	  IN rut int4,
		  OUT barcode int8,
		  OUT descripcion varchar(50),
		  OUT marca varchar(35),
		  OUT contenido varchar(10),
		  OUT unidad varchar(10),
		  OUT suma_cantingresada double precision,
		  OUT vendidos float8)
returns setof record as $$
declare
	l record;
	q text;
begin
q := $S$ select barcode, descripcion, marca, contenido, unidad,
     	 	sum(cantidad_ingresada) as suma, vendidos
		from compra inner join compra_detalle
		     on compra.id = compra_detalle.id_compra
		     inner join producto
		     on compra_detalle.barcode_product = producto.barcode
		where compra.rut_proveedor = $S$ || quote_literal(rut)
		|| $S$ group by 1,2,3,4,5,7 $S$;

for l in execute q loop
    barcode := l.barcode;
    descripcion := l.descripcion;
    marca := l.marca;
    contenido := l.contenido;
    unidad := l.unidad;
    suma_cantingresada := l.suma;
    vendidos := l.vendidos;
    return next;
end loop;

return;
end; $$ language plpgsql;",funciones.sql
"create or replace function select_vendidos(
       in codigo_barras bigint,
       in shortcode varchar)
returns double precision as $$
declare
prod_vendidos double precision;
begin

if codigo_barras != 0 then
   select vendidos into prod_vendidos from producto where barcode = codigo_barras;
else
   select vendidos into prod_vendidos from producto where codigo_corto = shortcode;
end if;
return prod_vendidos;
end; $$ language plpgsql;",funciones.sql
"create or replace function sells_get_totals (
        in starts timestamp,
        in ends timestamp,
        out total_cash_sell integer,
        out total_cash integer,
        out total_cash_discount integer,
        out total_discount integer,
        out total_credit_sell integer,
        out total_credit integer,
        out total_ventas integer
        )
returns setof record as $$
declare
       q text;
       l record;
begin
	--Tipo Venta = 0 (es en efectivo), tipo_venta debería llamarse ""tipo_pago""
        select COALESCE (SUM (descuento), 0) into total_cash_discount from venta where fecha >= starts and fecha <= ends and descuento!=0
                and tipo_venta=0 and venta.id not in (select id_sale from venta_anulada);

        select COALESCE (count(*), 0) into total_discount from venta where fecha >= starts and fecha <= ends and descuento!=0
                and tipo_venta=0 and venta.id not in (select id_sale from venta_anulada);
return next;
return;
end; $$ language plpgsql;",funciones.sql
"create or replace function set_tbl() returns setof record as $$      
declare      
begin      
  for i in 0..55 loop             
    perform conn('link'||i,  'hostaddr=127.0.0.1 port='||current_setting('port')||' user=postgres dbname=postgres');             
    perform 1 from dblink_get_result('link'||i) as t(res text);            
    perform dblink_send_query('link'||i, format('alter table ut%s set (autovacuum_enabled=on, toast.autovacuum_enabled=on)', i));            
  end loop;         
  for i in 0..55 loop      
    return query select * from dblink_get_result('link'||i) as t(res text);      
  end loop;      
end;      
$$ language plpgsql strict;",20180427_03.md
"create or replace function source.get_row2(in a int, inout b text, out c date) language plpgsql
as $body$
begin
  b := 'hello, ' || b;
  c := '2000-12-31';
end;
$body$;",test_schema.sql
"create or replace function strToHash(param text) returns hstore as $$
DECLARE
	hash hstore;
BEGIN
	--进行字符串转换.
			--raise info 'param:%',param;
			param=replace(param,'|',',');
			param=replace(param,':','=>');
			param=replace(param,'{','');
			param=replace(param,'}','');
			select param into hash;
			return hash;
END;
$$ language plpgsql;",V1.0.1.0243__A_gamebox_rebate.sql
"create or replace function string_to_tsquery(v text) returns tsquery as $$  
declare  
  x int := 1;  
  res text := '';  
  i text;  
begin  
  for i in select regexp_split_to_table(v,'')   
  loop  
    if x>1 then  
      res := res||' <-> '||chr(92)||i;   -- 这一句<->符号是用来带上相邻信息的  
    else  
      res := chr(92)||i;  
    end if;  
    x := x+1;  
  end loop;  
    return res::tsquery;  
end;  
$$ language plpgsql strict immutable;",20161231_01.md
"create or replace function string_to_tsvector(v text) returns tsvector as $$  
declare  
  x int := 1;  
  res text := '';  
  i text;  
begin  
  for i in select regexp_split_to_table(v,'')   
  loop  
    res := res||' '||chr(92)||i||':'||x;  
    x := x+1;  
  end loop;  
    return res::tsvector;  
end;  
$$ language plpgsql strict immutable;",20161231_01.md
"create or replace function sum_transfn(state int4, n int4) returns int4 as
$$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates.out
"create or replace function sum_transfn(state int4, n int4) returns int4 as
$$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates_1.out
"create or replace function sum_transfn(state int4, n int4) returns int4 as
$$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;

	return null;
end
$$ language plpgsql;",aggregates_optimizer.out
"create or replace function test(int) returns void as $$      
declare      
begin      
  for i in 1..$1 loop      
perform array_agg(vid) from (      
SELECT vid       
FROM tbl_v_box_n         
where       
'\x128b7f8895a3f5af28cafe'::hll <> hll_add('\x128b7f8895a3f5af28cafe'::hll, hll_hash_integer(vid))      
ORDER BY          
vec <?> '0,0,0,0,0,0,0,0,0,0,0,0,75,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,0,0,13,72,0,0,0,0,0,0,0,0,30,0,0,0,0,0,0,0,0,0,0,0,92,0,0,0,0,0,45,0,4,0,0,0,0,0,85,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,47,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,36,0,0,0,0,0,0,0,94,33,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,85,0,0,90,0,84,0,0,0,0,0,0,0,0,0,0,62,0,0,0,0,0,0,44,0,0,0,0,0,0,0,0,0,4,0,0,0,0,49,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,87,0,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,13,85,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,0,0,0,0,0,0,0,78,0,27,0,0,0,0,0,57,0,0,0,0,0,0,0,0,99,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,73,0,0,0,4,0,0,77,0,74,0,0,0,0,0,21,0,0,0,0,0,0,0,0,0,0,0,22,0,0,0,0,83,0,0,0,0,0,0,0,64,0,85,0,0,0,0,97,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,29,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,51,82,22,0,0,0,0,0,0,48,58,86,0,0,0,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,68,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0:40:0'::pase        
LIMIT 100) t;      
  end loop;      
return;      
end;      
$$ language plpgsql strict;",20200424_01.md
"create or replace function test_param_where() returns void as $$
DECLARE
  n varchar;
BEGIN
  FOR x IN 1..9 LOOP
    select b into n from numbers where a=x;
    raise notice 'Found number %', n;
  end loop;
  return;
END
$$ LANGUAGE plpgsql;",mysql_fdw.out
"create or replace function test_param_where() returns void as $$
DECLARE
  n varchar;
BEGIN
  FOR x IN 1..9 LOOP
    select b into n from test_numbers where a=x;
    raise notice 'Found Item %', n;
  end loop;
  return;
END
$$ LANGUAGE plpgsql;",mongo_fdw.out
"create or replace function throw_error(msg text) returns text as $$
begin
	raise exception '%', msg;
end;
$$ language plpgsql;",tpcc_ddl_pgsql.sql
"create or replace function user_group_label() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='user_group_label' ) THEN
        execute 'CREATE TABLE public.user_group_label
                    (
                      id_group integer NOT NULL DEFAULT nextval(''user_group_label__id_seq''::regclass),
                      label_group character varying,
                      CONSTRAINT ""user_group-label_pkey"" PRIMARY KEY (id_group)
                    )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function user_group_thesaurus() returns void as $$
begin
    IF NOT EXISTS (SELECT * FROM information_schema.tables WHERE table_name='user_group_thesaurus' ) THEN
        execute 'CREATE TABLE user_group_thesaurus
                    (
                      id_group integer NOT NULL,
                      id_thesaurus character varying NOT NULL,
                      CONSTRAINT user_group_thesaurus_pkey PRIMARY KEY (id_group, id_thesaurus),
                      CONSTRAINT user_group_thesaurus_id_thesaurus_key UNIQUE (id_thesaurus)
                    )';
    END IF;
end
$$language plpgsql;",maj_bdd_current.sql
"create or replace function verificar_usuario(in character varying,in character varying,out integer, out character varying,out bytea, out character varying,out integer)
RETURNS SETOF record AS
$$
begin
	return query select id_user, name_user, img, position_user,islogged from User_VE u inner join Img_VE i on u.id_img=i.id_img where username_user=$1 and password_user=$2;
	
end
$$
LANGUAGE plpgsql VOLATILE COST 100;",gad_manta.sql
"create or replace function write_lo (i_bytea bytea) returns oid as $$    
declare    
  oid_new_lo oid;    
  fd_new_lo int;    
begin    
  select lo_creat(-1) into oid_new_lo;    
  select lo_open(oid_new_lo, 131072) into fd_new_lo;    
  perform lowrite(fd_new_lo, i_bytea);    
  perform lo_close(fd_new_lo);    
  return oid_new_lo;    
end;    
$$ language plpgsql;",20130109_01.md
